<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱酱酱的学习博客</title>
  <icon>https://www.gravatar.com/avatar/336d255f627c733c7a50883547bcec06</icon>
  <subtitle>From Zero to Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuuu.work/"/>
  <updated>2021-03-28T07:48:13.702Z</updated>
  <id>http://zhuuu.work/</id>
  
  <author>
    <name>Zhuuu</name>
    <email>353446503@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ-07-交换机类型</title>
    <link href="http://zhuuu.work/2021/03/28/rabbitMQ/RabbitMQ-07-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhuuu.work/2021/03/28/rabbitMQ/RabbitMQ-07-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-03-28T08:02:24.000Z</published>
    <updated>2021-03-28T07:48:13.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-07-交换机类型"><a href="#RabbitMQ-07-交换机类型" class="headerlink" title="RabbitMQ-07-交换机类型"></a>RabbitMQ-07-交换机类型</h2><h2 id="1-交换机的类型"><a href="#1-交换机的类型" class="headerlink" title="1. 交换机的类型"></a>1. 交换机的类型</h2><p><strong>AMQP 0-9-1 的代理提供了四种交换机：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-150948908.png" alt="mark"></p><ul><li>参考官网：<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">https://www.rabbitmq.com/getstarted.html</a></li></ul><a id="more"></a><ul><li><p><strong>交换机可以有两个状态：持久（durable）、暂存（transient）。</strong></p></li><li><p><strong>持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。</strong></p></li><li><p>在正式介绍五种交换机（包括默认交换机）前，在这里重申一下，发布者生产的消息中包含了交换机类型。<strong>消息中声明的交换机类型不同，路由规则也就不同，也就会采取不同的规则将消息投入队列。</strong></p></li></ul><h3 id="1-1-默认交换机"><a href="#1-1-默认交换机" class="headerlink" title="1.1 默认交换机"></a>1.1 默认交换机</h3><ul><li><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的<strong>直连交换机（direct exchange）。</strong></p></li><li><p>它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p><ul><li>举个栗子：当你声明了一个名为<code>“search-indexing-online”</code>的队列，AMQP 代理会自动将其绑定到默认交换机上，绑定（<code>binding</code>）的路由键名称也是为 <code>“search-indexing-online”。</code></li><li>因此，当携带着名为 “search-indexing-online” 的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为 “search-indexing-online” 的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列.</li></ul></li></ul><h3 id="1-2-Direct"><a href="#1-2-Direct" class="headerlink" title="1.2 Direct"></a>1.2 Direct</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-151430656.png" alt="mark"></p><ul><li><p>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应绑定键的队列。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。下边介绍它是如何工作的：</p><ul><li>将一个队列绑定到某个交换机上时，赋予该绑定一个绑定键（Binding Key），假设为R；</li><li>当一个携带着路由键（Routing Key）为R的消息被发送给直连交换机时，交换机会把它路由给绑定键为R的队列。</li></ul></li><li><p>直连交换机的队列通常是循环分发任务给多个消费者（我们称之为轮询）。比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。</p></li><li><p>综上，我们很容易得出一个结论，在 AMQP 0-9-1 中，<strong>消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</strong></p></li></ul><p><strong>如图举例</strong></p><ul><li><p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p></li><li><p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p></li></ul><p><strong>注意：</strong></p><ul><li><code>BindingKey</code>和 <code>RoutingKey</code> 的区别<ul><li><code>BindingKey</code> : <strong>在绑定的时候</strong>，其中需要的路由键是<code>BindingKey</code>，涉及的客户端方法为<code>channel.exchangeBind,channel.queueBind</code><ul><li><code>RoutingKey</code>  : <strong>在发送消息的时候</strong>，其中需要的路由键是<code>RoutingKey</code> ，涉及的客户端方法如<code>channel.basicPublish</code> 对应的AMQP命令为<code>Basic.Publish</code></li></ul></li></ul></li></ul><h3 id="1-3-fanout"><a href="#1-3-fanout" class="headerlink" title="1.3 fanout"></a>1.3 fanout</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-152013014.png" alt="mark"></p><ul><li><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，<strong>而不理会绑定的路由键。</strong></p></li><li><p>如果 N 个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的 N 个队列。</p></li><li><p>扇型用来交换机处理消息的广播路由（broadcast routing）。</p><ul><li>因为扇型交换机投递消息的拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：<ul><li>大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件</li><li>体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li><li>分发系统使用它来广播各种状态和配置更新</li><li>在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP 没有内置 presence 的概念，因此 XMPP 可能会是个更好的选择）</li></ul></li></ul></li></ul><p><strong>如图举例</strong></p><ul><li>上图所示，生产者（P）生产消息 1 将消息 1 推送到 <code>Exchange</code>，由于 <code>Exchange Type=fanout</code>这时候会遵循 <code>fanout</code>的规则将消息推送到所有与它绑定<code>Queue</code>，也就是图上的两个 <code>Queue</code>最后两个消费者消费。</li></ul><h3 id="1-4-Topic"><a href="#1-4-Topic" class="headerlink" title="1.4 Topic"></a>1.4 Topic</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-153449817.png" alt="mark"></p><ul><li>前面提到的 direct 规则是<strong>严格意义上的匹配</strong>，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.</li><li>而Topic 的路由规则是一种<strong>模糊匹配</strong>，可以通过通配符满足一部分规则就可以传送。<ul><li>binding key 中可以存在两种特殊字符 <code>“*” 与“#”，</code>用于做模糊匹配，其中 <code>“*”</code>用于匹配一个单词，<code>“#”</code>用于匹配多个单词（可以是零个）<ul><li><code>“*”</code> : 一定要有一个匹配 （只有一个）</li><li><code>“#”</code> ：0个 1个 多个  （都可以匹配）</li></ul></li><li><code>routing key</code>为一个句点号 <code>“.”</code> 分隔的字符串（我们将被句点号 <code>“. ”</code> 分隔开的每一段独立的字符串称为一个单词），如<code>“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”binding key 与 routing key</code>一样也是句点号<code>“.”</code>分隔的字符串</li></ul></li></ul><p><strong>如图举例</strong></p><ul><li>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue1 中</li><li>如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</li></ul><p><strong>注意：</strong></p><ul><li><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 <strong>多消费者 / 多应用（multiple consumers/applications） 的时候</strong>，主题交换机都可以被列入考虑范围。</p></li><li><p><strong>使用场景：</strong></p><ul><li>分发有关于特定地理位置的数据，例如销售点</li><li>由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务</li><li>股票价格更新（以及其他类型的金融数据更新）</li><li>涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）</li><li>云端的不同种类服务的协调</li><li>分布式架构 / 基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</li></ul></li></ul><h3 id="1-5-headers"><a href="#1-5-headers" class="headerlink" title="1.5 headers"></a>1.5 headers</h3><ul><li><p><code>headers</code> 类型的 <code>Exchange</code> 不依赖于<code>routing key</code> 与 <code>binding key</code>的匹配规则来路由消息，而是根据发送的消息内容中的 <code>headers</code> 属性进行匹配。</p></li><li><p><strong>头交换机可以视为直连交换机的另一种表现形式。但直连交换机的路由键必须是一个字符串，而头属性值则没有这个约束</strong></p><ul><li>它们甚至可以是整数或者哈希值（字典）等。</li><li>灵活性更强（但实际上我们很少用到头交换机）。</li></ul></li><li><p><strong>工作流程：</strong></p><ul><li>绑定一个队列到头交换机上时，会同时绑定多个用于匹配的头<code>header</code>。</li><li>传来的消息会携带<code>header</code>，以及会有一个 <code>“x-match”</code>参数。<ul><li>当 “x-match” 设置为 “any” 时，消息头的任意一个值被匹配就可以满足条件</li><li>当 “x-match” 设置为 “all” 的时候，就需要消息头的所有值都匹配成功。</li></ul></li></ul></li></ul><h3 id="1-6-交换机小结"><a href="#1-6-交换机小结" class="headerlink" title="1.6 交换机小结"></a>1.6 交换机小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-165226361.png" alt="mark"></p><ul><li><strong>何时创建交换机或者队列的问题？</strong><ul><li><code>rabbitMQ</code> 的消息都存储在队列中，因此交换机的使用不用真正的耗费服务器的性能，但是队列是会的</li><li>所以衡量<code>rabbitMQ</code> 当前的QPS只需要看当前的队列即可</li><li>按照<code>rabbitMQ</code> 官方的建议，生产者和消费者都应该尝试创建队列<ul><li>这是一个很好的建议，但是不适用于所有的情况</li><li>如果业务架构之初已经考虑好了所有的情况，这样的话业务可以免去声明的过程，直接使用</li><li>还有一个好处的：可以确保交换机和队列之间正确的绑定<ul><li>这样不会出现发送的消息和交换器没有绑定任何队列造成的消息丢失</li><li>同时路由键无法与现存的队列进行匹配</li></ul></li><li>后期超过预定的QPS，只需要对集群进行扩容或者队列进行迁移即可</li></ul></li><li>总之，动态创建或者静态创建的方式需要从业务的逻辑去考虑</li></ul></li></ul><h2 id="2-入门代码演示"><a href="#2-入门代码演示" class="headerlink" title="2. 入门代码演示"></a>2. 入门代码演示</h2><h3 id="2-1-核心流程再讲"><a href="#2-1-核心流程再讲" class="headerlink" title="2.1 核心流程再讲"></a>2.1 核心流程再讲</h3><p><strong>生产者</strong></p><ul><li>生产者链接到<code>rabbitMQ Broker</code>,建立一个Connection并且开启一个信道</li><li>生产者声明一个交换器，并设置相关的属性，比如交换器的类型，是否持久化等</li><li>生产者声明一个队列并设置相关属性：是否排他，是否持久化，是否自动删除等</li><li>生产者通过路由键将交换器和队列绑定起来</li><li>生产者发送消息到<code>rabbitMQ Broker</code>，其中包含路由键，浇花器等信息</li><li>相应的交换器把接收到的路由key查找相匹配的队列<ul><li>如果找到，则将生产者发送过来的消息存入相应的队列中</li><li>如果没有找到，则根据生产者的配置属性选择丢弃还是退还给生产者</li></ul></li><li>关闭信道</li><li>关闭连接</li></ul><p><strong>消费者</strong></p><ul><li>消费者连接到 <code>rabbitMQ Broker</code>，建立一个连接并且开启一个信道</li><li>消费者向<code>rabbitMQ Broker</code>请求消费相应队列中的消息，可能会设置回调函数之类的</li><li>等待<code>rabbitMQ Broker</code>的回应并且投递相应队列中的消息</li><li>消费者确认（ACK）接收到的消息</li><li><code>rabbitMQ Broker</code> 从队列中删除相应的被确认的消息</li><li>关闭信道</li><li>关闭连接</li></ul><h3 id="2-2-fanout-发布-订阅"><a href="#2-2-fanout-发布-订阅" class="headerlink" title="2.2 fanout (发布/订阅)"></a>2.2 fanout (发布/订阅)</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-105512613.png" alt="mark"></p><ul><li>特点：Fanout—发布与订阅模式，是一种广播机制，它是没有路由key的模式。</li></ul><p><strong>生产者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"fanout"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队列的名字</span></span><br><span class="line">        <span class="keyword">final</span> String queueName = Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.接收消息并且处理异常</span></span><br><span class="line">            Channel finalchannel = channel;</span><br><span class="line">            finalchannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息是"</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收消息失败！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动三个线程去执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong><ul><li><strong><code>Connection</code> 可以用来创建多个<code>Channel</code> 实例，但是<code>Channel</code> 实例不能在线程间共享，应用程序应该为每一个线程开辟一个Channel。</strong></li><li>在某些情况下<code>Channel</code> 的操作可以并发的运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时会影响发送方的确认机制，所以多线程间共享channel是非线程安全的</li></ul></li></ul><h3 id="2-3-Direct"><a href="#2-3-Direct" class="headerlink" title="2.3 Direct"></a>2.3 Direct</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-152219269.png" alt="mark"></p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"direct"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">"你的路由key"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Topic"><a href="#2-4-Topic" class="headerlink" title="2.4 Topic"></a>2.4 Topic</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-152409430.png" alt="mark"></p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"topic"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">"模糊匹配"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-注意事项小结"><a href="#2-5-注意事项小结" class="headerlink" title="2.5 注意事项小结"></a>2.5 注意事项小结</h3><p><strong>注意</strong></p><ul><li><strong><code>Connection</code> 可以用来创建多个<code>Channel</code> 实例，但是<code>Channel</code> 实例不能在线程间共享，应用程序应该为每一个线程开辟一个Channel。</strong></li><li>在某些情况下<code>Channel</code> 的操作可以并发的运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时会影响发送方的确认机制，所以多线程间共享channel是非线程安全的</li></ul><ul><li><p><strong>生产者和消费者都可以声明一个交换器和队列。</strong></p><ul><li><p>如果声明的一个已经存在的交换器或者队列，只要声明的参数完全匹配现存的交换器或者队列，rabbitMQ就什么都不做</p></li><li><p>否则的话，就会抛出异常（<code>ShutdownSignalException</code>）</p></li></ul></li></ul><p><strong>应答AutoAck</strong></p><ul><li><strong>在生产实践中需要显示的设置<code>autoAck</code>为false,然后再接收到消息之后进行显示的ack操作（<code>channel.basicAck</code>） ，对于消费者来说这个是十分必要的，可以防止消息不必要的丢失</strong></li><li>当<code>autoAck</code>为false的时候，对于<code>rabbitMQ</code>服务器而言，队列的消息分为了两个部分<ul><li>一个是等待投递给消费者的消息</li><li>一个是已经投递给消费者，但是还没有收到确认的消息</li></ul></li><li>如果<code>rabbitMQ</code>服务器一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开了连接，那么<code>rabbitMQ</code>服务器会重新安排该消息进入队列，等待下一个消费者，可能这个消费者就是原来的那个消费者</li><li>如果将消息进行拒绝（<code>channel.basicReject 和 channel.basicNack</code>）中的 <code>requeue</code> 设置为false,那么将启用<strong>“死信队列”功能</strong><ul><li>死信队列可以通过检测被拒绝的消息或者未送达的消息来追踪问题</li></ul></li></ul><p><strong>对于消费和的推(push) 和 拉（pull）模式而言</strong></p><ul><li><code>Basic.Consume</code> 将 channel 设置为投递模式（push），直到取消队列的订阅为止。在投递消息的期间，RabbitMQ会不断的将消息推送给消费者，当然推送消息的个数还是收到<code>Basic.Qos</code>的限制</li><li>如果只想要获得带条消息而不是持续的订阅，建议还是使用<code>Basic.Get()</code>方法进行消费。(pull)</li><li>建议消费者应该使用<code>Basic.Consume</code> 来提高吞吐量</li></ul><h3 id="2-6-完整版本生产者"><a href="#2-6-完整版本生产者" class="headerlink" title="2.6 完整版本生产者"></a>2.6 完整版本生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 声明交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line">            String type = <span class="string">"direct"</span>;</span><br><span class="line">            channel.exchangeDeclare(exchangeName,type,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 路由key和声明队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">"queue5"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">"queue6"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">"queue7"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            String routingKey = <span class="string">"你的路由key"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 绑定队列</span></span><br><span class="line">            channel.queueBind(<span class="string">"queue5"</span>,exchangeName,routingKey);</span><br><span class="line">            channel.queueBind(<span class="string">"queue6"</span>,exchangeName,routingKey);</span><br><span class="line">            channel.queueBind(<span class="string">"queue7"</span>,exchangeName,routingKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 10. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 11. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>操作结果如下</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-165147022.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-165202693.png" alt="mark"></p><ul><li><strong>绑定的关系既可以在web界面进行声明也可以如上使用代码进行绑定</strong></li><li>最好使用代码的方式进行绑定</li><li><strong>如果队列或者交换机没有进行声明是会抛异常的</strong><ul><li><strong>同时消费者和生产者中声明队列和交换机都是可以的</strong></li><li><strong>因为channel是双向可以创建的</strong></li></ul></li></ul><h2 id="3-Worker-模式"><a href="#3-Worker-模式" class="headerlink" title="3. Worker 模式"></a>3. Worker 模式</h2><ul><li><strong>这里需要单独列出的是Woker模式</strong><ul><li>因为工作队列模式中有两种机制</li><li>分别是轮询模式和公平分发</li></ul></li></ul><ul><li><strong>如何均衡消费者消费信息的多少呢?</strong></li><li>主要有两种模式：<br>1、<strong>轮询模式</strong>的分发：一个消费者一条，<strong>按均分配；</strong><br>2、<strong>公平分发</strong>：根据消费者的消费能力进行公平分发，处理快的处理的多，处理慢的处理的少；<strong>按劳分配；</strong></li></ul><h3 id="3-1-轮询分发"><a href="#3-1-轮询分发" class="headerlink" title="3.1 轮询分发"></a>3.1 轮询分发</h3><ul><li>特点：该模式接收消息是当有多个消费者接入时，消息的分配模式是一个消费者分配一条，直至消息消费完成；</li><li><strong>默认情况下，rabbitMQ是轮询分发</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-113640288.png" alt="mark"></p><p><strong>代码样例</strong></p><ol><li><strong>生产者：生产消息进行投递</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line">            String queuename = <span class="string">"queue1"</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.queueDeclare(queuename,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//消息的内容</span></span><br><span class="line">                String msg = <span class="string">"朱酱酱:"</span> + i;</span><br><span class="line">                <span class="comment">// 7: 发送消息给中间件rabbitmq-server</span></span><br><span class="line">                <span class="comment">// @params1: 交换机exchange</span></span><br><span class="line">                <span class="comment">// @params2: 队列名称/routingkey</span></span><br><span class="line">                <span class="comment">// @params3: 属性配置</span></span><br><span class="line">                <span class="comment">// @params4: 发送消息的内容</span></span><br><span class="line">                channel.basicPublish(<span class="string">""</span>, <span class="string">"queue1"</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>消费者 worker1</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work1-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work1-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2：worker2(代码几乎一摸一样)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work2-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work2-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预览结果如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-152557735.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-152615219.png" alt="mark"></p><ul><li><strong>小结：可以看到的是，轮询分发不会因为服务器的性能差异而产生竞争消费，而是依次消费</strong></li><li>案例采用的是自动应答模式</li></ul><h3 id="3-2-公平分发"><a href="#3-2-公平分发" class="headerlink" title="3.2 公平分发"></a>3.2 公平分发</h3><ul><li>特点：由于消息接收者处理消息的能力不同，存在处理快慢的问题，我们就需要能者多劳，处理快的多处理，处理慢的少处理；</li><li><strong>公平分发：一定要将应答模式改为手动应答</strong></li></ul><p><strong>案例分析：</strong></p><ol><li><strong>生产者：代码不变</strong></li></ol><ol start="2"><li><strong>消费者1：关闭自动应答，设置手动应答</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.fair;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work1-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work1-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>消费者2：关闭自动应答，设置手动应答</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.fair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work2-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work2-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果预览</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-153656542.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-153708362.png" alt="mark"></p><ul><li><strong>小结：可以看到的是，消费者2由于性能较高，对消费者1的工作进行了截取</strong><ul><li>公平分发需要消费者开启手动应答，关闭自动应答</li><li>关闭自动应答代码channel.BasicConsume(“queue_test”, false, consumer);</li><li>消费者开启手动应答代码：channel.BasicAck(ea.DeliveryTag, false);</li><li>消费者一次接收一条消息，代码channel.BasicQos(0, 1, false);</li></ul></li></ul><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><ul><li>当队列里消息较多时，我们通常会开启多个消费者处理消息；公平分发和轮询分发都是我们经常使用的模式。</li><li>轮询分发的主要思想是“按均分配”，不考虑消费者的处理能力，所有消费者均分；这种情况下，处理能力弱的服务器，一直都在处理消息，而处理能力强的服务器，在处理完消息后，处于空闲状态；</li><li>公平分发的主要思想是”能者多劳”，按需分配，能力强的干的多。</li><li>Qos 在线上环境建议不要设置的太大，会影响服务器的性能</li><li><strong>默认情况下，rabbitMQ是轮询分发</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-07-交换机类型&quot;&gt;&lt;a href=&quot;#RabbitMQ-07-交换机类型&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-07-交换机类型&quot;&gt;&lt;/a&gt;RabbitMQ-07-交换机类型&lt;/h2&gt;&lt;h2 id=&quot;1-交换机的类型&quot;&gt;&lt;a href=&quot;#1-交换机的类型&quot; class=&quot;headerlink&quot; title=&quot;1. 交换机的类型&quot;&gt;&lt;/a&gt;1. 交换机的类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;AMQP 0-9-1 的代理提供了四种交换机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-150948908.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考官网：&lt;a href=&quot;https://www.rabbitmq.com/getstarted.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/getstarted.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-04-数据的表示</title>
    <link href="http://zhuuu.work/2021/03/27/Compute_Organization/%E8%AE%A1%E7%BB%84-04-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>http://zhuuu.work/2021/03/27/Compute_Organization/%E8%AE%A1%E7%BB%84-04-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/</id>
    <published>2021-03-27T03:02:24.000Z</published>
    <updated>2021-03-28T01:43:39.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-04-数据的表示"><a href="#计算机组成原理-04-数据的表示" class="headerlink" title="计算机组成原理-04-数据的表示"></a>计算机组成原理-04-数据的表示</h2><h2 id="1-定点数和浮点数的区别"><a href="#1-定点数和浮点数的区别" class="headerlink" title="1. 定点数和浮点数的区别"></a>1. 定点数和浮点数的区别</h2><ul><li><p>根据小数点的位置是否固定，在计算机内有两种数据格式</p><ul><li>定点数</li><li>浮点数</li></ul></li><li><p>定点表示：约定机器数中的小数点位置固定不变，小数点不再用“,”表示，而是约定了它的位置</p></li></ul><h2 id="2-无符号数和有符号数"><a href="#2-无符号数和有符号数" class="headerlink" title="2. 无符号数和有符号数"></a>2. 无符号数和有符号数</h2><ul><li><strong>无符号数</strong>：指整个机器字长的全部二进制位均为数值位，没有符号位。若机器字长为8位，则数的表示范围 0<del>2^8-1 , 即0</del>255。<ul><li>无符号数一般只代表整数，不代表小数</li></ul></li><li><strong>有符号数</strong>：在机器中，数的正负我们无法识别，但是我们可以用<strong>二进制数来代替正负号。一般‘0’为正，‘1’为负</strong>，符号位一般在有效数的最前面。若机器字长为8位，是有符号数，则数的表示范围为 -2^7<del>2^7-1 ，即-128</del>127。</li></ul><a id="more"></a><h2 id="3-定点数的表示"><a href="#3-定点数的表示" class="headerlink" title="3. 定点数的表示"></a>3. 定点数的表示</h2><ul><li>定点小数：一般将小数点的位置固定在数据的<code>最高位之前</code>。</li><li>定点整数：一般将小数点的位置固定在数据的<code>最低位之后</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091024201.png" alt="mark"></p><h3 id="3-1-原码"><a href="#3-1-原码" class="headerlink" title="3.1 原码"></a>3.1 原码</h3><ul><li>用机器数的最高位来代表该数的符号，其余的各位表示数的绝对值    </li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091658245.png" alt="mark"></p><h3 id="3-2-反码"><a href="#3-2-反码" class="headerlink" title="3.2 反码"></a>3.2 反码</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091855834.png" alt="mark"></p><ul><li>反码通常用于原码求补码的中间过渡</li><li>反码<ul><li>若符号位为0，则反码和原码相同</li><li>若符号位为1，则数值位全部取反</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-092022869.png" alt="mark"></p><h3 id="3-3-补码"><a href="#3-3-补码" class="headerlink" title="3.3 补码"></a>3.3 补码</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093338403.png" alt="mark"></p><ul><li>正数的补码和原码相同</li><li>负数的补码<ul><li>先求出反码</li><li>反码的基础上+1（需要注意进位的问题）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093400463.png" alt="mark"></p><ul><li>补码如何求原码？<ul><li>正数的补码和原码一样</li><li>负数 ：数值位全部取反，然后+1</li></ul></li></ul><h3 id="3-4-移码"><a href="#3-4-移码" class="headerlink" title="3.4 移码"></a>3.4 移码</h3><ul><li>移码的特性：非常方便比较大小</li><li>只能用于表示整数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093731979.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093824082.png" alt="mark"></p><h3 id="3-5-例题小结"><a href="#3-5-例题小结" class="headerlink" title="3.5 例题小结"></a>3.5 例题小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-094010561.png" alt="mark"></p><ul><li><strong>如何从[x]补 求得 [-x]补</strong><ul><li>技巧：符号位 数值位 全部取反</li><li>并且末尾+1</li></ul></li><li><strong>转换技巧小结</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-094226591.png" alt="mark"></p><h2 id="4-定点数的移位操作"><a href="#4-定点数的移位操作" class="headerlink" title="4. 定点数的移位操作"></a>4. 定点数的移位操作</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-04-数据的表示&quot;&gt;&lt;a href=&quot;#计算机组成原理-04-数据的表示&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-04-数据的表示&quot;&gt;&lt;/a&gt;计算机组成原理-04-数据的表示&lt;/h2&gt;&lt;h2 id=&quot;1-定点数和浮点数的区别&quot;&gt;&lt;a href=&quot;#1-定点数和浮点数的区别&quot; class=&quot;headerlink&quot; title=&quot;1. 定点数和浮点数的区别&quot;&gt;&lt;/a&gt;1. 定点数和浮点数的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据小数点的位置是否固定，在计算机内有两种数据格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定点数&lt;/li&gt;
&lt;li&gt;浮点数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定点表示：约定机器数中的小数点位置固定不变，小数点不再用“,”表示，而是约定了它的位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-无符号数和有符号数&quot;&gt;&lt;a href=&quot;#2-无符号数和有符号数&quot; class=&quot;headerlink&quot; title=&quot;2. 无符号数和有符号数&quot;&gt;&lt;/a&gt;2. 无符号数和有符号数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无符号数&lt;/strong&gt;：指整个机器字长的全部二进制位均为数值位，没有符号位。若机器字长为8位，则数的表示范围 0&lt;del&gt;2^8-1 , 即0&lt;/del&gt;255。&lt;ul&gt;
&lt;li&gt;无符号数一般只代表整数，不代表小数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有符号数&lt;/strong&gt;：在机器中，数的正负我们无法识别，但是我们可以用&lt;strong&gt;二进制数来代替正负号。一般‘0’为正，‘1’为负&lt;/strong&gt;，符号位一般在有效数的最前面。若机器字长为8位，是有符号数，则数的表示范围为 -2^7&lt;del&gt;2^7-1 ，即-128&lt;/del&gt;127。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-06-核心组成部分</title>
    <link href="http://zhuuu.work/2021/03/26/rabbitMQ/RabbitMQ-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/"/>
    <id>http://zhuuu.work/2021/03/26/rabbitMQ/RabbitMQ-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</id>
    <published>2021-03-26T08:02:24.000Z</published>
    <updated>2021-03-26T09:03:37.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-06-核心组成部分"><a href="#RabbitMQ-06-核心组成部分" class="headerlink" title="RabbitMQ-06-核心组成部分"></a>RabbitMQ-06-核心组成部分</h2><h2 id="1-核心组成概览"><a href="#1-核心组成概览" class="headerlink" title="1. 核心组成概览"></a>1. 核心组成概览</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-114609454.png" alt="mark"></p><p><strong>核心概念：</strong></p><ul><li><strong>Server</strong>：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server</li><li><strong>Connection</strong>：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手</li><li><strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。</li><li><strong>Message</strong> :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。</li><li><strong>Virtual Host</strong> 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机可以有若干个Exhange和Queue，同一个虚拟主机里面不能有相同名字的Exchange</li><li><strong>Exchange</strong>：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)</li><li><strong>Bindings</strong>：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.</li><li><strong>Routing key</strong>：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。</li><li><strong>Queue</strong>：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144505890.png" alt="mark"></p><a id="more"></a><h2 id="2-运行流程"><a href="#2-运行流程" class="headerlink" title="2. 运行流程"></a>2. 运行流程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144556342.png" alt="mark"></p><ul><li><strong>Producer ：</strong> 生产者创建消息，然后发布到RabbitMQ中，消息一般包含两个部分：消息体和标签（Label）。消息体也可以称为<code>payload</code>, 在实际的应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JSON字符串，当然可以进一步对这个 消息体进行序列化操作。</li><li><strong>Consumer :</strong> 消费者连接到rabbitMQ服务器，并订阅到该队列上。当消费者消费一条消息的时候，只是消费消息体（payload）。在消息路由的过程中，消息的标签会被丢弃，存入到队列的消息只有消息体，消费者也只会得到消息体，也就是不知道消息的生产者是谁，，当然消费者也不需要知道这些。</li><li><strong>Broker :</strong> 对于rabbitMQ来说，一个rabbitMQ broker 可以看作一台服务节点，也就是服务器</li></ul><p><strong>注意</strong></p><ul><li><p>真实的情况是，生产者将消息发送到<code>Exchange</code>,而不是将消息发送到队列中，由交换机将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。</p></li><li><p>如果不填，默认是一定存在一个交换机的</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-145855934.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-145901162.png" alt="mark"></p><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h2><ul><li>AMQP 中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。</li></ul><h3 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h3><p>队列跟交换机共享某些属性，<strong>但是队列也有一些另外的属性。</strong></p><ul><li><p>Name</p></li><li><p>Durable（消息代理重启后，队列依旧存在）</p></li><li><p>Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）</p></li><li><p>Auto-delete（当最后一个消费者退订后即被删除</p></li><li><p>Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）</p></li></ul><h3 id="3-2-队列的创建"><a href="#3-2-队列的创建" class="headerlink" title="3.2 队列的创建"></a>3.2 队列的创建</h3><ul><li>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。</li><li>如果声明的队列已经存在，并且属性<strong>完全相同</strong>，那么此次声明不会对原有队列产生任何影响。</li><li>如果声明中的属性与已存在队列的<strong>属性有差异</strong>，那么一个错误代码为 406 的通道级异常就会被抛出。</li></ul><h3 id="3-3-队列的持久化"><a href="#3-3-队列的持久化" class="headerlink" title="3.3 队列的持久化"></a>3.3 队列的持久化</h3><ul><li><p><strong>持久化队列<code>（Durable queues）</code>会被存储在磁盘</strong>上，当消息代理<code>（broker）</code>重启的时候，它依旧存在。</p></li><li><p><strong>没有被持久化的队列称作暂存队列</strong>（<code>Transient queues</code>）。并不是所有的场景和案例都需要将队列持久化。</p></li><li><p><strong>持久化的队列并不会使得路由到它的消息也具有持久性</strong>。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p></li></ul><h2 id="4-消费者"><a href="#4-消费者" class="headerlink" title="4. 消费者"></a>4. 消费者</h2><ul><li><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。在 AMQP 0-9-1 模型中，有两种途径可以达到此目的：</p><ul><li>将消息投递给应用 <strong>(“push API”)</strong></li><li>应用根据需要主动获取消息 <strong>(“pull API”)</strong></li></ul></li><li><p><strong>使用 push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。</strong>如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p></li><li><p><strong>每个消费者（订阅者）都有一个叫做消费者标签的标识符</strong>。它可以被用来退订消息。消费者标签实际上是一个字符串。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-06-核心组成部分&quot;&gt;&lt;a href=&quot;#RabbitMQ-06-核心组成部分&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-06-核心组成部分&quot;&gt;&lt;/a&gt;RabbitMQ-06-核心组成部分&lt;/h2&gt;&lt;h2 id=&quot;1-核心组成概览&quot;&gt;&lt;a href=&quot;#1-核心组成概览&quot; class=&quot;headerlink&quot; title=&quot;1. 核心组成概览&quot;&gt;&lt;/a&gt;1. 核心组成概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-114609454.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Server&lt;/strong&gt;：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connection&lt;/strong&gt;：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Channel&lt;/strong&gt;：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message&lt;/strong&gt; :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Virtual Host&lt;/strong&gt; 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机可以有若干个Exhange和Queue，同一个虚拟主机里面不能有相同名字的Exchange&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exchange&lt;/strong&gt;：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bindings&lt;/strong&gt;：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Routing key&lt;/strong&gt;：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt;：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144505890.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-03-校验码</title>
    <link href="http://zhuuu.work/2021/03/26/Compute_Organization/%E8%AE%A1%E7%BB%84-03-%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
    <id>http://zhuuu.work/2021/03/26/Compute_Organization/%E8%AE%A1%E7%BB%84-03-%E6%A0%A1%E9%AA%8C%E7%A0%81/</id>
    <published>2021-03-26T03:02:24.000Z</published>
    <updated>2021-03-27T12:43:21.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-03-校验码"><a href="#计算机组成原理-03-校验码" class="headerlink" title="计算机组成原理-03-校验码"></a>计算机组成原理-03-校验码</h2><h2 id="1-校验码概述"><a href="#1-校验码概述" class="headerlink" title="1. 校验码概述"></a>1. 校验码概述</h2><ul><li><p>校验码：指能够<code>发现</code>或能够<code>自动纠正错误</code>的数据编码，也称检错纠错编码。</p></li><li><p>实现原理：通过加一<code>冗余码</code>，来检验或纠错编码</p></li><li><p>码距：简单来说就是两个二进制数比较，在同一数位的地方，数位值不同的个数有多少个，即码距，也称海明距离；</p></li><li><p>两种方法计算码距。比如0100和1111<br><code>直接观察法</code>：可以看出，有3个数位值不同，所以码距为3.<br><code>异或计算法</code>：0100⊕1111=1011 ，结果为1011，里面有几个1就代表有多少个数位值不同，即码距是多少，这里码距是3。</p></li></ul><a id="more"></a><h2 id="2-奇偶校验码"><a href="#2-奇偶校验码" class="headerlink" title="2. 奇偶校验码"></a>2. 奇偶校验码</h2><ul><li>实现原理： 在原编码中加一个校验位，则<code>原编码就变成了校验码</code>，它的码距为2，可以检查出奇数位错误，但不能检查出偶数位错误，增加的冗余位为奇偶校验位，一般校验位设置在原编码的最左边或最右边。</li><li>奇校验码：整个校验码（信息位+校验位）中1的个数位奇数</li><li>偶校验码：整个校验码（信息位+校验位）中1的个数位偶数</li></ul><h3 id="2-1-奇校验"><a href="#2-1-奇校验" class="headerlink" title="2.1 奇校验"></a>2.1 奇校验</h3><p><strong>如何检测出错误？</strong></p><ul><li>首先在计算机中，我们<strong>就要约定好，数据是采用奇校验还是偶校验</strong>，下面分奇校验和偶校验来说明一下奇偶校验如何检查在计算机传输数据的过程中数据是否正确。</li><li>假设我们的原始编码是<code>10110111</code>，因为我们规定计算机采用<code>奇校验</code>，所以我们在原编码最左边多加了一个校验位，并置为1，那么原编码就变成了奇校验码，有奇数（7）个1。<ul><li><code>传输过程中奇数个数据改变</code>：在传输过程中有<code>奇数个数位值发生了改变</code>，那么我们通过<code>奇校验运算</code>，可以发现现在变成了6个1，和奇校验码相比有3个数位值发生了改变，奇校验码不再有奇数个1，而是变成了偶数个1，可以判断我们的数据发生了改变，可以检查出错误。</li><li><code>传输过程中有偶数个数据改变</code>：在传输过程中有<code>偶数个数位值发生了改变</code>，那么我们通过<code>奇校验运算</code>，都是奇数，这时我们便无法通过奇校验运算判断数据是否发生了改变，<code>即无法检查出偶数个错误</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-093122129.png" alt="mark"></p><h3 id="2-2-偶校验"><a href="#2-2-偶校验" class="headerlink" title="2.2 偶校验"></a>2.2 偶校验</h3><ul><li>假设我们的原始编码是<code>10110111</code>，因为我们规定计算机采用<code>偶校验</code>，所以我们在原编码最左边多加了一个校验位，并置为0，那么原编码就变成了偶校验码，有偶数（6）个1。<ul><li><code>传输过程中奇数个数据改变</code>：在传输过程中有<code>奇数个数位值发生了改变</code>，那么我们通过<code>偶校验运算</code>，可以发现现在变成了5个1，和偶校验码相比有3个数位值发生了改变，偶校验码不再有偶数个1，而是变成了奇数个1，可以判断我们的数据发生了改变，可以检查出错误。</li><li><code>传输过程中有偶数个数据改变</code>：在传输过程中有<code>偶数个数位值发生了改变</code>，那么我们通过<code>偶校验运算</code>，可以发现现在变成了6个1，和原偶校验码6个1一样，都是偶数，这时我们便无法通过偶校验运算判断数据是否发生了改变，<code>即无法检查出偶数个错误</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-093311353.png" alt="mark"></p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><ul><li>通过上述奇偶校验两种方式校验数据，<strong>可以比较得出奇偶校验可以检测出奇数个错误而无法检查出偶数个错误，也无法纠正错误，无法定位错误位置。</strong></li></ul><h2 id="3-汉明校验码"><a href="#3-汉明校验码" class="headerlink" title="3. 汉明校验码"></a>3. 汉明校验码</h2><ul><li>一种多重奇偶校验码。</li><li><strong>实现原理</strong>：在有效信息位中加入几个校验位形成海明码，并把海明码的每一个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化。</li><li>特点：可以发现错误，定位错误位置，自动纠正错误。 <code>可以检测双比特错误，但只能纠正单比特错误</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">纠错理论：L-1&#x3D;D+C且D≥C</span><br><span class="line">编码最小码距L越大，其检测错误的位数D越大，纠正错误的位数C也越大，且纠错能力恒小于检错能力</span><br></pre></td></tr></table></figure><h3 id="3-1-例题讲解"><a href="#3-1-例题讲解" class="headerlink" title="3.1 例题讲解"></a>3.1 例题讲解</h3><ul><li>信息为 n=4 , 校验位 k=3,求1010的海明码</li></ul><ol><li><strong>确定海明码的位数</strong></li></ol><ul><li>根据公式：<strong>2k ≥ n+k+1</strong>（若要检测两位错，则需再增加1位校验位，即k+1位）</li><li>海明码位数n+k=7，公式 <strong>2^3 ≥ n+k+1=8</strong>成立，n,k有效。设置变量来表示信息位、校验位、海明码。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203146422.png" alt="mark"></p><ol start="2"><li><strong>确定校验位的分布</strong></li></ol><ul><li>规定校验位 pi 在海明位号位 2^(i-1) 的位置上，所以：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203249694.png" alt="mark"></p><ol start="3"><li><strong>分组形成校验关系</strong></li></ol><ul><li>每个数据位用多个校验位来检验。</li><li>必须满足条件：<code>被校验数据位的海明码位号 = 校验该数据位的各校验位海明位号之和</code>，比如校验D3，它的海明位号H6为6，那么校验它的校验位为P3和P2，因为他们的海明位号H4和H2加起来等于6。（化为二进制的位数）</li><li>校验位不需要再被校验</li><li>分组关系如图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203511638.png" alt="mark"></p><ol start="4"><li><strong>校验位的取值</strong></li></ol><ul><li>Pi的值 = 第 i 组所有数据位求异或⨁</li><li>P1=D1⨁D2⨁D4=0</li><li>P2=D1⨁D3⨁D4=1</li><li>P3=D2⨁D3⨁D4=0</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203558634.png" alt="mark"></p><ol start="5"><li><strong>海明码的校验原理</strong></li></ol><ul><li><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，即异或运算⨁，构成k个校验方程。</p><ul><li>S1=P1⨁D1⨁D2⨁D4</li><li>S2=P2⨁D1⨁D3⨁D4</li><li>S3=P3⨁D2⨁D3⨁D4</li></ul></li><li><p>若S1S2S3=000,则说明无错，否则说明出错。</p></li><li><p>这个数的值就是出错的位置，如S1S2S3=001,表示第1位出错，即H1出错，直接将该位取反就可以达到<code>纠错</code>的目的。</p></li></ul><h2 id="4-循环冗余CRC码"><a href="#4-循环冗余CRC码" class="headerlink" title="4. 循环冗余CRC码"></a>4. 循环冗余CRC码</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203807533.png" alt="mark"></p><ul><li>基本思想：校验码中的一种。在K位信息位后拼接R位检验位，组成CRC码，这种编码也称(N,R)码</li><li>特点：可以发现错误，定位错误位置，自动纠正错误。<code>可检测出所有奇数位错，所有双比特的错和所有小于、等于校验位长度的突发错</code></li></ul><ol><li><strong>生成多项式</strong></li></ol><ul><li>首先，发送端和接受端会有一个生成多项式G(x)约定,生成多项式G(x)的最高次幂为<code>R</code>。任意一个二进制数码都可用一个系数为0或1的多项式与之对应。比如：二进制数码 1101 对应的G(x)=1<em>X^3+1</em>X^2+0<em>X^1+1</em>X^0= X^3+X^2+1</li><li>在发送端，将要传送的K位二进制信息码左移R位，将它与生成多项式G(x)所对应的的二进制数码进行<code>模2除法</code>，产生余数，生成一个R位检验码，并附在信息码后，构成一个新的二进制码（CRC）码，共K+R位。</li></ul><h3 id="4-1-例题讲解"><a href="#4-1-例题讲解" class="headerlink" title="4.1 例题讲解"></a>4.1 例题讲解</h3><ul><li>例题： 设生成多项式G(x)=X^3+X^2+1 ,信息码为 101001 ，求对应的CRC码 。</li></ul><p><strong>分析</strong></p><ul><li>分析：校验位长度：R=3 , 信息码长度：K=6 , CRC码长度：N=R+K= 9</li><li>生成多项式对应二进制码：1101</li></ul><ol><li><strong>信息码左移R位</strong></li></ol><ul><li>发送端将原信息码左移R位，低位补0：101001 000</li></ul><ol start="2"><li><strong>模2除得到余数</strong></li></ol><ul><li>方法：发送端用移位后的信息码 101001000 除以G(x)所对应的二进制数码 1101 求余数，余数除得够就写1，不够就写0，直到余数小于 1101 ，余数即为校验位的数值。</li><li>图中即为具体计算步骤，得到最后的结果CRC码为：101001 001，然后发送端将CRC码101001 001发送给接收端。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-204223140.png" alt="mark"></p><ol start="3"><li><strong>如何检错和纠错？</strong></li></ol><ul><li><p>接收端收到CRC码后，用生成的CRC码除以生成多项式G(x)所对应的的二进制数码，<strong>若余数为0，则信息码在传输过程中没有产生错误，数据正确。</strong></p></li><li><p>若接受到的CRC码为<code>C9C8C7C6C5C4C3C2C1= 101001011</code>,除以G(x)所对应的二进制码1101得到余数为010，不为0，说明数据在传输过程中产生错误。<code>010=2（10）</code>说明C2出错，将C2取反即可纠正错误。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-03-校验码&quot;&gt;&lt;a href=&quot;#计算机组成原理-03-校验码&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-03-校验码&quot;&gt;&lt;/a&gt;计算机组成原理-03-校验码&lt;/h2&gt;&lt;h2 id=&quot;1-校验码概述&quot;&gt;&lt;a href=&quot;#1-校验码概述&quot; class=&quot;headerlink&quot; title=&quot;1. 校验码概述&quot;&gt;&lt;/a&gt;1. 校验码概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;校验码：指能够&lt;code&gt;发现&lt;/code&gt;或能够&lt;code&gt;自动纠正错误&lt;/code&gt;的数据编码，也称检错纠错编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现原理：通过加一&lt;code&gt;冗余码&lt;/code&gt;，来检验或纠错编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;码距：简单来说就是两个二进制数比较，在同一数位的地方，数位值不同的个数有多少个，即码距，也称海明距离；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两种方法计算码距。比如0100和1111&lt;br&gt;&lt;code&gt;直接观察法&lt;/code&gt;：可以看出，有3个数位值不同，所以码距为3.&lt;br&gt;&lt;code&gt;异或计算法&lt;/code&gt;：0100⊕1111=1011 ，结果为1011，里面有几个1就代表有多少个数位值不同，即码距是多少，这里码距是3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-02-进制与编码</title>
    <link href="http://zhuuu.work/2021/03/25/Compute_Organization/%E8%AE%A1%E7%BB%84-02-%E8%BF%9B%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <id>http://zhuuu.work/2021/03/25/Compute_Organization/%E8%AE%A1%E7%BB%84-02-%E8%BF%9B%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/</id>
    <published>2021-03-25T03:02:24.000Z</published>
    <updated>2021-03-26T01:20:26.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-02-数据的表示和运算"><a href="#计算机组成原理-02-数据的表示和运算" class="headerlink" title="计算机组成原理-02-数据的表示和运算"></a>计算机组成原理-02-数据的表示和运算</h2><h2 id="1-进制概述"><a href="#1-进制概述" class="headerlink" title="1. 进制概述"></a>1. 进制概述</h2><ol><li><strong>使用二进制的原因</strong><ul><li>二进制只有两种状态，物理电路的高电平和低电平可以很好的表示0和1</li><li>二进制的0和1正好可以分别代表 true 和 false</li><li>二进制的运算规则特别适合逻辑门电路的计算</li></ul></li></ol><a id="more"></a><ul><li><strong>10进制</strong></li></ul><blockquote><p>先说 我们最 熟悉的 10进制 , 就是 用 0~9 的数表示 , 逢 10 进 1 .</p></blockquote><ul><li><strong>16进制</strong></li></ul><blockquote><p>如果是 16 进制 , 它就是 由 0-9，A-F组成， 与10进制的对应关系是：0-9 对应 0-9；A-F对应10-15；<br>字母不区分大小写。</p></blockquote><ul><li><strong>2进制 和 8进制</strong></li></ul><blockquote><p>2进制 由 0-1组成</p><p>8进制 由 0-7组成</p></blockquote><p><strong>再看几个特别的例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 写出各个进制1-20</span><br><span class="line"></span><br><span class="line"># 一进制 </span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"># 三进制</span><br><span class="line">0 1 2</span><br><span class="line">101112</span><br><span class="line">202122</span><br><span class="line">100101102</span><br><span class="line">110111112</span><br><span class="line">120121122</span><br><span class="line">1000 .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 七进制</span><br><span class="line">0123456</span><br><span class="line">10111213141516</span><br><span class="line">20212223242526</span><br><span class="line">30313233343536</span><br><span class="line"></span><br><span class="line"># 十进制(自己定义)</span><br><span class="line">0 1 2 3 4 5 6 7 8 9        10  11 12</span><br><span class="line">0 2 4 6 8 9 a c d f    20  22 24</span><br></pre></td></tr></table></figure><ul><li><strong>八进制</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 八进制计算下面结果</span><br><span class="line"></span><br><span class="line">2 + 3 &#x3D; 5</span><br><span class="line">2 * 3 &#x3D; 6</span><br><span class="line">4 + 5 &#x3D; 11</span><br><span class="line">4 * 5 &#x3D; 24</span><br><span class="line"></span><br><span class="line"># 运算的本质就是查数</span><br><span class="line">0 1 2 3 4 5 6 7 </span><br><span class="line">10 11 12 13 14 15 16 17</span><br><span class="line">20 21 22 23 24 25 26 27</span><br><span class="line"></span><br><span class="line">八进制计算  (进位和计算)</span><br><span class="line">277 + 333 &#x3D; </span><br><span class="line">276 * 54 &#x3D; </span><br><span class="line">237 - 54 &#x3D; </span><br><span class="line">234 &#x2F; 4 &#x3D;</span><br></pre></td></tr></table></figure><ul><li><strong>各种进制的乘法表</strong>：<a href="https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**八进制乘法表**</span><br></pre></td></tr></table></figure><table><thead><tr><th>1*1 = 1</th><th>1*2 = 2</th><th>1*3 = 3</th><th>1*4 =4</th><th>1*5 =5</th><th>1*6 = 6</th><th>1*7 = 7</th></tr></thead><tbody><tr><td>2*2 = 2</td><td>2*3 = 6</td><td>2*4 = 10</td><td>2*5 = 12</td><td>2*6 = 14</td><td>2*7 = 16</td><td></td></tr><tr><td>3*3 = 11</td><td>3*4 = 14</td><td>3*5 = 17</td><td>3* 6 = 22</td><td>3*7 = 25</td><td></td><td></td></tr><tr><td>4*4 = 20</td><td>4 * 5= 24</td><td>4*6 = 30</td><td>4*7 = 34</td><td></td><td></td><td></td></tr><tr><td>5*5 = 31</td><td>5*6 = 36</td><td>5*7 = 43</td><td></td><td></td><td></td><td></td></tr><tr><td>6*6 = 44</td><td>6*7 = 52</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7*7 = 61</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h2><ul><li>所谓进位计数法是一种计数方法，咱们最常用的莫过于十进制了，除此之外还有八进制、十六进制等。</li><li>这里不得不提几个概念术语：<ul><li>基数：比如说十进制、八进制和十六进制，它们的基数分别为10（0<del>9）、8（0</del>7）、16（0~15）</li><li>数位：比如二进制数1010，这里就有4个数位，从高位到低位依次的数码值为1、0、1、1</li><li>数码：比如八进制，那么数码，即数码值的范围为（0~7）</li><li>基数和数码的关系：每个数位所用到的不同数码的个数称为基</li><li>位权：每个数码所表示的数值等于该数码值乘以一个与它所在位有关的常数，这个常数称为位权。</li></ul></li></ul><ol start="2"><li><strong>二进制转换为八进制和十六进制</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-085929193.png" alt="mark"></p><ol start="3"><li><strong>十进制转换成二进制</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090058906.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li><strong>不是每一个十进制小数都可以准确的用二进制表示<code>，比如：0.3转换为二进制数，无论经过多少次</code>乘二取整<code>都</code>无法获得精确<code>的结果。</code>但任意一个二进制小数都可以用十进制小数表示！！！</strong></li></ul><h2 id="3-真值，机器数"><a href="#3-真值，机器数" class="headerlink" title="3. 真值，机器数"></a>3. 真值，机器数</h2><ul><li><strong>真值</strong>：我们日常见到的，有<code>“+”、“-”</code>号的数为真值，比如：+5，-7。真值是机器数所代表的实际值，一般为十进制数。</li><li><strong>机器数</strong>：将<code>“符号-&gt;数字化”</code>的数。一般为二进制数，比如带符号位的4位二进制数<strong>0</strong>110，最高位<code>0</code>就是符号位，这个数的<code>真值就是+6</code>。通常<code>0</code>代表“+”号，<code>1</code>代表<code>-</code>号。</li></ul><h2 id="4-BCD-码"><a href="#4-BCD-码" class="headerlink" title="4. BCD 码"></a>4. BCD 码</h2><ul><li><p>简单来说：就是用<strong>4位二进制数来表示1位十进制数（0—9）</strong>，是一种用二进制编码来代替十进制编码的方式。</p></li><li><p>BCD码可分为两类：<code>有权码和无权码</code></p></li><li><p>这种编码方法使得二进制数和十进制数之间的转换十分的快速，但4位二进制数字可以转换出16中代码的组合，因此会有6种冗余的状态。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090452539.png" alt="mark"></p><h3 id="4-1-8421码"><a href="#4-1-8421码" class="headerlink" title="4.1 8421码"></a>4.1 8421码</h3><ul><li><strong>其中最常用的BCD码就是8421码</strong></li><li>当两个8421码进行计算时，如果结果<code>小于等于9</code>，则不作任何操作</li><li>如果计算结果<code>大于9</code>则需要进行+6的修正操作（10-18（9+9）需要进行修正，1010-10010范围）需要进行修正操作，并向高位进位</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090727440.png" alt="mark"></p><h2 id="5-ASCII-码"><a href="#5-ASCII-码" class="headerlink" title="5. ASCII 码"></a>5. ASCII 码</h2><p>ASCII码大致由三部分组成： </p><ol><li><strong>ASCII 打印字符：</strong>数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。注：十进制32代表空格 ，十进制数字 127 代表 DELETE 命令。下面是ASCII码和相应数字的对照表</li></ol><table><thead><tr><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td></td><td></td><td></td></tr><tr><td>032</td><td>20</td><td></td><td></td><td>056</td><td>38</td><td>8</td><td></td><td>080</td><td>50</td><td>P</td><td></td><td>104</td><td>68</td><td>h</td></tr><tr><td>033</td><td>21</td><td>!</td><td></td><td>057</td><td>39</td><td>9</td><td></td><td>081</td><td>51</td><td>Q</td><td></td><td>105</td><td>69</td><td>i</td></tr><tr><td>034</td><td>22</td><td>“</td><td></td><td>058</td><td>3A</td><td>:</td><td></td><td>082</td><td>52</td><td>R</td><td></td><td>106</td><td>6A</td><td>j</td></tr><tr><td>035</td><td>23</td><td>#</td><td></td><td>059</td><td>3B</td><td>;</td><td></td><td>083</td><td>53</td><td>S</td><td></td><td>107</td><td>6B</td><td>k</td></tr><tr><td>036</td><td>24</td><td>$</td><td></td><td>060</td><td>3C</td><td>&lt;</td><td></td><td>084</td><td>54</td><td>T</td><td></td><td>108</td><td>6C</td><td>l</td></tr><tr><td>037</td><td>25</td><td>%</td><td></td><td>061</td><td>3D</td><td>=</td><td></td><td>085</td><td>55</td><td>U</td><td></td><td>109</td><td>6D</td><td>m</td></tr><tr><td>038</td><td>26</td><td>&amp;</td><td></td><td>062</td><td>3E</td><td>&gt;</td><td></td><td>086</td><td>56</td><td>V</td><td></td><td>110</td><td>6E</td><td>n</td></tr><tr><td>039</td><td>27</td><td>‘</td><td></td><td>063</td><td>3F</td><td>?</td><td></td><td>087</td><td>57</td><td>W</td><td></td><td>111</td><td>6F</td><td>o</td></tr><tr><td>040</td><td>28</td><td>(</td><td></td><td>064</td><td>40</td><td>@</td><td></td><td>088</td><td>58</td><td>X</td><td></td><td>112</td><td>70</td><td>p</td></tr><tr><td>041</td><td>29</td><td>)</td><td></td><td>065</td><td>41</td><td>A</td><td></td><td>089</td><td>59</td><td>Y</td><td></td><td>113</td><td>71</td><td>q</td></tr><tr><td>042</td><td>2A</td><td>*</td><td></td><td>066</td><td>42</td><td>B</td><td></td><td>090</td><td>5A</td><td>Z</td><td></td><td>114</td><td>72</td><td>r</td></tr><tr><td>043</td><td>2B</td><td>+</td><td></td><td>067</td><td>43</td><td>C</td><td></td><td>091</td><td>5B</td><td>[</td><td></td><td>115</td><td>73</td><td>s</td></tr><tr><td>044</td><td>2C</td><td>,</td><td></td><td>068</td><td>44</td><td>D</td><td></td><td>092</td><td>5C</td><td>\</td><td></td><td>116</td><td>74</td><td>t</td></tr><tr><td>045</td><td>2D</td><td>-</td><td></td><td>069</td><td>45</td><td>E</td><td></td><td>093</td><td>5D</td><td>]</td><td></td><td>117</td><td>75</td><td>u</td></tr><tr><td>046</td><td>2E</td><td>.</td><td></td><td>070</td><td>46</td><td>F</td><td></td><td>094</td><td>5E</td><td>^</td><td></td><td>118</td><td>76</td><td>v</td></tr><tr><td>047</td><td>2F</td><td>/</td><td></td><td>071</td><td>47</td><td>G</td><td></td><td>095</td><td>5F</td><td>_</td><td></td><td>119</td><td>77</td><td>w</td></tr><tr><td>048</td><td>30</td><td>0</td><td></td><td>072</td><td>48</td><td>H</td><td></td><td>096</td><td>60</td><td>`</td><td></td><td>120</td><td>78</td><td>x</td></tr><tr><td>049</td><td>31</td><td>1</td><td></td><td>073</td><td>49</td><td>I</td><td></td><td>097</td><td>61</td><td>a</td><td></td><td>121</td><td>79</td><td>y</td></tr><tr><td>050</td><td>32</td><td>2</td><td></td><td>074</td><td>4A</td><td>J</td><td></td><td>098</td><td>62</td><td>b</td><td></td><td>122</td><td>7A</td><td>z</td></tr><tr><td>051</td><td>33</td><td>3</td><td></td><td>075</td><td>4B</td><td>K</td><td></td><td>099</td><td>63</td><td>c</td><td></td><td>123</td><td>7B</td><td>{</td></tr><tr><td>052</td><td>34</td><td>4</td><td></td><td>076</td><td>4C</td><td>L</td><td></td><td>100</td><td>64</td><td>d</td><td></td><td>124</td><td>7C</td><td>|</td></tr><tr><td>053</td><td>35</td><td>5</td><td></td><td>077</td><td>4D</td><td>M</td><td></td><td>101</td><td>65</td><td>e</td><td></td><td>125</td><td>7D</td><td>}</td></tr><tr><td>054</td><td>36</td><td>6</td><td></td><td>078</td><td>4E</td><td>N</td><td></td><td>102</td><td>66</td><td>f</td><td></td><td>126</td><td>7E</td><td>~</td></tr><tr><td>055</td><td>37</td><td>7</td><td></td><td>079</td><td>4F</td><td>O</td><td></td><td>103</td><td>67</td><td>g</td><td></td><td>127</td><td>7F</td><td>DEL</td></tr></tbody></table><ol start="2"><li><strong>ASCII 非打印控制字符：</strong>ASCII 表上的数字 0–31 分配给了控制字符，用于控制像打印机等一些外围设备。例如，12 代表换页/新页功能。此命令指示打印机跳到下一页的开头。</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-091133175.png" alt="mark"></p><ol start="3"><li><strong>扩展 ASCII 打印字符：</strong>扩展的 ASCII 字符满足了对更多字符的需求。扩展的 ASCII 包含 ASCII 中已有的 128 个字符（数字 0–32 显示在下图中），又增加了 128 个字符，总共是 256 个。即使有了这些更多的字符，许多语言还是包含无法压缩到 256 个字符中的符号。因此，出现了一些 ASCII 的变体来囊括地区性字符和符号.</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-091206473.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li>0-9的ASCII码值位48（0110000）-57（0111001）</li><li>即去掉高3位，只保留四位的话，正好是二进制的0-9</li><li>大写字母和小写字母转换成二进制也是同样的道理</li></ul><h2 id="6-汉字编码"><a href="#6-汉字编码" class="headerlink" title="6. 汉字编码"></a>6. 汉字编码</h2><ul><li><code>分类</code>：计算机中汉字的表示也是用二进制编码，同样是人为编码的。根据应用目的的不同，汉字编码分为外码、交换码、机内码和字形码。</li></ul><ol><li>外码（输入码）</li></ol><ul><li>外码也叫输入码，是用来将汉字输入到计算机中的一组键盘符号。常用的输入码有拼音码、五笔字型码、自然码、表形码、认知码、区位码和电报码等</li></ul><ol start="2"><li>交换码(国标码)</li></ol><ul><li>计算机内部处理的信息，都是用二进制代码表示的，汉字也不例外。</li><li>而二进制代码使用起来是不方便的，于是需要采用信息交换码。中国标准总局1981年制定了中华人民共和国国家标准GB2312–80《信息交换用汉字编码字符集–基本集》<strong>，即国标码。</strong></li><li>区位码是国标码的另一种表现形式，把国标GB2312–80中的汉字、图形符号组成一个<strong>94×94的方阵，分为94个“区”</strong>，每区包含94个“位”，其中“区”的序号由01至94，“位”的序号也是从01至94。</li><li>94个区中位置总数=94×94=8836个，其中7445个汉字和图形字符中的每一个占一个位置后，还剩下1391个空位，这1391个位置空下来保留备用。</li></ul><ol start="3"><li>机内码</li></ol><ul><li>根据国标码的规定，每一个汉字都有了确定的二进制代码，在微机内部汉字代码都用机内码<strong>，在磁盘上记录汉字代码也使用机内码。</strong></li></ul><ol start="4"><li>字形码</li></ol><ul><li>字形码是汉字的输出码，输出汉字时都采用图形方式，无论汉字的笔画多少，每个汉字都可以写在同样大小的方块中。通常用16×16点阵来显示汉字。</li><li>其实也就是0101的网格 （类似于Banner）</li></ul><p><strong>转换关系</strong></p><ul><li>国际码 = （区位码）+ 2020H<ul><li>20H = 32 ：为了传输的时候避开前32个控制字符</li></ul></li><li>汉字内码 = （国际码）+ 8080H<ul><li>80H = 128: 为了与英文的ASCII码兼容</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-02-数据的表示和运算&quot;&gt;&lt;a href=&quot;#计算机组成原理-02-数据的表示和运算&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-02-数据的表示和运算&quot;&gt;&lt;/a&gt;计算机组成原理-02-数据的表示和运算&lt;/h2&gt;&lt;h2 id=&quot;1-进制概述&quot;&gt;&lt;a href=&quot;#1-进制概述&quot; class=&quot;headerlink&quot; title=&quot;1. 进制概述&quot;&gt;&lt;/a&gt;1. 进制概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用二进制的原因&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;二进制只有两种状态，物理电路的高电平和低电平可以很好的表示0和1&lt;/li&gt;
&lt;li&gt;二进制的0和1正好可以分别代表 true 和 false&lt;/li&gt;
&lt;li&gt;二进制的运算规则特别适合逻辑门电路的计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--083-删除排序链表中的重复元素I</title>
    <link href="http://zhuuu.work/2021/03/25/Leetcode/Leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0I/"/>
    <id>http://zhuuu.work/2021/03/25/Leetcode/Leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0I/</id>
    <published>2021-03-25T03:02:24.000Z</published>
    <updated>2021-03-27T02:46:38.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–083-删除排序链表中的重复元素"><a href="#Leetcode–083-删除排序链表中的重复元素" class="headerlink" title="Leetcode–083-删除排序链表中的重复元素"></a>Leetcode–083-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</li><li>返回同样按升序排列的结果链表。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095204452.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095226721.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><a id="more"></a><h2 id="算法与思路"><a href="#算法与思路" class="headerlink" title="算法与思路"></a>算法与思路</h2><ul><li>由于给定的链表是排好序的，因此<strong>重复的元素在链表中出现的位置是连续的</strong>，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</li><li>具体地，从指针cur 指向链表的头节点，随后开始对链表进行遍历<ul><li>如果当前的<em>cur</em> 与 <code>cur.next</code>对应元素相同，那么我们就将<code>cur.next</code> 从链表中移除；</li><li>否则说明链表中已经不存在其它与<code>cur</code>对应元素相同的节点，因此可以将<code>cur</code> 指向 <code>cur.next</code></li></ul></li><li>当遍历完整个链表之后，返回链表的头节点即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 处理逻辑</span></span><br><span class="line">        ListNode cur = head;                    <span class="comment">// cur 指向头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;                <span class="comment">// 遍历一次链表</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val)&#123;        <span class="comment">// 如果相邻的链表节点是重复的</span></span><br><span class="line">                cur.next = cur.next.next;       <span class="comment">// 跳过这个节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                          </span><br><span class="line">                cur = cur.next;                 <span class="comment">// 否则cur向前移动一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) 遍历一次链表所花费的时间</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–083-删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#Leetcode–083-删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–083-删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;Leetcode–083-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除排序链表中的重复元素&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存在一个按升序排列的链表，给你这个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你删除所有重复的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;返回同样按升序排列的结果链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095204452.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095226721.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,2,3,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中节点数目在范围 &lt;code&gt;[0, 300]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证链表已经按升序排列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-05-AMQP协议</title>
    <link href="http://zhuuu.work/2021/03/24/rabbitMQ/RabbitMQ-05-AMQP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://zhuuu.work/2021/03/24/rabbitMQ/RabbitMQ-05-AMQP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-03-24T07:02:24.000Z</published>
    <updated>2021-03-24T08:44:01.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-05-AMQP协议"><a href="#RabbitMQ-05-AMQP协议" class="headerlink" title="RabbitMQ-05-AMQP协议"></a>RabbitMQ-05-AMQP协议</h2><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h2><ul><li>AMQP全称：<code>Advanced Message Queuing Protocol</code>(高级消息队列协议)。</li><li><strong>是应用层协议的一个开发标准，为面向消息的中间件设计。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-162118081.png" alt="mark"></p><ul><li><strong>工作过程：</strong><ul><li>发布者（Publisher）发布消息（Message），经由交换机（Exchange）。</li><li>交换机根据<strong>路由规则</strong>将收到的消息分发给与该交换机绑定的队列（Queue）。</li><li>最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</li></ul></li></ul><a id="more"></a><h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><ul><li>发布者、交换机、队列、消费者都可以有多个。同时因为 AMQP 是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以分别存在于不同的设备上。</li><li>发布者发布消息时可以给消息指定各种消息属性（Message Meta-data）。有些属性有可能会被消息代理（Brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。</li><li>从安全角度考虑，网络是不可靠的，又或是消费者在处理消息的过程中意外挂掉，这样没有处理成功的消息就会丢失。基于此原因，AMQP 模块包含了一个消息确认（Message Acknowledgements）机制：当一个消息从队列中投递给消费者后，不会立即从队列中删除，直到它收到来自消费者的确认回执（Acknowledgement）后，才完全从队列中删除。</li><li>在某些情况下，例如当一个消息无法被成功路由时（无法从交换机分发到队列），消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。</li></ul><h2 id="3-AMQP-生产者流转过程"><a href="#3-AMQP-生产者流转过程" class="headerlink" title="3. AMQP 生产者流转过程"></a>3. AMQP 生产者流转过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-163035448.png" alt="mark"></p><ul><li>当客户端与<code>Broker</code>建立链接的时候，会调用<code>factory.newConnection()</code> 方法，这个方法会进一步封装成<code>Protocol Header 0-9-1</code>的报文头发送给<code>Broker</code>，以此通知<code>Broker</code>本次交互采用的是<code>AMQP 0-9-1</code>协议，紧接着<code>Broker</code>返回<code>Connection.Start</code> 来建立链接，在链接的过程中涉及的交互命令如图上过程1所示</li><li>当客户端调用<code>Connection.createChannel()</code>时候准备开启信道，其中包含的<code>Channel.Open</code> 发送给<code>Broker</code>，等待确认<code>Channel.Open-ok</code> </li><li>当客户端发送消息的时候，需要调用<code>Basic.Publish</code> ，注意这个命令和前面设计的命令有所不同，这个命令还包含了<code>Content Header</code> 和 <code>Content Body</code>, <code>Content Header</code>里面包含的是消息体的属性，例如投递模式和优先级等等，而<code>Content Body</code>包含了消息体的本身</li><li>当客户端断开资源的时候，如图过程4所示。</li></ul><h2 id="4-AMQP-消费者流转过程"><a href="#4-AMQP-消费者流转过程" class="headerlink" title="4. AMQP 消费者流转过程"></a>4. AMQP 消费者流转过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-163757877.png" alt="mark"></p><ul><li>当客户端与<code>Broker</code>建立链接的时候，会调用<code>factory.newConnection()</code> 方法，这个方法会进一步封装成<code>Protocol Header 0-9-1</code>的报文头发送给<code>Broker</code>，以此通知<code>Broker</code>本次交互采用的是<code>AMQP 0-9-1</code>协议，紧接着<code>Broker</code>返回<code>Connection.Start</code> 来建立链接，在链接的过程中涉及的交互命令如图上过程1所示</li><li>当客户端调用<code>Connection.createChannel()</code>时候准备开启信道，其中包含的<code>Channel.Open</code> 发送给<code>Broker</code>，等待确认<code>Channel.Open-ok</code> </li><li><strong>上面都和生产者一样</strong></li><li>在真正消费之前，消费者客户端需要向<code>Broker</code>发送<code>Basic.Consume</code>命令（channel.BasicConsume 方法）将Channel 设置为接收的模式，之后<code>Broker</code>向消费者客户端推送消息（即<code>Basic.Deliver</code> 命令），有意思的是这个<code>Basic.Deliver</code> 命令一样会携带<code>Content Header</code> 和 <code>Content Body</code></li><li>消费者接收到消息并且真正确实消费之后，向<code>Broker</code> 发送确认，即<code>Basic.Ack</code>命令</li><li>在消费者停止消费之后，主动关闭链接，这点和生产者一样</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-05-AMQP协议&quot;&gt;&lt;a href=&quot;#RabbitMQ-05-AMQP协议&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-05-AMQP协议&quot;&gt;&lt;/a&gt;RabbitMQ-05-AMQP协议&lt;/h2&gt;&lt;h2 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1. 概要&quot;&gt;&lt;/a&gt;1. 概要&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;AMQP全称：&lt;code&gt;Advanced Message Queuing Protocol&lt;/code&gt;(高级消息队列协议)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是应用层协议的一个开发标准，为面向消息的中间件设计。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-162118081.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作过程：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;发布者（Publisher）发布消息（Message），经由交换机（Exchange）。&lt;/li&gt;
&lt;li&gt;交换机根据&lt;strong&gt;路由规则&lt;/strong&gt;将收到的消息分发给与该交换机绑定的队列（Queue）。&lt;/li&gt;
&lt;li&gt;最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-04-Simple模式</title>
    <link href="http://zhuuu.work/2021/03/24/rabbitMQ/RabbitMQ-04-Simple%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2021/03/24/rabbitMQ/RabbitMQ-04-Simple%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-24T06:02:24.000Z</published>
    <updated>2021-03-24T07:57:27.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-04-Simple模式"><a href="#RabbitMQ-04-Simple模式" class="headerlink" title="RabbitMQ-04-Simple模式"></a>RabbitMQ-04-Simple模式</h2><h2 id="1-rabbitMQ角色分类"><a href="#1-rabbitMQ角色分类" class="headerlink" title="1. rabbitMQ角色分类"></a>1. rabbitMQ角色分类</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-103601463.png" alt="mark"></p><ol><li><strong>none</strong></li></ol><ul><li>不能访问<code>management plugin</code></li></ul><ol start="2"><li><strong>management : 查看自己的相关节点信息</strong></li></ol><ul><li>列出自己可以通过AMQP登入的虚拟机</li><li>查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息</li><li>查看和关闭自己的channels和connections</li><li>查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。</li></ul><ol start="3"><li><strong>Policymaker</strong></li></ol><ul><li>包含management所有权限</li><li>查看和创建和删除自己的virtual hosts所属的policies和parameters信息。</li></ul><a id="more"></a><ol start="4"><li><strong>Monitoring</strong></li></ol><ul><li>包含management所有权限</li><li>罗列出所有的virtual hosts，包括不能登录的virtual hosts。</li><li>查看其他用户的connections和channels信息</li><li>查看节点级别的数据如clustering和memory使用情况</li><li>查看所有的virtual hosts的全局统计信息。</li></ul><ol start="5"><li><strong>Administrator</strong></li></ol><ul><li>最高权限</li><li>可以创建和删除virtual hosts</li><li>可以查看，创建和删除users</li><li>查看创建permisssions</li><li>关闭所有用户的connections</li></ul><h2 id="2-工作模式预览"><a href="#2-工作模式预览" class="headerlink" title="2. 工作模式预览"></a>2. 工作模式预览</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113120197.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113216449.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113232003.png" alt="mark"></p><h2 id="3-Simple-简单模式"><a href="#3-Simple-简单模式" class="headerlink" title="3. Simple 简单模式"></a>3. Simple 简单模式</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>1：jdk1.8<br>2：构建一个maven工程<br>3：导入rabbitmq的maven依赖<br>4：启动rabbitmq-server服务<br>5：定义生产者<br>6：定义消费者<br>7：观察消息的在rabbitmq-server服务中的过程</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-111925099.png" alt="mark"></p><ul><li><strong>导入maven依赖</strong></li></ul><ol><li><strong>Java原生依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Spring依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>SpringBoot 依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>番外：</strong>rabbitmq和spring同属一个公司开放的产品，所以他们的支持也是非常完善，这也是为什么推荐使用rabbitmq的一个原因。</li><li>上面根据自己的项目环境进行选择即可。</li></ul><h3 id="2-2-生产者-Provider"><a href="#2-2-生产者-Provider" class="headerlink" title="2.2 生产者 (Provider)"></a>2.2 生产者 (Provider)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line">            String queuename = <span class="string">"queue1"</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.queueDeclare(queuename, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, queuename, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行完毕后，这个时候可以在web控制台查看到这个队列queue的信息</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151035330.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151110538.png" alt="mark"></p><ul><li><strong>我们可以进行对队列的消息进行预览和测试如下：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151211114.png" alt="mark"></p><ul><li>进行预览和获取消息进行测试</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151235934.png" alt="mark"></p><h3 id="2-3-消费者（Consumer）"><a href="#2-3-消费者（Consumer）" class="headerlink" title="2.3 消费者（Consumer）"></a>2.3 消费者（Consumer）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.接收消息并且处理异常</span></span><br><span class="line">            channel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息是"</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收消息失败！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>持久化的消息是会进行存盘的，随着服务重启还在</strong></li><li><strong>非持久化的消息也会进行存盘，但是重启就没有了</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-04-Simple模式&quot;&gt;&lt;a href=&quot;#RabbitMQ-04-Simple模式&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-04-Simple模式&quot;&gt;&lt;/a&gt;RabbitMQ-04-Simple模式&lt;/h2&gt;&lt;h2 id=&quot;1-rabbitMQ角色分类&quot;&gt;&lt;a href=&quot;#1-rabbitMQ角色分类&quot; class=&quot;headerlink&quot; title=&quot;1. rabbitMQ角色分类&quot;&gt;&lt;/a&gt;1. rabbitMQ角色分类&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-103601463.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;none&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;不能访问&lt;code&gt;management plugin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;management : 查看自己的相关节点信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;列出自己可以通过AMQP登入的虚拟机&lt;/li&gt;
&lt;li&gt;查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息&lt;/li&gt;
&lt;li&gt;查看和关闭自己的channels和connections&lt;/li&gt;
&lt;li&gt;查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;strong&gt;Policymaker&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;包含management所有权限&lt;/li&gt;
&lt;li&gt;查看和创建和删除自己的virtual hosts所属的policies和parameters信息。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-03-安装与入门</title>
    <link href="http://zhuuu.work/2021/03/18/rabbitMQ/RabbitMQ-03-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/"/>
    <id>http://zhuuu.work/2021/03/18/rabbitMQ/RabbitMQ-03-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-18T06:02:24.000Z</published>
    <updated>2021-03-24T02:30:30.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-03-安装与入门"><a href="#RabbitMQ-03-安装与入门" class="headerlink" title="RabbitMQ-03-安装与入门"></a>RabbitMQ-03-安装与入门</h2><p><strong>简单概述：</strong></p><ul><li><p>RabbitMQ是一个开源的<strong>遵循AMQP协议实现的基于Erlang语言编写</strong>，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。</p></li><li><p>官网：<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">https://www.rabbitmq.com/</a></p></li><li><p>下载地址 ： <a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a></p></li><li><p><strong>环境准备：CentOS7.x+ / Erlang</strong></p><ul><li>RabbitMQ是采用Erlang语言开发的，所以系统环境必须提供Erlang环境，第一步就是安装Erlang。</li></ul></li></ul><a id="more"></a><h2 id="1-普通方式安装"><a href="#1-普通方式安装" class="headerlink" title="1. 普通方式安装"></a>1. 普通方式安装</h2><h3 id="1-1-Erlang-安装"><a href="#1-1-Erlang-安装" class="headerlink" title="1.1 Erlang 安装"></a>1.1 Erlang 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参考地址：https://www.erlang-solutions.com/downloads/</span><br><span class="line"></span><br><span class="line">1. 安装下载</span><br><span class="line">wget https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm</span><br><span class="line">rpm -Uvh erlang-solutions-2.0-1.noarch.rpm</span><br><span class="line">2. 安装成功</span><br><span class="line">yum install -y erlang</span><br><span class="line">3. erl -v</span><br><span class="line">4. 安装socat</span><br><span class="line">yum install -y socat</span><br><span class="line">5. 安装rabbitmq</span><br></pre></td></tr></table></figure><h3 id="2-rabbitMQ-下载"><a href="#2-rabbitMQ-下载" class="headerlink" title="2. rabbitMQ 下载"></a>2. rabbitMQ 下载</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-154059327.png" alt="mark"></p><ol><li>下载<code>rabbitmq</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;releases&#x2F;download&#x2F;v3.8.13&#x2F;rabbitmq-server-3.8.13-1.el8.noarch.rpm</span><br><span class="line">&gt; rpm -Uvh rabbitmq-server-3.8.13-1.el8.noarch.rpm</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动服务</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动服务</span><br><span class="line">&gt; systemctl start rabbitmq-server</span><br><span class="line"># 查看服务状态</span><br><span class="line">&gt; systemctl status rabbitmq-server</span><br><span class="line"># 停止服务</span><br><span class="line">&gt; systemctl stop rabbitmq-server</span><br><span class="line"># 开机启动服务</span><br><span class="line">&gt; systemctl enable rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>rabbitMQ的配置</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RabbitMQ默认情况下有一个配置文件，定义了RabbitMQ的相关配置信息，默认情况下能够满足日常的开发需求。如果需要修改需要，需要自己创建一个配置文件进行覆盖。</span><br><span class="line">参考官网：</span><br><span class="line">1:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;documentation.html</span><br><span class="line">2:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;configure.html</span><br><span class="line">3:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;configure.html#config-items</span><br><span class="line">4：https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;blob&#x2F;add-debug-messages-to-quorum_queue_SUITE&#x2F;docs&#x2F;rabbitmq.conf.example</span><br></pre></td></tr></table></figure><h3 id="3-rabbitMQ-端口"><a href="#3-rabbitMQ-端口" class="headerlink" title="3. rabbitMQ 端口"></a>3. rabbitMQ 端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5672:RabbitMQ的通讯端口</span><br><span class="line">25672:RabbitMQ的节点间的CLI通讯端口是</span><br><span class="line">15672:RabbitMQ HTTP_API的端口，管理员用户才能访问，用于管理RabbitMQ,需要启动Management插件。</span><br><span class="line">1883，8883：MQTT插件启动时的端口。</span><br><span class="line">61613、61614：STOMP客户端插件启用的时候的端口。</span><br><span class="line">15674、15675：基于webscoket的STOMP端口和MOTT端口</span><br></pre></td></tr></table></figure><h3 id="4-可视化管理节面"><a href="#4-可视化管理节面" class="headerlink" title="4. 可视化管理节面"></a>4. 可视化管理节面</h3><ol><li>默认情况下，rabbitmq是没有安装web端的客户端插件，需要安装才可以生效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><ol start="2"><li>安装完毕以后，重启服务即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="3"><li>在浏览器访问</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-154907967.png" alt="mark"></p><h3 id="5-授权账号和登录级别"><a href="#5-授权账号和登录级别" class="headerlink" title="5. 授权账号和登录级别"></a>5. 授权账号和登录级别</h3><ol><li><strong>新增用户</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>分配权限操作</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>对应级别</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户级别：</span><br><span class="line"></span><br><span class="line">1、administrator 可以登录控制台、查看所有信息、可以对rabbitmq进行管理</span><br><span class="line">2、monitoring 监控者 登录控制台，查看所有信息</span><br><span class="line">3、policymaker 策略制定者 登录控制台,指定策略</span><br><span class="line">4、managment 普通管理员 登录控制台</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>添加级别权限</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat set_permissions -p &#x2F; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>常用命令小结</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user 账号 密码</span><br><span class="line">rabbitmqctl set_user_tags 账号 administrator</span><br><span class="line">rabbitmqctl change_password Username Newpassword 修改密码</span><br><span class="line">rabbitmqctl delete_user Username 删除用户</span><br><span class="line">rabbitmqctl list_users 查看用户清单</span><br><span class="line">rabbitmqctl set_permissions -p &#x2F; 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 为用户设置administrator角色</span><br><span class="line">rabbitmqctl set_permissions -p &#x2F; root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="2-Docker方式安装"><a href="#2-Docker方式安装" class="headerlink" title="2. Docker方式安装"></a>2. Docker方式安装</h2><ol><li><strong>未安装Docker–&gt;安装Docker</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">（1）yum 包更新到最新</span><br><span class="line">&gt; yum update</span><br><span class="line">（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><br><span class="line">&gt; yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">（3）设置yum源为阿里云</span><br><span class="line">&gt; yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">（4）安装docker</span><br><span class="line">&gt; yum install docker-ce -y</span><br><span class="line">（5）安装后查看docker版本</span><br><span class="line">&gt; docker -v</span><br><span class="line"> (6) 安装加速镜像</span><br><span class="line"> sudo mkdir -p /etc/docker</span><br><span class="line"> sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://0wrdwnn6.mirror.aliyuncs.com"</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> EOF</span><br><span class="line"> sudo systemctl daemon-reload</span><br><span class="line"> sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>docker 常用命令</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker：</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 停止docker：</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment"># 重启docker：</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看docker状态：</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 开机启动：  </span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl unenable docker</span><br><span class="line"><span class="comment"># 查看docker概要信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="comment"># 查看docker帮助文档</span></span><br><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>安装rabbitMQ</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考网站：</span><br><span class="line">1：https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;download.html</span><br><span class="line">2：https:&#x2F;&#x2F;registry.hub.docker.com&#x2F;_&#x2F;rabbitmq&#x2F;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>拉取rabbitMQ镜像</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>创建容器并且执行</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myrabbit -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>不用进容器设置就创建镜像</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">—hostname：指定容器主机名称</span><br><span class="line">—name:指定容器名称</span><br><span class="line">-p:将mq端口号映射到本地</span><br><span class="line">或者运行时设置用户和密码</span><br><span class="line"></span><br><span class="line">docker run -di --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果你按照之前操作安装了docker , 那么现在需要将服务给停掉</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>查看docker 中的rabbitmq日志</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f myrabbit</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-03-安装与入门&quot;&gt;&lt;a href=&quot;#RabbitMQ-03-安装与入门&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-03-安装与入门&quot;&gt;&lt;/a&gt;RabbitMQ-03-安装与入门&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;简单概述：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ是一个开源的&lt;strong&gt;遵循AMQP协议实现的基于Erlang语言编写&lt;/strong&gt;，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网：&lt;a href=&quot;https://www.rabbitmq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载地址 ： &lt;a href=&quot;https://www.rabbitmq.com/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/download.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;环境准备：CentOS7.x+ / Erlang&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RabbitMQ是采用Erlang语言开发的，所以系统环境必须提供Erlang环境，第一步就是安装Erlang。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-02-消息队列</title>
    <link href="http://zhuuu.work/2021/03/16/rabbitMQ/RabbitMQ-02-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://zhuuu.work/2021/03/16/rabbitMQ/RabbitMQ-02-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2021-03-16T11:02:24.000Z</published>
    <updated>2021-03-18T06:31:27.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-02-消息队列"><a href="#RabbitMQ-02-消息队列" class="headerlink" title="RabbitMQ-02-消息队列"></a>RabbitMQ-02-消息队列</h2><h2 id="1-消息队列协议"><a href="#1-消息队列协议" class="headerlink" title="1. 消息队列协议"></a>1. 消息队列协议</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-210932098.png" alt="mark"></p><ul><li><strong>消息中间件负责数据的传递，存储，和分发消费三个部分</strong>，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，你是采用底层的TCP/IP，UDP协议还是其他的自己取构建等，而这些约定成俗的规范就称之为：协议。</li><li><strong>所谓协议是指：</strong><ul><li>计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有<strong>遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。</strong></li><li>和<strong>一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。</strong></li><li>协议对数据格式和计算机之间交换数据都必须<strong>严格遵守规范。</strong></li></ul></li></ul><a id="more"></a><h2 id="2-网络协议需要遵循的要素"><a href="#2-网络协议需要遵循的要素" class="headerlink" title="2. 网络协议需要遵循的要素"></a>2. 网络协议需要遵循的要素</h2><p><strong>1. 语法</strong>。语法是用户数据与控制信息的<strong>结构与格式,</strong>以及数据出现的顺序。<br><strong>2. 语义</strong>。语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息,以及<strong>完成的动作与做出什么样的响应。</strong><br><strong>3. 时序</strong>。时序是对<strong>事件发生顺序</strong>的详细说明。</p><ul><li><strong>而消息中间件采用的并不是http协议</strong>，而常见的消息中间件协议有：OpenWire、AMQP、MQTT、Kafka，OpenMessage协议。</li><li><strong>面试题：为什么消息中间件不直接使用http协议呢？</strong><ul><li><strong>1: 因为http请求报文头和响应报文头是比较复杂的</strong>，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，<strong>一定要追求的是高性能。尽量简洁，快速。</strong></li><li><strong>2:大部分情况下http大部分都是短链接</strong>，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就<strong>会造成请求的丢失</strong>。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</li></ul></li></ul><h2 id="3-消息队列协议"><a href="#3-消息队列协议" class="headerlink" title="3. 消息队列协议"></a>3. 消息队列协议</h2><h3 id="3-1AMQP协议"><a href="#3-1AMQP协议" class="headerlink" title="3.1AMQP协议"></a>3.1AMQP协议</h3><ul><li>AMQP：(全称：Advanced Message Queuing Protocol) 是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</li><li>基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等。</li></ul><p><strong>特性：</strong><br>1：分布式事务支持。<br>2：消息的持久化支持。<br>3：高性能和高可靠的消息处理优势。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141250242.png" alt="mark"></p><h3 id="3-2MQTT协议"><a href="#3-2MQTT协议" class="headerlink" title="3.2MQTT协议"></a>3.2MQTT协议</h3><ul><li><strong>MQTT协议：</strong>（Message Queueing Telemetry Transport）消息队列是IBM开放的一个即时通讯协议，<strong>物联网系统架构中的重要组成部分。</strong></li><li><strong>特点：</strong><br>1：轻量<br>2：结构简单<br>3：传输快，不支持事务<br>4：没有持久化设计。</li><li><strong>应用场景：</strong><br>1：适用于计算能力有限<br>2：低带宽<br>3：网络不稳定的场景。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141351884.png" alt="mark"></p><h3 id="3-3OpenMessage协议"><a href="#3-3OpenMessage协议" class="headerlink" title="3.3OpenMessage协议"></a>3.3OpenMessage协议</h3><ul><li>是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式消息中间件、流处理等领域的应用开发标准。</li><li><strong>特点：</strong><br>1：结构简单<br>2：解析速度快<br>3：支持事务和持久化设计。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141428320.png" alt="mark"></p><h3 id="3-4Kafka协议"><a href="#3-4Kafka协议" class="headerlink" title="3.4Kafka协议"></a>3.4Kafka协议</h3><ul><li><p><strong>Kafka协议是基于TCP/IP的二进制协议</strong>。消息内部是通过长度来分割，由一些基本数据类型组成。</p></li><li><p><strong>特点是</strong>：<br>1：结构简单<br>2：解析速度快<br>3：无事务支持<br>4：有持久化设计</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141511555.png" alt="mark"></p><h2 id="4-消息队列的持久化"><a href="#4-消息队列的持久化" class="headerlink" title="4. 消息队列的持久化"></a>4. 消息队列的持久化</h2><ul><li>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142053516.png" alt="mark"></p><ul><li>常见的持久化方式</li></ul><table><thead><tr><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th><th></th></tr></thead><tbody><tr><td>文件存储</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据库</td><td>支持</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><h2 id="5-消息的分发策略"><a href="#5-消息的分发策略" class="headerlink" title="5. 消息的分发策略"></a>5. 消息的分发策略</h2><ul><li><strong>MQ消息队列有如下几个角色</strong><br>1：生产者<br>2：存储消息<br>3：消费者</li><li><strong>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？</strong><ul><li>一般获取数据的方式无外乎<strong>推（push）或者拉（pull）两种方式，</strong></li><li><strong>典型的git就有推拉机制</strong>，我们发送的http请求就是一种典型的拉取数据库数据返回的过程。</li><li><strong>而消息队列MQ是一种推送的过程</strong>，而这些推机制会适用到很多的业务场景也有很多对应推机制策略。</li></ul></li></ul><h3 id="5-1-场景一"><a href="#5-1-场景一" class="headerlink" title="5.1 场景一"></a>5.1 场景一</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142306233.png" alt="mark"></p><ul><li>比如我在APP上下了一个订单，我们的系统和服务很多，我们如何得知这<strong>个消息被那个系统或者那些服务或者系统进行消费，那这个时候就需要一个分发的策略</strong>。这就需要消费策略。或者称之为消费的方法论。</li></ul><h3 id="5-2-场景二"><a href="#5-2-场景二" class="headerlink" title="5.2 场景二"></a>5.2 场景二</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142359085.png" alt="mark"></p><ul><li>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费MQ接受，<strong>订单系统出现故障，导致用户支付失败</strong>，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，<strong>消息不丢失还可以进行重发。</strong></li><li><strong>小结如下：</strong></li></ul><table><thead><tr><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th><th></th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>公平分发</td><td>/</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>/</td><td>支持</td></tr><tr><td>消息拉取</td><td>/</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><h2 id="6-消息队列高可用和高可靠"><a href="#6-消息队列高可用和高可靠" class="headerlink" title="6. 消息队列高可用和高可靠"></a>6. 消息队列高可用和高可靠</h2><h3 id="6-1-高可用"><a href="#6-1-高可用" class="headerlink" title="6.1 高可用"></a>6.1 高可用</h3><ul><li><strong>高可用：</strong>是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力。<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU,内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以<strong>消息中间件必须支持集群部署。来达到高可用的目的。</strong></li></ul><ul><li><h3 id="集群模式1-Master-slave主从共享数据的部署方式"><a href="#集群模式1-Master-slave主从共享数据的部署方式" class="headerlink" title="集群模式1 - Master-slave主从共享数据的部署方式"></a>集群模式1 - Master-slave主从共享数据的部署方式</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142651818.png" alt="mark"></p><p>生产者将消费发送到Master节点，所有的都连接这个消息队列共享这块数据区域，Master节点负责写入，一旦Master挂掉，slave节点继续服务。从而形成高可用，</p><ul><li><h3 id="集群模式2-Master-slave主从同步部署方式"><a href="#集群模式2-Master-slave主从同步部署方式" class="headerlink" title="集群模式2 - Master- slave主从同步部署方式"></a>集群模式2 - Master- slave主从同步部署方式</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142728662.png" alt="mark"></p><p>这种模式写入消息同样在Master主节点上，但是主节点会同步数据到slave节点形成副本，和zookeeper或者redis主从机制很类同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点就行消费，以为消息的拷贝和同步会暂用很大的带宽和网络资源。在后续的rabbtmq中会有使用。</p><ul><li><h3 id="集群模式3-多主集群同步部署模式"><a href="#集群模式3-多主集群同步部署模式" class="headerlink" title="集群模式3 - 多主集群同步部署模式"></a>集群模式3 - 多主集群同步部署模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142830807.png" alt="mark"></p></li></ul><p><strong>解释：</strong></p><p>如果你插入的数据是broker-1中，元数据信息会存储数据的相关描述和记录存放的位置（队列）。<br>它会对描述信息也就是元数据信息就行同步，如果消费者在broker-2中进行消费，发现自己几点没有对应的消息，可以从<strong>对应的元数据信息中去查询</strong>，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他会去联系其他的黄牛询问，如果有就返回。</p><ul><li><h3 id="集群模式5-Master-slave与Broker-cluster组合的方案"><a href="#集群模式5-Master-slave与Broker-cluster组合的方案" class="headerlink" title="集群模式5 Master-slave与Broker-cluster组合的方案"></a>集群模式5 Master-slave与Broker-cluster组合的方案</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142935098.png" alt="mark"></p><p><strong>解释：</strong>实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</p><p><strong>反正终归三句话：</strong><br><strong>1：要么消息共享，</strong><br><strong>2：要么消息同步</strong><br><strong>3：要么元数据共享</strong></p><h3 id="6-2-高可靠"><a href="#6-2-高可靠" class="headerlink" title="6.2 高可靠"></a>6.2 高可靠</h3><ul><li><strong>高可靠</strong>：是指系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</li><li>在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</li><li>如何保证<strong>中间件消息的可靠性</strong>呢？可以从两个方面考虑：<br><strong>1：消息的传输：通过协议来保证系统间数据解析的正确性。</strong><br><strong>2：消息的存储可靠：通过持久化来保证消息的可靠性。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-02-消息队列&quot;&gt;&lt;a href=&quot;#RabbitMQ-02-消息队列&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-02-消息队列&quot;&gt;&lt;/a&gt;RabbitMQ-02-消息队列&lt;/h2&gt;&lt;h2 id=&quot;1-消息队列协议&quot;&gt;&lt;a href=&quot;#1-消息队列协议&quot; class=&quot;headerlink&quot; title=&quot;1. 消息队列协议&quot;&gt;&lt;/a&gt;1. 消息队列协议&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-210932098.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息中间件负责数据的传递，存储，和分发消费三个部分&lt;/strong&gt;，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，你是采用底层的TCP/IP，UDP协议还是其他的自己取构建等，而这些约定成俗的规范就称之为：协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所谓协议是指：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有&lt;strong&gt;遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;和&lt;strong&gt;一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;协议对数据格式和计算机之间交换数据都必须&lt;strong&gt;严格遵守规范。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-01-中间件概述</title>
    <link href="http://zhuuu.work/2021/03/15/rabbitMQ/RabbitMQ-01-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2021/03/15/rabbitMQ/RabbitMQ-01-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2021-03-15T11:02:24.000Z</published>
    <updated>2021-03-17T12:07:39.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-01-中间件概述"><a href="#RabbitMQ-01-中间件概述" class="headerlink" title="RabbitMQ-01-中间件概述"></a>RabbitMQ-01-中间件概述</h2><h2 id="1-中间件简介"><a href="#1-中间件简介" class="headerlink" title="1. 中间件简介"></a>1. 中间件简介</h2><ul><li><p><code>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件=平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。</code></p></li><li><p>为解决分布异构问题，人们提出了中间件(middleware)的概念。中间件是位于平台(硬件和操作系统)和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口和协议规范的多种实现。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195441380.png" alt="mark"></p><a id="more"></a><ul><li>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。<strong>这使得中间件一定是可替换的。如果一个系统设计中，中间件是不可替换的，不是架构、框架设计有问题，那么就是这个中间件，在 别处可能是个中间件，在这个系统内是引擎</strong>。哈。</li></ul><h2 id="2-中间件的使用时机"><a href="#2-中间件的使用时机" class="headerlink" title="2. 中间件的使用时机"></a>2. 中间件的使用时机</h2><ul><li>在项目的架构和重构中，使用任何技术和架构的改变我们都需要谨慎斟酌和思考，因为任何技术的融入和变化都可能人员，技术，和成本的增加，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果你仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而追求的背后一定是业务的驱动和项目的驱动，因为一旦追求就意味着你的学习成本，公司的人员结构以及服务器成本，维护和运维的成本都会增加，所以需要谨慎选择和考虑。</li><li>但是作为一个开放人员，一定要有学习中间件技术的能力和思维，否则很容易当项目发展到一个阶段在去掌握估计或者在面试中提及，就会给自己带来不小的困扰，在当今这个时代这些技术也并不是什么新鲜的东西，如果去掌握和挖掘最关键的还是自己花时间和花精力去探讨和研究。</li></ul><h2 id="3-单体架构和分布式架构"><a href="#3-单体架构和分布式架构" class="headerlink" title="3. 单体架构和分布式架构"></a>3. 单体架构和分布式架构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195713227.png" alt="mark"></p><p>在实际的项目中，大部分的企业项目开发中，在早期都采用的是<strong>单体的架构模式</strong>，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200010624.png" alt="mark"></p><p>在企业开发的中，大部分的初期架构都采用的是单体架构的模式进行架构，而这种架构的典型的特点：就是把所有的业务和模块，源代码，静态资源文件等都放在一个一工程中，如果其中的一个模块升级或者迭代发生一个很小变动都会重新编译和重新部署项目。 这种的架构存在的问题就是：<br>1：耦合度太高<br>2：运维的成本过高<br>3：不易维护<br>4：服务器的成本高<br>5：以及升级架构的复杂度也会增大<br>这样就有后续的分布式架构系统。如下</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200044247.png" alt="mark"></p><p><strong>通俗一点：就是一个请求由服务器端的多个服务（服务或者系统）协同处理完成</strong></p><ul><li>和单体架构不同的是，单体架构是一个请求发起jvm调度线程（确切的是tomcat线程池）分配线程Thread来处理请求直到释放，而分布式是系统是：一个请求是由多个系统共同来协同完成，jvm和环境都可能是独立。如果生活中的比喻的话，单体架构就想建设一个小房子很快就能够搞定，如果你要建设一个鸟巢或者大型的建筑，你就必须是各个环节的协同和分布，这样目的也是项目发展都后期的时候要去部署和思考的问题。</li></ul><h2 id="4-消息中间件概念"><a href="#4-消息中间件概念" class="headerlink" title="4. 消息中间件概念"></a>4. 消息中间件概念</h2><p><strong>应用场景</strong></p><p>1:跨系统数据传递<br>2:高并发的流量削峰<br>3:数据的分发和异步处理<br>4:大数据分析与传递<br>5:分布式事务<br>比如你有一个数据要进行迁移或者请求并发过多的时候，比如你有10W的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行。</p><p><strong>常见的消息中间件</strong></p><ul><li>ActiveMQ、RabbitMQ、Kafka、RocketMQ等。</li></ul><p><strong>同时消息中间件是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200352244.png" alt="mark"></p><p>谁来生产消息，存储消息和消费消息呢？</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200408369.png" alt="mark"></p><h2 id="5-消息中间件的两种模式"><a href="#5-消息中间件的两种模式" class="headerlink" title="5. 消息中间件的两种模式"></a>5. 消息中间件的两种模式</h2><ol><li><strong>点对点模式 P2P</strong></li></ol><ul><li>点对点模式是基于队列的，消息的生产者发送消息到队列，消息的消费者从队列中接收消息，队列的存在使得消息的异步传输成为可能</li></ul><ol start="2"><li><strong>发布订阅模式</strong></li></ol><ul><li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic）,主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题中，而消息的订阅者从主题中订阅消息。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-01-中间件概述&quot;&gt;&lt;a href=&quot;#RabbitMQ-01-中间件概述&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-01-中间件概述&quot;&gt;&lt;/a&gt;RabbitMQ-01-中间件概述&lt;/h2&gt;&lt;h2 id=&quot;1-中间件简介&quot;&gt;&lt;a href=&quot;#1-中间件简介&quot; class=&quot;headerlink&quot; title=&quot;1. 中间件简介&quot;&gt;&lt;/a&gt;1. 中间件简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件=平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为解决分布异构问题，人们提出了中间件(middleware)的概念。中间件是位于平台(硬件和操作系统)和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口和协议规范的多种实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195441380.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-01-计算机系统概述</title>
    <link href="http://zhuuu.work/2021/03/15/Compute_Organization/%E8%AE%A1%E7%BB%84-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2021/03/15/Compute_Organization/%E8%AE%A1%E7%BB%84-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-22T07:24:56.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-01-计算机系统概述"><a href="#计算机组成原理-01-计算机系统概述" class="headerlink" title="计算机组成原理-01-计算机系统概述"></a>计算机组成原理-01-计算机系统概述</h2><h2 id="1-计算机的四代变化"><a href="#1-计算机的四代变化" class="headerlink" title="1. 计算机的四代变化"></a>1. 计算机的四代变化</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105224626.png" alt="mark"></p><p><strong>1）摩尔定律。</strong>摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度 。尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法 。</p><p><strong>2）半导体存储器的发展。</strong>1970年仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代；单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB、1GB。</p><p>3）微处理器的发展。微处理器位数：8-&gt;16-&gt;32-&gt;64，这里的32、64指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。</p><a id="more"></a><h2 id="2-计算机的组成"><a href="#2-计算机的组成" class="headerlink" title="2. 计算机的组成"></a>2. 计算机的组成</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105756753.png" alt="mark"></p><p><strong>软件分类如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105842514.png" alt="mark"></p><p><strong>语言等级</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105934707.png" alt="mark"></p><h2 id="3-冯·诺依曼机"><a href="#3-冯·诺依曼机" class="headerlink" title="3. 冯·诺依曼机"></a>3. 冯·诺依曼机</h2><ul><li><p>美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。</p><ul><li>“程序存储”：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</li></ul></li><li><p><strong>计算机的五大功能部件</strong>：<code>输入设备、输出设备、存储器、运算器、控制器</code></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-111632056.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-111934913.png" alt="mark"></p><h2 id="4-现代计算机的结构"><a href="#4-现代计算机的结构" class="headerlink" title="4. 现代计算机的结构"></a>4. 现代计算机的结构</h2><ul><li>在微处理器问世之前，运算器与控制器分离。而且存储器容量小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递，如上图所示。</li><li>随着微电子技术的进步，同时计算机需要处理的信息也越来越多，大量I/O设备的速度和CPU的速度差距悬殊，因此需要更新换代计算机的组织结构以适应新的需求。计算机发展为了以存储器为中心，使I/O设备尽可能的绕过CPU，直接在I/O设备与存储器之间完成操作，以提高整体效率。其结构如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-112030679.png" alt="mark"></p><h2 id="5-主存储器"><a href="#5-主存储器" class="headerlink" title="5. 主存储器"></a>5. 主存储器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113400653.png" alt="mark"></p><ul><li>存储体：存放二进制信息</li><li>地址寄存器（MAR-Memory Address Register）:存放访存地址，经过地址译码后找到所选的逻辑单元</li><li>数据寄存器（MDR-Memory Data Register）:暂存要从存储器中读或写的信息</li><li>时序控制逻辑：用于产生存储器操作所需的各种时序信号</li><li>地址寄存器（MAR-Memory Address Register）用于寻址，其位数对应着存储单元的个数，如MAR为10位，则有2^10^=1024个存储单元，记为1K。MAR的长度与PC（程序计数器）长度相等。</li><li>MDR位数=存储字长，一般为字节(B)的二次幂的整数倍</li><li>MAR和MDR虽然是存储器的一部分，但在现代CPU中却是存在于CPU中的；另外高速缓存（Cache）也存在于CPU中<br><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113700559.png" alt="mark"></li></ul><h2 id="6-运算器"><a href="#6-运算器" class="headerlink" title="6. 运算器"></a>6. 运算器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113919523.png" alt="mark"></p><ul><li>运算器：ALU 算数逻辑单元是最主要的组成部件，运算器包含若干通用寄存器，用于暂存操作数和中间结果。</li></ul><h2 id="7-控制器"><a href="#7-控制器" class="headerlink" title="7. 控制器"></a>7. 控制器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-114103653.png" alt="mark"></p><ul><li>控制器是计算机的<code>指挥中心</code>，它指挥着各部件自动协调地进行工作</li></ul><h2 id="8-工作过程小结"><a href="#8-工作过程小结" class="headerlink" title="8. 工作过程小结"></a>8. 工作过程小结</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-115017372.png" alt="mark"></p><ul><li><p><code>总线</code>中有<code>地址、数据、控制</code>三组信号线</p></li><li><p><code>CPU与主存</code>之间通过一组<code>总线</code>相连</p></li><li><p><code>MAR</code>中的地址信息会直接送到<code>地址线</code>上，用于指向<code>读/写</code>操作的<code>主存存储单元</code></p></li><li><p><code>控制线</code>中有<code>读/写</code>信号线，指出数据是从CPU<code>写入</code>主存还是从主存<code>读出</code>到<code>CPU</code></p></li><li><p>根据<code>读</code>操作还是<code>写</code>操作来控制将<code>MDR中的数据</code>是直接<code>送到数据线上</code>还是将数据线上的数据<code>接收到MDR</code>中</p></li></ul><h2 id="9-计算机的工作过程"><a href="#9-计算机的工作过程" class="headerlink" title="9. 计算机的工作过程"></a>9. 计算机的工作过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-151055001.png" alt="mark"></p><ul><li>这里以UNIX系统中的GCC编译器程序为例，将C语言源程序转换为<code>可执行文件（以二进制磁盘文件形式存储）</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-151153003.png" alt="mark"></p><p> 例题：以取数指令（即将指令地址码指示的存储单元中的操作数取出后送至运算器的累加器(ACC)中）为例进行说明。其信息流程如下：</p><blockquote><p>累加器ACC：二进制8位寄存器，存放操作数或运算结果。<br>M : 主存储器</p></blockquote><ol><li><strong>取指令</strong>  ：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</li></ol><ul><li><code>根据PC取指令到IR</code>。将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读/写信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接受指令信息，并传送到IR中。</li></ul><ol start="2"><li><strong>分析指令</strong> ： OP(IR)-&gt;CU</li></ol><ul><li><code>指令译码器解释操作码OP(IR)并送出控制信号</code>。指令寄存器（IR）将操作码OP(IR)送至指令译码器（ID）进行解释翻译，将翻译的信息送至操作控制器（OC），OC生成相应的控制信号，送到不同的执行部件。</li></ul><ol start="3"><li><strong>执行指令</strong> ： Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</li></ol><ul><li><code>取数操作</code>。将IR中的指令地址码送MAR，MAR将内容送至地址线，同时控制器将读/写信号送读/写线，从主存指定单元读出操作数，并通过数据线送至MDR，再传送到ACC中。</li></ul><ol start="4"><li><strong>每取完一条指令，(PC)+1-&gt;PC，取下一条指令的地址。</strong></li></ol><h2 id="10-计算机的层次结构"><a href="#10-计算机的层次结构" class="headerlink" title="10. 计算机的层次结构"></a>10. 计算机的层次结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-150749119.png" alt="mark"></p><h2 id="11-计算机的主要性能指标"><a href="#11-计算机的主要性能指标" class="headerlink" title="11. 计算机的主要性能指标"></a>11. 计算机的主要性能指标</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-152255067.png" alt="mark"></p><p><strong>性能指标：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-152429772.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-01-计算机系统概述&quot;&gt;&lt;a href=&quot;#计算机组成原理-01-计算机系统概述&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-01-计算机系统概述&quot;&gt;&lt;/a&gt;计算机组成原理-01-计算机系统概述&lt;/h2&gt;&lt;h2 id=&quot;1-计算机的四代变化&quot;&gt;&lt;a href=&quot;#1-计算机的四代变化&quot; class=&quot;headerlink&quot; title=&quot;1. 计算机的四代变化&quot;&gt;&lt;/a&gt;1. 计算机的四代变化&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105224626.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）摩尔定律。&lt;/strong&gt;摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度 。尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）半导体存储器的发展。&lt;/strong&gt;1970年仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代；单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB、1GB。&lt;/p&gt;
&lt;p&gt;3）微处理器的发展。微处理器位数：8-&amp;gt;16-&amp;gt;32-&amp;gt;64，这里的32、64指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--082-删除排序链表中的重复元素II</title>
    <link href="http://zhuuu.work/2021/03/15/Leetcode/Leetcode-082-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/"/>
    <id>http://zhuuu.work/2021/03/15/Leetcode/Leetcode-082-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-25T11:37:29.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–082-删除排序链表中的重复元素-II"><a href="#Leetcode–082-删除排序链表中的重复元素-II" class="headerlink" title="Leetcode–082-删除排序链表中的重复元素 II"></a>Leetcode–082-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素 II</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</li><li>返回同样按升序排列的结果链表。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185810569.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185829197.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><a id="more"></a><h2 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h2><ul><li>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（<code>dummy node</code>）指向链表的头节点。</li><li>具体地，首先从指针<code>cur</code>指向链表的哑节点，<ul><li>随后开始对链表进行遍历。如果当前<code>cur.next</code>与<code>cur.next.next</code>对应的元素相同，那么我们就需要将<code>cur.next</code> 以及所有后面拥有相同元素值的链表节点全部删除。</li><li>记下这个元素值 x，随后不断将<code>cur.next</code>从链表中移除，直到 <code>cur.next</code>为空节点或者其元素值不等于<code>x</code> 为止。此时，将链表中所有元素值为<code>x</code>的节点全部删除。</li></ul></li><li>如果当前<code>cur.next</code> 与<code>cur.next.next</code> 对应的元素不相同，那么说明链表中只有一个元素值为<code>cur.next</code> 的节点，那么就可以将 <code>cur</code> 指向 <code>cur.next</code>。</li></ul><ul><li>当遍历完整个链表之后，我们返回链表的的哑节点的下一个节点 <em>dummy.next</em> 即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 如果链表为空</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 创建哑节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 处理逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123; <span class="comment">// 如果是重复元素的话</span></span><br><span class="line">                <span class="keyword">int</span> x = cur.next.val;<span class="comment">// 为了在删除前记录重复的值大小</span></span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == x)&#123;<span class="comment">// 循环删除重复元素</span></span><br><span class="line">                    cur.next = cur.next.next;<span class="comment">// 删除这个重复元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 如果不是重复元素的话</span></span><br><span class="line">                cur = cur.next;<span class="comment">// 指针向前走一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 返回dummy.next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是链表的长度。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–082-删除排序链表中的重复元素-II&quot;&gt;&lt;a href=&quot;#Leetcode–082-删除排序链表中的重复元素-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–082-删除排序链表中的重复元素 II&quot;&gt;&lt;/a&gt;Leetcode–082-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除排序链表中的重复元素 II&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存在一个按升序排列的链表，给你这个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 &lt;strong&gt;没有重复出现&lt;/strong&gt; 的数字。&lt;/li&gt;
&lt;li&gt;返回同样按升序排列的结果链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185810569.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,2,3,3,4,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,5]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185829197.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中节点数目在范围 &lt;code&gt;[0, 300]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证链表已经按升序排列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--456-132模式</title>
    <link href="http://zhuuu.work/2021/03/15/Leetcode/Leetcode-456-132%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2021/03/15/Leetcode/Leetcode-456-132%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-27T01:43:57.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–456-132-模式"><a href="#Leetcode–456-132-模式" class="headerlink" title="Leetcode–456-132 模式"></a>Leetcode–456-<a href="https://leetcode-cn.com/problems/132-pattern/" target="_blank" rel="noopener">132 模式</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成</li><li>并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</li></ul><p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>注意：</strong></p><p><strong>进阶：</strong>很容易想到时间复杂度为 <code>O(n^2)</code> 的解决方案，你可以设计一个时间复杂度为 <code>O(n logn)</code> 或 <code>O(n)</code> 的解决方案吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：序列中不存在 132 模式的子序列。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [3,1,4,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,3,2,0]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><strong>思路</strong></p><ul><li><strong>由于本题中的<code>n</code> 最大值为10^4，因此对一个满足132的三元组下标（i,j,k），枚举其中两个下标的时间复杂度是O(n^2),很容易超出时间的限制</strong></li><li><strong>因此我们可以考虑枚举其中的 1个下标，并使用合适的数据结构维护另外的 2 个下标的可能值。</strong></li></ul><p><strong>算法：枚举3</strong></p><ul><li>枚举 3 是容易想到并且也是最容易实现的。由于 3 是模式中的最大值，并且其出现在 1 和 2 的中间，因此我们只需要从左到右枚举 3 的下标 j，那么：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-093150639.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判 : 少于三个元素不能构成132</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 定义左侧最小值</span></span><br><span class="line">        <span class="keyword">int</span> leftMin = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将右侧所有元素放进到有序集合中</span></span><br><span class="line">        TreeMap&lt;Integer,Integer&gt; rightAll = <span class="keyword">new</span> TreeMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>;k &lt; n;++k)&#123;</span><br><span class="line">            rightAll.put(nums[k],rightAll.getOrDefault(nums[k],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 枚举3</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n - <span class="number">1</span>;++j)&#123;</span><br><span class="line">            <span class="comment">// 3.1 满足132中的nums[i] &lt; nums[j]的条件</span></span><br><span class="line">            <span class="keyword">if</span>(leftMin &lt; nums[j])&#123;              </span><br><span class="line">                Integer next = rightAll.ceilingKey(leftMin + <span class="number">1</span>);        <span class="comment">// ceilingKey：方法调用返回的最小的大于或等于的键，如果不存在这样的键在则返回null。（这里的作用是返回TreeMap 中的大于leftMin的最小值）</span></span><br><span class="line">                <span class="keyword">if</span>(next != <span class="keyword">null</span> &amp;&amp; next &lt; nums[j])&#123;                     <span class="comment">// 如果这个最小值存在且小于nums[j]:说明满足132的整体条件</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.2 不满足132中：nums[i] &lt; nums[j] 条件</span></span><br><span class="line">            leftMin = Math.min(leftMin, nums[j]);                       <span class="comment">// 更新leftMin（nums[i]）的值</span></span><br><span class="line">            rightAll.put(nums[j + <span class="number">1</span>], rightAll.get(nums[j + <span class="number">1</span>]) - <span class="number">1</span>);   <span class="comment">// 将有序集合中的nums[j + 1]对应的键值-1 相当于将“窗口”右移一位</span></span><br><span class="line">            <span class="keyword">if</span>(rightAll.get(nums[j + <span class="number">1</span>]) == <span class="number">0</span>)&#123;                         <span class="comment">// 若有序集合中的nums[j + 1]对应的键值==0 删除这个键值对</span></span><br><span class="line">                rightAll.remove(nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举结束未找到返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-094311749.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–456-132-模式&quot;&gt;&lt;a href=&quot;#Leetcode–456-132-模式&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–456-132 模式&quot;&gt;&lt;/a&gt;Leetcode–456-&lt;a href=&quot;https://leetcode-cn.com/problems/132-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;132 模式&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，数组中共有 &lt;code&gt;n&lt;/code&gt; 个整数。&lt;strong&gt;132 模式的子序列&lt;/strong&gt; 由三个整数 &lt;code&gt;nums[i]&lt;/code&gt;、&lt;code&gt;nums[j]&lt;/code&gt; 和 &lt;code&gt;nums[k]&lt;/code&gt; 组成&lt;/li&gt;
&lt;li&gt;并同时满足：&lt;code&gt;i &amp;lt; j &amp;lt; k&lt;/code&gt; 和 &lt;code&gt;nums[i] &amp;lt; nums[k] &amp;lt; nums[j]&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 &lt;code&gt;nums&lt;/code&gt; 中存在 &lt;strong&gt;132 模式的子序列&lt;/strong&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;很容易想到时间复杂度为 &lt;code&gt;O(n^2)&lt;/code&gt; 的解决方案，你可以设计一个时间复杂度为 &lt;code&gt;O(n logn)&lt;/code&gt; 或 &lt;code&gt;O(n)&lt;/code&gt; 的解决方案吗？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中不存在 132 模式的子序列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [3,1,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1,3,2,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == nums.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^9 &amp;lt;= nums[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="(i,j,k)" scheme="http://zhuuu.work/tags/i-j-k/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-697-数组的度</title>
    <link href="http://zhuuu.work/2021/02/15/Leetcode/Leetcode-697-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/"/>
    <id>http://zhuuu.work/2021/02/15/Leetcode/Leetcode-697-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</id>
    <published>2021-02-15T07:52:53.000Z</published>
    <updated>2021-02-20T05:16:28.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-697-数组的度"><a href="#Leecode-697-数组的度" class="headerlink" title="Leecode-697-数组的度"></a>Leecode-697-<a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">数组的度</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。</p></li><li><p>你的任务是在 <code>nums</code> 中找到与 <code>nums</code>拥有<strong>相同大小的度的最短连续子数组，返回其长度。</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[1, 2, 2, 3, 1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">输入数组的度是2，因为元素1和2的出现频数最大，均为2.</span><br><span class="line">连续子数组里面拥有相同度的有如下所示:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">最短连续子数组[2, 2]的长度为2，所以返回2.</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[1,2,2,3,1,4,2]</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">nums.length 在1到 50,000 区间范围内。</span><br><span class="line">nums[i] 是一个在 0 到 49,999 范围内的整数。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路：哈希表-贪心"><a href="#思路：哈希表-贪心" class="headerlink" title="思路：哈希表+贪心"></a>思路：哈希表+贪心</h2><ul><li>记原数组中出现次数最多的数为 x<em>，那么和原数组的度相同的最短连续子数组，必然包含了原数组中的全部 x</em>，<strong>且两端恰为 x 第一次出现和最后一次出现的位置。</strong></li><li>因为符合条件的 x可能有多个，即多个不同的数在原数组中出现次数相同。所以为了找到这个子数组，我们需要统计每一个数出现的次数，同时还需要统计每一个数第一次出现和最后一次出现的位置。<ul><li>使用哈希表实现该功能，每一个数映射到一个长度为 3 的数组，</li><li>数组中的三个元素分别代表这个数出现的次数、这个数在原数组中第一次出现的位置和这个数在原数组中最后一次出现的位置。</li></ul></li><li>当我们记录完所有信息后，我们需要遍历该哈希表，找到元素出现次数最多，且前后位置差最小的数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 哈希表记录：遍历一次哈希表</span></span><br><span class="line">            <span class="comment">// 1.数字出现的次数</span></span><br><span class="line">            <span class="comment">// 2.该数字第一次出现的下标</span></span><br><span class="line">            <span class="comment">// 3.该数字最后一次出现的下标</span></span><br><span class="line">        Map&lt;Integer,<span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.get(nums[i])[<span class="number">0</span>]++;                      <span class="comment">// 当前数字出现次数加1</span></span><br><span class="line">                map.get(nums[i])[<span class="number">2</span>] = i;                    <span class="comment">// 更新出现的最后一次下标</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,i,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 统计哈希表</span></span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;                                     <span class="comment">// 出现次数最多的数字</span></span><br><span class="line">        <span class="keyword">int</span> minLen = <span class="number">0</span>;                                     <span class="comment">// 第一次出现和最后一次出现的间隔</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,<span class="keyword">int</span>[]&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = entry.getValue();                   <span class="comment">// 遍历哈希表拿到每个数字对应的数组</span></span><br><span class="line">            <span class="keyword">if</span>(maxNum &lt; arr[<span class="number">0</span>])&#123;                            <span class="comment">// 如果不是出现次数最多的</span></span><br><span class="line">                maxNum = arr[<span class="number">0</span>];</span><br><span class="line">                minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxNum == arr[<span class="number">0</span>])&#123;                     <span class="comment">// 如果出现次数是最多的数字</span></span><br><span class="line">                <span class="keyword">if</span>(minLen &gt; arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;                                      <span class="comment">// 返回子数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是原数组的长度，我们需要遍历原数组和哈希表各一次，它们的大小均为 O(n)。</p></li><li><p>空间复杂度：O(n)，其中 n 是原数组的长度，最坏情况下，哈希表和原数组等大。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-697-数组的度&quot;&gt;&lt;a href=&quot;#Leecode-697-数组的度&quot; class=&quot;headerlink&quot; title=&quot;Leecode-697-数组的度&quot;&gt;&lt;/a&gt;Leecode-697-&lt;a href=&quot;https://leetcode-cn.com/problems/degree-of-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组的度&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个非空且只包含非负数的整数数组 &lt;code&gt;nums&lt;/code&gt;，数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你的任务是在 &lt;code&gt;nums&lt;/code&gt; 中找到与 &lt;code&gt;nums&lt;/code&gt;拥有&lt;strong&gt;相同大小的度的最短连续子数组，返回其长度。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1, 2, 2, 3, 1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入数组的度是2，因为元素1和2的出现频数最大，均为2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;连续子数组里面拥有相同度的有如下所示:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最短连续子数组[2, 2]的长度为2，所以返回2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,2,2,3,1,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums.length 在1到 50,000 区间范围内。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums[i] 是一个在 0 到 49,999 范围内的整数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-703-数据流中的第K大元素</title>
    <link href="http://zhuuu.work/2021/02/11/Leetcode/Leetcode-703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2021/02/11/Leetcode/Leetcode-703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2021-02-11T05:24:53.000Z</published>
    <updated>2021-02-11T06:19:00.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-703-数据流中的第-K-大元素"><a href="#Leetcode-703-数据流中的第-K-大元素" class="headerlink" title="Leetcode-703- 数据流中的第 K 大元素"></a>Leetcode-703-<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener"> 数据流中的第 K 大元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p></li><li><p>请实现 <code>KthLargest</code>类：</p><ul><li><code>KthLargest(int k, int[] nums)</code> 使用整数 k 和整数流 <code>nums</code>初始化对象。<br><code>int add(int val)</code>将 val 插入数据流 <code>nums</code>后，返回当前数据流中第 k 大的元素。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]</span><br><span class="line">[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, 4, 5, 5, 8, 8]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest &#x3D; new KthLargest(3, [4, 5, 8, 2]);</span><br><span class="line">kthLargest.add(3);   &#x2F;&#x2F; return 4</span><br><span class="line">kthLargest.add(5);   &#x2F;&#x2F; return 5</span><br><span class="line">kthLargest.add(10);  &#x2F;&#x2F; return 5</span><br><span class="line">kthLargest.add(9);   &#x2F;&#x2F; return 8</span><br><span class="line">kthLargest.add(4);   &#x2F;&#x2F; return 8</span><br><span class="line"></span><br><span class="line">**注意:**</span><br><span class="line"></span><br><span class="line">- 提示：</span><br><span class="line">  1 &lt;&#x3D; k &lt;&#x3D; 104</span><br><span class="line">  0 &lt;&#x3D; nums.length &lt;&#x3D; 104</span><br><span class="line">  -104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</span><br><span class="line">  -104 &lt;&#x3D; val &lt;&#x3D; 104</span><br><span class="line">  最多调用 add 方法 10^4 次</span><br><span class="line">  题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-优先队列"><a href="#思路-：-优先队列" class="headerlink" title="思路 ： 优先队列"></a>思路 ： 优先队列</h2><ul><li>使用一个大小为 k 的优先队列来存储前 k大的元素，其中优先队列的队头为队列中最小的元素，也就是第 k 大的元素。</li><li>在单次插入的操作中，我们首先将元素 val 加入到优先队列中。</li><li>如果此时优先队列的大小大于 k，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 <em>k</em>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. k大元素逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.offer(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><h2 id="时间复杂度：O-nlogk"><a href="#时间复杂度：O-nlogk" class="headerlink" title="时间复杂度：O(nlogk)"></a>时间复杂度：O(nlogk)</h2></li><li>空间复杂度：O(k) 使用大小为k的优先队列</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-703-数据流中的第-K-大元素&quot;&gt;&lt;a href=&quot;#Leetcode-703-数据流中的第-K-大元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-703- 数据流中的第 K 大元素&quot;&gt;&lt;/a&gt;Leetcode-703-&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 数据流中的第 K 大元素&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请实现 &lt;code&gt;KthLargest&lt;/code&gt;类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KthLargest(int k, int[] nums)&lt;/code&gt; 使用整数 k 和整数流 &lt;code&gt;nums&lt;/code&gt;初始化对象。&lt;br&gt;&lt;code&gt;int add(int val)&lt;/code&gt;将 val 插入数据流 &lt;code&gt;nums&lt;/code&gt;后，返回当前数据流中第 k 大的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;KthLargest&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[null, 4, 5, 5, 8, 8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;KthLargest kthLargest &amp;#x3D; new KthLargest(3, [4, 5, 8, 2]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(3);   &amp;#x2F;&amp;#x2F; return 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(5);   &amp;#x2F;&amp;#x2F; return 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(10);  &amp;#x2F;&amp;#x2F; return 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(9);   &amp;#x2F;&amp;#x2F; return 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(4);   &amp;#x2F;&amp;#x2F; return 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**注意:**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- 提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  0 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -104 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -104 &amp;lt;&amp;#x3D; val &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  最多调用 add 方法 10^4 次&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="优先队列" scheme="http://zhuuu.work/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-643-子数组最大平均数1</title>
    <link href="http://zhuuu.work/2021/02/04/Leetcode/Leetcode-643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B01/"/>
    <id>http://zhuuu.work/2021/02/04/Leetcode/Leetcode-643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B01/</id>
    <published>2021-02-04T07:52:53.000Z</published>
    <updated>2021-02-04T02:27:43.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-643-子数组最大平均数-I"><a href="#Leetcode-643-子数组最大平均数-I" class="headerlink" title="Leetcode-643-子数组最大平均数 I"></a>Leetcode-643-<a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">子数组最大平均数 I</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 30,000。</span><br><span class="line">所给数据范围 [-10,000，10,000]。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-滑动窗口"><a href="#方法一-：-滑动窗口" class="headerlink" title="方法一 ： 滑动窗口"></a>方法一 ： 滑动窗口</h2><ul><li><strong>由于规定了子数组的长度为 k，因此可以通过寻找子数组的最大元素和的方式寻找子数组的最大平均数，元素和最大的子数组对应的平均数也是最大的。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设两个不同的子数组的长度都是 k，这两个子数组的元素和分别是 x 和 y，</span><br><span class="line">则这两个子数组的平均数分别是 x&#x2F;k 和 y&#x2F;k。</span><br><span class="line">如果 x≥y，则有 x&#x2F;k ≥ y&#x2F;k，即如果一个子数组的元素和更大，则该子数组的平均数也更大。</span><br></pre></td></tr></table></figure><ul><li><strong>为了找到子数组的最大元素和，需要对数组中的每个长度为k的子数组为别计算元素和。对于长度为n的数组，当k &lt;= n的时候，有n - k + 1个长度为k的子数组</strong></li><li>如果直接计算每个子数组的元素和，则时间复杂度过高，无法通过全部测试用例，因此需要使用时间复杂度更低的方法计算每个子数组的元素和。</li></ul><hr><p><strong>滑动窗口推导</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102250831.png" alt="mark"></p><ul><li><p>上述过程可以看成维护一个长度为k的滑动窗口。当滑动窗口的下标范围从<code>[i - k,i - 1]</code> 到 <code>[i - k + 1,i]</code>时，<code>nums[i - k]</code> 从窗口移除，<code>nums[i]</code> 进入到窗口内</p></li><li><p>利用上述关系，可以在O(1) 的时候内通过<code>sum_i-1</code> 得到 <code>sum_i</code></p></li><li><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102651739.png" alt="mark"></p></li><li><p>在上述过程中维护最大的子数组元素和，记为maxSum，子数组的最大平均数即为 maxSum/k。</p></li><li><p>需要注意返回值是浮点型，因此计算除法时需要进行数据类型转换。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102557416.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102613774.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102624973.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102630741.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102636265.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 长度小于k的时候，直接初始化sum</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 长度大于等于k的时候，比较最大的连续子数组和</span></span><br><span class="line">        <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; n;i++)&#123;</span><br><span class="line">            sum = sum - nums[i - k] + nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回浮点结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * maxSum/k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度  : O(n)</li><li>空间复杂度 ：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-643-子数组最大平均数-I&quot;&gt;&lt;a href=&quot;#Leetcode-643-子数组最大平均数-I&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-643-子数组最大平均数 I&quot;&gt;&lt;/a&gt;Leetcode-643-&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-average-subarray-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;子数组最大平均数 I&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个整数，找出平均数最大且长度为 &lt;code&gt;k&lt;/code&gt; 的连续子数组，并输出该最大平均数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,12,-5,-6,50,3], k &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：12.75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最大平均数 (12-5-6+50)&amp;#x2F;4 &amp;#x3D; 51&amp;#x2F;4 &amp;#x3D; 12.75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 30,000。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所给数据范围 [-10,000，10,000]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-424-替换后的最长重复字符</title>
    <link href="http://zhuuu.work/2021/02/03/Leetcode/Leetcode-424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
    <id>http://zhuuu.work/2021/02/03/Leetcode/Leetcode-424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</id>
    <published>2021-02-03T03:52:53.000Z</published>
    <updated>2021-02-04T13:21:09.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-424-替换后的最长重复字符"><a href="#Leetcode-424-替换后的最长重复字符" class="headerlink" title="Leetcode-424-替换后的最长重复字符"></a>Leetcode-424-<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">替换后的最长重复字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p>注意：字符串长度 和 k 不会超过 104。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;ABAB&quot;, k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#39;A&#39;替换为两个&#39;B&#39;,反之亦然。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;AABABBA&quot;, k &#x3D; 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将中间的一个&#39;A&#39;替换为&#39;B&#39;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-滑动窗口"><a href="#方法一-：-滑动窗口" class="headerlink" title="方法一 ： 滑动窗口"></a>方法一 ： 滑动窗口</h2><p><strong>说一下暴力解法：</strong></p><ul><li><p>如果一个问题暂时没有思路，可以先考虑暴力解法（不一定要实现）。<strong>当前问题的暴力解法是：枚举输入字符串的 所有 子串，对于每一个子串：</strong></p><ul><li>如果子串里所有的字符都一样，就考虑长度更长的子串；</li><li>如果当前子串里出现了至少两种字符，要想使得替换以后所有的字符都一样，并且重复的、连续的部分更长，<strong>应该替换掉出现次数最多字符 以外 的字符。</strong></li></ul></li></ul><p><strong>暴力解法的缺点：</strong></p><ul><li>做了重复的工作，子串和子串有很多重合的部分，重复扫描它们是不划算的；</li><li>做了很多没有必要的工作：<ul><li><strong>如果找到了一个长度为 L 且替换 k 个字符以后全部相等的子串</strong>，就没有必要考虑长度小于等于 L 的子串，因为题目只让我们找到符合题意的最长的长度；</li><li><strong>如果找到了一个长度为 L 且替换 k 个字符以后不能全部相等的子串</strong>，左边界相同、长度更长的子串一定不符合要求（原因我们放在最后说）。</li></ul></li></ul><hr><p><strong>滑动窗口</strong></p><ul><li>以 <code>s = AABCABBB</code>，<code>k = 2</code> 为例，寻找替换 <code>k</code> 次以后字符全部相等的最长子串的长度的过程如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104646614.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104658660.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104706538.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104713644.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104722926.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104731243.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104740342.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/112527361.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113537783.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113631793.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113644299.png" alt="mark"></p><hr><ul><li><p>整个过程，我们使用了两个表示边界的变量，一前一后，交替在字符串上前进</p></li><li><p>右边界先向右移动，直到不能移动了为止，左边界再继续向右移动，整个过程像极了一条滑动的窗口在线段上移动。</p></li><li><p>除此之外，考虑的子串中最多出现的字符是次数，因此须要一个频数数组，记录每个字符出现的次数。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/114022723.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;                                <span class="comment">// 长度为0或1</span></span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化条件</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];                   <span class="comment">// 记录字符出现的频率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历一次字符数组</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 3.1 在这里维护maxCount,因为每一次右边界读入一个字符，字符的频率增加，才会使得maxCount增加</span></span><br><span class="line">            freq[charArray[right] - <span class="string">'A'</span>]++;</span><br><span class="line">            maxCount = Math.max(maxCount,freq[charArray[right] - <span class="string">'A'</span>]);</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 </span></span><br><span class="line">            <span class="keyword">if</span>(right - left &gt; maxCount + k)&#123;        <span class="comment">// 说明此时的k不够用，其他不适 最多出现的字符替换以后，都不能填满这个滑动窗口</span></span><br><span class="line">                freq[charArray[left] - <span class="string">'A'</span>]--;      <span class="comment">// 移出滑动窗口的时候，频数数组须要相应地做减法</span></span><br><span class="line">                left++;                             <span class="comment">// 左边界向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.3 </span></span><br><span class="line">            res = Math.max(res,right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是输入字符串 <code>S</code> 的长度；</li><li>空间复杂度：O(A)，这里 A<em>A</em> 是输入字符串 <code>S</code> 出现的字符 ASCII 值的范围</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-424-替换后的最长重复字符&quot;&gt;&lt;a href=&quot;#Leetcode-424-替换后的最长重复字符&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-424-替换后的最长重复字符&quot;&gt;&lt;/a&gt;Leetcode-424-&lt;a href=&quot;https://leetcode-cn.com/problems/longest-repeating-character-replacement/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;替换后的最长重复字符&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。&lt;/p&gt;
&lt;p&gt;注意：字符串长度 和 k 不会超过 104。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;ABAB&amp;quot;, k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：用两个&amp;#39;A&amp;#39;替换为两个&amp;#39;B&amp;#39;,反之亦然。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;AABABBA&amp;quot;, k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;将中间的一个&amp;#39;A&amp;#39;替换为&amp;#39;B&amp;#39;,字符串变为 &amp;quot;AABBBBA&amp;quot;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;子串 &amp;quot;BBBB&amp;quot; 有最长重复字母, 答案为 4。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-888-公平的糖果交换</title>
    <link href="http://zhuuu.work/2021/02/01/Leetcode/Leetcode-888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/"/>
    <id>http://zhuuu.work/2021/02/01/Leetcode/Leetcode-888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/</id>
    <published>2021-02-01T02:52:53.000Z</published>
    <updated>2021-02-03T12:24:35.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-888-公平的糖果棒交换"><a href="#Leetcode-888-公平的糖果棒交换" class="headerlink" title="Leetcode-888-公平的糖果棒交换"></a>Leetcode-888-<a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">公平的糖果棒交换</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。</p></li><li><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</p></li><li><p>返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。</p></li><li><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,1], B &#x3D; [2,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2], B &#x3D; [2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2], B &#x3D; [1,3]</span><br><span class="line">输出：[2,3]</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2,5], B &#x3D; [2,4]</span><br><span class="line">输出：[5,4]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; B.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; A[i] &lt;&#x3D; 100000</span><br><span class="line">1 &lt;&#x3D; B[i] &lt;&#x3D; 100000</span><br><span class="line">保证爱丽丝与鲍勃的糖果总量不同。</span><br><span class="line">答案肯定存在。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-哈希表"><a href="#方法一-：-哈希表" class="headerlink" title="方法一 ： 哈希表"></a>方法一 ： 哈希表</h2><ul><li>记爱丽丝的糖果棒的总大小为sumA，鲍勃的糖果棒的总大小为sumB。</li><li>设答案为 {x,y}，即爱丽丝的大小为 x 的糖果棒与鲍勃的大小为 y 的糖果棒交换，则有如下等式：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210203/202301960.png" alt="mark"></p><ul><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210203/202316825.png" alt="mark"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fairCandySwap(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">        <span class="comment">// 1. 分别求出数组A和B的和</span></span><br><span class="line">        <span class="keyword">int</span> sumA = Arrays.stream(A).sum();</span><br><span class="line">        <span class="keyword">int</span> sumB = Arrays.stream(B).sum();</span><br><span class="line">        <span class="keyword">int</span> delta = (sumA - sumB)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将A的数字存入哈希表 方便查询</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];                             <span class="comment">// 结果集</span></span><br><span class="line">        Set&lt;Integer&gt; setA = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:A)&#123;</span><br><span class="line">            setA.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历B中每一个元素，看A中是否存在可以交换的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y:B)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = y + delta;</span><br><span class="line">            <span class="keyword">if</span>(setA.contains(x))&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = x;</span><br><span class="line">                ans[<span class="number">1</span>] = y;</span><br><span class="line">                <span class="keyword">break</span>;                                     <span class="comment">// 存在一组立即结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度 ： O(m + n) ，最差情况下两个数组都需要进行遍历</li><li>空间复杂度 ： O(n)  , n 为 数组A的长度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-888-公平的糖果棒交换&quot;&gt;&lt;a href=&quot;#Leetcode-888-公平的糖果棒交换&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-888-公平的糖果棒交换&quot;&gt;&lt;/a&gt;Leetcode-888-&lt;a href=&quot;https://leetcode-cn.com/problems/fair-candy-swap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公平的糖果棒交换&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有多个答案，你可以返回其中任何一个。保证答案存在。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,1], B &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2], B &amp;#x3D; [2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2], B &amp;#x3D; [1,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2,5], B &amp;#x3D; [2,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[5,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; B.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 100000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; B[i] &amp;lt;&amp;#x3D; 100000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;保证爱丽丝与鲍勃的糖果总量不同。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;答案肯定存在。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-724-寻找数组的中心索引</title>
    <link href="http://zhuuu.work/2021/01/28/Leetcode/Leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
    <id>http://zhuuu.work/2021/01/28/Leetcode/Leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</id>
    <published>2021-01-28T05:24:53.000Z</published>
    <updated>2021-01-28T01:24:28.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-724-寻找数组的中心索引"><a href="#Leetcode-724-寻找数组的中心索引" class="headerlink" title="Leetcode-724-寻找数组的中心索引"></a>Leetcode-724-<a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">寻找数组的中心索引</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p></li><li><p>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p></li><li><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">索引 <span class="number">3</span> (nums[<span class="number">3</span>] = <span class="number">6</span>) 的左侧数之和 (<span class="number">1</span> + <span class="number">7</span> + <span class="number">3</span> = <span class="number">11</span>)，与右侧数之和 (<span class="number">5</span> + <span class="number">6</span> = <span class="number">11</span>) 相等。</span><br><span class="line">同时, <span class="number">3</span> 也是第一个符合要求的中心索引。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li></ul><a id="more"></a><h2 id="方法一-：-前缀和"><a href="#方法一-：-前缀和" class="headerlink" title="方法一 ： 前缀和"></a>方法一 ： 前缀和</h2><ul><li><p><strong>记录数组的全部元素之和为total</strong></p></li><li><p>当遍历到第i个元素的时候，设其左侧元素之和为sum,右侧之和就是<code>total - sum - nums[i]</code></p></li><li><p>左右侧元素相等 <code>sum = total - nums[i] - sum</code> ，即 <code>2 * sum + nums[i] = total</code></p></li><li><p>当中心索引左侧或右侧没有元素时，即为零个项相加，<strong>这在数学上称作「空和」（empty sum）。在程序设计中我们约定「空和是零」。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 计算全部元素之和</span></span><br><span class="line">        <span class="keyword">int</span> total = Arrays.stream(nums).sum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 左侧元素之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 左右侧元素之和相等</span></span><br><span class="line">        <span class="comment">// sum = total - nums[i] - sum</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * sum + nums[i] == total)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 不存在的话</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)</li><li>空间复杂度 ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-724-寻找数组的中心索引&quot;&gt;&lt;a href=&quot;#Leetcode-724-寻找数组的中心索引&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-724-寻找数组的中心索引&quot;&gt;&lt;/a&gt;Leetcode-724-&lt;a href=&quot;https://leetcode-cn.com/problems/find-pivot-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;寻找数组的中心索引&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;索引 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; (nums[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) 的左侧数之和 (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;)，与右侧数之和 (&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) 相等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;同时, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 也是第一个符合要求的中心索引。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组中不存在满足此条件的中心索引。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; 的长度范围为 &lt;code&gt;[0, 10000]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;任何一个 &lt;code&gt;nums[i]&lt;/code&gt; 将会是一个范围在 &lt;code&gt;[-1000, 1000]&lt;/code&gt;的整数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-989-数组形式的加法</title>
    <link href="http://zhuuu.work/2021/01/22/Leetcode/Leetcode-989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95/"/>
    <id>http://zhuuu.work/2021/01/22/Leetcode/Leetcode-989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95/</id>
    <published>2021-01-22T07:52:53.000Z</published>
    <updated>2021-01-22T02:22:12.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-989-数组形式的整数加法"><a href="#Leetcode-989-数组形式的整数加法" class="headerlink" title="Leetcode-989-数组形式的整数加法"></a>Leetcode-989-<a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">数组形式的整数加法</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 <code>X = 1231</code>，那么其数组形式为<code>[1,2,3,1]</code>。</p></li><li><p>给定非负整数 X 的数组形式 A，返回整数<code>X+K</code>的数组形式。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2,0,0], K &#x3D; 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 &#x3D; 1234</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2,7,4], K &#x3D; 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 &#x3D; 455</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2,1,5], K &#x3D; 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 &#x3D; 1021</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [9,9,9,9,9,9,9,9,9,9], K &#x3D; 1</span><br><span class="line">输出：[1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">解释：9999999999 + 1 &#x3D; 10000000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">0 &lt;&#x3D; A[i] &lt;&#x3D; 9</span><br><span class="line">0 &lt;&#x3D; K &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-模拟按位相加"><a href="#方法一-：-模拟按位相加" class="headerlink" title="方法一 ： 模拟按位相加"></a>方法一 ： 模拟按位相加</h2><ul><li>逐位将数字加在一起。例如计算 123+912，我们从低位到高位依次计算 3+2、2+1 和 1+9。任何时候，若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中，所以最终结果为 1035。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化参数</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从后往前逐位相加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 1.1 逐位相加</span></span><br><span class="line">            <span class="keyword">int</span> sum = A[i] + K % <span class="number">10</span>;         <span class="comment">// 每次重置sum</span></span><br><span class="line">            K /= <span class="number">10</span>;    </span><br><span class="line">            <span class="comment">// 1.2 处理两位相加 进位的情况</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                K++;                        <span class="comment">// 进位到K的末尾</span></span><br><span class="line">                sum -= <span class="number">10</span>;                  <span class="comment">// 进位清掉</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.2 当前相加的结果 添加到结果集</span></span><br><span class="line">            res.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. K的数字长度大于数组的数字长度</span></span><br><span class="line">        <span class="keyword">for</span>(;K &gt; <span class="number">0</span>;K /= <span class="number">10</span>)&#123;                <span class="comment">// 每次K左移一位</span></span><br><span class="line">            res.add(K % <span class="number">10</span>);                <span class="comment">// 添加到结果集</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将结果集翻转即是所求答案</span></span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : O(max(n,logK)) , 其中K是数组的长度</li><li>空间复杂度 : O(max(n,logK))</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-989-数组形式的整数加法&quot;&gt;&lt;a href=&quot;#Leetcode-989-数组形式的整数加法&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-989-数组形式的整数加法&quot;&gt;&lt;/a&gt;Leetcode-989-&lt;a href=&quot;https://leetcode-cn.com/problems/add-to-array-form-of-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组形式的整数加法&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 &lt;code&gt;X = 1231&lt;/code&gt;，那么其数组形式为&lt;code&gt;[1,2,3,1]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定非负整数 X 的数组形式 A，返回整数&lt;code&gt;X+K&lt;/code&gt;的数组形式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2,0,0], K &amp;#x3D; 34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：1200 + 34 &amp;#x3D; 1234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2,7,4], K &amp;#x3D; 181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,5,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：274 + 181 &amp;#x3D; 455&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2,1,5], K &amp;#x3D; 806&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,0,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：215 + 806 &amp;#x3D; 1021&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [9,9,9,9,9,9,9,9,9,9], K &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,0,0,0,0,0,0,0,0,0,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：9999999999 + 1 &amp;#x3D; 10000000000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; K &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://zhuuu.work/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1232-缀点成线</title>
    <link href="http://zhuuu.work/2021/01/17/Leetcode/Leetcode-1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/"/>
    <id>http://zhuuu.work/2021/01/17/Leetcode/Leetcode-1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/</id>
    <published>2021-01-17T07:52:53.000Z</published>
    <updated>2021-01-17T06:02:14.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1232-缀点成线"><a href="#Leetcode-1232-缀点成线" class="headerlink" title="Leetcode-1232-缀点成线"></a>Leetcode-1232-缀点成线</h1><h2 id="思路：深度优先遍历-DFS"><a href="#思路：深度优先遍历-DFS" class="headerlink" title="思路：深度优先遍历/DFS"></a>思路：深度优先遍历/DFS</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p></li><li><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。</p></li></ul><p><strong>示例1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135800973.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coordinates &#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135821014.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coordinates &#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-数学直线知识"><a href="#思路-：-数学直线知识" class="headerlink" title="思路 ： 数学直线知识"></a>思路 ： 数学直线知识</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/140102900.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 将所有点向(-deltax,-deltay) 方向进行平移 : 第一个点就移到了原点</span></span><br><span class="line">        <span class="keyword">int</span> deltaX = coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> deltaY = coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            coordinates[i][<span class="number">0</span>] -= deltaX;</span><br><span class="line">            coordinates[i][<span class="number">1</span>] -= deltaY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 两点确定一条直线 设直线方程为 Ax + By = 0 带入(-deltax_1,-deltay_1)坐标</span></span><br><span class="line">        <span class="keyword">int</span> A = coordinates[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> B = -coordinates[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 判断从原点和第一个点以外的所有点是否在这条直线上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = coordinates[i][<span class="number">0</span>];<span class="comment">// 每个点的横坐标</span></span><br><span class="line">            <span class="keyword">int</span> y = coordinates[i][<span class="number">1</span>];<span class="comment">// 每个点的纵坐标</span></span><br><span class="line">            <span class="keyword">if</span>(A * x + B * y != <span class="number">0</span>)&#123;             <span class="comment">// 说明不在直线上</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是数组中的元素数量。</li><li>时间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-1232-缀点成线&quot;&gt;&lt;a href=&quot;#Leetcode-1232-缀点成线&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1232-缀点成线&quot;&gt;&lt;/a&gt;Leetcode-1232-缀点成线&lt;/h1&gt;&lt;h2 id=&quot;思路：深度优先遍历-DFS&quot;&gt;&lt;a href=&quot;#思路：深度优先遍历-DFS&quot; class=&quot;headerlink&quot; title=&quot;思路：深度优先遍历/DFS&quot;&gt;&lt;/a&gt;思路：深度优先遍历/DFS&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135800973.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：coordinates &amp;#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135821014.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：coordinates &amp;#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://zhuuu.work/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-228-汇总区间</title>
    <link href="http://zhuuu.work/2021/01/10/Leetcode/Leetcode-228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2021/01/10/Leetcode/Leetcode-228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</id>
    <published>2021-01-10T00:33:53.000Z</published>
    <updated>2021-01-10T01:00:35.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-228-汇总区间"><a href="#Leetcode-228-汇总区间" class="headerlink" title="Leetcode-228-汇总区间"></a>Leetcode-228-<a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noopener">汇总区间</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p></li><li><p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p></li><li><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-双指针"><a href="#思路-：-双指针" class="headerlink" title="思路 ： 双指针"></a>思路 ： 双指针</h2><ul><li><strong>从数组的位置 0 出发，向右遍历。</strong></li><li>每次遇到相邻元素之间的差值大于 1 时，我们就找到了一个区间。遍历完数组之后，就能得到一系列的区间的列表。</li><li>在遍历过程中，<strong>维护下标 low 和 high 分别记录区间的起点和终点</strong><ul><li>对于任何区间都有 <code>low &lt;= high</code></li><li><strong>当得到一个区间的时候，根据low 和 high 的值生成区间的字符串表示</strong><ul><li><code>low &lt;= high</code> ，区间的字符串表示为<code>“nums[low] -&gt;nums[high]”</code></li><li><code>low == high</code> ，区间的字符串表表示为<code>&quot;nums[low]&quot;</code></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();                               <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(idx &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 1.1 区间扩大 ： 区间未断开</span></span><br><span class="line">            <span class="keyword">int</span> low = idx;                                                      <span class="comment">// 记录区间的起</span></span><br><span class="line">            idx++;                                                              <span class="comment">// ++到下一个位置 </span></span><br><span class="line">            <span class="keyword">while</span>(idx &lt; n &amp;&amp; nums[idx] == nums[idx - <span class="number">1</span>] + <span class="number">1</span>)&#123;                   <span class="comment">// 如果区间没有断开</span></span><br><span class="line">                idx++;                                                          <span class="comment">// 将区间进行扩大</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.2 记录区间的终点 ： 断开退出循环</span></span><br><span class="line">            <span class="keyword">int</span> high = idx - <span class="number">1</span>;                                                 <span class="comment">// 记录区间的终点</span></span><br><span class="line">            <span class="comment">// 1.3 处理结果</span></span><br><span class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder(Integer.toString(nums[low]));<span class="comment">// 首先加入起点位置,如果low &lt; high，当前区间为nums[low]]本身</span></span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)&#123;                                                     <span class="comment">// low &lt; high 说明是一个完整连续的区间</span></span><br><span class="line">                temp.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">                temp.append(Integer.toString(nums[high]));                      <span class="comment">// low -&gt; high</span></span><br><span class="line">            &#125;                   </span><br><span class="line">            <span class="comment">// 1.4 加入到结果集中</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)  其中n 为数组的长度</li><li>空间复杂度 ： O(1) 没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-228-汇总区间&quot;&gt;&lt;a href=&quot;#Leetcode-228-汇总区间&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-228-汇总区间&quot;&gt;&lt;/a&gt;Leetcode-228-&lt;a href=&quot;https://leetcode-cn.com/problems/summary-ranges/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汇总区间&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个无重复元素的有序整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列表中的每个区间范围 &lt;code&gt;[a,b]&lt;/code&gt; 应该按如下格式输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a-&amp;gt;b&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a != b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a == b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0,1,2,4,5,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：区间范围是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,2] --&amp;gt; &amp;quot;0-&amp;gt;2&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,5] --&amp;gt; &amp;quot;4-&amp;gt;5&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[7,7] --&amp;gt; &amp;quot;7&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0,2,3,4,6,8,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0&amp;quot;,&amp;quot;2-&amp;gt;4&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;8-&amp;gt;9&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：区间范围是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,0] --&amp;gt; &amp;quot;0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2,4] --&amp;gt; &amp;quot;2-&amp;gt;4&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[6,6] --&amp;gt; &amp;quot;6&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[8,9] --&amp;gt; &amp;quot;8-&amp;gt;9&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;-1&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 5：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>图像学-色温、白平衡与色彩恒常性</title>
    <link href="http://zhuuu.work/2021/01/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E6%B8%A9%E3%80%81%E7%99%BD%E5%B9%B3%E8%A1%A1%E4%B8%8E%E8%89%B2%E5%BD%A9%E6%81%92%E5%B8%B8%E6%80%A7/"/>
    <id>http://zhuuu.work/2021/01/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E6%B8%A9%E3%80%81%E7%99%BD%E5%B9%B3%E8%A1%A1%E4%B8%8E%E8%89%B2%E5%BD%A9%E6%81%92%E5%B8%B8%E6%80%A7/</id>
    <published>2021-01-09T09:38:38.000Z</published>
    <updated>2021-01-10T07:15:44.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-色温、白平衡与色彩恒常性"><a href="#图像学-色温、白平衡与色彩恒常性" class="headerlink" title="图像学-色温、白平衡与色彩恒常性"></a>图像学-色温、白平衡与色彩恒常性</h1><h2 id="1-色温"><a href="#1-色温" class="headerlink" title="1. 色温"></a>1. 色温</h2><ul><li><strong>色温这个概念是从黑体辐射来的。</strong></li><li>根据日常的经验我们可以知道，给一个铁块加热，随着温度升高，铁块开始是暗红色，逐渐变成亮红色，如果能达到炼钢炉里那样的高温，铁融化成铁水，发出耀眼的金黄色光芒。</li><li>而天文学家也告诉我们，宇宙中的恒星可以看做一个个黑体，随着恒星温度的升高，恒星的颜色也是从红色到黄色，非常高温度的恒星甚至发出偏蓝色的光。</li></ul><p>直接渲染了不同温度下黑体辐射的颜色。下图就是渲染出的不同温度黑体的颜色。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/160318930.png" alt="mark"></p><p>​                                                                            （黑体辐射的颜色）</p><ul><li><p>从这个例子里可以看出，随着温度的升高，黑体的颜色从暗红到亮红，逐渐到金黄色，再慢慢到蓝色。</p></li><li><p>在下面这个色品图上可以看得更清楚，随着温度升高，黑体颜色在色品图上移动，形成一条曲线轨迹</p></li><li><p>这条轨迹从右下角的红色区域出发，经过黄色区域，中间的白色区域，到达左侧的蓝色区域。这条轨迹就叫做 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Planckian_locus">普朗克轨迹</a>。下图显示了色品图上的普朗克轨迹（来自维基百科 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Planckian_locus">普朗克轨迹</a>）</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/161107925.png" alt="mark"></p><p>​                                                                                （普朗克轨迹）</p><ul><li>我们日常生活中，最重要的光源就是太阳，太阳发出的光很接近黑体光谱。我们的太阳表面温度约为 5500K，这个温度的黑体发出的光，基本就是白色。</li><li>读过本专栏之前文章的读者朋友肯定能理解，这当然不是巧合。在色彩空间中我们需要定义一个白点，而常见的一些标准白点，就是以 5500K 左右的黑体辐射（也就是我们的太阳）为基础的。</li><li>CIE 委员会规定的几种标准白点中，D50、D55 和 D65 是常用的白点，参照了 5000K、5500K 和 6500K 的黑体辐射来定义，模拟了不同条件下（比如地平线方向的光照，上下午的室外，正午室外）的光照。</li><li>色彩空间 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/SRGB">sRGB</a> 所依赖的白点就是 D65。</li></ul><a id="more"></a><hr><p>注意：</p><ul><li>对于色温，通常有几个误解。<strong>第一个误解是</strong>混淆了色温和情感上的温度倾向。我们必须理解，色温是根据黑体辐射温度来定义的，是物理上的温度，而不是情感上的温度。<ul><li>从我们的情感上来说，橙色红色给人感觉温暖，蓝色给人感觉寒冷。但从色温的定义来看，红色橙色是温度较低的黑体发出的颜色，而温度高的黑体颜色反而是蓝色。</li></ul></li><li><strong>第二个误解</strong>是混淆了色温针对的对象。狭义上来说，色温是针对光源的。比如晴朗正午的室外，光源是太阳（以及部分蓝天），这个时候的光源接近标准光源 D65，色温接近 6500K；<ul><li>又比如说傍晚日落，经过大气层的散射，阳光中的蓝光大大减少，光线颜色偏黄，光源颜色也许接近 3500K 的黑体。</li></ul></li></ul><h2 id="2-白平衡"><a href="#2-白平衡" class="headerlink" title="2. 白平衡"></a>2. 白平衡</h2><ul><li><p>物理世界里是无所谓「颜色」这个概念的，一切都是 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Spectral_power_distribution">光谱功率分布</a>，所谓的「颜色」，是人类视觉过程产生的一种感受。</p></li><li><p>正是如此，我们才有了「三原色」理论，我们才可以用三种颜色的光来模拟世间万物的颜色。</p></li><li><p>生活常识告诉我们，光源的颜色不同，照射到同一个物体上，会引起物体颜色的变化。从单纯的物理的角度来看，这个事情再正常不过了。</p></li><li><p>光源有光谱功率分布，物体对不同波长的光线又有不同的反射率，那么光源照射到物体上，再反射到眼睛里的光，它的光谱功率分布就和光源密切相关了。</p></li><li><p>不同的光源，照射到同样的物体上，物体反射光的光谱功率分布就会不一样。</p></li></ul><p>下图展示了一个例子，物体的反射率是对蓝色光更高，对红色光更低。</p><ul><li>第一行的光源是一个接近白色的光源，照射到物体上之后，反射的光线就是蓝色；</li><li>而第二行的光源是一个黄色的光源，照射到物体上之后，反射的光线是偏棕红色的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/164802986.png" alt="mark"></p><p>​                                                            （不同光源下物体有不同颜色）</p><ul><li>这里需要再强调一下，物理上没有所谓的「颜色」的概念，只有「光谱功率分布」、「反射率」这些概念。一个物体的反射率是固定不变的，但是这个物体的「颜色」在不同条件下是不一样的。<ul><li>我们可以用一个标准白点（比如 D65）作为光源，照射到物体上。我们认为这个时候物体表现出来的「颜色」就是物体「本来」的颜色，可以定义为物体的「固有色」。</li><li>很显然，固有色的光谱功率分布曲线与物体本身的反射率曲线两者是很接近的（参见上图中第一行的例子）。</li></ul></li></ul><ul><li><p><strong>白平衡（<a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Color_balance">White Balance</a>）要做的</strong>，就是在不同的光线条件下，根据当时得到的物体颜色，尽量恢复物体的「固有色」，</p><ul><li>或者说，尽量减小光源颜色对物体颜色的影响。（在下一节会继续讨论这个定义的合理性，本小节中先按照这个定义进行讨论）。</li><li>我们可以在色彩转换的过程中根据光源的情况指定不同的白点，从而得到相应正确的色彩转换结果。举例来说，在晴天正午室外拍摄的一张照片，光源近似于标准白点 D65，那么我们就用 D65 点作为白点进行色彩转换（实际上就是直接用 sRGB 空间进行展示）。</li><li>又比如在黄昏的光线下拍摄了照片，<strong>此时光源接近 2500K 的黑体</strong>，那么我们从普朗克曲线上找到 2500K 的点，作为新的白点，进行色彩转换，就能得到正确的颜色。</li><li><strong>由于色彩空间的线性性质，这个转换过程就是一个矩阵乘法</strong>，非常方便。详细的计算过程可以参见之前的文章，这里不再赘述。</li></ul></li><li><p><strong>这就是相机上色温调节的原理。</strong></p><ul><li>也就是说，相机上的色温选项，<strong>调节的是色彩转换中的白点的位置，在普朗克曲线上选取与色温相对应的点作为白点进行色彩转换，从而得到正确的颜色。</strong></li><li><strong>这个色温选项，是要与拍摄时的光源色温相匹配的</strong>，这也是为什么在晴朗的白天拍摄，色温控制在 5000K ~ 6000K 是比较合适的，而在黄昏时候拍摄，色温需要设置成 2500K ~ 3000K 才比较合适。</li></ul></li></ul><hr><p>注意：</p><ul><li>可以看到，沿着普朗克线移动白点，总体上是调节了画面偏蓝或者偏黄的色彩倾向。</li><li>当然，<strong>完整的白平衡要求白点可以任意设置，所以必须增加第二个移动方向。</strong><ul><li><strong>最合理的选择就是与普朗克线正交的另一个方向</strong></li><li>从色品图上看大致是从左上角到右下侧直线边的方向，也就是绿色到品红的方向。</li></ul></li><li>正因为如此，我们可以看到，<code>Photoshop、Lightroom</code>这样的照片处理软件，白平衡的面板上总是会有两个调节滑块<ul><li>一个调节黄-蓝平衡，<strong>通常叫色温（<code>Temperature</code>）</strong></li><li>一个调节绿-品红平衡，<strong>通常叫色调（Tint）</strong></li><li>这两个方向互相配合，才能使得白点位于色品图中的任意位置，才能对任意光线条件下拍摄的照片进行白平衡的调节。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/165816640.png" alt="mark"></p><p>​                                                        <strong>（Photoshop 中的白平衡调节面板）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/165629562.png" alt="mark"></p><p>​                                                                <strong>（色温和色调调节）</strong></p><h2 id="3-色彩恒常性"><a href="#3-色彩恒常性" class="headerlink" title="3. 色彩恒常性"></a>3. 色彩恒常性</h2><ul><li>白平衡解决了「怎样才能正确得到白色」的问题，在上一小节中，我提出白平衡的目的是「在不同的光线条件下，根据当时得到的物体颜色，尽量恢复物体的固有色」，这句话看似简单，仔细想想，却又并不那么显然</li><li>一个很明显的疑问是：我们怎么知道什么是物体的固有色？白炽灯照明下的一张白纸，与阳光照明下的一张橙黄色的纸，两者从物理上而言可以是几乎一样的，或者说两者的光谱功率分布函数，可以是几乎一样的。那么我们凭什么说一张是白纸，一张是橙黄色的纸呢？</li></ul><p>答案是，不能区分。如果仅仅看这张纸的话，我们不能区分哪张是白纸，哪张是黄纸。</p><hr><ul><li><p>但是，我们不仅仅只看了纸，我们还看到了周围的景物，也许是摆放纸张的书桌，也许是周围的植物盆景，也许是旁边的水果，甚至是我们自己的手。</p></li><li><p>所有这一切，都帮助我们认识周围的环境，根据环境去推测这张纸本来的颜色。</p></li><li><p>人类视觉过程不仅仅有视网膜的参与，更重要的还有大脑的参与。视觉是人类获取外界信息最重要的手段，在日复一日的使用中，人类大脑对外界环境建立起了复杂的感知和对应。我们的大脑早就知道，植物叶子是绿色的，樱桃是红色的，我们的皮肤是黄色</p></li><li><p><strong>通过对这些周围环境的感知，我们的大脑推断出了这个时候光源的情况——是白炽灯还是阳光，从而自动完成了「白平衡」的过程，使得我们迅速感知到一个物体本来的颜色是什么。这就是人类视觉的色彩恒常性。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/150214753.png" alt="mark"></p><p>​                                                            没有红色的草莓</p><ul><li>上图是一个很好的例子（图片来自 <a href="https://link.zhihu.com/?target=http%3A//www.psy.ritsumei.ac.jp/~akitaoka/colorconstancy6e.html">Color constancy</a>），在这幅图中，如果我们单独一个一个像素点来看，没有一个像素点是红色的，所有的像素点都是绿色、青色、灰色，图中选取的几个像素点的 RGB 值也充分说明了这一点</li><li>但是当我们从整体来这张图，立刻会产生「红色草莓」、「黄色木桌」、「白色盘子」的印象。<strong>这就是我们大脑根据一些「先验知识」进行自动白平衡的结果。</strong></li></ul><hr><p>当然，在没有一个强有力的先验知识的情况下，人类也很容易给出错误的答案。君不见引起网络大撕逼的「白金、蓝黑」神奇衣服？</p><ul><li><p>在我看来，这些争论都是没什么意义的，因为图片提供的场景信息太少，人类的大脑还不足以利用先验知识，建立对当场光源的感知，只能凭借自身的经验进行推断，而每个人自身经验千差万别，自然也没办法正确推断衣服的颜色了。</p></li><li><p>如果大家能在现场看一眼，或者图片作者能上传一段附带周围环境的视频，我想大概就不会有人对这件衣服的颜色有疑问了。</p></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/151159127.png" alt="mark" style="zoom:80%;" /><p>​                                                    <strong>（白金？蓝黑？）</strong></p><hr><p>当然，我们可以有意识地利用这种错觉，造成一些有趣的结果。比如下图中，绿色条纹和蓝色条纹，其实是同一种颜色（图片来自 <a href="https://link.zhihu.com/?target=http%3A//www.independent.co.uk/news/weird-news/forget-the-dress-theres-another-optical-illusion-blowing-our-minds-10076727.html">independent</a>）。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/151241238.png" alt="mark"></p><p>​                                                            <strong>（绿色？蓝色？）</strong></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol><li><p><strong>色温是根据黑体辐射进行定义的，橙黄色色温低，蓝色色温高；</strong></p></li><li><p><strong>相机中的色温设置，需要与当时光源的色温相匹配；</strong></p></li><li><p><strong>白平衡的目的，是希望在不同光线条件下，都能正确得到物体的固有色；</strong></p></li><li><p><strong>白平衡本质上是调节两个参数：色温和色调</strong></p><ul><li>色温条件蓝-&gt;黄 的色调</li><li>色调调节绿-&gt;品红偏色</li><li>白平衡通过调节两个参数，来设置白点的位置，从而得到正确的色彩转换</li></ul></li><li><p><strong>人类视觉具有色彩恒常性，是大脑对外界环境感知的反应。当外界环境信息不足时，无法建立正确的色彩恒常感知。</strong></p></li></ol><p><strong>参考博客</strong> ： <a href="https://zhuanlan.zhihu.com/p/27165715" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27165715</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-色温、白平衡与色彩恒常性&quot;&gt;&lt;a href=&quot;#图像学-色温、白平衡与色彩恒常性&quot; class=&quot;headerlink&quot; title=&quot;图像学-色温、白平衡与色彩恒常性&quot;&gt;&lt;/a&gt;图像学-色温、白平衡与色彩恒常性&lt;/h1&gt;&lt;h2 id=&quot;1-色温&quot;&gt;&lt;a href=&quot;#1-色温&quot; class=&quot;headerlink&quot; title=&quot;1. 色温&quot;&gt;&lt;/a&gt;1. 色温&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;色温这个概念是从黑体辐射来的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根据日常的经验我们可以知道，给一个铁块加热，随着温度升高，铁块开始是暗红色，逐渐变成亮红色，如果能达到炼钢炉里那样的高温，铁融化成铁水，发出耀眼的金黄色光芒。&lt;/li&gt;
&lt;li&gt;而天文学家也告诉我们，宇宙中的恒星可以看做一个个黑体，随着恒星温度的升高，恒星的颜色也是从红色到黄色，非常高温度的恒星甚至发出偏蓝色的光。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接渲染了不同温度下黑体辐射的颜色。下图就是渲染出的不同温度黑体的颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/160318930.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;​                                                                            （黑体辐射的颜色）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从这个例子里可以看出，随着温度的升高，黑体的颜色从暗红到亮红，逐渐到金黄色，再慢慢到蓝色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在下面这个色品图上可以看得更清楚，随着温度升高，黑体颜色在色品图上移动，形成一条曲线轨迹&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这条轨迹从右下角的红色区域出发，经过黄色区域，中间的白色区域，到达左侧的蓝色区域。这条轨迹就叫做 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Planckian_locus&quot;&gt;普朗克轨迹&lt;/a&gt;。下图显示了色品图上的普朗克轨迹（来自维基百科 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Planckian_locus&quot;&gt;普朗克轨迹&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/161107925.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;​                                                                                （普朗克轨迹）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们日常生活中，最重要的光源就是太阳，太阳发出的光很接近黑体光谱。我们的太阳表面温度约为 5500K，这个温度的黑体发出的光，基本就是白色。&lt;/li&gt;
&lt;li&gt;读过本专栏之前文章的读者朋友肯定能理解，这当然不是巧合。在色彩空间中我们需要定义一个白点，而常见的一些标准白点，就是以 5500K 左右的黑体辐射（也就是我们的太阳）为基础的。&lt;/li&gt;
&lt;li&gt;CIE 委员会规定的几种标准白点中，D50、D55 和 D65 是常用的白点，参照了 5000K、5500K 和 6500K 的黑体辐射来定义，模拟了不同条件下（比如地平线方向的光照，上下午的室外，正午室外）的光照。&lt;/li&gt;
&lt;li&gt;色彩空间 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/SRGB&quot;&gt;sRGB&lt;/a&gt; 所依赖的白点就是 D65。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-547-省份数量</title>
    <link href="http://zhuuu.work/2021/01/07/Leetcode/Leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <id>http://zhuuu.work/2021/01/07/Leetcode/Leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</id>
    <published>2021-01-07T07:21:53.000Z</published>
    <updated>2021-01-07T02:37:52.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-547-省份数量"><a href="#Leetcode-547-省份数量" class="headerlink" title="Leetcode-547-省份数量"></a>Leetcode-547-<a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener">省份数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p></li><li><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p></li><li><p>给你一个 n x n 的矩阵<code>isConnected</code>，其中<code>isConnected[i][j] = 1</code> 表示第 i 个城市和第 j 个城市直接相连，而<code>isConnected[i][j] = 0</code>表示二者不直接相连。</p></li><li><p>返回矩阵中 省份 的数量。</p></li></ul><p><strong>示例一 ：</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093358281.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093431219.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 200</span><br><span class="line">n &#x3D;&#x3D; isConnected.length</span><br><span class="line">n &#x3D;&#x3D; isConnected[i].length</span><br><span class="line">isConnected[i][j] 为 1 或 0</span><br><span class="line">isConnected[i][i] &#x3D;&#x3D; 1</span><br><span class="line">isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>可以把 n个城市和它们之间的相连关系看成图，城市是图中的节点，相连关系是图中的边，</p></li><li><p>给定的矩阵 <code>isConnected</code> 即为图的邻接矩阵，</p></li><li><p>省份即为图中的连通分量。</p></li></ul><p>计算省份总数，等价于计算图中的连通分量数，<strong>可以通过深度优先搜索或广度优先搜索实现，也可以通过并查集实现。</strong></p><h2 id="方法一-：-DFS"><a href="#方法一-：-DFS" class="headerlink" title="方法一 ： DFS"></a>方法一 ： DFS</h2><ul><li>深度优先搜索的思路很直观<ul><li>遍历所有的城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索</li><li>通过矩阵<code>isConnected</code> 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量</li><li>然后对这些城市继续进行深度优先搜索，直到同一个连通分量的所有城市都被访问到，即可得到一个省份</li><li>遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始需要的变量</span></span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;                 <span class="comment">// 城市数量</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[provinces];         <span class="comment">// 标记该城市是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;                                    <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历所有的城市</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; provinces;i++)&#123;</span><br><span class="line">            <span class="comment">// 2.1 对于该城市尚未被访问过，从该城市开始深度优先搜索</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;                                <span class="comment">// 该城市没有被访问过</span></span><br><span class="line">                dfs(isConnected,visited,provinces,i);       <span class="comment">// 2.2 dfs 逻辑</span></span><br><span class="line">                circles++;                                  <span class="comment">// 直到同一个连通分量的所有城市都被访问到，即可得到一个省份</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.2 dfs 逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] isConnected,<span class="keyword">boolean</span>[] visited,<span class="keyword">int</span> provinces,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; provinces;j++)&#123;                  <span class="comment">// i : 作为起点 ，遍历 i 行元素，得到这一行元素（城市） 哪些是连通的</span></span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;     <span class="comment">// 如果到达一个没有访问过且可达的元素（城市）</span></span><br><span class="line">                visited[j] = <span class="keyword">true</span>;                         <span class="comment">// 标记为访问过           </span></span><br><span class="line">                dfs(isConnected,visited,provinces,j);      <span class="comment">// j : 作为起点， 遍历 j 行元素，得到这一行元素（城市） 哪些是连通的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n^2)，其中 <em>n</em> 是城市的数量。需要遍历矩阵 n 中的每个元素。</li><li>空间复杂度：  O(n)，其中 n 是城市的数量。<ul><li>需要使用数组visited 记录每个城市是否被访问过，数组长度是 n，</li><li>递归调用栈的深度不会超过 n。</li></ul></li></ul><h2 id="方法二-：-BFS"><a href="#方法二-：-BFS" class="headerlink" title="方法二 ： BFS"></a>方法二 ： BFS</h2><ul><li>对于每个城市，如果该城市尚未被访问过，则从该城市开始广度优先搜索，直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始需要的变量</span></span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;                         <span class="comment">// 城市数量</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[provinces];                 <span class="comment">// 标记该城市是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;                                            <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. BFS 逻辑</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();                  <span class="comment">// 2.1 队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; provinces;i++)&#123;                           <span class="comment">// 遍历每个城市</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;                                        <span class="comment">// 如果该城市未被访问过</span></span><br><span class="line">                queue.offer(i);                                     <span class="comment">// 从该城市开始BFS搜索</span></span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;                            <span class="comment">// 2.2 BFS逻辑</span></span><br><span class="line">                    <span class="keyword">int</span> j = queue.poll();                           <span class="comment">// 弹出该城市</span></span><br><span class="line">                    visited[j] = <span class="keyword">true</span>;                              <span class="comment">// 标记该城市为访问过</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; provinces;k++)&#123;               <span class="comment">// 遍历与该城市所有邻接的城市</span></span><br><span class="line">                        <span class="keyword">if</span>(isConnected[j][k] == <span class="number">1</span> &amp;&amp; !visited[k])&#123;  <span class="comment">// 如果可以访问到</span></span><br><span class="line">                            queue.offer(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                circles++;                                          <span class="comment">// 直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n^2)，其中 <em>n</em> 是城市的数量。需要遍历<code>isConnected</code>中的每个元素</li><li>空间复杂度：  O(n)，其中 n 是城市的数量。<ul><li>visited 数组长度不会超过n</li><li>广度优先搜索队列元素不会超过n</li></ul></li></ul><h2 id="方法三-：-并查集"><a href="#方法三-：-并查集" class="headerlink" title="方法三 ： 并查集"></a>方法三 ： 并查集</h2><ul><li>待学习</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[provinces];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; provinces; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    union(parent, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">                circles++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-547-省份数量&quot;&gt;&lt;a href=&quot;#Leetcode-547-省份数量&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-547-省份数量&quot;&gt;&lt;/a&gt;Leetcode-547-&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-provinces/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;省份数量&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给你一个 n x n 的矩阵&lt;code&gt;isConnected&lt;/code&gt;，其中&lt;code&gt;isConnected[i][j] = 1&lt;/code&gt; 表示第 i 个城市和第 j 个城市直接相连，而&lt;code&gt;isConnected[i][j] = 0&lt;/code&gt;表示二者不直接相连。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回矩阵中 省份 的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例一 ：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093358281.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：isConnected &amp;#x3D; [[1,1,0],[1,1,0],[0,0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093431219.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：isConnected &amp;#x3D; [[1,0,0],[0,1,0],[0,0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n &amp;#x3D;&amp;#x3D; isConnected.length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n &amp;#x3D;&amp;#x3D; isConnected[i].length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][j] 为 1 或 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][i] &amp;#x3D;&amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][j] &amp;#x3D;&amp;#x3D; isConnected[j][i]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="BFS" scheme="http://zhuuu.work/tags/BFS/"/>
    
      <category term="DFS" scheme="http://zhuuu.work/tags/DFS/"/>
    
      <category term="并查集" scheme="http://zhuuu.work/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-830-较大分组的位置</title>
    <link href="http://zhuuu.work/2021/01/05/Leetcode/Leetcode-830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://zhuuu.work/2021/01/05/Leetcode/Leetcode-830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-01-05T00:52:53.000Z</published>
    <updated>2021-01-05T01:33:09.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-830-较大分组的位置"><a href="#Leetcode-830-较大分组的位置" class="headerlink" title="Leetcode-830-较大分组的位置"></a>Leetcode-830-较大分组的位置</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p></li><li><p>例如，在字符串<code>s = &quot;abbxxxxzyy&quot;</code>中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p></li><li><p>分组可以用区间 <code>[start, end]</code>表示,其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p></li><li><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p></li><li><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abbxxxxzzy&quot;</span><br><span class="line">输出：[[3,6]]</span><br><span class="line">解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出：[[3,5],[6,9],[12,14]]</span><br><span class="line">解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;aba&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅含小写英文字母</li></ul><a id="more"></a><h2 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();                <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span> n   = s.length();                                       <span class="comment">// 字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;                                                <span class="comment">// 用于记录分组长度 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 一次遍历该字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="comment">// 2.1 如果下一个字符与当前字符不同,或者已经枚举到字符串尾部,就说明当前字符为当前分组的尾部</span></span><br><span class="line">            <span class="keyword">if</span>(i == n - <span class="number">1</span> || s.charAt(i) != s.charAt(i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= <span class="number">3</span>)&#123;                                       <span class="comment">// 如果分组长度达到3</span></span><br><span class="line">                    res.add(Arrays.asList(i - num + <span class="number">1</span>,i));          <span class="comment">// 记录结果</span></span><br><span class="line">                &#125;   </span><br><span class="line">                num = <span class="number">1</span>;                                            <span class="comment">// 重置分组长度</span></span><br><span class="line">            <span class="comment">// 2.2 字符重复的情况</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num++;                                              <span class="comment">// ++字符分区长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回结果集</span></span><br><span class="line">        <span class="keyword">return</span> res;                                                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)</li><li>空间复杂度 ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-830-较大分组的位置&quot;&gt;&lt;a href=&quot;#Leetcode-830-较大分组的位置&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-830-较大分组的位置&quot;&gt;&lt;/a&gt;Leetcode-830-较大分组的位置&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如，在字符串&lt;code&gt;s = &amp;quot;abbxxxxzyy&amp;quot;&lt;/code&gt;中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分组可以用区间 &lt;code&gt;[start, end]&lt;/code&gt;表示,其中 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分别表示该分组的起始和终止位置的下标。上例中的 &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt; 分组用区间表示为 &lt;code&gt;[3,6]&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们称所有包含大于或等于三个连续字符的分组为 &lt;strong&gt;较大分组&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;找到每一个 &lt;strong&gt;较大分组&lt;/strong&gt; 的区间，&lt;strong&gt;按起始位置下标递增顺序排序后&lt;/strong&gt;，返回结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abbxxxxzzy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[3,6]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&amp;quot;xxxx&amp;quot; 是一个起始于 3 且终止于 6 的较大分组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot; 和 &amp;quot;c&amp;quot; 均不是符合要求的较大分组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abcdddeeeeaabbbcd&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[3,5],[6,9],[12,14]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：较大分组为 &amp;quot;ddd&amp;quot;, &amp;quot;eeee&amp;quot; 和 &amp;quot;bbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;aba&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅含小写英文字母&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-509-斐波那契数</title>
    <link href="http://zhuuu.work/2021/01/04/Leetcode/Leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://zhuuu.work/2021/01/04/Leetcode/Leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2021-01-04T00:52:53.000Z</published>
    <updated>2021-01-04T01:19:23.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-509-斐波那契数"><a href="#Leetcode-509-斐波那契数" class="headerlink" title="Leetcode-509-斐波那契数"></a>Leetcode-509-<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路一-：-动态规划"><a href="#思路一-：-动态规划" class="headerlink" title="思路一 ： 动态规划"></a>思路一 ： 动态规划</h2><ul><li><p>斐波那契数的边界条件是 <code>F(0) =0</code> 和 <code>F(1)=1</code>。</p></li><li><p>n&gt;1时，每一项的和都等于前两项的和，因此有如下递推关系：</p><ul><li>​                                            F<em>(</em>n<em>)=*F</em>(<em>n</em>−1)+<em>F</em>(<em>n</em>−2)</li></ul></li></ul><ul><li><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 F(0) 和 F(1)。</p></li><li><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n) 的实现。</p></li><li><p><strong>由于 F(n) 只和 F(n-1)与 F(n-2)有关，因此可以使用「滚动数组思想」把空间复杂度优化成 O(1)。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/085317533.gif" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.初始化变量</span></span><br><span class="line">        <span class="keyword">int</span> dp_a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 3. 滚动数组：动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp_a = dp_b;</span><br><span class="line">            dp_b = dp_i;</span><br><span class="line">            dp_i = dp_a + dp_b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h2 id="思路二-：-数学通项"><a href="#思路二-：-数学通项" class="headerlink" title="思路二 ： 数学通项"></a>思路二 ： 数学通项</h2><ul><li>斐波那契数 F(n)是齐次线性递推，根据递推方程 F(n)=F(n-1)+F(n-2)可以写出这样的特征方程：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/090716393.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/091850906.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt_5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fib_n  = Math.pow((<span class="number">1</span> + sqrt_5)/<span class="number">2</span>,n) - Math.pow((<span class="number">1</span> - sqrt_5)/<span class="number">2</span>,n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.round(fib_n/sqrt_5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>与各个语言的pow 函数有关</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-509-斐波那契数&quot;&gt;&lt;a href=&quot;#Leetcode-509-斐波那契数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-509-斐波那契数&quot;&gt;&lt;/a&gt;Leetcode-509-&lt;a href=&quot;https://leetcode-cn.com/problems/fibonacci-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;斐波那契数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt;，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) &amp;#x3D; 0，F(1) &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(n) &amp;#x3D; F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;给你 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(2) &amp;#x3D; F(1) + F(0) &amp;#x3D; 1 + 0 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(3) &amp;#x3D; F(2) + F(1) &amp;#x3D; 1 + 1 &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(4) &amp;#x3D; F(3) + F(2) &amp;#x3D; 2 + 1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-205-同构字符串</title>
    <link href="http://zhuuu.work/2020/12/27/Leetcode/Leetcode-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/12/27/Leetcode/Leetcode-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-12-27T00:52:53.000Z</published>
    <updated>2021-01-17T02:21:00.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-205-同构字符串"><a href="#Leetcode-205-同构字符串" class="headerlink" title="Leetcode-205-同构字符串"></a>Leetcode-205-<a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">同构字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定两个字符串 <strong><em>s</em></strong> 和 <em>t</em>，判断它们是否是同构的。</li><li>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <em>t</em> ，那么这两个字符串是同构的。</li><li>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">你可以假设 s 和 t 具有相同的长度。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-集合论双射"><a href="#思路-：-集合论双射" class="headerlink" title="思路 ： 集合论双射"></a>思路 ： 集合论双射</h2><ul><li><p>此题是「290. 单词规律」的简化版，</p></li><li><p><strong>需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。</strong></p><ul><li>以示例 2 为例，t 中的字符 a 和 r 虽然有唯一的映射 o，但对于 s 中的字符 o 来说其存在两个映射 {a,r}，故不满足条件。</li></ul></li></ul><ul><li>因此 ， 我们需要维护两张哈希表。<ul><li>第一张哈希表s2t : 以s中的字符为键，t中的字符为值</li><li>第二张哈希表t2s : 以t中的字符为键，s中的字符为值</li></ul></li></ul><p><strong>算法整体</strong></p><ol><li>从左直右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突，说明两个字符无法构成同构，返回false</li><li>如果遍历没有发生冲突，说明两个字符串是同构的 ， 返回true 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Leetcode__205;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringtostring</span><span class="params">(String input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">booleanToString</span><span class="params">(<span class="keyword">boolean</span> input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input?<span class="string">"True"</span>:<span class="string">"False"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String s = stringtostring(line);</span><br><span class="line">            line = in.readLine();</span><br><span class="line">            String t = stringtostring(line);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> ret = <span class="keyword">new</span> Solution().isIsomorphic(s,t);</span><br><span class="line">            String out = booleanToString(ret);</span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化</span></span><br><span class="line">        Map&lt;Character,Character&gt; s2t = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Character&gt; t2s = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            <span class="comment">// 2.1 拿到当前字符做判断</span></span><br><span class="line">            <span class="keyword">char</span> curr_s = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> curr_t = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>((s2t.containsKey(curr_s) &amp;&amp; s2t.get(curr_s) != curr_t) || (t2s.containsKey(curr_t) &amp;&amp; t2s.get(curr_t) != curr_s))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.2 不在map中就放入到map中</span></span><br><span class="line">            s2t.put(curr_s,curr_t);</span><br><span class="line">            t2s.put(curr_t,curr_s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度：O(n)，其中 n 为字符串的长度。</strong>我们只需同时遍历一遍字符串 s和 t 即可。</p></li><li><p><strong>空间复杂度：O(∣Σ∣)，其中 \SigmaΣ 是字符串的字符集。</strong>哈希表存储字符的空间取决于字符串的字符集大小，最坏情况下每个字符均不相同，需要 O(∣Σ∣) 的空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-205-同构字符串&quot;&gt;&lt;a href=&quot;#Leetcode-205-同构字符串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-205-同构字符串&quot;&gt;&lt;/a&gt;Leetcode-205-&lt;a href=&quot;https://leetcode-cn.com/problems/isomorphic-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;同构字符串&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;em&gt;t&lt;/em&gt;，判断它们是否是同构的。&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 中的字符可以被替换得到 &lt;em&gt;t&lt;/em&gt; ，那么这两个字符串是同构的。&lt;/li&gt;
&lt;li&gt;所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;egg&amp;quot;, t &amp;#x3D; &amp;quot;add&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;foo&amp;quot;, t &amp;#x3D; &amp;quot;bar&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;paper&amp;quot;, t &amp;#x3D; &amp;quot;title&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 s 和 t 具有相同的长度。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>单调栈-合集</title>
    <link href="http://zhuuu.work/2020/12/25/LeetcodeExplore/%E5%8D%95%E8%B0%83%E6%A0%88-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/12/25/LeetcodeExplore/%E5%8D%95%E8%B0%83%E6%A0%88-%E5%90%88%E9%9B%86/</id>
    <published>2020-12-25T07:11:53.000Z</published>
    <updated>2020-12-26T02:44:19.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈-合集"><a href="#单调栈-合集" class="headerlink" title="单调栈-合集"></a>单调栈-合集</h1><p>以下列出了单调栈的问题，供大家参考。</p><table><thead><tr><th><strong>序号</strong></th><th><strong>题目</strong></th><th><strong>题解</strong></th></tr></thead><tbody><tr><td>1</td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水（困难）</a></td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/" target="_blank" rel="noopener">暴力解法、优化、双指针、单调栈</a></td></tr><tr><td>2</td><td><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度（中等）</a></td><td><a href="https://leetcode-cn.com/problems/daily-temperatures/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419/" target="_blank" rel="noopener">暴力解法 + 单调栈</a></td></tr><tr><td>3</td><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I（简单）</a></td><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419-2/" target="_blank" rel="noopener">暴力解法、单调栈</a></td></tr><tr><td>4</td><td><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母（困难）</a></td><td><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/zhan-by-liweiwei1419/" target="_blank" rel="noopener">栈 + 哨兵技巧（Java、C++、Python）</a></td></tr><tr><td>5</td><td><a href="https://leetcode-cn.com/problems/online-stock-span/" target="_blank" rel="noopener">901. 股票价格跨度（中等）</a></td><td><a href="https://blog.csdn.net/lw_power/article/details/103957702" target="_blank" rel="noopener"> 「力扣」第 901 题：股票价格跨度（单调栈）</a></td></tr><tr><td>6</td><td><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></td><td></td></tr><tr><td>7</td><td><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></td><td></td></tr><tr><td>8</td><td></td><td></td></tr><tr><td>9</td><td></td><td></td></tr></tbody></table><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单调栈-合集&quot;&gt;&lt;a href=&quot;#单调栈-合集&quot; class=&quot;headerlink&quot; title=&quot;单调栈-合集&quot;&gt;&lt;/a&gt;单调栈-合集&lt;/h1&gt;&lt;p&gt;以下列出了单调栈的问题，供大家参考。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;题解&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;42. 接雨水（困难）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法、优化、双指针、单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;739. 每日温度（中等）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法 + 单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;496. 下一个更大元素 I（简单）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法、单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;316. 去除重复字母（困难）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/solution/zhan-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;栈 + 哨兵技巧（Java、C++、Python）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/online-stock-span/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;901. 股票价格跨度（中等）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://blog.csdn.net/lw_power/article/details/103957702&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 「力扣」第 901 题：股票价格跨度（单调栈）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;402. 移掉K位数字&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;581. 最短无序连续子数组&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://zhuuu.work/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-290-单词规律</title>
    <link href="http://zhuuu.work/2020/12/16/Leetcode/Leetcode-290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/"/>
    <id>http://zhuuu.work/2020/12/16/Leetcode/Leetcode-290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</id>
    <published>2020-12-16T05:52:53.000Z</published>
    <updated>2020-12-16T08:34:44.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-290-单词规律"><a href="#Leetcode-290-单词规律" class="headerlink" title="Leetcode-290-单词规律"></a>Leetcode-290-<a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">单词规律</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p></li><li><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着<strong>双向连接的对应规律</strong>。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;aaaa&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br><span class="line">说明:</span><br><span class="line">你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。</span><br></pre></td></tr></table></figure><p>​    </p><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li><p>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。<strong>在集合论中，这种关系被称为「双射」。</strong></p></li><li><p>想要解决本题，我们可以利用<strong>哈希表记录每一个字符对应的字符串</strong>，<strong>以及每一个字符串对应的字符。</strong></p></li><li><p>然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。</p></li></ul><p><strong>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。</strong></p><p><strong>每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Character&gt; str2ch = <span class="keyword">new</span> HashMap&lt;&gt;();         <span class="comment">// 字符串映射字符</span></span><br><span class="line">        Map&lt;Character,String&gt; ch2str = <span class="keyword">new</span> HashMap&lt;&gt;();         <span class="comment">// 字符映射字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m   = s.length();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;                                            <span class="comment">// idx 用于记录每个单词的开头位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举pattern中的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>;p &lt; pattern.length();++p)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern.charAt(p);                                <span class="comment">// 枚举pattern中的每一个字符</span></span><br><span class="line">            <span class="keyword">if</span>(idx &gt;= m)&#123;                                               <span class="comment">// 说明字符和对应字符串的数量不匹配，直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理空格之间的字符串单词</span></span><br><span class="line">            <span class="keyword">int</span> j = idx;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; m &amp;&amp; s.charAt(j) != <span class="string">' '</span>)&#123;                         <span class="comment">// j用于记录每个字符串单词的结束位置</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            String temp = s.substring(idx,j);                           <span class="comment">// 拿出空格之间的这个单词</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 离散数学：集合的双射匹配</span></span><br><span class="line">            <span class="keyword">if</span>(str2ch.containsKey(temp) &amp;&amp; str2ch.get(temp) != ch)&#123;     <span class="comment">// 字符串不匹配字符直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch2str.containsKey(ch) &amp;&amp; !temp.equals(ch2str.get(ch)))&#123; <span class="comment">// 字符不匹配字符串直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不在哈希表中 就加入到哈希表中 并且进入下一轮字符匹配</span></span><br><span class="line">            str2ch.put(temp,ch);</span><br><span class="line">            ch2str.put(ch,temp);</span><br><span class="line">            idx = j + <span class="number">1</span>;            <span class="comment">// 从下一个单词的开头进行匹配 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配到结束都满足条件（idx = j + 1）</span></span><br><span class="line">        <span class="keyword">return</span> idx &gt; m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong> ： O(n + m)。 其中 n 是pattern的长度 , m是str 的长度。每个字符至多只被遍历一次，插入和查询哈希表的均摊时间复杂度为O(n + m)</li><li><strong>空间复杂度</strong> ： O(n + m) 。其中 n 是pattern的长度 , m是str 的长度。最坏情况下，我们需要存储pattern的每一个字符和str中的每一个字符串</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-290-单词规律&quot;&gt;&lt;a href=&quot;#Leetcode-290-单词规律&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-290-单词规律&quot;&gt;&lt;/a&gt;Leetcode-290-&lt;a href=&quot;https://leetcode-cn.com/problems/word-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词规律&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着&lt;strong&gt;双向连接的对应规律&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat fish&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;aaaa&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog dog dog dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;​    &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>排序-04-基数排序</title>
    <link href="http://zhuuu.work/2020/12/13/Sort/%E6%8E%92%E5%BA%8F-04-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/12/13/Sort/%E6%8E%92%E5%BA%8F-04-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-12-13T10:33:24.000Z</published>
    <updated>2020-12-13T08:34:19.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-04-基数排序"><a href="#排序-04-基数排序" class="headerlink" title="排序-04-基数排序"></a>排序-04-基数排序</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-04-基数排序&quot;&gt;&lt;a href=&quot;#排序-04-基数排序&quot; class=&quot;headerlink&quot; title=&quot;排序-04-基数排序&quot;&gt;&lt;/a&gt;排序-04-基数排序&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-376-摆动序列</title>
    <link href="http://zhuuu.work/2020/12/12/Leetcode/Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <id>http://zhuuu.work/2020/12/12/Leetcode/Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-12T01:52:53.000Z</published>
    <updated>2020-12-12T02:29:42.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-376-摆动序列"><a href="#Leetcode-376-摆动序列" class="headerlink" title="Leetcode-376-摆动序列"></a>Leetcode-376-<a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">摆动序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p><strong>如果连续数字之间的差严格地在正数和负数之间交替</strong>，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p></li><li><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反,<code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p></li><li><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 <strong>通过从原始序列中删除一些（也可以不删除）元素来获得子序列</strong>，剩下的元素保持其原始顺序。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题?</p><a id="more"></a><h2 id="算法思路-：-贪心算法"><a href="#算法思路-：-贪心算法" class="headerlink" title="算法思路 ： 贪心算法"></a>算法思路 ： 贪心算法</h2><ul><li><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p></li><li><p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p></li></ul><p>用示例二来举例，如图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201212/092659036.png" alt="mark"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p><p>（为方便表述，以下说的峰值都是指局部峰值）</p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong>。</p><ul><li>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</li><li>例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</li><li>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即<code>preDiff = 0</code>，如图：<ul><li>此时<code>curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0</code>，那么<code>result++</code></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201212/092926932.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 长度为1的都是摆动序列</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 初始化</span></span><br><span class="line">        <span class="keyword">int</span> prevdiff = nums[<span class="number">1</span>] - nums[<span class="number">0</span>];        <span class="comment">// 记录相邻三个元素 x y z(x 和 y 的差是正还是负)</span></span><br><span class="line">        <span class="keyword">int</span> ret = prevdiff != <span class="number">0</span>?<span class="number">2</span>:<span class="number">1</span>;             <span class="comment">// 前两个元素是否有重复（产生了坡度）</span></span><br><span class="line">        <span class="comment">// 3. 贪心遍历数组:加入一个新元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];   <span class="comment">// 记录相邻三个元素 x y z(y 和 z 的差是正还是负)</span></span><br><span class="line">            <span class="keyword">if</span>((diff &gt; <span class="number">0</span> &amp;&amp; prevdiff &lt;= <span class="number">0</span>) || (diff &lt; <span class="number">0</span> &amp;&amp; prevdiff &gt;= <span class="number">0</span>))&#123;  <span class="comment">// 如果出现了峰或者谷</span></span><br><span class="line">                ret++;                          <span class="comment">// 如果出现了「峰」或「谷」，答案加一</span></span><br><span class="line">                prevdiff = diff;                <span class="comment">// 更新当前序列的上升下降趋势</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-376-摆动序列&quot;&gt;&lt;a href=&quot;#Leetcode-376-摆动序列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-376-摆动序列&quot;&gt;&lt;/a&gt;Leetcode-376-&lt;a href=&quot;https://leetcode-cn.com/problems/wiggle-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摆动序列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如果连续数字之间的差严格地在正数和负数之间交替&lt;/strong&gt;，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如， &lt;code&gt;[1,7,4,9,2,5]&lt;/code&gt; 是一个摆动序列，因为差值 &lt;code&gt;(6,-3,5,-7,3)&lt;/code&gt; 是正负交替出现的。相反,&lt;code&gt;[1,4,7,2,5]&lt;/code&gt; 和 &lt;code&gt;[1,7,4,5,5]&lt;/code&gt; 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定一个整数序列，返回作为摆动序列的最长子序列的长度。 &lt;strong&gt;通过从原始序列中删除一些（也可以不删除）元素来获得子序列&lt;/strong&gt;，剩下的元素保持其原始顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,7,4,9,2,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 整个序列均为摆动序列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,17,5,10,13,15,10,5,16,8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,4,5,6,7,8,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;br&gt;你能否用 O(&lt;em&gt;n&lt;/em&gt;) 时间复杂度完成此题?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-649-Dota2参议院</title>
    <link href="http://zhuuu.work/2020/12/11/Leetcode/Leetcode-649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
    <id>http://zhuuu.work/2020/12/11/Leetcode/Leetcode-649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/</id>
    <published>2020-12-11T07:52:53.000Z</published>
    <updated>2020-12-11T02:12:43.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-649-Dota2-参议院"><a href="#Leetcode-649-Dota2-参议院" class="headerlink" title="Leetcode-649-Dota2 参议院"></a>Leetcode-649-<a href="https://leetcode-cn.com/problems/dota2-senate/" target="_blank" rel="noopener">Dota2 参议院</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><ul><li><p>禁止一名参议员的权利：</p></li><li><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p></li></ul><p>宣布胜利：</p><pre><code>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</code></pre><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p><strong>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</strong></p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 <code>Dota2</code>游戏中决定改变。输出应该是 <code>Radiant</code> 或 <code>Dire</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：&quot;RD&quot;</span><br><span class="line">输出：&quot;Radiant&quot;</span><br><span class="line">解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：&quot;RDD&quot;</span><br><span class="line">输出：&quot;Dire&quot;</span><br><span class="line">解释：</span><br><span class="line">第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span><br><span class="line">第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止</span><br><span class="line">第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span><br><span class="line">因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定字符串的长度在 <code>[1, 10,000]</code> 之间.</li></ul><a id="more"></a><h2 id="算法思路-循环队列"><a href="#算法思路-循环队列" class="headerlink" title="算法思路 : 循环队列"></a>算法思路 : 循环队列</h2><ul><li>我们以天辉方的议员为例。当一名天辉方的议员行使权利时：<ul><li>如果目前所有的议员都为天辉方，那么该议员可以直接宣布天辉方取得胜利；</li><li>如果目前仍然有夜魇方的议员，那么这名天辉方的议员只能行使「禁止一名参议员的权利」这一项权利。<ul><li>显然，该议员不会令一名同为天辉方的议员丧失权利，所以他一定会挑选一名夜魇方的议员。那么应该挑选哪一名议员呢？</li><li>容易想到的是，<strong>应该贪心地挑选按照投票顺序的下一名夜魇方的议员</strong>。</li><li>这也是很容易形象化证明的：既然只能挑选<strong>一名</strong>夜魇方的议员，那么就应该挑最早可以进行投票的那一名议员；</li><li>如果挑选了其它较晚投票的议员，那么等到最早可以进行投票的那一名议员行使权利时，一名天辉方议员就会丧失权利，这样就得不偿失了。</li></ul></li></ul></li></ul><p><strong>具体算法</strong></p><ul><li>由于我们总要挑选投票顺序最早的议员 ，因此我们可以使用两个队列<code>radiant</code> 和 <code>dire</code> 分别按照投票顺序存储天辉方和夜魇方每一名议员的投票时间</li><li>随后我们就可以开始模拟整个投票的过程：<ul><li><strong>如果此时 队列<code>radiant</code> 或者 <code>dire</code> 为空</strong>，那么就可以宣布另一方获得胜利；</li><li><strong>如果此时队列不为空</strong> ： 那么比较这两个队列的首元素，就可以确定当前行使权利的是哪一名议员<ul><li><strong>如果 <em>radiant</em> 的首元素较小，</strong>那说明轮到天辉方的议员行使权利，其会挑选 <em>dire</em> 的首元素对应的那一名议员</li><li><strong>因此，我们会将 <em>dire</em> 的首元素永久地弹出</strong></li><li><strong>并将 <em>radiant</em> 的首元素弹出，增加 <em>n</em> 之后再重新放回队列</strong></li><li>这里 n 是给给定字符串 senate 的长度,即表示该议员因为没有被ban掉所以参加了下一轮投票</li><li>同理 ： 如果dire 首元素较小,那么会永久的弹出 <code>radiant  的首元素，剩余的处理方法也是一样的</code></li></ul></li></ul></li></ul><blockquote><p>为什么这里是固定地增加 n，而不是增加与当前剩余议员数量相关的一个数？</p></blockquote><p>这样一来，我们就模拟了整个投票的过程，也就可以得到最终的答案了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">predictPartyVictory</span><span class="params">(String senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = senate.length();</span><br><span class="line">        Queue&lt;Integer&gt; radiant = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; dire    = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历数组 记录下每个阵营议员的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(senate.charAt(i) == <span class="string">'R'</span>)&#123;</span><br><span class="line">                radiant.offer(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dire.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果两个队列都不空的情况下</span></span><br><span class="line">        <span class="keyword">while</span>(!radiant.isEmpty() &amp;&amp; !dire.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> radiantIndex = radiant.poll();      <span class="comment">// radiant的第一名议员 暂时弹出</span></span><br><span class="line">            <span class="keyword">int</span> direIndex    = dire.poll();         <span class="comment">// dire 的第一名议员   暂时弹出</span></span><br><span class="line">            <span class="keyword">if</span>(radiantIndex &lt; direIndex)&#123;           <span class="comment">// 如果radiant第一名议员首元素较小</span></span><br><span class="line">                radiant.offer(radiantIndex + n);    <span class="comment">// 暂时弹出 +n之后重新放回队列 对应dire第一名议员永久弹出</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                     <span class="comment">// 加上n后，可以保证这个议员只会参加下一轮，或者被上一轮的对手干掉。</span></span><br><span class="line">                dire.offer(direIndex + n);          <span class="comment">// 暂时弹出 +n之后重新放回队列 对应radiant第一名议员永久弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 宣布胜利</span></span><br><span class="line">        <span class="keyword">return</span> !radiant.isEmpty()?<span class="string">"Radiant"</span>:<span class="string">"Dire"</span>; <span class="comment">// 最后非空的队列宣布胜利</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ：</strong> O(n)   其中 <code>n</code> 是字符串<code>senate</code> 的长度。在模拟整个投票过程的每一步，我们进行的操作的时间复杂度均为<code>O(1)</code>，并且会弹出一名天辉方或夜魇方的议员。由于议员的数量为 n，因此模拟的步数不会超过 n，时间复杂度即为 O(n)。</li><li><strong>空间复杂度</strong> ： O(n)   队列所需要的复杂度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-649-Dota2-参议院&quot;&gt;&lt;a href=&quot;#Leetcode-649-Dota2-参议院&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-649-Dota2 参议院&quot;&gt;&lt;/a&gt;Leetcode-649-&lt;a href=&quot;https://leetcode-cn.com/problems/dota2-senate/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dota2 参议院&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)&lt;/p&gt;
&lt;p&gt;Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;禁止一名参议员的权利：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宣布胜利：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 &lt;code&gt;Dota2&lt;/code&gt;游戏中决定改变。输出应该是 &lt;code&gt;Radiant&lt;/code&gt; 或 &lt;code&gt;Dire&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;RD&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;Radiant&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;RDD&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;Dire&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定字符串的长度在 &lt;code&gt;[1, 10,000]&lt;/code&gt; 之间.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-860-柠檬水找零</title>
    <link href="http://zhuuu.work/2020/12/10/Leetcode/Leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>http://zhuuu.work/2020/12/10/Leetcode/Leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2020-12-10T02:52:53.000Z</published>
    <updated>2020-12-10T01:27:30.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-860-柠檬水找零"><a href="#Leetcode-860-柠檬水找零" class="headerlink" title="Leetcode-860-柠檬水找零"></a>Leetcode-860-<a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">柠檬水找零</a></h1><h2 id="思路：贪心算法"><a href="#思路：贪心算法" class="headerlink" title="思路：贪心算法"></a>思路：贪心算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p></li><li><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p></li><li><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p></li></ul><p>  注意，一开始你手头没有任何零钱。</p><p>  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">3</span> 位顾客那里，我们按顺序收取 <span class="number">3</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">第 <span class="number">4</span> 位顾客那里，我们收取一张 <span class="number">10</span> 美元的钞票，并返还 <span class="number">5</span> 美元。</span><br><span class="line">第 <span class="number">5</span> 位顾客那里，我们找还一张 <span class="number">10</span> 美元的钞票和一张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 <span class="keyword">true</span>。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">2</span> 位顾客那里，我们按顺序收取 <span class="number">2</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">对于接下来的 <span class="number">2</span> 位顾客，我们收取一张 <span class="number">10</span> 美元的钞票，然后返还 <span class="number">5</span> 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 <span class="number">15</span> 美元，因为我们现在只有两张 <span class="number">10</span> 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 <span class="keyword">false</span>。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路：贪心-模拟（CRUD）"><a href="#算法思路：贪心-模拟（CRUD）" class="headerlink" title="算法思路：贪心 + 模拟（CRUD）"></a>算法思路：贪心 + 模拟（CRUD）</h2><p>由于顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票的面值只可能是 5 美元，10美元和 20 美元三种。基于此，我们可以进行如下的分类讨论。</p><ol><li><strong>5 美元</strong>，由于柠檬水的价格也为 5美元，因此我们直接收下即可</li><li><strong>10 美元，我们需要找回 5 美元</strong>，如果没有 5 美元面值的钞票，则无法正确找零。</li><li><strong>20 美元，我们需要找回 15 美元</strong>，此时有<strong>两种组合方式</strong><ul><li>一种是一张 10 美元和 5 美元的钞票</li><li>一种是 3 张  5 美元的钞票</li><li>如果两种组合方式都没有，则无法正确找零</li></ul></li></ol><ol start="4"><li><strong>对于情况三的找零方式 ：</strong> <ul><li>当可以正确找零时，两种找零的方式中我们更倾向于第一种</li><li>即如果存在5美元和10美元 我们就按照第一种方式找零</li><li>否则按照第二种情况找零，这样的目的是尽可以保留5美元的钞票</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  遍历所有的数组元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> bill:bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bill == <span class="number">5</span>)&#123;          <span class="comment">// 如果发现是五块钱，直接收了</span></span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bill == <span class="number">10</span>)&#123;   <span class="comment">// 如果发现是10块钱</span></span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>)&#123;      <span class="comment">// 如果没有钱来找零了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                  <span class="comment">// 如果账单是20块钱</span></span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>)&#123;    <span class="comment">// 1. 首先判断10块和5块的组合够不够找钱</span></span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>)&#123;        <span class="comment">// 2. 不够的话就用3张5块钱去找零</span></span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 3. 都没有零钱可找了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以找零的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong> ： O（N） 遍历一遍数组所需要的时间</li><li><strong>空间复杂度</strong>  ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-860-柠檬水找零&quot;&gt;&lt;a href=&quot;#Leetcode-860-柠檬水找零&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-860-柠檬水找零&quot;&gt;&lt;/a&gt;Leetcode-860-&lt;a href=&quot;https://leetcode-cn.com/problems/lemonade-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;柠檬水找零&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：贪心算法&quot;&gt;&lt;a href=&quot;#思路：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;思路：贪心算法&quot;&gt;&lt;/a&gt;思路：贪心算法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 5 美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 位顾客那里，我们按顺序收取 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 位顾客那里，我们收取一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票，并返还 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 位顾客那里，我们找还一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票和一张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于所有客户都得到了正确的找零，所以我们输出 &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 位顾客那里，我们按顺序收取 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于接下来的 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 位顾客，我们收取一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票，然后返还 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于最后一位顾客，我们无法退回 &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; 美元，因为我们现在只有两张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于不是每位顾客都得到了正确的找零，所以答案是 &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学-伽马修正</title>
    <link href="http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E4%BC%BD%E9%A9%AC%E4%BF%AE%E6%AD%A3/"/>
    <id>http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E4%BC%BD%E9%A9%AC%E4%BF%AE%E6%AD%A3/</id>
    <published>2020-12-09T09:38:38.000Z</published>
    <updated>2020-12-09T09:04:02.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-伽马修正"><a href="#图像学-伽马修正" class="headerlink" title="图像学-伽马修正"></a>图像学-伽马修正</h1><h1 id="计算机图形学-伽马修正"><a href="#计算机图形学-伽马修正" class="headerlink" title="计算机图形学-伽马修正"></a>计算机图形学-伽马修正</h1><p><strong>起因：</strong> [][][一个伽马矫正的视频][<a href="https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]</a></p><p><strong>答案 ：</strong> [一个知乎答案][<a href="https://www.zhihu.com/question/27467127]" target="_blank" rel="noopener">https://www.zhihu.com/question/27467127]</a></p><p><strong>参考博客 ：</strong> [博客地址][<a href="http://hanshilin.com/blog/gamma-and-linear-workflow/]" target="_blank" rel="noopener">http://hanshilin.com/blog/gamma-and-linear-workflow/]</a></p><a id="more"></a><h2 id="1-韦伯-费希纳定律"><a href="#1-韦伯-费希纳定律" class="headerlink" title="1. 韦伯-费希纳定律"></a>1. 韦伯-费希纳定律</h2><ul><li>最早见到韦伯定律的时候，以为就是个非常简单的式子：△I/I=K，△I是差别阈限；I是刺激强度；K是韦伯常数</li><li>根据刺激的不同，受试的不同，其值不同，但对于同一个被试在同等条件下进行同类型的刺激，该值为常数。</li><li>意思是，刺激强度I和在该刺激强度下引起最小可觉差所需要的刺激强度呈正比。例如，假设手里拿一个重量为10g的物体，若增加1g能让你恰好感觉到它的重量产生了变化（增加的重量低于1g你便不能感觉到重量发生了改变），那么如果手里拿一个重量为100g的物体，则需要增加其重量10g才能让你恰好感觉到重量发生了变化。</li></ul><p><strong>费希纳则在韦伯的基础上作出这样一个假设</strong>：</p><ul><li><strong>恰好引起感觉变化的刺激强度变化所引起的感觉变化是相等的。</strong>以上面那个例子为例，<ul><li>意思是，对于给10g物体增加1g所引起的你感觉变化与给100g物体增加10g所引起的你的感觉变化是一样的，都是1个单位的感觉变化。</li><li>换言之，你左手拿11g物体右手拿10g物体，你感觉左手比右手重”一些“；你左手拿110g物体右手拿100g物体，感觉左手比右手重”一些“，这两个”一些“的程度是一样的。 </li></ul></li></ul><ul><li>在这个假设的基础上，费希纳总结出公式：△P = k * △S/S         </li><li>根据该公式，若在某初始刺激为S的条件下，进行强度为10倍最小可觉差的刺激，则相应的感觉变化也应当变成10倍。比如给10g物体增加1g重量刚好能感觉到重量发生了改变，主观感觉变化量为△p；</li></ul><ul><li>虽然这个公式有一部分与韦伯定律的公式非常相似，但意义并不相同：<ul><li>在韦伯定律那里， △I/I=K指的是“当前刺激强度下的最小可觉差”与”当前刺激强度“的关系， △I与I均为变量。</li><li>而关系式△P = k * △S/S 则指示了在初始刺激强度为S时，刺激变化量△S与主观感觉变化量△P的关系。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">将上式改写成微分式，则有dP &#x3D; k * dS &#x2F; S</span><br><span class="line">   </span><br><span class="line">      对该式两侧同时进行积分：</span><br><span class="line">       ∫ dP  &#x3D; P &#x3D;  ∫ k&#x2F;S * dS  &#x3D;  k*lnS + C</span><br><span class="line">      </span><br><span class="line">      得到了主观感觉量P与刺激强度S的关系式：</span><br><span class="line">      P &#x3D; k*lnS + C</span><br><span class="line"></span><br><span class="line">      为消除积分常数C，令P&#x3D;0，有C &#x3D; -k*lns, s是绝对阈限。</span><br><span class="line"></span><br><span class="line">      可得：</span><br><span class="line">      P &#x3D; k * (lnS - lns)</span><br><span class="line">     </span><br><span class="line">     设绝对阈限为单位1，则lns &#x3D;0，</span><br><span class="line"></span><br><span class="line">     故可改写为P &#x3D;k *lnS &#x3D; k*(lgS&#x2F;lge) &#x3D; k&#x2F;lge * lgS  </span><br><span class="line">                         &#x3D; K * lgS</span><br><span class="line"></span><br><span class="line">     得到费希纳定律的公式。</span><br><span class="line"></span><br><span class="line">     若某振幅为10个单位的音波引起的声音的主观感觉量为1，如果把该音波的振幅扩大到100个单位，则声音的主观感觉量仅增加1。换言之，根据费希纳定律，若要感觉强度呈线性增长，则刺激强度需要呈几何倍数增长。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>[知乎另外一个答案][<a href="https://www.zhihu.com/question/314657948?sort=created]" target="_blank" rel="noopener">https://www.zhihu.com/question/314657948?sort=created]</a></p><p><strong>参考博客 ：</strong> </p><p><a href="https://www.douban.com/note/506270934/" target="_blank" rel="noopener">https://www.douban.com/note/506270934/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-伽马修正&quot;&gt;&lt;a href=&quot;#图像学-伽马修正&quot; class=&quot;headerlink&quot; title=&quot;图像学-伽马修正&quot;&gt;&lt;/a&gt;图像学-伽马修正&lt;/h1&gt;&lt;h1 id=&quot;计算机图形学-伽马修正&quot;&gt;&lt;a href=&quot;#计算机图形学-伽马修正&quot; class=&quot;headerlink&quot; title=&quot;计算机图形学-伽马修正&quot;&gt;&lt;/a&gt;计算机图形学-伽马修正&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;起因：&lt;/strong&gt; [][][一个伽马矫正的视频][&lt;a href=&quot;https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案 ：&lt;/strong&gt; [一个知乎答案][&lt;a href=&quot;https://www.zhihu.com/question/27467127]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/27467127]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考博客 ：&lt;/strong&gt; [博客地址][&lt;a href=&quot;http://hanshilin.com/blog/gamma-and-linear-workflow/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hanshilin.com/blog/gamma-and-linear-workflow/]&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>图像学-色彩空间</title>
    <link href="http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/</id>
    <published>2020-12-09T09:38:38.000Z</published>
    <updated>2021-01-10T08:44:38.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-色彩空间"><a href="#图像学-色彩空间" class="headerlink" title="图像学-色彩空间"></a>图像学-色彩空间</h1><ul><li>作为摄影师，你是不是遇到过这样的问题：相机设置里的色彩空间是什么意思？ sRGB 和 Adobe RGB 有什么不同？为什么我的图片在 Photoshop 里看着好好的，一保存发布到网上色彩就变了？</li><li>本篇文章将分为几个部分。首先从几个实验规律出发，借助线性代数相关的概念，定义色彩空间，然后介绍并推导几个重要的色彩空间之间的关系。</li></ul><a id="more"></a><h2 id="1-实验基础"><a href="#1-实验基础" class="headerlink" title="1. 实验基础"></a>1. 实验基础</h2><ul><li><p>相信大家都熟悉「三原色」理论，也知道现代显示器是按照 RGB 模式来显示色彩，不知道有没有想过，为什么是「三原色」？为什么是「三」这个数字？为什么一定要选择 RGB 红绿蓝三种颜色作为原色呢？选其他行不行？用四种颜色行不行？</p></li><li><p>知乎上有个问题 <a href="https://www.zhihu.com/question/24886171" target="_blank" rel="noopener">红绿蓝三色是（唯一的）正交基吗？</a> 就提出了这个疑问</p></li><li><p>追根溯源的话，得从我们人类的<strong>视网膜说起。大部分人类的视网膜上有三种感知颜色的感光细胞，叫做视锥细胞，分别对不同波长的光线敏感，称为 L/M/S 型细胞</strong>。三种视锥细胞最敏感的波长分别是橙红色（长波，Long），绿色（中波，Medium），蓝色（短波，Short）。这三种视锥细胞的归一化感光曲线如下图所示（图片数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk/">CVLR</a> ）</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/154904307.png" alt="mark"></p><hr><p>可以看到 L 型视锥细胞与 M 型视锥细胞的感光曲线差别很小，实际上这两种视锥细胞起源于一次基因变异，在这之前人类可都是红绿色盲呢，多亏这个基因变异，让人类可以看到更加多彩的世界——这又是一个庞大的话题了，就此打住。</p><p>总之，大自然的这千千万万种颜色，在人类的眼里看到，最后传送到大脑里的信号，就只有这三种视锥细胞的电信号而已。根据这三种电信号的强弱，大脑解读成了不同的颜色。这就是三原色理论的生物学依据。</p><hr><ul><li><p>不仅如此，人类眼睛对不同颜色光线混合的反应还是 <strong>线性</strong> 的。</p></li><li><p>根据 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Grassmann%27s_law_(optics)">格拉斯曼定律（Grassmann’s Law）</a>，两束不同颜色的光 <img src="https://www.zhihu.com/equation?tex=C_1" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=C_2" alt="[公式]">，假设某个视锥细胞对他们的反应分别是 <img src="https://www.zhihu.com/equation?tex=r_1" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=r_2" alt="[公式]">，现在将他们按照一个比例混合，得到第三种颜色 <img src="https://www.zhihu.com/equation?tex=C_3+%3D+%5Calpha+C_1+%2B+%5Cbeta+C_2" alt="[公式]">，那么视锥细胞对这个混合颜色的反应也将是前两个反应的线性叠加 <img src="https://www.zhihu.com/equation?tex=r_3+%3D+%5Calpha+r_1+%2B+%0A%5Cbeta+r_2" alt="[公式]">。</p></li><li><p>格拉斯曼定律是一个实验规律，并没有物理或者生物学上的依据。然而这个规律大大简化了我们对人类彩色视觉系统的建模，并且给我们使用线性代数理论分析人类彩色视觉系统提供了一个前提和基础。</p></li></ul><h2 id="2-色匹配函数"><a href="#2-色匹配函数" class="headerlink" title="2. 色匹配函数"></a>2. 色匹配函数</h2><ul><li>前面已经提到，人类视网膜上有三种感知色彩的视锥细胞，所以理论上我们用三种颜色的光就可以混合出自然界中任何一种颜色来。</li><li>在 20 世纪 20 年代，David Wright 和 John Guild 各自独立地领导了一些实验，通过三种颜色的光源进行匹配，得到了人眼对于不同颜色光的匹配函数。此后，多名科学家多次进行了类似的实验，加深了我们对人类彩色视觉的认识。</li></ul><p>实验过程大致是这样的，把一个屏幕用不透光的挡板分割成两个区域，左边照射某个被测试的颜色的光线，这里记为<img src="https://www.zhihu.com/equation?tex=C" alt="[公式]"> （以下用大写字母表明颜色，用小写字母表明分量大小），右边同时用三种颜色的光同时照射，这里记为<img src="https://www.zhihu.com/equation?tex=R" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=G" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=B" alt="[公式]">)。然后，调节右边三种颜色光源的强度，直到左右两边的颜色看上去一样为止。假设这个时候三种颜色的光源强度分别为<img src="https://www.zhihu.com/equation?tex=r" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=g" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=b" alt="[公式]">，那么根据光色叠加的线性性质，我们可以写出</p><p><img src="https://www.zhihu.com/equation?tex=C+%3D+rR+%2B+gG+%2B+bB" alt="[公式]"></p><p>也就是说，只要按照 (r,g,b) 的分量来混合 (R,G,B) 三种颜色的光，就可以得到 C 这个颜色的光。</p><hr><ul><li><p>于是在这一系列实验里，科学家们把左边的颜色按着光谱顺序，挨个测试了一遍，得到了纯光谱色的混合叠加的数据，这就是 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/CIE_1931_color_space%23/Color_matching_functions">色匹配函数（Color Matching Function）</a> ，并且在这个基准下定义的色彩空间，就是 CIE RGB 色彩空间。</p></li><li><p>图是 CIE RGB 的色匹配函数曲线，数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk">CVLR</a>。浅色的细线代表实验中不同参与者个人的色匹配函数曲线，中间深色的粗线代表数据的平均值。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/161352290.png" alt="mark"></p><ul><li><p>可以看到，曲线上出现了负数，这是怎么回事？</p><ul><li>回想一下前面描述的实验过程，左边是被测试的光色，右边是可调节的三色光的混合。如果碰到一种情况，右边三色光无论如何调节比例，都不能混合出左边的颜色</li><li>比如某种颜色的光强度已经减小为 0 了，然而看趋势还需要继续减小才能与左边的光色相匹配，怎么办？</li><li>这时候需要往左边的光色中混入三色光中的一种或者几种，继续调节，直到两边的颜色匹配。</li><li>在左边（被测试）的色光中添加，那就是相当于在右边的混合光中减去，这就导致了色匹配函数曲线上出现了负数。实际上，这相当于就是光线的「减法」了。</li></ul></li><li><p>比如，对于 555nm 的黄色光，色匹配函数的值是 (1.30, 0.97, -0.01)，意味着将 1.30 份的红光与 0.97 份的绿光混合放在右边，左边放上 1 份的 555nm 的黄光，以及 0.01 份的蓝光，这样左右两边的光色看上去就一样了。</p></li></ul><hr><ul><li>因为有部分出现了负数，在使用和计算上都有不方便，因此就对这个匹配函数进行了一下线性变换，变换到一个所有分量都是正的空间中。</li><li>变换后的色彩空间就是 CIE XYZ 色彩空间。 图片数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk">CVLR</a>，</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/161910992.png" alt="mark"></p><ul><li>CIE RGB 色彩空间和 CIE XYZ 色彩空间是完全等价的，两者只是差了一个线性变换。由于允许「减法」的存在，因此 CIE RGB 空间是能够表示所有颜色的；同样的，CIE XYZ 空间也能。</li></ul><h2 id="3-从线性空间的角度理解色彩空间"><a href="#3-从线性空间的角度理解色彩空间" class="headerlink" title="3. 从线性空间的角度理解色彩空间"></a>3. 从线性空间的角度理解色彩空间</h2><ul><li>以上的实验基础提示我们，色彩空间和线性代数中的线性空间之间具有某种相似性。我们可以看到，由于人类有三种感知色彩的视锥细胞，自然界千千万万的色彩被眼睛接收后，可以用三个数值来表征。</li><li>而格拉斯曼定律也揭示了色彩叠加的线性性质。<strong>这似乎意味着，色彩空间就是一个 3 维的线性空间。事实上也的确如此</strong>（详细的论证参见末尾小节）。</li></ul><hr><ul><li><p>自然界本身是没有「颜色」这个属性的，只有对不同波长光线的反射率/透过率，到达人眼中的，显然是一个连续的光谱分布函数。数学上，这是一个无穷维的函数空间（巴拿赫空间）。</p><ul><li>而人眼内的三种视锥细胞，它们的感光特性曲线相当于是在这个无穷维的函数空间中建立了三个基底。任何一个光谱分布进来，三种视锥细胞被激发。由于色视觉响应的线性性，这一过程相当于光谱分布函数与三个基底做内积，或者说，「投影」到这三个基底上。</li></ul></li><li><p><strong>从这个观点看，人类的色视觉，是相当于在自然界所有颜色的无穷维函数空间中取了一个三维的投影。这个三维空间的基底，既可以是视锥细胞的感光特性曲线（我们的大脑就用的是这套），当然也可以是选取三种颜色的光进行组合（CIE RGB 空间），甚至还可以是用实际中不存在的「光线」进行组合 （CIE XYZ 空间）。</strong></p><ul><li><strong>既然这几个空间实际上是同一个线性空间，只不过由于选择了不同的基底而有不同的表达形式，那么根据线性代数的结论，这几个空间的表述形式之间，只需要通过矩阵乘法就可以完成转换，这是完全的线性变换。</strong></li><li>当然，色彩空间并不是真正数学意义上的三维线性空间。由于不存在真正数学意义的「减法」，在实际应用中是有所限制的。数学中的「线性组合」在这里就要被替换为「锥组合」，也就是每个分量都必须是大于等于 0 的。</li></ul></li></ul><hr><ul><li>至此我们终于可以回答开头的部分问题了，<strong>为什么是三原色？因为人类对色彩的感知结果位于一个三维的线性空间中。最少需要三种颜色的光才能有足够的表达能力来表现各种颜色。</strong></li><li>为什么选 RGB 作为三原色？因为色彩空间不是真正数学意义上的线性空间，从工程角度考虑，以 RGB 作为三原色，能让显示器能够显示更多的颜色（此外，最初测试人眼对 RGB 三色光的色匹配曲线，也是希望能尽量单独地刺激三种视锥细胞）。</li></ul><h2 id="4-设备相关的RGB色彩空间"><a href="#4-设备相关的RGB色彩空间" class="headerlink" title="4. 设备相关的RGB色彩空间"></a>4. 设备相关的RGB色彩空间</h2><ul><li><p>如前文所述，色彩空间的基底的选择有一定的任意性。事实上，如果允许真正的减法存在，那么选择哪三种颜色作为基底是无关紧要的。不过由于实际中我们不能对色光采用减法，只能使用「锥组合」而非「线性组合」，这时候到底如何选取基底就显得重要了。好的基底不仅能表达的颜色更丰富，而且工程上也易于稳定地实现。</p></li><li><p>由于 CIE XYZ 空间是一个很方便的线性空间，与具体设备无关，因此常用来做各种颜色空间转换的中间媒介。设想某个颜色的光，经过色匹配函数的计算，得到了三个 XYZ 的值，如果直接将这三个值作为 RGB 颜色显示到屏幕上，显然是不对的。我们必须把 XYZ 的值转换到屏幕的 RGB 空间中的值。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A++++++++R_%7B%5Ctext%7Blin%7D%7D+%5C%5C+G_%7B%5Ctext%7Blin%7D%7D+%5C%5C+B_%7B%5Ctext%7Blin%7D%7D%0A++++%5Cend%7Barray%7D%5Cright%5D+%3D+%0A++++%5Cboldsymbol%7BM%7D%0A++++%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A++++++++X+%5C%5C+Y+%5C%5C+Z%0A++++%5Cend%7Barray%7D%5Cright%5D" alt="[公式]"></p></li></ul><p>这里下标 lin 代表线性空间，<img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7BM%7D" alt="[公式]"> 是转换矩阵。得到线性 RGB 空间的表达之后，还需要经过 gamma 校正，才是最终在屏幕上显示的 RGB 的值。一般的 gamma 校正过程为 <img src="https://www.zhihu.com/equation?tex=C+%3D+%5Ctextstyle+C%5E%7B1%2F%5Cgamma%7D_%7B%5Ctext%7Blin%7D%7D" alt="[公式]">，其中 <img src="https://www.zhihu.com/equation?tex=C" alt="[公式]"> 代表 RGB 的某个分量，<img src="https://www.zhihu.com/equation?tex=%5Cgamma" alt="[公式]"> 值通常为 2.2。对于如何计算的细节，我希望在 <a href="https://zhuanlan.zhihu.com/p/24281841" target="_blank" rel="noopener">下一篇文章</a> 中进行详细说明。</p><ul><li>对于 RGB 色彩空间来说，关键点在于两个：<ul><li><strong>如何选择三个作为基底的颜色；</strong></li><li><strong>如何定义白色</strong>。一旦选好这两个关键参数，那么从 CIE XYZ 空间到设备的 RGB 空间的转换就完全确定了。我们平时常说的 sRGB 空间和 Adobe RGB 空间，他们的区别就在于这两个关键参数的定义不同。常用的的 RGB 空间的转换矩阵如下表：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/164118772.png" alt="mark"></p><p>不同的 RGB 空间能表示的范围如下图所示（这个图在 <a href="https://zhuanlan.zhihu.com/p/24281841" target="_blank" rel="noopener">以后的文章</a> 中再详细解释），</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/164151141.png" alt="mark"></p><ul><li><p>可以看到，不同的 RGB 空间所能表示的颜色范围是不一样的，并且我们可以推断出，即使是同样的 RGB 分量，在不同的 RGB 空间中所代表的颜色也是不一样的。所以我们在描述一个 RGB 颜色的时候，<strong>不仅需要描述它的 RGB 三个分量，还要说明是在哪个空间，这就是 ICC 文件的作用。</strong></p></li><li><p><strong>很多数码相机都可以设置色彩空间，常见的有 sRGB 和 Adobe RGB</strong></p><ul><li>从上面的图中我们可以看到， Adobe RGB 所能表达的色彩比 sRGB 要丰富很多。然而常见的网络环境下图片的色彩空间是 sRGB，有很多浏览器不能正确地解析图片自带的色彩空间说明，默认按照 sRGB 来进行解析。</li><li>如果使用相机直出的 JPG 文件直接上传，或者说在后期处理过程中没有进行色彩空间转换，保留了相机设置的 Adobe RGB 空间，那么在浏览器中看到的图片很可能与 Photoshop 中看到的不一样。</li><li>浏览器很可能会将一张 Adobe RGB 空间中的图片解释为 sRGB 空间下的图片，引起颜色偏差。<strong>由于 sRGB 是目前屏幕显示的「事实标准」</strong>，大多数屏幕空间都在 sRGB 内（这是颜色复现设备本身决定的），所以我的建议是，对用于网络交流目的的图片，统一转换到 sRGB 中进行保存。</li></ul></li></ul><h2 id="5-数学论证"><a href="#5-数学论证" class="headerlink" title="5. 数学论证"></a>5. 数学论证</h2><p>回顾一下线性代数中构成线性空间的几个要素：</p><blockquote><p>交换律：<img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%2B%5Cboldsymbol%7By%7D+%3D+%5Cboldsymbol%7By%7D%2B%5Cboldsymbol%7Bx%7D" alt="[公式]"></p><p>结合律：<img src="https://www.zhihu.com/equation?tex=%28%5Cboldsymbol%7Bx%7D%2B%5Cboldsymbol%7By%7D%29%2B%5Cboldsymbol%7Bz%7D+%3D+%0A%5Cboldsymbol%7Bx%7D%2B%28%5Cboldsymbol%7By%7D%2B%5Cboldsymbol%7Bz%7D%29" alt="[公式]"></p></blockquote><p>这两条容易理解，显然，交换不同色光叠加的顺序并不会改变叠加的结果。</p><blockquote><p>加法零元：<img src="https://www.zhihu.com/equation?tex=%5Cexists+%5C%3A+%5Cboldsymbol%7B0%7D%2C%5C%3B+%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B+%5Cboldsymbol%7Bx%7D+%2B+%5Cboldsymbol%7B0%7D+%3D+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>这一点也很好理解，加法零元就是全黑，什么光都没有。任何一种色光叠加一个全黑那还是它自身。</p><blockquote><p>加法逆元：<img src="https://www.zhihu.com/equation?tex=%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%5Cexists+%5C%3A+%28-%5Cboldsymbol%7Bx%7D%29%2C%5C%3B+%0A%5Cboldsymbol%7Bx%7D+%2B+%28-%5Cboldsymbol%7Bx%7D%29+%3D+%5Cboldsymbol%7B0%7D" alt="[公式]"></p></blockquote><p>回想前文对实验中需要「负数」数量的光的处理手法，我们可以在左边叠加光线，这就相当于在右边减去光线。如果承认这种形式的「减法」，那么加法逆元也是顺理成章了：在另一边加入自身。</p><blockquote><p>乘法幺元：<img src="https://www.zhihu.com/equation?tex=%5Cexists+%5C%3A+1%2C%5C%3B+%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%0A1%5Ccdot%5Cboldsymbol%7Bx%7D+%3D+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>这也很明显，数字 1 就可以作为乘法幺元。</p><blockquote><p>乘法分配率：<br><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Cboldsymbol%7Bx%7D%2C+%5C%3A+%5Cboldsymbol%7By%7D%2C+%5C%3A+%5Calpha%2C%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B%5Calpha%5C%2C%28%5Cboldsymbol%7Bx%7D+%2B+%5Cboldsymbol%7By%7D%29+%3D+%5Calpha+%5Cboldsymbol%7Bx%7D+%2B+%0A%5Calpha+%5Cboldsymbol%7By%7D" alt="[公式]"><br><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5C%3A%5Cbeta%2C%5C%3A%5Cboldsymbol%7Bx%7D%2C%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B+%28%5Calpha%2B%5Cbeta%29%5C%2C%5Cboldsymbol%7Bx%7D+%3D+%0A%5Calpha+%5Cboldsymbol%7Bx%7D+%2B+%5Cbeta+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>根据格拉斯曼定律，这一点也是实际上成立的。</p><p>综上所述，人类对色彩的感知在实验层面满足线性性质，人眼感知的色彩空间是一个 3 维线性空间。当然，容易想见，通常我们选取的基底（比如 CIE XYZ 空间的色匹配函数），是不正交的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-色彩空间&quot;&gt;&lt;a href=&quot;#图像学-色彩空间&quot; class=&quot;headerlink&quot; title=&quot;图像学-色彩空间&quot;&gt;&lt;/a&gt;图像学-色彩空间&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;作为摄影师，你是不是遇到过这样的问题：相机设置里的色彩空间是什么意思？ sRGB 和 Adobe RGB 有什么不同？为什么我的图片在 Photoshop 里看着好好的，一保存发布到网上色彩就变了？&lt;/li&gt;
&lt;li&gt;本篇文章将分为几个部分。首先从几个实验规律出发，借助线性代数相关的概念，定义色彩空间，然后介绍并推导几个重要的色彩空间之间的关系。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-897-递增顺序查找树</title>
    <link href="http://zhuuu.work/2020/12/07/Leetcode/Leetcode-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/12/07/Leetcode/Leetcode-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2020-12-07T07:52:53.000Z</published>
    <updated>2020-12-07T03:42:02.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-897-递增顺序查找树"><a href="#Leetcode-897-递增顺序查找树" class="headerlink" title="Leetcode-897-递增顺序查找树"></a>Leetcode-897-<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">递增顺序查找树</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p><pre><code>示例 ：输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]      5      /     \    3    6   / \    \  2   4    8 /        / \ 1        7   9输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1  \   2    \     3      \       4        \         5          \           6            \             7              \               8                \                 9  </code></pre><a id="more"></a><h2 id="思路：中序遍历-构造新树"><a href="#思路：中序遍历-构造新树" class="headerlink" title="思路：中序遍历 + 构造新树"></a>思路：中序遍历 + 构造新树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root,vals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造新树</span></span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode cur = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:vals)&#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> TreeNode(val);  <span class="comment">// 构造新的结点</span></span><br><span class="line">            cur = cur.right;    <span class="comment">// 方向只向右延伸</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node,List&lt;Integer&gt; vals)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(node.left,vals);</span><br><span class="line">        vals.add(node.val);</span><br><span class="line">        inorder(node.right,vals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，其中 N 是树上的节点个数。</li><li><strong>空间复杂度</strong>：O(N)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-897-递增顺序查找树&quot;&gt;&lt;a href=&quot;#Leetcode-897-递增顺序查找树&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-897-递增顺序查找树&quot;&gt;&lt;/a&gt;Leetcode-897-&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-order-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;递增顺序查找树&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给你一个树，请你 &lt;strong&gt;按中序遍历&lt;/strong&gt; 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 ：

输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]

      5
      /     \
    3    6
   / \    \
  2   4    8
 /        / \ 
1        7   9

输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="中序遍历" scheme="http://zhuuu.work/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-861-翻转矩阵后的得分</title>
    <link href="http://zhuuu.work/2020/12/07/Leetcode/Leetcode-861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/"/>
    <id>http://zhuuu.work/2020/12/07/Leetcode/Leetcode-861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/</id>
    <published>2020-12-07T02:52:53.000Z</published>
    <updated>2020-12-07T03:22:28.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-861-翻转矩阵后的得分"><a href="#Leetcode-861-翻转矩阵后的得分" class="headerlink" title="Leetcode-861-翻转矩阵后的得分"></a>Leetcode-861-<a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/" target="_blank" rel="noopener">翻转矩阵后的得分</a></h1><h2 id="思路：贪心算法"><a href="#思路：贪心算法" class="headerlink" title="思路：贪心算法"></a>思路：贪心算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p></li><li><p><strong>移动是指选择任一行或列</strong>，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p></li><li><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p></li><li><p>返回尽可能高的分数。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">39</span></span><br><span class="line">解释：</span><br><span class="line">转换为 [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="number">0b1111</span> + <span class="number">0b1001</span> + <span class="number">0b1111</span> = <span class="number">15</span> + <span class="number">9</span> + <span class="number">15</span> = <span class="number">39</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>根据题意，能够知道一个重要的事实：给定一个翻转方案，则它们之间任意交换顺序后，得到的结果保持不变。<strong>因此，我们总可以先考虑所有的行翻转，再考虑所有的列翻转。</strong></li><li><strong>行翻转</strong> ：<strong>不难发现一点：为了得到最高的分数，矩阵的每一行的最左边的数都必须为1。为了做到这一点，我们可以翻转那些最左边的数不为 1 的那些行，而其他的行则保持不动。</strong></li><li><strong>列翻转</strong> ： 当将每一行的最左边的数都变为 1 之后，就只能进行列翻转了。<ul><li>为了使得总得分最大，我们要让每个列中 1 的数目尽可能多。</li><li>因此，我们扫描除了最左边的列以外的每一列，<strong>如果该列 0 的数目多于 1 的数目，就翻转该列，其他的列则保持不变。</strong></li></ul></li></ol><p><strong>对于实际编码的时候：我们无需要修改原来的矩阵</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201207/110943111.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此做法不必修改原来的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 直接统计第一列的贡献（假设第一列全为1的结果）</span></span><br><span class="line">        <span class="keyword">int</span> ret = m * (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 统计从第二列开始 每一列的贡献</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nOnes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;           <span class="comment">// 说明这一行没有进行过行翻转</span></span><br><span class="line">                    nOnes += A[i][j];       <span class="comment">// 直接统计本列1的个数</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 说明这一行开头是0,需要行翻转</span></span><br><span class="line">                    nOnes += (<span class="number">1</span> - A[i][j]); <span class="comment">// 如果这一行进行了翻转,则该元素的实际取值就是 1 - A[i][j]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = Math.max(nOnes, m - nOnes);     <span class="comment">// k 是列翻转后1的数量 nOnes是1的数量 m - nOnes是0的数量</span></span><br><span class="line">            ret += k * (<span class="number">1</span> &lt;&lt; (n - j - <span class="number">1</span>));          <span class="comment">// 本列对于结果的贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ： <code>O(mn)</code></strong></li><li><strong>空间复杂度：  <code>O(1)</code></strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-861-翻转矩阵后的得分&quot;&gt;&lt;a href=&quot;#Leetcode-861-翻转矩阵后的得分&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-861-翻转矩阵后的得分&quot;&gt;&lt;/a&gt;Leetcode-861-&lt;a href=&quot;https://leetcode-cn.com/problems/score-after-flipping-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;翻转矩阵后的得分&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：贪心算法&quot;&gt;&lt;a href=&quot;#思路：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;思路：贪心算法&quot;&gt;&lt;/a&gt;思路：贪心算法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一个二维矩阵 A 其中每个元素的值为 0 或 1 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;移动是指选择任一行或列&lt;/strong&gt;，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回尽可能高的分数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;39&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;转换为 [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0b1111&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0b1001&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0b1111&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;39&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-204-计数质数</title>
    <link href="http://zhuuu.work/2020/12/03/Leetcode/Leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/12/03/Leetcode/Leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</id>
    <published>2020-12-03T00:52:53.000Z</published>
    <updated>2020-12-03T01:44:43.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-204-计数质数"><a href="#Leetcode-204-计数质数" class="headerlink" title="Leetcode-204-计数质数"></a>Leetcode-204-<a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">计数质数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 5 * 106</span><br></pre></td></tr></table></figure><h2 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h2><ul><li><p>很直观的思路是我们枚举每个数判断其是不是质数。</p></li><li><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。</p></li><li><p>因此对于每个数 x，我们可以从小到大枚举<code>[2,x-1]</code>中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 <code>O(n)</code>，无法通过所有测试数据。</p></li></ul><p><strong>注意：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091156606.png" alt="mark"></p><p>举例子 ： </p><ul><li><code>x = 6 y = 2 x/y =3</code></li><li><code>min(y,x/y)= 2</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数据</span></span><br><span class="line">        String line;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(line);</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="keyword">new</span> Solution().countPrimes(n);</span><br><span class="line">            String out = String.valueOf(ret);</span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;++i)&#123;</span><br><span class="line">            ans += isPrime(i)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(sqrt(n))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i*i &lt;= x;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091257182.png" alt="mark"></p><a id="more"></a><h2 id="方法二-：-埃氏筛"><a href="#方法二-：-埃氏筛" class="headerlink" title="方法二 ： 埃氏筛"></a>方法二 ： 埃氏筛</h2><ul><li>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（<code>Eratosthenes</code>）提出，称为厄拉多塞筛法，简称埃氏筛。</li></ul><p><strong>注意：</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091731007.png" alt="mark" style="zoom:150%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化质数数组</span></span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 进行统计</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>)&#123;   <span class="comment">// 如果遇到的这个数是质数的话,开始判断,否则不会进循环</span></span><br><span class="line">                ans += <span class="number">1</span>;           <span class="comment">// 遍历数组,如果是质数的话,那么给结果加1</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">long</span>)i*i &lt; n)&#123;  <span class="comment">// 如果i是质数 那么i*i就是合数 起始位置：需要标记为0</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i;j &lt; n;j += i)&#123;  <span class="comment">// 同时,从i*i 位置开始标记,</span></span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;             <span class="comment">// 标记i*i + i也同时为i的倍数，只要是i的倍数,那么就一定不是质数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/094440295.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-204-计数质数&quot;&gt;&lt;a href=&quot;#Leetcode-204-计数质数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-204-计数质数&quot;&gt;&lt;/a&gt;Leetcode-204-&lt;a href=&quot;https://leetcode-cn.com/problems/count-primes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计数质数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;统计所有小于非负整数 &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; 的质数的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 5 * 106&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;方法一：枚举&quot;&gt;&lt;a href=&quot;#方法一：枚举&quot; class=&quot;headerlink&quot; title=&quot;方法一：枚举&quot;&gt;&lt;/a&gt;方法一：枚举&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很直观的思路是我们枚举每个数判断其是不是质数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此对于每个数 x，我们可以从小到大枚举&lt;code&gt;[2,x-1]&lt;/code&gt;中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 &lt;code&gt;O(n)&lt;/code&gt;，无法通过所有测试数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091156606.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;举例子 ： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x = 6 y = 2 x/y =3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min(y,x/y)= 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        BufferedReader in = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InputStreamReader(System.in));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 初始化数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String line;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((line = in.readLine()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = Integer.parseInt(line);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Solution().countPrimes(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String out = String.valueOf(ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(out);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;countPrimes&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i &amp;lt; n;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans += isPrime(i)?&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// O(sqrt(n))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i*i &amp;lt;= x;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(x % i == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091257182.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-134-加油站</title>
    <link href="http://zhuuu.work/2020/11/18/Leetcode/Leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://zhuuu.work/2020/11/18/Leetcode/Leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</id>
    <published>2020-11-18T09:22:53.000Z</published>
    <updated>2020-11-18T04:56:06.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-134-加油站"><a href="#Leetcode-134-加油站" class="headerlink" title="Leetcode-134-加油站"></a>Leetcode-134-<a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">加油站</a></h1><h2 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：一次遍历"><a href="#方法-：一次遍历" class="headerlink" title="方法 ：一次遍历"></a>方法 ：一次遍历</h2><ul><li><p>最容易想到的解法是：从头到尾遍历每个加油站，并检查以该加油站为起点，最终能否行驶一周。我们可以通过减小被检查的加油站数目，来降低总的时间复杂度。</p></li><li><p>假设我们此前发现，从加油站 xx 出发，每经过一个加油站就加一次油，第一个无法到达的加油站是 y（不妨设 x&lt;y）。这就说明：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201118/124732560.png" alt="mark"></p><ul><li>现在，考虑任意一个位于 x,y之间的加油站 z<em>，我们现在考察从该加油站出发，能否到达加油站 y</em></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201118/124851837.png" alt="mark"></p><p><strong>这也就是说明，从x,y 之间任何一个加油站出发,都无法到达加油站y(说明起点只能有一个,这个加油站不行的话，中间任何一个点作为起点都不可以，起点只能从下一次加油站 x + 1开始检查，故最后只遍历了一遍数组)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = gas.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从头到尾遍历每个加油站，并且检查以该加油站为起点，能否行驶一周</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> sumOfGas  = <span class="number">0</span>; <span class="comment">// 总共加的油</span></span><br><span class="line">            <span class="keyword">int</span> SumOfCost = <span class="number">0</span>; <span class="comment">// 总共消费的油</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;     <span class="comment">// 记录能走过几个站点</span></span><br><span class="line">            <span class="keyword">while</span>(count &lt; n)&#123;  <span class="comment">// 退出循环的条件是走过所有的站点</span></span><br><span class="line">                <span class="keyword">int</span> j = (i + count) % n; <span class="comment">// 加油站是环形的</span></span><br><span class="line">                sumOfGas += gas[j];</span><br><span class="line">                SumOfCost += cost[j];</span><br><span class="line">                <span class="keyword">if</span>(SumOfCost &gt; sumOfGas)&#123; <span class="comment">// 如果这个站点发现油不够了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++; <span class="comment">// 这个站点满足情况</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count == n)&#123;  <span class="comment">// 如果能环绕一圈</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不行的话 从下一个站点开始 检查</span></span><br><span class="line">                i = i + count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有加油站作为起点都不满足</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)，其中 N为数组的长度。我们对数组进行了单次遍历。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-134-加油站&quot;&gt;&lt;a href=&quot;#Leetcode-134-加油站&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-134-加油站&quot;&gt;&lt;/a&gt;Leetcode-134-&lt;a href=&quot;https://leetcode-cn.com/problems/gas-station/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;加油站&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：一次遍历&quot;&gt;&lt;a href=&quot;#思路：一次遍历&quot; class=&quot;headerlink&quot; title=&quot;思路：一次遍历&quot;&gt;&lt;/a&gt;思路：一次遍历&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。&lt;/p&gt;
&lt;p&gt;你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。&lt;/p&gt;
&lt;p&gt;如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p&gt;
&lt;p&gt;说明: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果题目有解，该答案即为唯一答案。&lt;/li&gt;
&lt;li&gt;输入数组均为非空数组，且长度相同。&lt;/li&gt;
&lt;li&gt;输入数组中的元素均为非负数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gas  &amp;#x3D; [1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cost &amp;#x3D; [3,4,5,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &amp;#x3D; 0 + 4 &amp;#x3D; 4 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 4 号加油站，此时油箱有 4 - 1 + 5 &amp;#x3D; 8 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 0 号加油站，此时油箱有 8 - 2 + 1 &amp;#x3D; 7 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 1 号加油站，此时油箱有 7 - 3 + 2 &amp;#x3D; 6 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 2 号加油站，此时油箱有 6 - 4 + 3 &amp;#x3D; 5 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，3 可为起始索引。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gas  &amp;#x3D; [2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cost &amp;#x3D; [3,4,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &amp;#x3D; 0 + 4 &amp;#x3D; 4 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 0 号加油站，此时油箱有 4 - 3 + 2 &amp;#x3D; 3 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 1 号加油站，此时油箱有 3 - 3 + 3 &amp;#x3D; 3 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，无论怎样，你都不可能绕环路行驶一周。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1030-距离顺序排列矩阵单元格</title>
    <link href="http://zhuuu.work/2020/11/17/Leetcode/Leetcode-1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/"/>
    <id>http://zhuuu.work/2020/11/17/Leetcode/Leetcode-1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/</id>
    <published>2020-11-17T07:52:53.000Z</published>
    <updated>2020-11-17T03:41:20.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1030-距离顺序排列矩阵单元格"><a href="#Leetcode-1030-距离顺序排列矩阵单元格" class="headerlink" title="Leetcode-1030-距离顺序排列矩阵单元格"></a>Leetcode-1030-<a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/" target="_blank" rel="noopener">距离顺序排列矩阵单元格</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为<code>(r, c)</code>，满足 <code>0 &lt;= r &lt; R</code>且<code>0 &lt;= c &lt; C。</code></p><p>另外，我们在该矩阵中给出了一个坐标为<code>(r0, c0)</code> 的单元格。</p><p>返回矩阵中的所有单元格的坐标，并按到 <code>(r0, c0)</code> 的距离从最小到最大的顺序排，其中，两单元格<code>(r1, c1) 和 (r2, c2)</code> 之间的距离是曼哈顿距离，<code>|r1 - r2| + |c1 - c2|</code>。（你可以按任何满足此条件的顺序返回答案。）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 1, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 0</span><br><span class="line">输出：[[0,0],[0,1]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 2, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 1</span><br><span class="line">输出：[[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]</span><br><span class="line">[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 2, C &#x3D; 3, r0 &#x3D; 1, c0 &#x3D; 2</span><br><span class="line">输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]</span><br><span class="line">其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-暴力排序"><a href="#方法一-：-暴力排序" class="headerlink" title="方法一 ： 暴力排序"></a>方法一 ： 暴力排序</h2><ul><li>最容易想到的方法是首先存储矩阵内所有的点，然后将其按照哈曼顿距离直接排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[R * C][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                ret[i * C + j] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ret, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Math.abs(a[<span class="number">0</span>] - r0) + Math.abs(a[<span class="number">1</span>] - c0)) - (Math.abs(b[<span class="number">0</span>] - r0) + Math.abs(b[<span class="number">1</span>] - c0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/113741576.png" alt="mark"></p><h2 id="方法二-：桶排序"><a href="#方法二-：桶排序" class="headerlink" title="方法二 ：桶排序"></a>方法二 ：桶排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用桶排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="comment">// 计算需要几个桶 并把创建相应数量的桶</span></span><br><span class="line">        <span class="keyword">int</span> maxDist = Math.max(r0,R - <span class="number">1</span> - r0) + Math.max(c0, C- <span class="number">1</span> - c0);</span><br><span class="line">        List&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxDist;i++)&#123;</span><br><span class="line">            bucket.add(<span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出哈曼顿距离 并结果加入到相应的桶里面(时间复杂度 O(RC))</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; R;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; C;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> d = dist(i,j,r0,c0);</span><br><span class="line">                bucket.get(d).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建结果集，并把Arraylist&lt;List&lt;int[]&gt; 转换成int[][]</span></span><br><span class="line">        <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[R*C][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每个桶,把桶中的元素加入到结果集中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= maxDist;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] it:bucket.get(i))&#123;</span><br><span class="line">                ret[idx++] = it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈曼顿距离（排序方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> c1,<span class="keyword">int</span> r2,<span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(r1 - r2) + Math.abs(c1 - c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/114113486.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-1030-距离顺序排列矩阵单元格&quot;&gt;&lt;a href=&quot;#Leetcode-1030-距离顺序排列矩阵单元格&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1030-距离顺序排列矩阵单元格&quot;&gt;&lt;/a&gt;Leetcode-1030-&lt;a href=&quot;https://leetcode-cn.com/problems/matrix-cells-in-distance-order/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;距离顺序排列矩阵单元格&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给出 R 行 C 列的矩阵，其中的单元格的整数坐标为&lt;code&gt;(r, c)&lt;/code&gt;，满足 &lt;code&gt;0 &amp;lt;= r &amp;lt; R&lt;/code&gt;且&lt;code&gt;0 &amp;lt;= c &amp;lt; C。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外，我们在该矩阵中给出了一个坐标为&lt;code&gt;(r0, c0)&lt;/code&gt; 的单元格。&lt;/p&gt;
&lt;p&gt;返回矩阵中的所有单元格的坐标，并按到 &lt;code&gt;(r0, c0)&lt;/code&gt; 的距离从最小到最大的顺序排，其中，两单元格&lt;code&gt;(r1, c1) 和 (r2, c2)&lt;/code&gt; 之间的距离是曼哈顿距离，&lt;code&gt;|r1 - r2| + |c1 - c2|&lt;/code&gt;。（你可以按任何满足此条件的顺序返回答案。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 1, C &amp;#x3D; 2, r0 &amp;#x3D; 0, c0 &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[0,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 2, C &amp;#x3D; 2, r0 &amp;#x3D; 0, c0 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[0,1],[0,0],[1,1],[1,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 2, C &amp;#x3D; 3, r0 &amp;#x3D; 1, c0 &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="桶排序" scheme="http://zhuuu.work/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="BFS" scheme="http://zhuuu.work/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-402-移除K个数</title>
    <link href="http://zhuuu.work/2020/11/15/Leetcode/Leetcode-402-%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/11/15/Leetcode/Leetcode-402-%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0/</id>
    <published>2020-11-15T07:52:53.000Z</published>
    <updated>2020-11-15T01:32:21.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-409-移掉K位数字"><a href="#Leecode-409-移掉K位数字" class="headerlink" title="Leecode-409-移掉K位数字"></a>Leecode-409-<a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">移掉K位数字</a></h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><ul><li>给定一个以字符串表示的非负整数 <em>num*，移除这个数中的 *k</em> 位数字，使得剩下的数字最小。</li></ul><p><strong>注意:</strong></p><ul><li><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></li><li><em>num</em> 不会包含任何前导零。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br><span class="line"></span><br><span class="line">示例 2 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br><span class="line"></span><br><span class="line">示例 3 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-贪心算法"><a href="#方法-：-贪心算法" class="headerlink" title="方法 ： 贪心算法"></a><strong>方法 ： 贪心算法</strong></h2><p><strong>官方很好的题解 ：</strong> <a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201115/093033535.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> digit : num.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span> &amp;&amp; stack.peekLast() &gt; digit)&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 而当遍历完成，如果 k 仍然大于 0。</span></span><br><span class="line">        <span class="comment">// 不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 处理删除后的前导0，直接跳过即可</span></span><br><span class="line">        <span class="keyword">boolean</span> leadingZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> digit:stack)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leadingZero &amp;&amp; digit == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            leadingZero = <span class="keyword">false</span>;</span><br><span class="line">            ret.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终数字序列为空的话,返回0</span></span><br><span class="line">        <span class="keyword">if</span>(ret.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度 ： O(n)，其中 n 为字符串的长度。尽管存在嵌套循环，但内部循环最多运行 k次。</strong>由于<code>0&lt;k≤n</code>，主循环的时间复杂度被限制在 <code>2n</code>以内。对于主循环之外的逻辑，它们的时间复杂度是 O(n)，因此总时间复杂度为 O(n)。</li><li><strong>空间复杂度 ： O(n) 栈所需要的空间大小</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-409-移掉K位数字&quot;&gt;&lt;a href=&quot;#Leecode-409-移掉K位数字&quot; class=&quot;headerlink&quot; title=&quot;Leecode-409-移掉K位数字&quot;&gt;&lt;/a&gt;Leecode-409-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移掉K位数字&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个以字符串表示的非负整数 &lt;em&gt;num*，移除这个数中的 *k&lt;/em&gt; 位数字，使得剩下的数字最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;num&lt;/em&gt; 的长度小于 10002 且 ≥ &lt;em&gt;k。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;num&lt;/em&gt; 不会包含任何前导零。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;1432219&amp;quot;, k &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;1219&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;10200&amp;quot;, k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;200&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;10&amp;quot;, k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从原数字移除所有的数字，剩余为空就是0。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1122-数组的相对排序</title>
    <link href="http://zhuuu.work/2020/11/14/Leetcode/Leetcode-1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/11/14/Leetcode/Leetcode-1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-11-14T07:52:53.000Z</published>
    <updated>2020-11-14T01:22:40.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings"><a href="#Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings" class="headerlink" title="Leecode-1122-数组的相对排序https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)"></a>Leecode-1122-<a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">数组的相对排序</a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/</a>)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你两个数组，arr1 和 arr2，</span><br><span class="line"></span><br><span class="line">arr2 中的元素各不相同</span><br><span class="line">arr2 中的每个元素都出现在 arr1 中</span><br><span class="line">对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]</span><br><span class="line">输出：[2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">arr1.length, arr2.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; arr1[i], arr2[i] &lt;&#x3D; 1000</span><br><span class="line">arr2 中的元素 arr2[i] 各不相同</span><br><span class="line">arr2 中的每个元素 arr2[i] 都出现在 arr1 中</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-计数排序"><a href="#方法-：-计数排序" class="headerlink" title="方法 ： 计数排序"></a>方法 ： 计数排序</h2><ul><li>注意到本题中元素的范围为 [0, 1000][0,1000]，这个范围不是很大，我们也可以考虑不基于比较的排序，例如「计数排序」。</li></ul><p><strong>具体算法</strong></p><ol><li><p>使用长度为1001【下标0 - 1000】 的数组<code>frequency</code> 记录每一个元素在<code>arr1</code> 中出现的次数 </p></li><li><p>随后遍历数组<code>arr2</code>,当遍历到元素x的时候。将<code>frequency[x]</code> 放入到结果集中，并将<code>frequency[x]</code>清0</p></li><li><p>此时还剩下没有在<code>arr2</code> 中出现过的元素，因此我们还需要对整个数组<code>frequency</code> 进行一次遍历。当遍历到x时，如果<code>frequency[x]!=0</code> ，说明这个元素没有在arr2中出现，那么将这个元素添加到答案的最后。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="comment">// 本题中元素的范围是[0,1000] 这个范围不是很大，可以不考虑比较排序，例如【计数排序】</span></span><br><span class="line">        <span class="comment">// 对空间的优化，使用比数组arr1中最大值upper 使用长度upper + 1;</span></span><br><span class="line">        <span class="keyword">int</span> upper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            upper = Math.max(upper,x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个数出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[upper + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            ++frequency[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组arr2，当遍历到元素x的时候</span></span><br><span class="line">        <span class="comment">// 将frequency[x] 放入到结果集中，并将frequency[x]清0</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; frequency[x];i++)&#123;</span><br><span class="line">                ans[idx++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            frequency[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将frequency[x]中剩余的数字放入到结果集中</span></span><br><span class="line">        <span class="comment">// 按照frequency中的升序放入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt;= upper;++x)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; frequency[x];++i)&#123;</span><br><span class="line">                ans[idx++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(<code>m + n + upper</code>)</li><li>空间复杂度 :   O(<code>upper</code>),即为<code>frequency</code>数组使用的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings&quot;&gt;&lt;a href=&quot;#Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings&quot; class=&quot;headerlink&quot; title=&quot;Leecode-1122-数组的相对排序https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)&quot;&gt;&lt;/a&gt;Leecode-1122-&lt;a href=&quot;https://leetcode-cn.com/problems/relative-sort-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组的相对排序&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&lt;/a&gt;)&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给你两个数组，arr1 和 arr2，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的元素各不相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的每个元素都出现在 arr1 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：arr1 &amp;#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &amp;#x3D; [2,1,4,3,9,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,2,2,1,4,3,3,9,6,7,19]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr1.length, arr2.length &amp;lt;&amp;#x3D; 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; arr1[i], arr2[i] &amp;lt;&amp;#x3D; 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的元素 arr2[i] 各不相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的每个元素 arr2[i] 都出现在 arr1 中&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="计数排序" scheme="http://zhuuu.work/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法模式</title>
    <link href="http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-13T07:02:24.000Z</published>
    <updated>2020-11-19T11:12:26.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-模板方法模式"><a href="#设计模式-模板方法模式" class="headerlink" title="设计模式-模板方法模式"></a>设计模式-模板方法模式</h1><h2 id="模板方法模式（Template-Method）"><a href="#模板方法模式（Template-Method）" class="headerlink" title="模板方法模式（Template Method）"></a>模板方法模式（Template Method）</h2><ul><li>动机：对于一项任务，常常有<strong>稳定的整体操作结构</strong>，但各个子步骤却又很多改变的需求，或者需要子步骤的晚期实现（<strong>延迟到子类去实现</strong>）。</li><li><strong><code>Template Method</code>使得子类可以复用一个算法的结构</strong>（<code>Override</code> 重写）该算法的某些特定步骤。</li><li><strong>不要调用我，让我来调用你，实现晚绑定机制</strong>，<strong>这也就是控制反转的思想。</strong></li><li><strong>声明成 <code>protected</code> ,因为具体步骤在流程中才有意义。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/161657528.png" alt="mark"></p><ul><li><strong>AbstractClass : 稳定的骨架（里面有具体的方法和需要被重写的方法）</strong></li><li><strong>ContreteClass : 具体的重写方法</strong></li></ul><p><strong>模板方法模式定义</strong>（特别的常用）：</p><ul><li><strong>定义一个操作中的算法的骨架（稳定） ,而将一些步骤（变化）延迟到子类中。</strong></li><li><strong>Template Method 使得子类可以不改变（复用）一个算法的结构即可（Override 重写）该算法某些特定的步骤</strong></li></ul><a id="more"></a><ul><li>具体实现（举例）</li></ul><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/162632540.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 骨架流程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourIncoup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourIncoup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入咖啡粉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒茶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">        coffee.prepareRecipe();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"========"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AbstractClass tea = <span class="keyword">new</span> Tea();</span><br><span class="line">        tea.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">倒水</span><br><span class="line">倒咖啡</span><br><span class="line">倒进杯子</span><br><span class="line">加入咖啡粉</span><br><span class="line">========</span><br><span class="line">倒水</span><br><span class="line">倒茶</span><br><span class="line">倒进杯子</span><br><span class="line">加入茶叶</span><br></pre></td></tr></table></figure><p><strong>JDK中实现：</strong></p><ul><li><code>java.util.Collections#sort()</code></li><li><code>java.io.InputStream#skip()</code></li><li><code>java.io.InputStream#read()</code></li><li><code>java.util.AbstractList#indexOf()</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式-模板方法模式&quot;&gt;&lt;a href=&quot;#设计模式-模板方法模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-模板方法模式&quot;&gt;&lt;/a&gt;设计模式-模板方法模式&lt;/h1&gt;&lt;h2 id=&quot;模板方法模式（Template-Method）&quot;&gt;&lt;a href=&quot;#模板方法模式（Template-Method）&quot; class=&quot;headerlink&quot; title=&quot;模板方法模式（Template Method）&quot;&gt;&lt;/a&gt;模板方法模式（Template Method）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动机：对于一项任务，常常有&lt;strong&gt;稳定的整体操作结构&lt;/strong&gt;，但各个子步骤却又很多改变的需求，或者需要子步骤的晚期实现（&lt;strong&gt;延迟到子类去实现&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Template Method&lt;/code&gt;使得子类可以复用一个算法的结构&lt;/strong&gt;（&lt;code&gt;Override&lt;/code&gt; 重写）该算法的某些特定步骤。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要调用我，让我来调用你，实现晚绑定机制&lt;/strong&gt;，&lt;strong&gt;这也就是控制反转的思想。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明成 &lt;code&gt;protected&lt;/code&gt; ,因为具体步骤在流程中才有意义。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/161657528.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AbstractClass : 稳定的骨架（里面有具体的方法和需要被重写的方法）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ContreteClass : 具体的重写方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模板方法模式定义&lt;/strong&gt;（特别的常用）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义一个操作中的算法的骨架（稳定） ,而将一些步骤（变化）延迟到子类中。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template Method 使得子类可以不改变（复用）一个算法的结构即可（Override 重写）该算法某些特定的步骤&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-13T07:02:24.000Z</published>
    <updated>2020-11-16T09:50:42.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-观察者模式"><a href="#设计模式-观察者模式" class="headerlink" title="设计模式-观察者模式"></a>设计模式-观察者模式</h1><h4 id="观察者模式（Obersver）"><a href="#观察者模式（Obersver）" class="headerlink" title="观察者模式（Obersver）"></a>观察者模式（Obersver）</h4><ul><li><strong>观察者模式是使用频率非常高的模式了，它定义了对象间一种一对多的关系，使得每当一个对象改变状态，则所有依赖它的对象都会收到通知，并且自动更新。</strong></li><li><strong>例如：<code>Java</code>中的监听器<code>Listener</code>用的就是观察者模式。</strong></li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/094333516.png" alt="mark"></p><ul><li><strong><code>Subject:</code> 具有注册和移除观察者，并且通知观察者的功能，主体是通过某种数据结构（可能是列表）来维护一张观察者列表实现这些操作的。</strong></li><li><strong>观察者（<code>Observer</code>）的注册功能需要调用主体的<code>registerObserver()</code>方法。</strong></li></ul><a id="more"></a><p><strong>实现：</strong></p><ul><li>开发<strong>技术周报</strong>，每周会更新一些内容，但是不知道具体的更新时间，又想第一时间阅读更新内容。</li><li>难道要一直按住<code>F5</code>等它更新么？那估计<code>F5</code>烂了可能都没有更新。其实我们只需要简单的订阅一下就好，当有新的内容更新的时候，会发邮件到你订阅的邮箱中。</li></ul><p>上述例子中：</p><ul><li>订阅者就是观察者，技术周报就是被观察者</li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者：程序员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的更新内容为"</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者：主体（开发周报）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekly</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一对多的通知</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        observers.forEach(observer -&gt; observer.update(<span class="string">"数据更新了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中自带的观察者模式的类</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/103921192.png" alt="mark"></p><ul><li><strong>在<code>java.util</code> 包中内置了<code>Observer</code> 和 <code>observable</code>类,同时<code>Observable</code>类实现了注册和反注册等方法，使用起来方便很多。可见观察者模式是非常重要的。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;java.util.Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Observer</code>接口则是比较简单的代码</strong>，<code>update()</code>的参数中除了可以传递数据意外，还提供了被观察者的引用对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called whenever the observed object is changed. An</span></span><br><span class="line"><span class="comment">     * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's</span></span><br><span class="line"><span class="comment">     * observers notified of the change.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o     the observable object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                 method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中的实现：</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener">javax.servlet.http.HttpSessionBindingListener</a></li><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式-观察者模式&quot;&gt;&lt;a href=&quot;#设计模式-观察者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-观察者模式&quot;&gt;&lt;/a&gt;设计模式-观察者模式&lt;/h1&gt;&lt;h4 id=&quot;观察者模式（Obersver）&quot;&gt;&lt;a href=&quot;#观察者模式（Obersver）&quot; class=&quot;headerlink&quot; title=&quot;观察者模式（Obersver）&quot;&gt;&lt;/a&gt;观察者模式（Obersver）&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;观察者模式是使用频率非常高的模式了，它定义了对象间一种一对多的关系，使得每当一个对象改变状态，则所有依赖它的对象都会收到通知，并且自动更新。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例如：&lt;code&gt;Java&lt;/code&gt;中的监听器&lt;code&gt;Listener&lt;/code&gt;用的就是观察者模式。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UML类图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/094333516.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Subject:&lt;/code&gt; 具有注册和移除观察者，并且通知观察者的功能，主体是通过某种数据结构（可能是列表）来维护一张观察者列表实现这些操作的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;观察者（&lt;code&gt;Observer&lt;/code&gt;）的注册功能需要调用主体的&lt;code&gt;registerObserver()&lt;/code&gt;方法。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-031-下一个排列</title>
    <link href="http://zhuuu.work/2020/11/10/Leetcode/Leetcode-031-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://zhuuu.work/2020/11/10/Leetcode/Leetcode-031-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2020-11-10T02:52:53.000Z</published>
    <updated>2020-11-10T01:20:54.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-031-下一个排列"><a href="#Leecode-031-下一个排列" class="headerlink" title="Leecode-031-下一个排列"></a>Leecode-031-<a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>实现获取<strong>下一个排列的函数</strong>，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p></li><li><p>如果<strong>不存在下一个更大的排列</strong>，则将<strong>数字重新排列成最小的排列（即升序排列）。</strong></p></li><li><p>必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>修改，只允许使用额外常数空间。</p></li></ul><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><a id="more"></a><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本题要求我们实现一个算法，将给定数字序列重新排列成字典序中下一个更大的排列。</span><br><span class="line"></span><br><span class="line">以数字序列 [1,2,3][1,2,3] 为例，其排列按照字典序依次为：</span><br><span class="line">[1,2,3]\\ [1,3,2]\\ [2,1,3]\\ [2,3,1]\\ [3,1,2]\\ [3,2,1]</span><br><span class="line"></span><br><span class="line">这样，排列 [2,3,1] 的下一个排列即为 [3,1,2]。特别的，最大的排列 [3,2,1] 的下一个排列为最小的排列 [1,2,3]。</span><br></pre></td></tr></table></figure><h2 id="方法：两边扫描"><a href="#方法：两边扫描" class="headerlink" title="方法：两边扫描"></a>方法：两边扫描</h2><p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，<strong>能够找到一个大于当前序列的新序列，且变大的幅度尽可能小</strong>。具体地：</p><ol><li>我们需要将一个<strong>左边的「较小数」与一个右边的「较大数」交换</strong>，以能够让当前排列变大，从而得到下一个排列。</li><li>同时我们要让这个「<strong>较小数」尽量靠右，而「较大数」尽可能小</strong>。</li><li><strong>当交换完成后，「较大数」右边的数需要按照升序重新排列</strong>。这样可以在保证新排列大于原来排列的情况下，使变大的幅</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以排列 [4,5,2,6,3,1] 为例：</span><br><span class="line"></span><br><span class="line">我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。</span><br><span class="line"></span><br><span class="line">当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。</span><br></pre></td></tr></table></figure><p><strong>具体地，我们这样描述该算法，对于长度为 n的排列 a：</strong></p><ol><li><p>首先从后向前查找第一个顺序对 <code>(i,i+1)</code>，满足 <code>a[i] &lt; a[i+1]</code>。这样「较小数」即为 <code>a[i]</code>。此时 <code>[i+1,n)</code>必然是下降序列。</p></li><li><p>如果找到了顺序对，那么在区间<code>[i+1,n)</code>中从后向前查找第一个元素 <code>j</code> 满足 <code>a[i] &lt; a[j]a[i]&lt;a[j]</code>。这样「较大数」即为 <code>a[j]</code>。</p></li><li><p>交换<code>a[i] 与 a[j]</code>，此时可以证明区间<code>[i+1,n)</code>必为降序。我们可以直接使用双指针反转区间 <code>[i+1,n)</code>使其变为升序，而无需对该区间进行排序。</p></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201110/090035559.gif" alt="mark"></p><p><strong>注意</strong></p><p><strong>如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，我们直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列。</strong></p><p><strong>该方法支持序列中存在重复元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前扫描 找到较小数</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时(i + 1,n] 一定是下降序列</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123; <span class="comment">// 如果这个条件不满足，说明当前序列已经是一个降序序列，即最大的序列 ，所以直接进行翻转reverser即可</span></span><br><span class="line">            <span class="comment">// 从[i + 1,n)从后往前查找</span></span><br><span class="line">            <span class="comment">// 找到丢一个元素j 满足 a[i] &lt; a[j] </span></span><br><span class="line">            <span class="comment">// 较大数即为 a[j]</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换a[i] 和 a[j]</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时[i + 1,n) 一定是降序序列</span></span><br><span class="line">        reverse(nums,i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i]  = nums[j];</span><br><span class="line">        nums[j]  = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双指针翻转区间[i + 1,n)</span></span><br><span class="line">    <span class="comment">// 使得该区间变成升序序列，而无需对区间进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = start;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，其中 N为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。</li><li><strong>空间复杂度</strong>：O(1)，只需要常数的空间存放若干变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-031-下一个排列&quot;&gt;&lt;a href=&quot;#Leecode-031-下一个排列&quot; class=&quot;headerlink&quot; title=&quot;Leecode-031-下一个排列&quot;&gt;&lt;/a&gt;Leecode-031-&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下一个排列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实现获取&lt;strong&gt;下一个排列的函数&lt;/strong&gt;，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果&lt;strong&gt;不存在下一个更大的排列&lt;/strong&gt;，则将&lt;strong&gt;数字重新排列成最小的排列（即升序排列）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;必须&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt;修改，只允许使用额外常数空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;br&gt;&lt;code&gt;1,2,3&lt;/code&gt; → &lt;code&gt;1,3,2&lt;/code&gt;&lt;br&gt;&lt;code&gt;3,2,1&lt;/code&gt; → &lt;code&gt;1,2,3&lt;/code&gt;&lt;br&gt;&lt;code&gt;1,1,5&lt;/code&gt; → &lt;code&gt;1,5,1&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-13-TCP粘包和拆包</title>
    <link href="http://zhuuu.work/2020/11/08/Netty/Netty-13-TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <id>http://zhuuu.work/2020/11/08/Netty/Netty-13-TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</id>
    <published>2020-11-08T02:05:24.000Z</published>
    <updated>2020-11-09T02:34:46.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-13-TCP粘包和拆包"><a href="#Netty-13-TCP粘包和拆包" class="headerlink" title="Netty-13-TCP粘包和拆包"></a>Netty-13-TCP粘包和拆包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>TCP是面向连接的，面向流的，提供高可靠性服务。</li><li>收发两端（<strong>客户端和服务器端）</strong>都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，<strong>使用了优化方法（Nagle算法</strong>），将多次<strong>间隔较小且数据量小</strong>的数据，合并成一个大的数据块，然后进行封包。</li><li>这样做虽然提高了效率，但是<strong>接收端就难于分辨出完整的数据包</strong>了，因为<strong>面向流的通信是无消息保护边界</strong>的</li></ul><p><strong>通常的解决方案</strong></p><ol><li><p><strong>发送端</strong>每发送一次消息，就需要在消息的内容之前<strong>携带消息的长度</strong></p></li><li><p>这样，<strong>接收方</strong>每次先接受消息的长度，再<strong>根据长度去读取消息剩余的元素</strong></p></li><li><p>如果 <code>socket</code> 中还有没有读取的内容，也只能放在下一次读取事件中读取</p></li></ol><a id="more"></a><h2 id="1-拆包、粘包的图解"><a href="#1-拆包、粘包的图解" class="headerlink" title="1. 拆包、粘包的图解"></a>1. 拆包、粘包的图解</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091157126.png" alt="mark"></p><p>假设客户端同时发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，固可能存在以下四种情况：</p><ol><li><p>服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包</p></li><li><p>服务端一次接受到了两个数据包，D1和D2粘合在一起，<strong>称之为TCP粘包</strong></p></li><li><p>服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这<strong>称之为TCP拆包</strong></p></li><li><p>服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。</p></li></ol><h2 id="2-TCP-拆包、粘包"><a href="#2-TCP-拆包、粘包" class="headerlink" title="2. TCP  拆包、粘包"></a>2. TCP  拆包、粘包</h2><p> 本实例主要演示出现拆包和粘包的场景。</p><p><strong>客户端：</strong></p><p> 我们将使用循环连续发送10个<code>String</code>类型的字符串。这里相当于发送了10次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用客户端发送10条数据，hello，server</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        String msg = <span class="string">"server"</span> + i + <span class="string">"  "</span>;</span><br><span class="line">        System.out.println(<span class="string">"发送消息 "</span> + msg);</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端：</strong></p><p> 我们接受客户端发过来的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">    msg.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将buffer转成字符串</span></span><br><span class="line">    String message = <span class="keyword">new</span> String(bytes, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"服务器接收到数据 "</span> + message);</span><br><span class="line">    System.out.println(<span class="string">"服务器接收到消息量 = "</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回送数据到客户端，回送一个随机Id</span></span><br><span class="line">    ByteBuf response = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="string">"--"</span>, CharsetUtil.UTF_8);</span><br><span class="line">    ctx.writeAndFlush(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端输出结果如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091543240.png" alt="mark"></p><ul><li>可以看到，服务端直接一次就把我们客户端10次发送的内容读取完成了。</li><li>这里也印证了我们开篇所说的，当<strong>数据量小且发送间隔短</strong>，如果我们客户端每次发送的都是不同的结果，这种情况下我们就不知道客户端返回了多少次结果以及每次结果究竟是什么。这就是我们本篇需要解决的问题。</li></ul><h2 id="3-TCP-问题解决方案"><a href="#3-TCP-问题解决方案" class="headerlink" title="3. TCP 问题解决方案"></a>3. TCP 问题解决方案</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091255970.png" alt="mark"></p><ul><li><strong>在数据包的前面加上一个固定字节数的数据长度</strong>，如加上一个 <code>int</code> (固定四个字节）类型的数据内容长度</li><li>就算客户端同时发送两个数据包到服务端，当服务端接收时，也可以先读取四个字节的长度，然后根据长度获取相应消息的内容，这样就不会出现多读取或者少读取的情况了。</li></ul><h3 id="3-1-解决方案代码演示"><a href="#3-1-解决方案代码演示" class="headerlink" title="3.1 解决方案代码演示"></a>3.1 解决方案代码演示</h3><ul><li><p><strong>使用自定义协议 + 编解码器 来解决</strong></p></li><li><p>关键就是要解决 <strong>服务器端每次读取数据长度的问题</strong></p></li><li><p>这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 。</p></li></ul><ol><li><strong>自定义协议(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义协议</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len; <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent()&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>客户端引导器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">MyClientInitializer</span>())</span>; <span class="comment">// 自定义初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync(); <span class="comment">// 监听关闭端口事件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>客户端pipeline</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入多个handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder()); <span class="comment">// 加入编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder()); <span class="comment">// 加入解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());  <span class="comment">// 加入自定义处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>客户端Handler(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 记录发送了几条消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端发送5条数据 "今天天气冷，吃火锅" 编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">"今天天气冷，吃火锅"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 封装数据对象</span></span><br><span class="line">            <span class="keyword">byte</span>[] content = msg.getBytes(Charset.forName(<span class="string">"utf-8"</span>));     <span class="comment">// 数据内容转换成字节数组</span></span><br><span class="line">            <span class="keyword">int</span> length = msg.getBytes(Charset.forName(<span class="string">"utf-8"</span>)).length;  <span class="comment">// 数据长度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 封装成自定义数据包对象</span></span><br><span class="line">            Message message = <span class="keyword">new</span> Message();</span><br><span class="line">            message.setLen(length);</span><br><span class="line">            message.setContent(content);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送</span></span><br><span class="line">            ctx.writeAndFlush(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>服务端引导器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">MyServerInitializer</span>())</span>;</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>服务端pipeline</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入自定义处理器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>服务端handler(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 统计接收的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收到数据进行处理</span></span><br><span class="line">        <span class="keyword">int</span> len = message.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = message.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器接收到信息如下"</span>);</span><br><span class="line">        System.out.println(<span class="string">"长度="</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"内容="</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"服务器接收到消息包数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回复客户端消息</span></span><br><span class="line">        String response = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> resLen = response.getBytes(<span class="string">"utf-8"</span>).length;</span><br><span class="line">        <span class="keyword">byte</span>[] rescontent = response.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把回复的消息封装成一个message对象</span></span><br><span class="line">        Message message1 = <span class="keyword">new</span> Message();</span><br><span class="line">        message1.setContent(rescontent);</span><br><span class="line">        message1.setLen(resLen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送给客户端</span></span><br><span class="line">        channelHandlerContext.writeAndFlush(message1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>自定义协议编码器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageEncoder encode 方法被调用"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将编码数据写入ByteBuf中</span></span><br><span class="line">        byteBuf.writeInt(message.getLen());</span><br><span class="line">        byteBuf.writeBytes(message.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li><strong>自定义协议解码器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageDecoder decode 被调用"</span>);</span><br><span class="line">        <span class="comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span></span><br><span class="line">        Message messageProtocol = <span class="keyword">new</span> Message();</span><br><span class="line">        messageProtocol.setLen(length);</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line"></span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-13-TCP粘包和拆包&quot;&gt;&lt;a href=&quot;#Netty-13-TCP粘包和拆包&quot; class=&quot;headerlink&quot; title=&quot;Netty-13-TCP粘包和拆包&quot;&gt;&lt;/a&gt;Netty-13-TCP粘包和拆包&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP是面向连接的，面向流的，提供高可靠性服务。&lt;/li&gt;
&lt;li&gt;收发两端（&lt;strong&gt;客户端和服务器端）&lt;/strong&gt;都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，&lt;strong&gt;使用了优化方法（Nagle算法&lt;/strong&gt;），将多次&lt;strong&gt;间隔较小且数据量小&lt;/strong&gt;的数据，合并成一个大的数据块，然后进行封包。&lt;/li&gt;
&lt;li&gt;这样做虽然提高了效率，但是&lt;strong&gt;接收端就难于分辨出完整的数据包&lt;/strong&gt;了，因为&lt;strong&gt;面向流的通信是无消息保护边界&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通常的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;发送端&lt;/strong&gt;每发送一次消息，就需要在消息的内容之前&lt;strong&gt;携带消息的长度&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这样，&lt;strong&gt;接收方&lt;/strong&gt;每次先接受消息的长度，再&lt;strong&gt;根据长度去读取消息剩余的元素&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果 &lt;code&gt;socket&lt;/code&gt; 中还有没有读取的内容，也只能放在下一次读取事件中读取&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="TCP" scheme="http://zhuuu.work/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-127-单词接龙</title>
    <link href="http://zhuuu.work/2020/11/05/Leetcode/Leetcode-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>http://zhuuu.work/2020/11/05/Leetcode/Leetcode-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</id>
    <published>2020-11-05T07:22:53.000Z</published>
    <updated>2020-11-05T06:06:39.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-127-单词接龙"><a href="#Leecode-127-单词接龙" class="headerlink" title="Leecode-127-单词接龙"></a>Leecode-127-<a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">单词接龙</a></h1><h2 id="思路：BFS-双向BFS"><a href="#思路：BFS-双向BFS" class="headerlink" title="思路：BFS/双向BFS"></a>思路：BFS/双向BFS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</span><br><span class="line"></span><br><span class="line">每次转换只能改变一个字母。</span><br><span class="line">转换过程中的中间单词必须是字典中的单词。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">如果不存在这样的转换序列，返回 0。</span><br><span class="line">所有单词具有相同的长度。</span><br><span class="line">所有单词只由小写字母组成。</span><br><span class="line">字典中不存在重复的单词。</span><br><span class="line">你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;</span><br><span class="line">endWord &#x3D; &quot;cog&quot;</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>无向图中两个顶点之间的最短路径的长度，可以通过广度优先遍历得到；</li><li>为什么 BFS 得到的路径最短？<strong>可以把起点和终点所在的路径拉直来看，两点之间线段最短</strong>；</li><li>已知目标顶点的情况下，可以<strong>分别从起点和目标顶点（终点）执行广度优先遍历</strong>，直到遍历的部分有交集，这是<strong>双向广度优先遍历的思想。</strong></li></ul><p><strong>分析题意：</strong></p><p>「转换」意即：两个单词对应位置只有一个字符不同，例如 “hit” 与 “hot”，这种转换是可以逆向的，因此，根据题目给出的单词列表，可以<strong>构建出一个无向（无权）图</strong>；</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201105/140134859.png" alt="mark"></p><ul><li>如果一开始就构建图，每一个单词都需要和除它以外的另外的单词进行比较，<strong>复杂度是 O(N O(NwordLen)</strong>，这里 N 是单词列表的长度；</li><li>为此，我们在遍历的一开始，把所有单词放入一个哈希表中，然后在遍历的过程中构件图，每一次得到在单词列表里可以转换的单词，<strong>复杂度是O(26×wordLen)，借助哈希表</strong>，找到邻居与 N 无关；</li><li>使用BFS ： 所需要的辅助数据结构是<ul><li>队列</li><li><code>visited</code> 集合<ul><li>说明：可以直接在 <code>wordSet</code> (由 <code>wordList</code> 放进集合中得到)里做删除</li><li>但更好的做法是新开一个哈希表，遍历过的字符串放进哈希表里。</li><li>这种做法具有普遍意义。绝大多数在线测评系统和应用场景都不会在意空间开销。</li></ul></li></ul></li></ul><h2 id="方法一-：-广度优先遍历"><a href="#方法一-：-广度优先遍历" class="headerlink" title="方法一 ： 广度优先遍历"></a>方法一 ： 广度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步 ： 图的广度优先遍历,必须使用队列和表示访问过的visited 访问过数据的哈希表</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步： 开始进行广度优先遍历，包含起点，因此起点的初始化步数为1</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; curSize;i++)&#123;</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                String currWord = queue.poll();</span><br><span class="line">                <span class="comment">// 如果currWord 能够修改依次字符便和 endWord 相同，那么立即返回step + 1即可</span></span><br><span class="line">                <span class="keyword">if</span>(changeWordEveryOneLetter(currWord,endWord,queue,visited,wordSet))&#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到的话返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">            <span class="keyword">char</span> originChar = charArray[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                charArray[i] = k;</span><br><span class="line">                String nextWord = String.valueOf(charArray);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(nextWord)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">                        queue.add(nextWord);</span><br><span class="line">                        <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                        visited.add(nextWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 恢复</span></span><br><span class="line">            charArray[i] = originChar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二：-双向广度优先遍历"><a href="#方法二：-双向广度优先遍历" class="headerlink" title="方法二： 双向广度优先遍历"></a>方法二： 双向广度优先遍历</h2><p><strong>参考题解 ：</strong> <a href="https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-127-单词接龙&quot;&gt;&lt;a href=&quot;#Leecode-127-单词接龙&quot; class=&quot;headerlink&quot; title=&quot;Leecode-127-单词接龙&quot;&gt;&lt;/a&gt;Leecode-127-&lt;a href=&quot;https://leetcode-cn.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词接龙&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：BFS-双向BFS&quot;&gt;&lt;a href=&quot;#思路：BFS-双向BFS&quot; class=&quot;headerlink&quot; title=&quot;思路：BFS/双向BFS&quot;&gt;&lt;/a&gt;思路：BFS/双向BFS&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;每次转换只能改变一个字母。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;转换过程中的中间单词必须是字典中的单词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果不存在这样的转换序列，返回 0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所有单词具有相同的长度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所有单词只由小写字母组成。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;字典中不存在重复的单词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 beginWord 和 endWord 是非空的，且二者不相同。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beginWord &amp;#x3D; &amp;quot;hit&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;endWord &amp;#x3D; &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wordList &amp;#x3D; [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 一个最短转换序列是 &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     返回它的长度 5。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beginWord &amp;#x3D; &amp;quot;hit&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;endWord &amp;#x3D; &amp;quot;cog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wordList &amp;#x3D; [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: endWord &amp;quot;cog&amp;quot; 不在字典中，所以无法进行转换。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双向BFS" scheme="http://zhuuu.work/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
  </entry>
  
  <entry>
    <title>Netty-12-handler调用机制</title>
    <link href="http://zhuuu.work/2020/11/05/Netty/Netty-12-handler%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/11/05/Netty/Netty-12-handler%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-05T05:05:24.000Z</published>
    <updated>2020-11-06T09:34:59.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-12-handler调用机制"><a href="#Netty-12-handler调用机制" class="headerlink" title="Netty-12-handler调用机制"></a>Netty-12-handler调用机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>netty的组件设计：Netty的主要组件有<code>Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe</code>等</li><li>我们先来复习一下<code>ChannelHandler</code>和<code>ChannelPipeline</code>的关系。示例图如下：我们可以将<code>pipeline</code>理解为一个双向链表，<code>ChannelHandlerContext</code>看作链表中的一个节点，<code>ChannelHandler</code>则为每个节点中保存的一个属性对象。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><a id="more"></a><ul><li><strong><code>ChannelHandler</code>充当了处理入站和出站数据的应用程序逻辑的容器。</strong><ul><li>例如，实现<code>ChannelInboundHandler</code>接口（或<code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。</li><li>当<strong>要给客户端发送响应</strong>时，也可以从<code>ChannelInboundHandler</code>冲刷数据。业务逻辑通常写在一个或者多个<code>ChannelInboundHandler</code>中。</li></ul></li><li><strong><code>ChannelPipeline</code>提供了<code>ChannelHandler</code>链的容器。</strong><ul><li>如果事件的运动方向是从<strong>客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过<code>pipeline</code>中的一系列<code>ChannelOutboundHandler</code>,被这些<code>Handler</code>处理</strong></li><li>反之则称为入站的</li></ul></li></ul><p><strong>下面，来看看我们常用的<code>Handler</code>的关系图：<code>Inbound</code>处理入站，<code>Outbound</code>处理出站</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/160524576.png" alt="mark"></p><p>一般来说，在我们接收数据时将数据解码后，就进行业务的相关处理，所以上图的<strong>入站的常用类更多(服务端到客户端)</strong>。<strong>在数据出站时（客户端到服务端）</strong>，一般我们只需要将数据编码后直接发出。</p><h2 id="1-Handler-链式调用"><a href="#1-Handler-链式调用" class="headerlink" title="1. Handler 链式调用"></a>1. Handler 链式调用</h2><ul><li><p><code>Pipeline</code>中的<code>Handler</code>可以当作一个双向链表。</p></li><li><p>但是<code>Handler</code>却又存在着入站和出站之分。那么<code>Netty</code>是如何将两种类型的<code>Handler</code>保存在一个链表中，却又能够入站的时候调用<code>InboundHandler</code>，出栈的时候调用<code>OutBoundHandler</code>呢</p></li><li><p>看下图，黄色的表示入站，以及入站的<code>Handler</code>，绿色的表示出站，以及出站的<code>Handler</code>。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/162411613.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//out</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//in</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> OutBoundHandler()); <span class="comment">//out</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> InBoundHandler()); <span class="comment">//in</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请求处理流程</strong></p><ul><li>当一个请求来了的时候，首先会将请求发给<code>pipeline</code>中位于链表首部的<code>Handler</code>。</li><li>首先由队列第一个handler 进行处理，如果接受类型不匹配，那么跳过，直接转发给下一个handler 进行处理</li><li>如果需要返回数据，我们就调用<code>writeAndFlush</code>方法，这个方法可不简单，当他一被调用，就会触发出站请求，然后就由当前所在的<code>handler</code> 节点往回调用</li></ul><p><strong>通过上面的描述，我们可以总结添加<code>Handler</code>的以下节点总结：</strong></p><ul><li><strong>调用<code>InboundHandler</code>的顺序和添加的顺序是一致的。</strong></li><li><strong>调用<code>OutboundHandler</code>的顺序和添加它的顺序是相反的。</strong></li><li><strong>链表的末尾不能有 <code>OutHandler</code>，因为如果最后是 <code>OutHandler</code>的话，当他前面的 <code>Inhandler</code> 处理完数据返回消息调用<code>writeAndflush</code> 方法后，它就直接在前面进行反向调用了。那么就无法调用到这个 <code>OutHandler</code></strong></li><li><strong>所以，平常会把 <code>OutHandler</code>写在前面，<code>InHandler</code> 一般放在链表的末尾</strong></li><li><strong><code>InHandler</code> 一旦进行了 <code>writeAndFlush</code> ，那么只有这个<code>Inhandler</code> 之前添加的 <code>Outhandler</code> 才能正确的处理数据</strong></li></ul><h2 id="2-Handler-编解码器"><a href="#2-Handler-编解码器" class="headerlink" title="2. Handler 编解码器"></a>2. Handler 编解码器</h2><ul><li><p>当<code>Netty</code>发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如<code>java</code>对象）；如果是出站消息，它会被编码成字节。</p></li><li><p>Netty提供一系列<strong>实用的编解码器</strong>，他们都实现了<code>ChannelInboundHadnler</code>或者<code>ChannelOutboundHandler</code>接口。在这些类中，<code>channelRead</code>方法已经被重写了</p></li><li><p><strong>以入站为例</strong>，对于每个从入站<code>Channel</code>读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的<code>decode()</code>方法进行解码，并将已经解码的字节转发给<code>ChannelPipeline</code>中的下一个<code>ChannelInboundHandler</code>。</p></li></ul><h3 id="2-1-解码器-ByteToMessageDecoder"><a href="#2-1-解码器-ByteToMessageDecoder" class="headerlink" title="2.1 解码器-ByteToMessageDecoder"></a>2.1 解码器-ByteToMessageDecoder</h3><ul><li>由于<strong>不可能知道远程节点是否会一次性发送一个完整的信息，tcp有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理。</strong></li></ul><p><strong>下面是段示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            out.add(in.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个例子中</strong></p><ol><li>每次入站从<code>ByteBuf</code>中读取4字节，将其解码为一个<code>int</code>，</li><li>然后将它添加到下一个<code>List</code>中。当没有更多元素可以被添加到该<code>List</code>中时，它的内容将会被发送给下一个<code>ChannelInboundHandler</code>。</li><li><code>int</code>在被添加到<code>List</code>中时，会被自动装箱为<code>Integer</code>。</li></ol><p>在调用<code>readInt()</code>方法前必须验证所输入的<code>ByteBuf</code>是否具有足够的数据</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/163527996.png" alt="mark"></p><h3 id="2-2-解码器-ReplayingDecoder"><a href="#2-2-解码器-ReplayingDecoder" class="headerlink" title="2.2 解码器 - ReplayingDecoder"></a>2.2 <strong>解码器 - ReplayingDecoder</strong></h3><ul><li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder{ }</code></li><li><code>ReplayingDecoder</code>扩展了<code>ByteToMessageDecoder</code>类，使用这个类，我们不必调用<code>readableBytes()</code>方法。参数S指定了用户状态管理的类型，<strong>其中Void代表不需要状态管理</strong></li><li>下面是代码示例：这段代码起到了上面<code>ByteToMessageDecoder</code>一样的作用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.add(in.readLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ReplayingDecoder</code>使用方便，但它也有一些局限性：<ul><li><strong>并不是所有的 <code>ByteBuf</code> 操作都被支持</strong>，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li><li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul></li></ul><p><strong>其他的解码器</strong></p><ul><li><code>LineBasedFrameDecoder</code>：这个类在Netty内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li><li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li><li><code>HttpObjectDecoder</code>：一个HTTP数据的解码器</li><li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li></ul><h2 id="3-简单实例"><a href="#3-简单实例" class="headerlink" title="3. 简单实例"></a>3. 简单实例</h2><p><strong>实例要求：</strong></p><ul><li>使用自定义的编码器和解码器来说明Netty的<code>handler</code> 调用机制</li><li>客户端发送<code>long</code> -&gt; 服务器</li><li>服务端发送<code>long</code>-&gt; 客户端</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/172833866.png" alt="mark"></p><p>注意 ：  这里只展示，<code>Handler</code>相应的代码和添加<code>Handler</code>的关键代码。</p><ol><li><strong>Decoder</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * decode 方法会根据接收到的数据，被调用多次，知道确定没有新的元素被添加到list，或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果 list out不为空，就会将list的内容传递给下一个 Handler 进行处理，该处理器的方法也会被调用多次。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入栈的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out list集合，将解码后的数据传给下一个Handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//因为long为8个字节，所以需要8个字节才能读取成一个long类型的数据</span></span><br><span class="line">        System.out.println(<span class="string">"ByteToLongDecoder：入栈数据被解码"</span>);</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Encoder</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LongToByteEncoder: 出栈数据，msg = "</span> + msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>服务器端添加Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//编码器，出站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//解码器，入站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ServerInBoundHandler()); <span class="comment">//业务处理，入站</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>客户端添加Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//编码器，出站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//解码器，入站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ClientInBoundHandler()); <span class="comment">//业务处理，入站。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>这里当客户端和服务端接收消息的时候<ul><li>首先会调用入站的解码器，然后进行业务的处理</li><li>然后在调用出站的解码解码器再返回消息</li></ul></li><li>后面可以在业务处理类中，增加发送消息的代码，此处省略。</li></ul><h2 id="4-Netty整合-log4j"><a href="#4-Netty整合-log4j" class="headerlink" title="4. Netty整合 log4j"></a>4. Netty整合 log4j</h2><ol><li><strong>添加依赖</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>添加配置文件</strong></li></ol><p>在<code>resource</code>目录下新建<code>log4j.properties</code>即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log5j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">[%p] %C&#123;1&#125; - %m%n</span></span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote><p><strong>参考博客 ：</strong> <a href="https://dongzl.github.io/netty-handbook/#/README" target="_blank" rel="noopener">https://dongzl.github.io/netty-handbook/#/README</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-12-handler调用机制&quot;&gt;&lt;a href=&quot;#Netty-12-handler调用机制&quot; class=&quot;headerlink&quot; title=&quot;Netty-12-handler调用机制&quot;&gt;&lt;/a&gt;Netty-12-handler调用机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;netty的组件设计：Netty的主要组件有&lt;code&gt;Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;我们先来复习一下&lt;code&gt;ChannelHandler&lt;/code&gt;和&lt;code&gt;ChannelPipeline&lt;/code&gt;的关系。示例图如下：我们可以将&lt;code&gt;pipeline&lt;/code&gt;理解为一个双向链表，&lt;code&gt;ChannelHandlerContext&lt;/code&gt;看作链表中的一个节点，&lt;code&gt;ChannelHandler&lt;/code&gt;则为每个节点中保存的一个属性对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="handler" scheme="http://zhuuu.work/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-057-插入区间</title>
    <link href="http://zhuuu.work/2020/11/04/Leetcode/Leetcode-057-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2020/11/04/Leetcode/Leetcode-057-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</id>
    <published>2020-11-04T03:52:53.000Z</published>
    <updated>2020-11-04T06:06:05.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-057-插入区间"><a href="#Leetcode-057-插入区间" class="headerlink" title="Leetcode-057-插入区间"></a>Leetcode-057-<a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">插入区间</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：模拟"><a href="#思路-：模拟" class="headerlink" title="思路 ：模拟"></a><strong>思路 ：模拟</strong></h2><ol><li><strong>是否有交集的探讨</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135246852.png" alt="mark"></p><ol start="2"><li><strong>思路与算法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135519588.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135533962.png" alt="mark"></p><ul><li><p>这样做的正确性在于，给定的区间<strong>集合中任意两个区间都是没有交集</strong>的，因此所有需要合并的区间，就是所有与区间 S 重叠的区间。</p></li><li><p>并且，在给定的区间集合已经按照左端点排序的前提下，所有与区间 S 重叠的区间在数组 <strong>intervals</strong> 中下标范围是连续的，因此我们<strong>可以对所有的区间进行一次遍历</strong>，就可以找到这个连续的下标范围。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135816063.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> placed = <span class="keyword">false</span>; <span class="comment">// 保证新插入的集合只被插入一次</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="keyword">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集（扩大区间）</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果走完发现 ： 新插入的集合还未加入到结果集中</span></span><br><span class="line">        <span class="comment">// 说明新插入的集合在 所有区间的最后</span></span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将ArrayList转化成 int[ansList.size()][2]</span></span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansList.size(); ++i) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是数组 intervals 的长度，即给定的区间个数。</li><li>空间复杂度:   O(1) 除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-057-插入区间&quot;&gt;&lt;a href=&quot;#Leetcode-057-插入区间&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-057-插入区间&quot;&gt;&lt;/a&gt;Leetcode-057-&lt;a href=&quot;https://leetcode-cn.com/problems/insert-interval/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;插入区间&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出一个&lt;em&gt;无重叠的 ，&lt;/em&gt;按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：intervals &amp;#x3D; [[1,3],[6,9]], newInterval &amp;#x3D; [2,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,5],[6,9]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：intervals &amp;#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &amp;#x3D; [4,8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,2],[3,10],[12,16]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-24-IO核心子系统</title>
    <link href="http://zhuuu.work/2020/11/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-24-IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhuuu.work/2020/11/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-24-IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-11-03T03:00:53.000Z</published>
    <updated>2020-11-02T03:39:29.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-24-IO核心子系统"><a href="#操作系统-24-IO核心子系统" class="headerlink" title="操作系统-24-IO核心子系统"></a>操作系统-24-IO核心子系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111350794.png" alt="mark"></p><p><strong>IO 核心子系统</strong></p><ul><li>设备独立性软件</li><li>设备驱动程序</li><li>中断处理程序</li></ul><h2 id="1-假脱机技术-SPOOLing"><a href="#1-假脱机技术-SPOOLing" class="headerlink" title="1. 假脱机技术(SPOOLing)"></a>1. 假脱机技术(SPOOLing)</h2><ul><li>在<strong>用户层软件</strong>实现，但是408大纲将其归入I/O核心子系统</li></ul><h3 id="1-1-什么是脱机技术？"><a href="#1-1-什么是脱机技术？" class="headerlink" title="1.1 什么是脱机技术？"></a>1.1 什么是脱机技术？</h3><p><strong>这里温习一下手工操作阶段：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111631459.png" alt="mark"></p><p>因为手工阶段的速度慢问题，引入了脱机技术</p><a id="more"></a><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111700059.png" alt="mark"></p><h3 id="1-2-假脱机技术"><a href="#1-2-假脱机技术" class="headerlink" title="1.2 假脱机技术"></a>1.2 假脱机技术</h3><ul><li>在脱机技术的基础上人们发明了更好的假脱机技术</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111730874.png" alt="mark"></p><p><strong>输入井和输出井</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111923725.png" alt="mark"></p><p><strong>输入进程和输出进程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111948908.png" alt="mark"></p><p><strong>输入和输出缓冲区</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112015684.png" alt="mark"></p><h3 id="1-3-共享打印机"><a href="#1-3-共享打印机" class="headerlink" title="1.3 共享打印机"></a>1.3 共享打印机</h3><p><strong>先了解一下独占和共享设备，以此引出假脱机技术如何实现对独占设备的共享：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112058454.png" alt="mark"></p><ul><li><strong>共享打印机原理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112156732.png" alt="mark"></p><p>打印请求完成后，请求表从打印队列删除，执行后续队列的打印任务</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112316764.png" alt="mark"></p><h2 id="2-IO-设备的分配和回收"><a href="#2-IO-设备的分配和回收" class="headerlink" title="2. IO 设备的分配和回收"></a>2. IO 设备的分配和回收</h2><p><strong>设备分配时应该考虑的因素</strong></p><ul><li><strong>设备的固有属性</strong><br>独占设备、共享设备、虚拟设备(SPOOLing技术将独占设备改造成虚拟的共享设备)</li><li><strong>设备分配算法</strong><br>先来先服务、优先级高者优先、短任务优先等等</li><li><strong>设备分配的安全性</strong><br><strong>安全分配方式</strong>：串行使用设备，为进程分配一个设备后将进程阻塞，I/O完成再唤醒。不会产生死锁<br><strong>不安全分配方式</strong>：进程请求I/O，操作系统负责分配设备，进程可以继续执行或者请求新的I/O，直到某个I/O无法满足才阻塞进程。可能产生死锁</li></ul><p><strong>静态分配和动态分配</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112601713.png" alt="mark"></p><h3 id="2-1-设备分配数据结构"><a href="#2-1-设备分配数据结构" class="headerlink" title="2.1 设备分配数据结构"></a>2.1 设备分配数据结构</h3><p><strong>设备、控制器、通道之间的关系：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112633304.png" alt="mark"></p><p><strong>设备控制表-DCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112655363.png" alt="mark"></p><p><strong>控制器控制表-COCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112713381.png" alt="mark"></p><p><strong>通道控制表-CHCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112740089.png" alt="mark"></p><p><strong>系统设备表-SDT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112751658.png" alt="mark"></p><h3 id="2-2-设备分配的步骤"><a href="#2-2-设备分配的步骤" class="headerlink" title="2.2 设备分配的步骤"></a>2.2 设备分配的步骤</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112815959.png" alt="mark"></p><h3 id="2-3-设备分配改进步骤"><a href="#2-3-设备分配改进步骤" class="headerlink" title="2.3 设备分配改进步骤"></a>2.3 设备分配改进步骤</h3><ul><li><strong>缺点</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112905248.png" alt="mark"></p><ul><li><strong>改进方法 ： 逻辑设备名</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112948310.png" alt="mark"></p><ul><li><strong>逻辑设备表</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113006948.png" alt="mark"></p><h2 id="3-缓冲区管理"><a href="#3-缓冲区管理" class="headerlink" title="3. 缓冲区管理"></a>3. 缓冲区管理</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113120359.png" alt="mark"></p><h3 id="3-1-缓冲区的作用"><a href="#3-1-缓冲区的作用" class="headerlink" title="3.1 缓冲区的作用"></a>3.1 缓冲区的作用</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113306353.png" alt="mark"></p><h3 id="3-2-单缓冲"><a href="#3-2-单缓冲" class="headerlink" title="3.2 单缓冲"></a><strong>3.2 单缓冲</strong></h3><p><strong>单缓冲的原则</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113336039.png" alt="mark"></p><ol><li><strong>T &gt; C</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113423300.png" alt="mark"></p><ol start="2"><li><strong>T &lt; C</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113434600.png" alt="mark"></p><h3 id="3-3-双缓冲"><a href="#3-3-双缓冲" class="headerlink" title="3.3 双缓冲"></a>3.3 双缓冲</h3><ol><li><strong>T  &gt; C+ M</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113506440.png" alt="mark"></p><ol start="2"><li><strong>T &lt; C + M</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113540130.png" alt="mark"></p><h3 id="3-4-循环缓冲"><a href="#3-4-循环缓冲" class="headerlink" title="3.4 循环缓冲"></a>3.4 循环缓冲</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113606985.png" alt="mark"></p><h3 id="3-5-缓冲池"><a href="#3-5-缓冲池" class="headerlink" title="3.5 缓冲池"></a>3.5 缓冲池</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113853966.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考笔记 ：</strong> <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-24-IO核心子系统&quot;&gt;&lt;a href=&quot;#操作系统-24-IO核心子系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统-24-IO核心子系统&quot;&gt;&lt;/a&gt;操作系统-24-IO核心子系统&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111350794.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO 核心子系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备独立性软件&lt;/li&gt;
&lt;li&gt;设备驱动程序&lt;/li&gt;
&lt;li&gt;中断处理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-假脱机技术-SPOOLing&quot;&gt;&lt;a href=&quot;#1-假脱机技术-SPOOLing&quot; class=&quot;headerlink&quot; title=&quot;1. 假脱机技术(SPOOLing)&quot;&gt;&lt;/a&gt;1. 假脱机技术(SPOOLing)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;用户层软件&lt;/strong&gt;实现，但是408大纲将其归入I/O核心子系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-什么是脱机技术？&quot;&gt;&lt;a href=&quot;#1-1-什么是脱机技术？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是脱机技术？&quot;&gt;&lt;/a&gt;1.1 什么是脱机技术？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;这里温习一下手工操作阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111631459.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为手工阶段的速度慢问题，引入了脱机技术&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-941-有效的山脉数组</title>
    <link href="http://zhuuu.work/2020/11/03/Leetcode/Leetcode-941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2020/11/03/Leetcode/Leetcode-941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</id>
    <published>2020-11-02T23:52:53.000Z</published>
    <updated>2020-11-03T00:50:59.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-941-有效的山脉数组"><a href="#Leetcode-941-有效的山脉数组" class="headerlink" title="Leetcode-941-有效的山脉数组"></a>Leetcode-941-<a href="https://leetcode-cn.com/problems/valid-mountain-array/" target="_blank" rel="noopener">有效的山脉数组</a></h1><h2 id="思路：线性扫描"><a href="#思路：线性扫描" class="headerlink" title="思路：线性扫描"></a>思路：线性扫描</h2><p><strong>题目描述</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</span><br><span class="line"></span><br><span class="line">A.length &gt;&#x3D; 3</span><br><span class="line">在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：</span><br><span class="line">A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</span><br><span class="line">A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201103/084745146.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[2,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[3,5,5]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>思路：线性扫描</strong></p><ul><li>按照题目模拟即可，我们从数组最左侧开始向右扫描</li><li>直到找到第一个不满足<em>A</em>[<em>i</em>]&lt;<em>A</em>[<em>i</em>+1]  的下标 i ,那么 i 就是这个数组的最高点下标</li><li>如果 i = 0 或者不存在这样的 i (即整个数组单调递增)，那么就返回false</li><li>否则 从 i 开始继续向右扫描，判断接下来的下标 j 是否都满足 <em>A</em>[<em>j</em>]&gt;<em>A</em>[<em>j</em>+1] ，若都满足返回true ,不满足返回false.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查最高点左半部分</span></span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最高点不能是数组的第一个位置或者最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查最高点后半部分</span></span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; A[i] &gt; A[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否正确走到了数组最后</span></span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span> == i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n) 扫描一遍数组所需要的时间</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-941-有效的山脉数组&quot;&gt;&lt;a href=&quot;#Leetcode-941-有效的山脉数组&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-941-有效的山脉数组&quot;&gt;&lt;/a&gt;Leetcode-941-&lt;a href=&quot;https://leetcode-cn.com/problems/valid-mountain-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有效的山脉数组&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：线性扫描&quot;&gt;&lt;a href=&quot;#思路：线性扫描&quot; class=&quot;headerlink&quot; title=&quot;思路：线性扫描&quot;&gt;&lt;/a&gt;思路：线性扫描&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A.length &amp;gt;&amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 0 &amp;lt; i &amp;lt; A.length - 1 条件下，存在 i 使得：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201103/084745146.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[3,5,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[0,3,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-10-WebSocket</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-10-WebSocket/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-10-WebSocket/</id>
    <published>2020-11-02T05:05:24.000Z</published>
    <updated>2020-11-02T06:13:44.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-10-WebSocket"><a href="#Netty-10-WebSocket" class="headerlink" title="Netty-10-WebSocket"></a>Netty-10-WebSocket</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>Http 协议是无状态的，浏览器和服务器之间的请求只响应一次，下一次会重新创建连接</li><li>要求  ： 实现基于webSocket 的长连接全双工的交互</li><li>改变Http 协议多次请求的约束，实现长连接，服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li></ul><a id="more"></a><h2 id="1-启动器代码"><a href="#1-启动器代码" class="headerlink" title="1. 启动器代码"></a>1. 启动器代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//因为是基于Http协议，所以要使用Http的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    <span class="comment">//是以块方式写，添加ChunkedWriter处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 1、http数据在传输过程中是分裂的,HttpObjectAggregator就可以将多个段聚合</span></span><br><span class="line"><span class="comment">                    * 2、这就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 1、对于websocket，它的数据是以帧的形式传递的</span></span><br><span class="line"><span class="comment">                    * 2、可以看到 WebsocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                    * 3、浏览器请求时：ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                    * 4、WebSocketServerProtocolHandler 核心功能是将 http 协议升级为 ws 协议，保持长连接</span></span><br><span class="line"><span class="comment">                    * 5、从Http协议升级到Websocket协议，是通过StatusCode 101（Switching Protocols）来切换的。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/hello"</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自定义Handler，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyTextWebSocketFrameHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        ChannelFuture sync = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">        sync.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-案例总结"><a href="#2-案例总结" class="headerlink" title="2 . 案例总结"></a>2 . 案例总结</h2><ol><li><strong>创建启动类</strong></li></ol><ul><li>首先初始化两个NioEventLoopGroup。其中BossGroup一般设置线程为1</li><li>初始化一个ServerBootStrap类。并调用它设置很多参数。<ul><li><code>group()</code>：服务端设置两个Group，客户端设置一个Group</li><li><code>channel()</code>：服务端传入<code>NioServerSocketChannel</code>，客户端传入<code>NioSocketChannel</code></li><li><code>option()</code>：服务端给BossGroup设置<code>SO_BACKLOG</code>任务队列大小</li><li><code>childOption()</code>：服务端给WorkerGroup设置连接<code>SO_KEEPALIVE</code>保持连接状态</li><li><code>handler()</code>：服务端给BossGroup设置Handler，客户端设置Handler</li><li><code>childHandler()</code>：服务端给WorkerGroup设置Handler。</li></ul></li><li>通过BootStrap去绑定端口，监听关闭事件。设置为异步拿到ChannelFuture对象</li></ul><ol start="2"><li><strong>Handler 处理逻辑</strong></li></ol><ul><li><code>SimpleChannelInboundHandler</code><ul><li>可以继承它来处理很多通信。经过上面几个案例推敲，一般写自己的Handler继承它就可以了</li></ul></li><li><code>ChannelInboundHandlerAdapter</code><ul><li>这个是上一个的父类，我们在心跳检测的时候通过继承它的<code>userEventTriggered</code>去判断连接状态</li><li>其实通过上面那个<code>simple</code>也可以继承这个<code>trigger</code></li></ul></li><li><code>IdleStateHandler</code><ul><li>在心跳检测时我们要通过这个Handler去触发上面的<code>trigger</code></li></ul></li><li><code>HttpServerCodec</code><ul><li>提供好的用于Http编码解码，一般用于Http请求</li></ul></li><li><code>ChunkedWriteHandler</code><ul><li>提供好的Handler，以块方式写，添加ChunkedWriter处理器</li><li>我搜了一下，它一般用于发送大文件。这个东西使我们在Websocket的时候用的。</li></ul></li><li><code>HttpObjectAggregator</code><ul><li>它会将http数据聚合在一起发送</li></ul></li><li><code>WebSocketServerProtocolHandler</code><ul><li>传入ws路径，将Http协议升级成为ws协议</li></ul></li></ul><ol start="3"><li><strong>netty 中通信数据实体</strong></li></ol><ul><li><code>TextWebSocketFrame</code><ul><li>这是我们在websocket连接的时候用的，它表示一个文本帧，是websocket进行通信的数据形式</li></ul></li><li><code>HttpObject</code><ul><li>这是我们在建立Http连接的时候用到的，可以将它转换成一个<code>HttpRequest</code></li></ul></li></ul><ol start="4"><li><strong>Handler 常用方法</strong></li></ol><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>channelRead0(ChannelHandlerContext channelHandlerContext, T t)</code></td><td>读取数据，并进行消息转发</td></tr><tr><td><code>handlerAdded(ChannelHandlerContext ctx)</code></td><td>连接建立，一旦建立连接，就第一个被执行</td></tr><tr><td><code>channelActive(ChannelHandlerContext ctx)</code></td><td>表示 channel 处于活动状态，提示 xxx 上线</td></tr><tr><td><code>channelInactive(ChannelHandlerContext ctx)</code></td><td>表示 channel 处于不活动状态，提示 xxx 离线</td></tr><tr><td><code>handlerRemoved(ChannelHandlerContext ctx)</code></td><td>表示 channel 断开连接，将xx客户离开信息推送给当前在线客户</td></tr><tr><td><code>exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code></td><td>出现错误如何进行处理</td></tr><tr><td><code>userEventTriggered(ChannelHandlerContext ctx, Object evt)</code></td><td>事件触发器，通过判断evt的类型去判断发生了什么事件，再通过里面的属性判断事件发生的类型。我们在<code>IdleStateHandler</code>后面加上一个触发器，可以检测心跳。</td></tr></tbody></table><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-10-WebSocket&quot;&gt;&lt;a href=&quot;#Netty-10-WebSocket&quot; class=&quot;headerlink&quot; title=&quot;Netty-10-WebSocket&quot;&gt;&lt;/a&gt;Netty-10-WebSocket&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Http 协议是无状态的，浏览器和服务器之间的请求只响应一次，下一次会重新创建连接&lt;/li&gt;
&lt;li&gt;要求  ： 实现基于webSocket 的长连接全双工的交互&lt;/li&gt;
&lt;li&gt;改变Http 协议多次请求的约束，实现长连接，服务器可以发送消息给浏览器&lt;/li&gt;
&lt;li&gt;客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="WebSocket" scheme="http://zhuuu.work/tags/WebSocket/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty-11-ProtoBuf</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-11-ProtoBuf/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-11-ProtoBuf/</id>
    <published>2020-11-02T05:05:24.000Z</published>
    <updated>2020-11-04T05:51:08.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-11-ProtoBuf"><a href="#Netty-11-ProtoBuf" class="headerlink" title="Netty-11-ProtoBuf"></a>Netty-11-ProtoBuf</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>编写网络应用程序时，因为<strong>数据在网络中传输的都是二进制字节码数据</strong>，在发送数据的时候就需要编码，接收数据时候就需要解码</li><li><strong>codec(编解码器)的组成部分有两个</strong><ul><li><code>decoder</code>(解码器) ： 负责把字节码数据转换成业务逻辑</li><li><code>encoder</code>(编码器) ： 负责把业务数据转换成字节码数据</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/084813142.png" alt="mark"></p><a id="more"></a><h2 id="1-Netty-提供的编解码机制"><a href="#1-Netty-提供的编解码机制" class="headerlink" title="1. Netty 提供的编解码机制"></a>1. Netty 提供的编解码机制</h2><ul><li>Netty 本身的编解码器的机制和问题分析（为什么要引入<code>protobuf</code> ?）</li><li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)<ul><li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li><li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li></ul></li><li><strong><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，</strong>存在如下问题<ul><li>无法跨语言</li><li>序列化后的体积太大，是二进制编码的5倍多</li><li>序列化性能太低</li></ul></li></ul><p><strong>于是引出了新的解决方案（Google Protobuf）</strong></p><h2 id="2-ProtoBuf-简介"><a href="#2-ProtoBuf-简介" class="headerlink" title="2. ProtoBuf 简介"></a>2. ProtoBuf 简介</h2><p><strong>1. Google ProtoBuf 参考文档</strong>：</p><ul><li><a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/proto</a> <strong>语言指南</strong></li></ul><p><strong>2. 简介概述</strong></p><ul><li>首先，<strong>ProtoBuf 是用来将对象进行序列化的</strong>，相类似的技术还有<code>Json</code> 序列化等等，它是一种高效的结构化数据存储格式，</li><li>可以用于结构化数据串行化（序列化）。它很适合做数据存储或者<strong>RPC(远程工程调用)数据交换格式</strong> （目前很多公司 <code>http + json || tcp + protobuf</code>）</li><li><strong>ProtoBuf 是以 message的方式来管理数据的</strong></li></ul><p><strong>3. 优点：</strong></p><ul><li><strong>支持跨平台跨语言</strong> 【即客户端可以使用不同的语言编写】<ul><li>支持目前绝大多数语言，例如 C++、C#、Java、python 等</li></ul></li><li><strong>使用 protobuf 编译器能自动生成代码</strong></li><li><code>protobuf</code> 是将 类的定义使用<code>.proto</code> 文件进行描述<ul><li>说明，在<code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.proto</code> 编写插件，可以让语法高亮</li><li><strong>然后通过 <code>proto.exe</code> 编译器根据 <code>.proto</code> 自动的生成java 文件</strong></li></ul></li></ul><p><strong>使用示意图 ：</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/085943886.png" alt="mark"></p><h2 id="3-Proto-文件格式"><a href="#3-Proto-文件格式" class="headerlink" title="3. Proto 文件格式"></a>3. Proto 文件格式</h2><ul><li><strong>首先我们需要在<code>.proto</code>文件中定义好实体及他们的属性，再进行编译成<code>java</code>对象为我们所用。下面将介绍<code>proto</code>文件的写法。</strong></li></ul><ol><li><strong>文件头</strong></li></ol><ul><li>像写<code>java</code>需要写<code>package</code>包名一样，<code>.proto</code>文件也要写一些文件的全局属性，主要用于将<code>.proto</code>文件编译成<code>Java</code>文件。</li></ul><table><thead><tr><th><code>实例</code></th><th><code>介绍</code></th></tr></thead><tbody><tr><td><code>syntax=&quot;proto3&quot;;</code></td><td>声明使用到的protobuf的版本</td></tr><tr><td><code>optimize_for=SPEED;</code></td><td>表示</td></tr><tr><td><code>java_package=&quot;com.mical.netty.pojo&quot;;</code></td><td>表示生成Java对象所在包名</td></tr><tr><td><code>java_outer_classname=&quot;MyWorker&quot;;</code></td><td>表示生成的Java对象的外部类名</td></tr></tbody></table><ul><li>我们一般将这些代码写在<code>proto</code>文件的开头，以表明生成<code>Java</code>对象的相关文件属性。</li></ul><ol start="2"><li><strong>定义类和属性</strong></li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">//版本</span></span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; <span class="comment">//加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"MyDataInfo"</span>; <span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123; <span class="comment">//会在StudentPojo 外部类生成一个内部类Student，他是真正发送的pojo对象</span></span><br><span class="line">    <span class="built_in">int32</span> id = <span class="number">1</span>; <span class="comment">//Student类中有一个属性名字为ID，类型为int32（protobuf类型），1表示序号，不是值</span></span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DateType</span> </span>&#123;</span><br><span class="line">    StudentType = <span class="number">0</span>; <span class="comment">//在proto3中，要求enum的编号从0开始</span></span><br><span class="line">    WorkerType = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如上图所示，我们在文件中不但声明了<code>protobuf</code>的版本，还声明了生成java对象的类名。当生成java对象后，<code>MyDataInfo</code>将是对象的类名，同时，它使用<code>message</code>声明了<code>Student</code>这个内部类，使用<code>enum</code>声明了<code>DataType</code>这个内部枚举类。就像下面这个样子</p></li><li><p><code>messag</code>：声明类。</p></li><li><p><code>enum</code>：声明枚举类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> DataType &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要注意的是，protobuf中的变量类型和其他语言的声明有所不同。下面是<strong>类型的对照表</strong>。</p><table><thead><tr><th>.proto类型</th><th>java类型</th><th>C++类型</th><th>备注</th></tr></thead><tbody><tr><td><strong>double</strong></td><td><strong>double</strong></td><td><strong>double</strong></td><td></td></tr><tr><td><strong>float</strong></td><td><strong>float</strong></td><td><strong>float</strong></td><td></td></tr><tr><td><strong>int32</strong></td><td><strong>int</strong></td><td><strong>int32</strong></td><td><strong>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint32。</strong></td></tr><tr><td><strong>int64</strong></td><td><strong>long</strong></td><td><strong>int64</strong></td><td><strong>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint64。</strong></td></tr><tr><td>unit32</td><td>int[1]</td><td>unit32</td><td>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。</td></tr><tr><td>unit64</td><td>long[1]</td><td>unit64</td><td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td></tr><tr><td>sint32</td><td>int</td><td>int32</td><td>使用可变长编码方式。有符号的整型值。编码时比通常的int32高效。</td></tr><tr><td>sint64</td><td>long</td><td>int64</td><td>使用可变长编码方式。有符号的整型值。编码时比通常的int64高效。</td></tr><tr><td>fixed32</td><td>int[1]</td><td>unit32</td><td></td></tr><tr><td>fixed64</td><td>long[1]</td><td>unit64</td><td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td></tr><tr><td>sfixed32</td><td>int</td><td>int32</td><td>总是4个字节。</td></tr><tr><td>sfixed64</td><td>long</td><td>int64</td><td>总是8个字节。</td></tr><tr><td><strong>bool</strong></td><td><strong>boolean</strong></td><td><strong>bool</strong></td><td></td></tr><tr><td><strong>string</strong></td><td><strong>String</strong></td><td><strong>string</strong></td><td><strong>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</strong></td></tr><tr><td>bytes</td><td>ByteString</td><td>string</td><td>可能包含任意顺序的字节数据</td></tr></tbody></table><ul><li>类型关注之后,我们看到代码中<code>string name = 2</code>，它并不是给name这个变量赋值，而是给它标号。每个类都需要给其中的变量标号，且需要注意的是类的标号是从1开始的，枚举的标号是从0开始的。</li></ul><ol start="3"><li><strong>复杂对象</strong></li></ol><ul><li>当我们<strong>需要统一发送对象和接受对象时，就需要使用一个对象将其他所有对象进行包装</strong>，再获取里面的某一类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">//版本</span></span><br><span class="line">option optimize_for = SPEED; <span class="comment">//加快解析</span></span><br><span class="line">option java_outer_classname = <span class="string">"MyDataInfo"</span>; <span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"></span><br><span class="line">message MyMessage &#123;</span><br><span class="line">    <span class="comment">//定义一个枚举类型</span></span><br><span class="line">    <span class="keyword">enum</span> DateType &#123;</span><br><span class="line">        StudentType = <span class="number">0</span>; <span class="comment">//在proto3中，要求enum的编号从0开始</span></span><br><span class="line">        WorkerType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用data_type来标识传的是哪一个枚举类型</span></span><br><span class="line">    DateType data_type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识每次枚举类型最多只能出现其中的一个类型，节省空间</span></span><br><span class="line">    oneof dataBody &#123;</span><br><span class="line">        Student stuent = <span class="number">2</span>;</span><br><span class="line">        Worker worker = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Student &#123; <span class="comment">//会在StudentPojo 外部类生成一个内部类Student，他是真正发送的pojo对象</span></span><br><span class="line">    int32 id = <span class="number">1</span>; <span class="comment">//Student类中有一个属性名字为ID，类型为int32（protobuf类型），1表示序号，不是值</span></span><br><span class="line">    string name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">message Worker &#123;</span><br><span class="line">    string name = <span class="number">1</span>;</span><br><span class="line">    int32 age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里面我们定义了<code>MyMessage</code>、<code>Student</code>、<code>Worker</code>三个对象</li><li><code>MyMessage</code>里面持有了一个枚举类<code>DataType</code>和，<code>Student</code>、<code>Worker</code>这两个类对象中的其中一个。</li><li>这样设计的目的是什么呢？当我们在发送对象时，设置<code>MyMessage</code>里面的对象的同时就可以给枚举赋值，这样当我们接收对象时，就可以根据枚举判断我们接受到哪个实例类了。</li></ul><h2 id="4-Netty-ProtoBuf编解码器"><a href="#4-Netty-ProtoBuf编解码器" class="headerlink" title="4. Netty ProtoBuf编解码器"></a>4. Netty ProtoBuf编解码器</h2><h3 id="4-1-发送端"><a href="#4-1-发送端" class="headerlink" title="4.1 发送端"></a>4.1 发送端</h3><ol><li>需要给发送端的<code>pipeline</code>添加编码器：<code>ProtobufEncoder</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(group)</span><br><span class="line">    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ProtoClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>在发送时，如何<strong>构造一个具体对象</strong>呢？以上面复杂对象为例，我们主要构造的是<code>MyMessage</code>对象，设置里面的枚举属性，和对应的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyDataInfo.MyMessage build = MyDataInfo.MyMessage.</span><br><span class="line">    newBuilder().</span><br><span class="line">    setDataType(MyDataInfo.MyMessage.DateType.StudentType)</span><br><span class="line">    .setStuent(MyDataInfo.Student</span><br><span class="line">                        .newBuilder()</span><br><span class="line">               .setId(<span class="number">5</span>)</span><br><span class="line">               .setName(<span class="string">"王五"</span>)</span><br><span class="line">               .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="4-2-接收端"><a href="#4-2-接收端" class="headerlink" title="4.2 接收端"></a>4.2 接收端</h3><ol><li>需要在接收端添加解码器：<code>ProtobufDecoder</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>())</span></span><br><span class="line"><span class="class">    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128)</span></span><br><span class="line"><span class="class">    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            <span class="comment">//需要指定对哪种对象进行解码</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ProtoServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>在接收对象时，我们就可以根据枚举变量去获取实例对象了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyDataInfo.MyMessage message = (MyDataInfo.MyMessage) msg;</span><br><span class="line">MyDataInfo.MyMessage.DateType dataType = message.getDataType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (dataType) &#123;</span><br><span class="line">    <span class="keyword">case</span> StudentType:</span><br><span class="line">        MyDataInfo.Student student = message.getStuent();</span><br><span class="line">        System.out.println(<span class="string">"学生Id = "</span> + student.getId() + student.getName());</span><br><span class="line">    <span class="keyword">case</span> WorkerType:</span><br><span class="line">        MyDataInfo.Worker worker = message.getWorker();</span><br><span class="line">        System.out.println(<span class="string">"工人：name = "</span> + worker.getName() + worker.getAge());</span><br><span class="line">    <span class="keyword">case</span> UNRECOGNIZED:</span><br><span class="line">        System.out.println(<span class="string">"输入的类型不正确"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote><p><strong>参考博客 ：</strong> <a href="https://dongzl.github.io/netty-handbook/#/README" target="_blank" rel="noopener">https://dongzl.github.io/netty-handbook/#/README</a></p><p><strong>idea 使用 protobuf 问题 ：</strong> <a href="https://www.cnblogs.com/liugh/p/7505533.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugh/p/7505533.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-11-ProtoBuf&quot;&gt;&lt;a href=&quot;#Netty-11-ProtoBuf&quot; class=&quot;headerlink&quot; title=&quot;Netty-11-ProtoBuf&quot;&gt;&lt;/a&gt;Netty-11-ProtoBuf&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编写网络应用程序时，因为&lt;strong&gt;数据在网络中传输的都是二进制字节码数据&lt;/strong&gt;，在发送数据的时候就需要编码，接收数据时候就需要解码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;codec(编解码器)的组成部分有两个&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;decoder&lt;/code&gt;(解码器) ： 负责把字节码数据转换成业务逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoder&lt;/code&gt;(编码器) ： 负责把业务数据转换成字节码数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/084813142.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="ProtoBuf" scheme="http://zhuuu.work/tags/ProtoBuf/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-059-螺旋矩阵II</title>
    <link href="http://zhuuu.work/2020/11/02/Leetcode/Leetcode-059-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <id>http://zhuuu.work/2020/11/02/Leetcode/Leetcode-059-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</id>
    <published>2020-11-02T03:52:53.000Z</published>
    <updated>2020-11-05T06:15:36.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-059-螺旋矩阵-II"><a href="#Leetcode-059-螺旋矩阵-II" class="headerlink" title="Leetcode-059-螺旋矩阵 II"></a>Leetcode-059-<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">螺旋矩阵 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em> 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：模拟"><a href="#思路-：模拟" class="headerlink" title="思路 ：模拟"></a><strong>思路 ：模拟</strong></h2><ul><li>定义当前左右上下边界 <code>l,r,t,b</code>，初始值 <code>num = 1</code>，迭代终止值 <code>tar = n * n</code>；</li><li>当 <code>num &lt;= tar</code> 时，始终按照 <code>从左到右</code> <code>从上到下</code> <code>从右到左</code> <code>从下到上</code> 填入顺序循环，每次填入后：<ul><li>执行 <code>num += 1</code>：得到下一个需要填入的数字；</li><li>更新边界：例如从左到右填完后，上边界<code>t += 1</code>，相当于上边界向内缩 1。</li></ul></li><li><strong>使用<code>num &lt;= tar</code>而不是<code>l &lt; r || t &lt; b</code>作为迭代条件，是为了解决当<code>n</code>为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  矩阵初始化 边界初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = matrix.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起始数字和终止数字</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = n * n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= target)&#123;</span><br><span class="line">            <span class="comment">// 从左到右</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r ; i++) &#123;</span><br><span class="line">                matrix[t][i] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            t++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b ; i++) &#123;</span><br><span class="line">                matrix[i][r] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            r--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从右到左</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l ; i--) &#123;</span><br><span class="line">                matrix[b][i] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            b--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从下到上</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t ; i--) &#123;</span><br><span class="line">                matrix[i][l] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n^2) 矩阵元素的个数</li><li>空间复杂度:   O(1) 除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-059-螺旋矩阵-II&quot;&gt;&lt;a href=&quot;#Leetcode-059-螺旋矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-059-螺旋矩阵 II&quot;&gt;&lt;/a&gt;Leetcode-059-&lt;a href=&quot;https://leetcode-cn.com/problems/spiral-matrix-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;螺旋矩阵 II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;，生成一个包含 1 到 &lt;em&gt;n&lt;/em&gt; 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 1, 2, 3 ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 8, 9, 4 ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 7, 6, 5 ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-09-心跳检测机制</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-09-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-09-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-02T02:05:24.000Z</published>
    <updated>2020-11-02T02:48:09.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-09-心跳检测机制"><a href="#Netty-09-心跳检测机制" class="headerlink" title="Netty-09-心跳检测机制"></a>Netty-09-心跳检测机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲</li><li>当服务器超过5秒没有写操作时，就提示写空闲</li><li>实现当服务器超过7秒没有读或者写操作时，就提示读写空闲</li></ul><a id="more"></a><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1. 服务端代码"></a>1. 服务端代码</h2><h3 id="1-1-启动类"><a href="#1-1-启动类" class="headerlink" title="1.1 启动类"></a>1.1 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>)) // 为<span class="title">bossGroup</span>请求日志处理<span class="title">handler</span></span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入一个netty提供的IdleStateHandler</span></span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                             * 1. IdleStateHandler 是netty提供的检测空闲状态的处理器</span></span><br><span class="line"><span class="comment">                             * 2. long readerIdleTime 表示多长事件没有读，就会发送一个心跳检测包检测是否还是连接状态</span></span><br><span class="line"><span class="comment">                             * 3、long writerIdleTime：表示多长时间没有写，就会发送一个心跳检测包检测是否还是连接的状态</span></span><br><span class="line"><span class="comment">                             * 4、long allIdleTime：表示多长时间没有读写，就会发送一个心跳检测包检测是否还是连接的状态</span></span><br><span class="line"><span class="comment">                             * 5、当 IdleStateEvent 触发后，就会传递给管道的下一个 Handler，通过调用（触发）下一个Handler的 userEventTriggered，在该方法区处理这个事件。</span></span><br><span class="line"><span class="comment">                             *</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入一个对空闲检测进一步处理的Handler(自定义)</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//启动服务器，设置为同步模式。</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Handler"><a href="#1-2-Handler" class="headerlink" title="1.2 Handler"></a>1.2 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.EventExecutorGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="comment">// 将evt向下转型成IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断空闲事件类型</span></span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() +<span class="string">"---超时时间--"</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理....."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2. 客户端代码"></a>2. 客户端代码</h2><h3 id="2-1-客户端代码"><a href="#2-1-客户端代码" class="headerlink" title="2.1 客户端代码"></a>2.1 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(eventExecutors)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入Handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// connect 事件</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">// 得到channel,打印本地地址</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"--------"</span> + channel.localAddress() + <span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端需要输入信息</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">// 通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">"127.0.0.1"</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Handler"><a href="#2-2-Handler" class="headerlink" title="2.2  Handler"></a>2.2  Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-09-心跳检测机制&quot;&gt;&lt;a href=&quot;#Netty-09-心跳检测机制&quot; class=&quot;headerlink&quot; title=&quot;Netty-09-心跳检测机制&quot;&gt;&lt;/a&gt;Netty-09-心跳检测机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲&lt;/li&gt;
&lt;li&gt;当服务器超过5秒没有写操作时，就提示写空闲&lt;/li&gt;
&lt;li&gt;实现当服务器超过7秒没有读或者写操作时，就提示读写空闲&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-23-IO管理</title>
    <link href="http://zhuuu.work/2020/11/01/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-23-IO%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/11/01/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-23-IO%E7%AE%A1%E7%90%86/</id>
    <published>2020-11-01T03:00:53.000Z</published>
    <updated>2020-11-02T03:04:15.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-23-IO管理"><a href="#操作系统-23-IO管理" class="headerlink" title="操作系统-23-IO管理"></a>操作系统-23-IO管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先了解一下什么是IO 设备</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112638277.png" alt="mark"></p><a id="more"></a><h2 id="1-IO-控制器"><a href="#1-IO-控制器" class="headerlink" title="1. IO 控制器"></a>1. IO 控制器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112847048.png" alt="mark"></p><ol><li><strong>机械部件</strong></li></ol><ul><li>执行具体的I/O操作，比如鼠标键盘的按钮，显示器的屏幕，移动硬盘的磁臂</li></ul><ol start="2"><li><strong>电子部件</strong></li></ol><ul><li><strong>CPU和机械部件的中介</strong>，通常是插入主板的电路板</li><li><strong>又叫I/O控制器，设备控制器</strong></li></ul><ol start="3"><li><strong>IO 控制器的组成</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/113021745.png" alt="mark"></p><ol start="4"><li><strong>IO 控制器两种寄存器编址方式</strong></li></ol><ul><li>内存映像</li><li>独立编址</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/113207976.png" alt="mark"></p><h2 id="2-IO-控制方式"><a href="#2-IO-控制方式" class="headerlink" title="2. IO 控制方式"></a>2. IO 控制方式</h2><ul><li><strong>有以下四种IO 控制方式</strong><ul><li><strong>程序直接控制</strong></li><li><strong>中断驱动方式</strong></li><li><strong>直接存储器存取DMA 方式</strong></li><li><strong>通道控制方式</strong></li></ul></li></ul><h3 id="2-1-程序直接控制"><a href="#2-1-程序直接控制" class="headerlink" title="2.1 程序直接控制"></a>2.1 程序直接控制</h3><ul><li>流程图如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/151737147.png" alt="mark"></p><h3 id="2-2-中断驱动方式"><a href="#2-2-中断驱动方式" class="headerlink" title="2.2 中断驱动方式"></a>2.2 中断驱动方式</h3><ul><li>流程图如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152102370.png" alt="mark"></p><h3 id="2-3-DMA-方式"><a href="#2-3-DMA-方式" class="headerlink" title="2.3 DMA 方式"></a><strong>2.3 DMA 方式</strong></h3><ol><li><strong>DMA 控制器图</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152156189.png" alt="mark"></p><ol start="2"><li><strong>流程图如下</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152438653.png" alt="mark"></p><h3 id="2-4-通道处理方式"><a href="#2-4-通道处理方式" class="headerlink" title="2.4 通道处理方式"></a>2.4 通道处理方式</h3><ol><li><strong>通道的概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152751952.png" alt="mark"></p><ol start="2"><li><strong>流程图</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153050863.png" alt="mark"></p><h3 id="2-5-小结对比"><a href="#2-5-小结对比" class="headerlink" title="2.5 小结对比"></a>2.5 小结对比</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153109627.png" alt="mark"></p><h2 id="3-IO-软件层次"><a href="#3-IO-软件层次" class="headerlink" title="3. IO 软件层次"></a>3. IO 软件层次</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/105845878.png" alt="mark"></p><h3 id="3-1-用户层软件"><a href="#3-1-用户层软件" class="headerlink" title="3.1 用户层软件"></a>3.1 用户层软件</h3><ul><li>向下提供系统调用</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/105904327.png" alt="mark"></p><h3 id="3-2-设备独立性软件"><a href="#3-2-设备独立性软件" class="headerlink" title="3.2 设备独立性软件"></a>3.2 设备独立性软件</h3><p><strong>功能</strong></p><ul><li>提供调用接口(read/write系统调用) </li><li>设备保护 </li><li>差错处理 </li><li><strong>设备分配与回收</strong> </li><li><strong>数据缓冲区管理</strong> </li><li><strong>建立逻辑设备名到物理设备名的映射关系</strong> </li><li>根据设备类型调用相应的驱动程序</li></ul><p><strong>逻辑设备表 LUT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110032068.png" alt="mark"></p><h3 id="3-3-设备驱动程序"><a href="#3-3-设备驱动程序" class="headerlink" title="3.3 设备驱动程序"></a>3.3 设备驱动程序</h3><ul><li>设置设备的寄存器</li><li>检测设备状态</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110122761.png" alt="mark"></p><h3 id="3-4-中断处理程序"><a href="#3-4-中断处理程序" class="headerlink" title="3.4 中断处理程序"></a>3.4 中断处理程序</h3><ul><li><strong>一次IO 请求的流程</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110157329.png" alt="mark"></p><ul><li><strong>中断处理逻辑</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110412976.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考笔记 ：</strong> <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-23-IO管理&quot;&gt;&lt;a href=&quot;#操作系统-23-IO管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-23-IO管理&quot;&gt;&lt;/a&gt;操作系统-23-IO管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先了解一下什么是IO 设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112638277.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-22-磁盘调度算法</title>
    <link href="http://zhuuu.work/2020/11/01/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/11/01/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-01T02:00:53.000Z</published>
    <updated>2020-11-01T03:24:21.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-22-磁盘调度算法"><a href="#操作系统-22-磁盘调度算法" class="headerlink" title="操作系统-22-磁盘调度算法"></a>操作系统-22-磁盘调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111815980.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><a id="more"></a><h2 id="1-一次读磁盘所需要的时间"><a href="#1-一次读磁盘所需要的时间" class="headerlink" title="1. 一次读磁盘所需要的时间"></a>1. 一次读磁盘所需要的时间</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111926789.png" alt="mark"></p><h2 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2. 磁盘调度算法"></a>2. 磁盘调度算法</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。</p><p>寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p><h3 id="2-1-先来先服务"><a href="#2-1-先来先服务" class="headerlink" title="2.1 先来先服务"></a>2.1 先来先服务</h3><ul><li><p>先来先服务（<em>First-Come，First-Served，FCFS</em>），顾名思义，先到来的请求，先被服务。</p></li><li><p>那按照这个序列的话：</p><p><code>98，183，37，122，14，124，65，67</code></p><p>那么，磁盘的写入顺序是从左到右，如下图：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144809106.png" alt="mark"></p><ul><li>先来先服务算法总共移动了 <code>640</code> 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</li></ul><h3 id="2-2-最短寻道时间优先"><a href="#2-2-最短寻道时间优先" class="headerlink" title="2.2 最短寻道时间优先"></a>2.2 最短寻道时间优先</h3><ul><li>最短寻道时间优先（<em>Shortest Seek First，SSF</em>）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</li></ul><p><code>98，183，37，122，14，124，65，67</code></p><ul><li>那么，那么根据距离磁头（ 53 位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：</li></ul><p><code>65，67，37，14，98，122，124，183</code></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144946962.png" alt="mark"></p><ul><li>磁头移动的总距离是 <code>236</code> 磁道，相比先来先服务性能提高了不少。<ul><li>但这个算法可能存在某些请求的<strong>饥饿</strong>，因为本次例子我们是静态的序列，看不出问题，</li><li>假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里<strong>产生饥饿的原因是磁头在一小块区域来回移动</strong>。</li></ul></li></ul><h3 id="2-3-扫描算法"><a href="#2-3-扫描算法" class="headerlink" title="2.3 扫描算法"></a>2.3 扫描算法</h3><ul><li>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</li><li>为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（Scan）算法</strong>。</li><li>这种算法也叫做<strong>电梯算法</strong>，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">37，14，0，65，67，98，122，124，183</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145111421.png" alt="mark"></p><ul><li>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</li><li>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题<ul><li><strong>中间部分的磁道会比较占便宜</strong>，中间部分相比其他部分<strong>响应的频率会比较多</strong>，也就是说每个磁道的响应频率存在差异。</li></ul></li></ul><h3 id="2-4-循环扫描算法"><a href="#2-4-循环扫描算法" class="headerlink" title="2.4 循环扫描算法"></a>2.4 循环扫描算法</h3><ul><li>扫描算法使得每个磁道响应的频率存在差异，那么<strong>要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</strong></li></ul><ul><li>循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而<strong>返回时直接快速移动至最靠边缘的磁道，也就是复位磁头</strong>，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">65，67，98，122，124，183，199，0，14，37</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145234782.png" alt="mark"></p><ul><li>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</li><li>循环扫描算法相比于扫描算法，对于<strong>各个位置磁道响应频率相对比较平均。</strong></li></ul><h3 id="2-5-LOOK-与-C-LOOK算法"><a href="#2-5-LOOK-与-C-LOOK算法" class="headerlink" title="2.5 LOOK 与 C-LOOK算法"></a>2.5 LOOK 与 C-LOOK算法</h3><ul><li>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</li><li>那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></li><li>那<strong>针对 SCAN 算法的优化则叫 LOOK 算法</strong>，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145437467.png" alt="mark"></p><ul><li>而针 <strong>C-SCAN 算法的优化则叫 C-LOOK</strong>，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145453441.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-22-磁盘调度算法&quot;&gt;&lt;a href=&quot;#操作系统-22-磁盘调度算法&quot; class=&quot;headerlink&quot; title=&quot;操作系统-22-磁盘调度算法&quot;&gt;&lt;/a&gt;操作系统-22-磁盘调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111815980.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="磁盘管理" scheme="http://zhuuu.work/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket理解</title>
    <link href="http://zhuuu.work/2020/11/01/NetworkCoding/WebSocket%E7%90%86%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/11/01/NetworkCoding/WebSocket%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-01T01:02:24.000Z</published>
    <updated>2020-11-01T01:56:34.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket理解"><a href="#WebSocket理解" class="headerlink" title="WebSocket理解"></a>WebSocket理解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）</strong></li><li>首先HTTP有<code>1.1</code>和<code>1.0</code>之说，也就是所谓的<code>keep-alive</code>，把多个HTTP请求合并为一个，但是<strong><code>Websocket</code>其实是一个新协议，跟HTTP协议基本没有关系</strong>，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/093305644.png" alt="mark"></p><p>有交集，但是并不是全部。</p><ul><li>另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。</li><li>通俗来说，你可以用HTTP<strong>协议</strong>传输非Html<strong>数据</strong>，就是这样=。=</li><li>再简单来说，<strong>层级不一样</strong>。</li></ul><a id="more"></a><h2 id="1-WebSocket概念"><a href="#1-WebSocket概念" class="headerlink" title="1. WebSocket概念"></a>1. WebSocket概念</h2><ul><li>首先，Websocket是一个<strong>持久化</strong>的协议，相对于HTTP这种<strong>非持久</strong>的协议来说。</li></ul><p>简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。</p><ol><li>HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么<strong>在</strong>HTTP1.0<strong>中</strong>，这次HTTP请求就结束了。</li><li>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。</li><li>但是请记住 Request = Response ， <strong>在HTTP中永远是这样，也就是说一个request只能有一个response</strong>。而且这个response也是<strong>被动</strong>的，不能主动发起。</li></ol><p><strong>HTTP 和 WebSocket 的关系</strong></p><ul><li><p>首先Websocket是基于HTTP协议的，或者说<strong>借用</strong>了HTTP的协议来完成一部分握手。</p></li><li><p>在握手阶段是一样的</p></li><li><p>然后我们来看个典型的WebSocket 握手</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。<br>我会顺便讲解下作用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>这个就是Websocket的核心了，告诉Apache、Nginx等服务器：<strong>注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>首先，Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器：<strong>泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。</strong></p></li><li><p>然后，Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：<strong>今晚我要服务A，别搞错啦~</strong></p></li><li><p>最后，Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft（协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦<del>大家都使用的一个东西</del> 脱水：<strong>服务员，我要的是13岁的噢→_→</strong></p></li></ol><ul><li>然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>依然是固定的，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。</p><p>然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。服务器：<strong>好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。</strong><br>后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。</p><p><strong>至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。</strong></p><h2 id="2-WebSocket的作用"><a href="#2-WebSocket的作用" class="headerlink" title="2. WebSocket的作用"></a>2. WebSocket的作用</h2><p>在讲Websocket之前，我就<strong>顺带着讲下 long poll 和 ajax轮询 的原理</strong>。</p><ol><li><strong>首先是 ajax轮询 ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">场景再现：</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：没有（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：没有。。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：你好烦啊，没有啊。。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line">服务端：好啦好啦，有啦给你。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line">服务端：。。。。。没。。。。没。。。没有（Response） ---- loop</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>long poll</strong></li></ol><ul><li>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，</li><li>不过采取的是<strong>阻塞模型</strong>（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。</li><li>直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）</span><br><span class="line">服务端：额。。 等待到有消息的时候。。来 给你（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</span><br></pre></td></tr></table></figure><p><strong>注意 ： 上面的共性</strong></p><ul><li><p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理</p></li><li><p>可以体现HTTP协议的另外一个特点，<strong>被动性</strong>。</p><ul><li>何为被动性呢，其实就是，<strong>服务端不能主动联系客户端，只能有客户端发起。</strong></li></ul></li><li><p>缺点：</p><ul><li>很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。</li><li><strong>ajax轮询 需要服务器有很快的处理速度和资源。（速度）</strong></li><li><strong>long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</strong></li></ul></li></ul><p><strong>所以ajax轮询 和long poll 都有可能发生这种情况。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦啦，有新信息么？</span><br><span class="line">服务端：月线正忙，请稍后再试（503 Server Unavailable）</span><br><span class="line">客户端：。。。。好吧，啦啦啦，有新信息么？</span><br><span class="line">服务端：月线正忙，请稍后再试（503 Server Unavailable）</span><br></pre></td></tr></table></figure><ul><li>通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。</li><li>HTTP还是一个<strong>无状态协议</strong>。<ul><li>通俗的说就是，服务器因为每天要接待太多客户了，是个<strong>健忘鬼</strong>，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。</li></ul></li></ul><h3 id="2-1-WebSocket-的诞生"><a href="#2-1-WebSocket-的诞生" class="headerlink" title="2.1 WebSocket 的诞生"></a>2.1 WebSocket 的诞生</h3><ul><li>所以在这种情况下出现了，Websocket出现了。</li><li>他解决了HTTP的这几个难题。<ul><li>首先，<strong>被动性</strong>，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">所以上面的情景可以做如下修改。</span><br><span class="line">客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）</span><br><span class="line">服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）</span><br><span class="line">客户端：麻烦你有信息的时候推送给我噢。。</span><br><span class="line">服务端：ok，有的时候会告诉你的。</span><br><span class="line">服务端：balabalabalabala服务端：balabalabalabala</span><br><span class="line">服务端：哈哈哈哈哈啊哈哈哈哈服务端：笑死我了哈哈哈哈哈哈哈</span><br></pre></td></tr></table></figure><ul><li><p>只需要经过<strong>一次HTTP请求</strong>，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做<strong>回调</strong>，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）</p></li><li><p>那么为什么他会<strong>解决服务器上消耗资源</strong>的问题呢？</p><ul><li>其实我们所用的程序是要经过两层代理的，即<strong>HTTP协议在Nginx等服务器的解析下</strong>，然后再传送给相应的<strong>Handler（PHP等）</strong>来处理。</li><li>简单地说，我们有一个非常快速的接<strong>线员（Nginx）</strong>，他负责把问题转交给相应的<strong>客服（Handler）</strong>。</li><li>本身<strong>接线员基本上速度是足够的</strong>，但是每次都卡在<strong>客服（Handler）</strong>了，老有<strong>客服</strong>处理速度太慢。，导致客服不够。</li><li>Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持<strong>久连接</strong>，有信息的时候客服想办法通知接线员，然后<strong>接线员</strong>在统一转交给客户。</li></ul></li></ul><ul><li><p>同时，在传统的方式上，要不断的建立，关闭HTTP协议</p><ul><li>由于HTTP是非状态性的，每次都要<strong>重新传输identity info（鉴别信息）</strong>，来告诉服务端你是谁。</li><li>虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的<strong>处理时间</strong>，而且还会在网路传输中消耗<strong>过多的流量/时间。</strong></li><li>但是Websocket只需要<strong>一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中</strong>，</li><li>也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。</li></ul></li><li><p>同时由<strong>客户主动询问</strong>，转换为<strong>服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。）</strong></p><ul><li>没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的<strong>客服（Handler）</strong>了</li></ul></li></ul><p><strong>PS  :</strong></p><p><strong>至于怎么在不支持Websocket的客户端上使用Websocket。。答案是：不能</strong></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.  总结"></a>3.  总结</h2><ul><li>可以把 WebSocket 看成是 HTTP 协议为了支持长连接所打的一个大补丁，它和 HTTP 有一些共性，是为了解决 HTTP 本身无法解决的某些问题而做出的一个改良设计。</li><li>在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header；所谓的 polling 是指从客户端（一般就是浏览器）不断主动的向服务器发 HTTP 请求查询是否有新数据。</li><li>这两种模式有一个共同的缺点，<strong>就是除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header</strong>，信息交换效率很低。<strong>它们建立的“长连接”都是伪.长连接</strong>，只不过好处是不需要对现有的 HTTP server 和浏览器架构做修改就能实现。</li></ul><p><strong>WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了</strong></p><ul><li>使得这个长连接变成了一个<strong>真.长连接</strong></li><li>但是不需要发送 HTTP header就能交换数据显然和原有的 HTTP 协议是有区别的，所以它需要对服务器和客户端都进行升级才能实现。</li><li>在此基础上 WebSocket 还是一个双通道的连接，在同一个 TCP 连接上既可以发也可以收信息。</li><li>另外外还有 multiplexing 功能，几个不同的 URI 可以复用同一个 WebSocket 连接。这些都是原来的 HTTP 不能做到的。</li></ul><p><strong>另外说一点技术细节，因为看到有人提问 WebSocket 可能进入某种半死不活的状态。这实际上也是原有网络世界的一些缺陷性设计</strong></p><ul><li>上面所说的 WebSocket 真.长连接虽然解决了服务器和客户端两边的问题，但坑爹的是网络应用除了服务器和客户端之外，另一个巨大的存在是中间的网络链路。</li><li>一个 HTTP/WebSocket 连接往往要经过无数的路由，防火墙。你以为你的数据是在一个“连接”中发送的，实际上它要跨越千山万水，经过无数次转发，过滤，才能最终抵达终点。在这过程中，中间节点的处理方法很可能会让你意想不到。</li><li>比如说，这些坑爹的中间节点可能会认为一份连接在一段时间内没有数据发送就等于失效，它们会自作主张的切断这些连接。</li><li>在这种情况下，不论服务器还是客户端都不会收到任何提示，它们只会一厢情愿的以为彼此间的红线还在，徒劳地一边又一边地发送抵达不了彼岸的信息。而计算机网络协议栈的实现中又会有一层套一层的缓存，除非填满这些缓存，你的程序根本不会发现任何错误</li></ul><p><strong>这样，本来一个美好的 WebSocket 长连接，就可能在毫不知情的情况下进入了半死不活状态。</strong></p><p><strong>而解决方案，WebSocket 的设计者们也早已想过。就是让服务器和客户端能够发送 Ping/Pong Frame</strong>（<a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6455%23section-5.5.2">RFC 6455 - The WebSocket Protocol</a>）。<strong>（心跳包）</strong></p><p><strong>这种 Frame 是一种特殊的数据包，它只包含一些元数据而不需要真正的 Data Payload，可以在不影响 Application 的情况下维持住中间网络的连接状态。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WebSocket理解&quot;&gt;&lt;a href=&quot;#WebSocket理解&quot; class=&quot;headerlink&quot; title=&quot;WebSocket理解&quot;&gt;&lt;/a&gt;WebSocket理解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;首先HTTP有&lt;code&gt;1.1&lt;/code&gt;和&lt;code&gt;1.0&lt;/code&gt;之说，也就是所谓的&lt;code&gt;keep-alive&lt;/code&gt;，把多个HTTP请求合并为一个，但是&lt;strong&gt;&lt;code&gt;Websocket&lt;/code&gt;其实是一个新协议，跟HTTP协议基本没有关系&lt;/strong&gt;，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/093305644.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;有交集，但是并不是全部。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。&lt;/li&gt;
&lt;li&gt;通俗来说，你可以用HTTP&lt;strong&gt;协议&lt;/strong&gt;传输非Html&lt;strong&gt;数据&lt;/strong&gt;，就是这样=。=&lt;/li&gt;
&lt;li&gt;再简单来说，&lt;strong&gt;层级不一样&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="WebSocket" scheme="http://zhuuu.work/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-21-磁盘管理</title>
    <link href="http://zhuuu.work/2020/10/31/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-21-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/31/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-21-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-31T02:00:53.000Z</published>
    <updated>2020-11-01T07:41:05.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-21-磁盘管理"><a href="#操作系统-21-磁盘管理" class="headerlink" title="操作系统-21-磁盘管理"></a>操作系统-21-磁盘管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111136067.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png" alt="mark"></p><a id="more"></a><h2 id="1-磁盘的结构"><a href="#1-磁盘的结构" class="headerlink" title="1. 磁盘的结构"></a>1. 磁盘的结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111241257.png" alt="mark"></p><ol><li><strong>如何在磁盘中读写数据？</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111310259.png" alt="mark"></p><ol start="2"><li><strong>柱面盘面扇区号 = 磁盘地址</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111349961.png" alt="mark"></p><ol start="3"><li><strong>磁盘的分类</strong></li></ol><ul><li>按盘面分类</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111429132.png" alt="mark"></p><ul><li>按磁头分类</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111434376.png" alt="mark"></p><h2 id="2-磁盘管理"><a href="#2-磁盘管理" class="headerlink" title="2. 磁盘管理"></a>2. 磁盘管理</h2><h3 id="2-1-磁盘初始化"><a href="#2-1-磁盘初始化" class="headerlink" title="2.1 磁盘初始化"></a>2.1 磁盘初始化</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111623596.png" alt="mark"></p><h3 id="2-2-引导块"><a href="#2-2-引导块" class="headerlink" title="2.2 引导块"></a>2.2 引导块</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111648466.png" alt="mark"></p><h3 id="2-3-坏道管理（坏块）"><a href="#2-3-坏道管理（坏块）" class="headerlink" title="2.3 坏道管理（坏块）"></a>2.3 坏道管理（坏块）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111715011.png" alt="mark"></p><h2 id="3-减少磁盘延迟"><a href="#3-减少磁盘延迟" class="headerlink" title="3. 减少磁盘延迟"></a>3. 减少磁盘延迟</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153257581.png" alt="mark"></p><p><strong>需要减少磁盘延迟的原因 ： 无法连续的读取数据</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153315306.png" alt="mark"></p><h3 id="3-1-交替编号"><a href="#3-1-交替编号" class="headerlink" title="3.1 交替编号"></a>3.1 交替编号</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153406299.png" alt="mark"></p><h3 id="3-2-磁盘地址结构的设计"><a href="#3-2-磁盘地址结构的设计" class="headerlink" title="3.2 磁盘地址结构的设计"></a>3.2 磁盘地址结构的设计</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153423711.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153509150.png" alt="mark"></p><h3 id="3-3-错位命名"><a href="#3-3-错位命名" class="headerlink" title="3.3 错位命名"></a>3.3 错位命名</h3><ul><li>不使用错位命名</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/154002106.png" alt="mark"></p><ul><li>使用错位命名</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/154100860.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-21-磁盘管理&quot;&gt;&lt;a href=&quot;#操作系统-21-磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-21-磁盘管理&quot;&gt;&lt;/a&gt;操作系统-21-磁盘管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111136067.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="磁盘管理" scheme="http://zhuuu.work/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复</title>
    <link href="http://zhuuu.work/2020/10/31/Leetcode/Leetcode-381-O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/"/>
    <id>http://zhuuu.work/2020/10/31/Leetcode/Leetcode-381-O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/</id>
    <published>2020-10-31T00:52:53.000Z</published>
    <updated>2020-10-31T02:06:35.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复"></a>Leetcode-381-<a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h1><h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(val)：向集合中插入元素 val。</span><br><span class="line">remove(val)：当 val 存在时，从集合中移除一个 val。</span><br><span class="line">getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedCollection collection &#x3D; new RandomizedCollection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示集合不包含 1 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span><br><span class="line">collection.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应当有 2&#x2F;3 的概率返回 1 ，1&#x2F;3 的概率返回 2 。</span><br><span class="line">collection.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">collection.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应有相同概率返回 1 和 2 。</span><br><span class="line">collection.getRandom();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-哈希表"><a href="#方法-哈希表" class="headerlink" title="方法 : 哈希表"></a>方法 : 哈希表</h2><ul><li><strong>对于get() 方法</strong><ul><li>为了使得 <strong>O(1) 时间内能够随机获取一个元素</strong>，我们将<strong>每个数值（可以重复）存储在一个列表nums 中</strong>。</li><li>这样，获取随机元素时，只需要随机生成一个列表中的索引，就能够得到一个随机元素。</li></ul></li></ul><ul><li><strong>对于 remove() 方法</strong><ul><li>这样做的问题在于：<strong>列表中的随机删除并不是 O(1) 的。</strong></li><li>然而我们可以发现，<strong>列表中元素的顺序是无关紧要的</strong>，只要它们正确地存在于列表中即可。</li><li><strong>因此，在删除元素时，我们可以将被删的元素与列表中最后一个元素交换位置，随后便可以在 O(1)时间内，从列表中去除该元素。</strong></li><li>这需要我们<strong>额外维护数值在列表中每一次出现的下标集合</strong>。对于数值 val 而言，记其下标集合为 S<strong>i</strong>dx。</li></ul></li></ul><p><strong>具体删除操作</strong></p><ul><li><strong>在删除时，我们找出 val出现的其中一个下标 i</strong></li><li><strong>并将 <code>nums[i]</code> 和<code>nums[nums.length - 1]</code> 交换。</strong></li><li><strong>随后，将 i 从 Sval 中删除，并将<code>Snums[nums.length - 1]</code> 中原有的 <code>nums[nums.length - 1]</code> 替换成 i 。</strong></li><li><strong>由于每个操作都是O(1)的 那么平均时间复杂度也是 O（1）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Set&lt;Integer&gt;&gt; idx; <span class="comment">// Map 用于维护数值在列表中每次出现的下标集合       Set 用于作为下标集合</span></span><br><span class="line">    List&lt;Integer&gt; nums; <span class="comment">// 用于随机获取元素 get() 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx  = <span class="keyword">new</span> HashMap&lt;Integer,Set&lt;Integer&gt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入操作</span></span><br><span class="line">        nums.add(val); <span class="comment">// 加入到列表中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录出现的下标集合</span></span><br><span class="line">        <span class="comment">// key 是 出现的数字</span></span><br><span class="line">        <span class="comment">// val 是 出现数字所对应的下标</span></span><br><span class="line">        <span class="comment">// 比如插入[1,1,1,2,2,2]</span></span><br><span class="line">        <span class="comment">// 对应idx 即为 [1,[0,1,2]] [2,[3,4,5]]</span></span><br><span class="line">        Set&lt;Integer&gt; set = idx.getOrDefault(val,<span class="keyword">new</span> HashSet&lt;Integer&gt;()); </span><br><span class="line">        set.add(nums.size() - <span class="number">1</span>); </span><br><span class="line">        idx.put(val,set); <span class="comment">// set记录每个数字每一次出现的下标</span></span><br><span class="line">        <span class="keyword">return</span> set.size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除操作</span></span><br><span class="line">        <span class="keyword">if</span>(!idx.containsKey(val))&#123; <span class="comment">// 如果根本没有这个数字的话，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在删除时 找到val出现的其中一个下标i</span></span><br><span class="line">        <span class="comment">// 并将其和 最后一个元素进行交换</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = idx.get(val).iterator();</span><br><span class="line">        <span class="keyword">int</span> i = it.next();</span><br><span class="line">        <span class="keyword">int</span> lastNum = nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        nums.set(i,lastNum);</span><br><span class="line"></span><br><span class="line">        idx.get(val).remove(i);</span><br><span class="line">        idx.get(lastNum).remove(nums.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; nums.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            idx.get(lastNum).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx.get(val).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            idx.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get((<span class="keyword">int</span>) (Math.random() * nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedCollection object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedCollection obj = new RandomizedCollection();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 O(1)</li><li>空间复杂度 O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复&quot;&gt;&lt;a href=&quot;#Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复&quot;&gt;&lt;/a&gt;Leetcode-381-&lt;a href=&quot;https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;O(1) 时间插入、删除和获取随机元素 - 允许重复&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：哈希表&quot;&gt;&lt;a href=&quot;#思路：哈希表&quot; class=&quot;headerlink&quot; title=&quot;思路：哈希表&quot;&gt;&lt;/a&gt;思路：哈希表&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。&lt;/p&gt;
&lt;p&gt;注意: 允许出现重复元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;insert(val)：向集合中插入元素 val。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remove(val)：当 val 存在时，从集合中移除一个 val。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 初始化一个空的集合。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RandomizedCollection collection &amp;#x3D; new RandomizedCollection();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入 1 。返回 true 表示集合不包含 1 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; getRandom 应当有 2&amp;#x2F;3 的概率返回 1 ，1&amp;#x2F;3 的概率返回 2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.getRandom();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.remove(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; getRandom 应有相同概率返回 1 和 2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.getRandom();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-463-岛屿的周长</title>
    <link href="http://zhuuu.work/2020/10/30/Leetcode/Leetcode-463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://zhuuu.work/2020/10/30/Leetcode/Leetcode-463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-30T08:35:53.000Z</published>
    <updated>2020-10-30T07:50:13.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-463-岛屿的周长"><a href="#Leetcode-463-岛屿的周长" class="headerlink" title="Leetcode-463-岛屿的周长"></a>Leetcode-463-<a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener">岛屿的周长</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。<strong>计算这个岛屿的周长。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/154731661.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 :</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">输出: 16</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-迭代"><a href="#思路-迭代" class="headerlink" title="思路:  迭代"></a>思路:  迭代</h2><ul><li>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。</li><li>因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 1）加入答案<em>ans</em> 中即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length; <span class="comment">// 行</span></span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].length; <span class="comment">// 列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个陆地格子，看其四个方向是否是边界或者水域</span></span><br><span class="line">        <span class="comment">// 如果是边界 或者 是水域 那么将这条边的贡献加1到ans中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="comment">// 遍历每一个陆地格子</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 遍历每个格子四条边4条边</span></span><br><span class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || grid[tx][ty] == <span class="number">0</span>)&#123;</span><br><span class="line">                            count += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 计算完一个格子之后</span></span><br><span class="line">                    ans += count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(nm)，其中 n 为网格的高度，m 为网格的宽度。我们需要遍历每个格子，每个格子要看其周围 4 个格子是否为岛屿，因此总时间复杂度为 O(nm)。</li><li><strong>空间复杂度</strong>：<em>O</em>(1)。只需要常数空间存放若干变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-463-岛屿的周长&quot;&gt;&lt;a href=&quot;#Leetcode-463-岛屿的周长&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-463-岛屿的周长&quot;&gt;&lt;/a&gt;Leetcode-463-&lt;a href=&quot;https://leetcode-cn.com/problems/island-perimeter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;岛屿的周长&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。&lt;/p&gt;
&lt;p&gt;网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。&lt;/p&gt;
&lt;p&gt;岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。&lt;strong&gt;计算这个岛屿的周长。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/154731661.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [1,1,1,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [1,1,0,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-20-文件的存储空间管理</title>
    <link href="http://zhuuu.work/2020/10/30/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-20-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/30/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-20-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-30T02:00:53.000Z</published>
    <updated>2020-10-31T08:44:44.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-20-文件的存储空间管理"><a href="#操作系统-20-文件的存储空间管理" class="headerlink" title="操作系统-20-文件的存储空间管理"></a>操作系统-20-文件的存储空间管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>操作系统对磁盘进行管理</strong></p><ul><li>对<strong>非空闲磁盘</strong>的管理（文件的分配方式）</li><li>对<strong>空闲磁盘</strong>的管理（文件的存储空间）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100452907.png" alt="mark"></p><a id="more"></a><h2 id="文件的存储空间管理"><a href="#文件的存储空间管理" class="headerlink" title="文件的存储空间管理"></a>文件的存储空间管理</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100830136.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100846144.png" alt="mark"></p><p><strong>接下来将一一介绍这些知识点</strong></p><h2 id="1-存储空间的划分和初始化"><a href="#1-存储空间的划分和初始化" class="headerlink" title="1. 存储空间的划分和初始化"></a>1. 存储空间的划分和初始化</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162611539.png" alt="mark"></p><h2 id="2-文件空闲分配空间分配算法"><a href="#2-文件空闲分配空间分配算法" class="headerlink" title="2. 文件空闲分配空间分配算法"></a>2. 文件空闲分配空间分配算法</h2><ul><li><strong>文件存储设备管理实质上是对空闲块的组织和管理</strong></li></ul><h3 id="2-1-空闲表法"><a href="#2-1-空闲表法" class="headerlink" title="2.1 空闲表法"></a>2.1 空闲表法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162811554.png" alt="mark"></p><h3 id="2-2-空闲链表法"><a href="#2-2-空闲链表法" class="headerlink" title="2.2 空闲链表法"></a>2.2 空闲链表法</h3><p><strong>空闲链表法是将磁盘上的所有空闲空间以盘块位单位拉成一条链</strong></p><h4 id="2-2-1-空闲盘块链"><a href="#2-2-1-空闲盘块链" class="headerlink" title="2.2.1 空闲盘块链"></a>2.2.1 空闲盘块链</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162946825.png" alt="mark"></p><h4 id="2-2-2-空闲盘区链"><a href="#2-2-2-空闲盘区链" class="headerlink" title="2.2.2 空闲盘区链"></a>2.2.2 空闲盘区链</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163024433.png" alt="mark"></p><h3 id="2-3-位示图法"><a href="#2-3-位示图法" class="headerlink" title="2.3 位示图法"></a>2.3 位示图法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163116309.png" alt="mark"></p><p><strong>如何进行分配和回收？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163235928.png" alt="mark"></p><h3 id="2-4-成组链接法"><a href="#2-4-成组链接法" class="headerlink" title="2.4 成组链接法"></a>2.4 成组链接法</h3><ul><li><strong>Unix 采用成组链接法对磁盘空闲块进行管理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163702699.png" alt="mark"></p><h4 id="2-4-1-超级块"><a href="#2-4-1-超级块" class="headerlink" title="2.4.1 超级块"></a>2.4.1 超级块</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163822214.png" alt="mark"></p><h4 id="2-4-2-分配策略"><a href="#2-4-2-分配策略" class="headerlink" title="2.4.2 分配策略"></a>2.4.2 分配策略</h4><ul><li><strong>需要1个空闲磁盘块</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164120779.png" alt="mark"></p><ul><li><strong>需要分配100个空心块</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164209348.png" alt="mark"></p><h4 id="2-4-3-回收策略"><a href="#2-4-3-回收策略" class="headerlink" title="2.4.3 回收策略"></a>2.4.3 回收策略</h4><ul><li><strong>回收区域未满</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164258244.png" alt="mark"></p><ul><li><strong>回收区域已满</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164404090.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-20-文件的存储空间管理&quot;&gt;&lt;a href=&quot;#操作系统-20-文件的存储空间管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-20-文件的存储空间管理&quot;&gt;&lt;/a&gt;操作系统-20-文件的存储空间管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;操作系统对磁盘进行管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对&lt;strong&gt;非空闲磁盘&lt;/strong&gt;的管理（文件的分配方式）&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;空闲磁盘&lt;/strong&gt;的管理（文件的存储空间）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100452907.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-19-文件的物理结构</title>
    <link href="http://zhuuu.work/2020/10/30/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-19-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/"/>
    <id>http://zhuuu.work/2020/10/30/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-19-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/</id>
    <published>2020-10-30T00:00:53.000Z</published>
    <updated>2020-10-30T01:28:55.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-19-文件的物理结构"><a href="#操作系统-19-文件的物理结构" class="headerlink" title="操作系统-19-文件的物理结构"></a>操作系统-19-文件的物理结构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/085837475.png" alt="mark"></p><a id="more"></a><h2 id="1-文件块，磁盘块"><a href="#1-文件块，磁盘块" class="headerlink" title="1. 文件块，磁盘块"></a>1. 文件块，磁盘块</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/090314126.png" alt="mark"></p><h2 id="2-文件的实现（文件的分配方式）"><a href="#2-文件的实现（文件的分配方式）" class="headerlink" title="2. 文件的实现（文件的分配方式）"></a>2. 文件的实现（文件的分配方式）</h2><h3 id="2-1-连续分配方式"><a href="#2-1-连续分配方式" class="headerlink" title="2.1 连续分配方式"></a>2.1 连续分配方式</h3><ul><li><strong>优点</strong>：支持随机访问；顺序访问时速度最快（移动磁头所需的时间短） </li><li><strong>缺点</strong>：不方便文件扩展，每次扩展都得迁移到一段连续的空间，代价大；存储空间利用率低，产生磁盘碎片</li></ul><h3 id="2-2-链接分配方式"><a href="#2-2-链接分配方式" class="headerlink" title="2.2 链接分配方式"></a>2.2 链接分配方式</h3><p>链接分配采用离散分配的方式，消除了外部碎片</p><ul><li><strong>链接分配又分为</strong><ul><li><strong>显式链接</strong></li><li><strong>隐式链接</strong></li></ul></li></ul><h4 id="2-2-1-隐式链接"><a href="#2-2-1-隐式链接" class="headerlink" title="2.2.1 隐式链接"></a>2.2.1 隐式链接</h4><ul><li>不支持随机访问，查找效率低</li><li>方便拓展，磁盘利用率高</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/091949038.png" alt="mark"></p><h4 id="2-2-2-显示链接"><a href="#2-2-2-显示链接" class="headerlink" title="2.2.2 显示链接"></a>2.2.2 显示链接</h4><ul><li>逻辑块号转物理块号不需要访问磁盘，因此支持随机访问；扩展方便且不会有磁盘碎片</li><li>缺点是FAT要占用一定的存储空间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092112596.png" alt="mark"></p><h4 id="2-2-3-链式分配小结"><a href="#2-2-3-链式分配小结" class="headerlink" title="2.2.3 链式分配小结"></a>2.2.3 链式分配小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092156870.png" alt="mark"></p><h3 id="2-3-索引分配"><a href="#2-3-索引分配" class="headerlink" title="2.3 索引分配"></a>2.3 索引分配</h3><ul><li>每一个文件建立一张索引表，其中记录文件的逻辑块对应的物理块。</li><li>存放索引表的磁盘块叫<strong>索引块</strong>，存放文件数据的磁盘块叫<strong>数据块</strong>。</li></ul><p><strong>索引分配支持直接访问，且没有外部碎片的问题。</strong></p><p><strong>但是每个文件都必须有一个索引块，因此索引块要尽可能的小。</strong></p><p>有如下几种方案减少索引块所占的空间：</p><ol><li><strong>链接方案</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092725382.png" alt="mark"></p><ol start="2"><li><strong>多层索引</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092811877.png" alt="mark"></p><ol start="3"><li><strong>混合索引</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092832505.png" alt="mark"></p><p><strong>索引分配小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092853080.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-19-文件的物理结构&quot;&gt;&lt;a href=&quot;#操作系统-19-文件的物理结构&quot; class=&quot;headerlink&quot; title=&quot;操作系统-19-文件的物理结构&quot;&gt;&lt;/a&gt;操作系统-19-文件的物理结构&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/085837475.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-129-求根到叶子节点数字之和</title>
    <link href="http://zhuuu.work/2020/10/29/Leetcode/Leetcode-129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/10/29/Leetcode/Leetcode-129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2020-10-29T07:22:53.000Z</published>
    <updated>2020-10-29T00:49:17.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-129-求根到叶子节点数字之和"><a href="#Leetcode-129-求根到叶子节点数字之和" class="headerlink" title="Leetcode-129-求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">Leetcode-129-求根到叶子节点数字之和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sum-root-to-leaf-numbers</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">输入: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sum-root-to-leaf-numbers</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-DFS"><a href="#方法-：-DFS" class="headerlink" title="方法 ： DFS"></a>方法 ： DFS</h2><ul><li>深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和</li><li>如果<strong>当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。</strong></li><li>如果<strong>当前节点是叶子节点，直接返回sum即可</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/084301292.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> prevSum)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 对叶子节点或者不是叶子节点的处理</span></span><br><span class="line">        <span class="keyword">int</span> sum = prevSum*<span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123; <span class="comment">//如果是叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root.left,sum) + dfs(root.right,sum); <span class="comment">// 如果是根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>： <em>O</em>(<em>n</em>)，其中<em>n</em> 是二叉树的节点个数。对每个节点访问一次。</li><li><strong>空间复杂度</strong>： <em>O</em>(<em>n</em>)，其中n 是二叉树节点的个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度。（最坏情况下，空间复杂度为<em>O</em>(<em>n</em>)）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-129-求根到叶子节点数字之和&quot;&gt;&lt;a href=&quot;#Leetcode-129-求根到叶子节点数字之和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-129-求根到叶子节点数字之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-129-求根到叶子节点数字之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。&lt;/p&gt;
&lt;p&gt;例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。&lt;/p&gt;
&lt;p&gt;计算从根到叶子节点生成的所有数字之和。&lt;/p&gt;
&lt;p&gt;说明: 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 1-&amp;gt;2 代表数字 12.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 1-&amp;gt;3 代表数字 13.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，数字总和 &amp;#x3D; 12 + 13 &amp;#x3D; 25.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来源：力扣（LeetCode）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;链接：https:&amp;#x2F;&amp;#x2F;leetcode-cn.com&amp;#x2F;problems&amp;#x2F;sum-root-to-leaf-numbers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [4,9,0,5,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  9   0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1026&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;9-&amp;gt;5 代表数字 495.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;9-&amp;gt;1 代表数字 491.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;0 代表数字 40.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，数字总和 &amp;#x3D; 495 + 491 + 40 &amp;#x3D; 1026.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来源：力扣（LeetCode）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;链接：https:&amp;#x2F;&amp;#x2F;leetcode-cn.com&amp;#x2F;problems&amp;#x2F;sum-root-to-leaf-numbers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-06-核心组件</title>
    <link href="http://zhuuu.work/2020/10/28/Netty/Netty-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>http://zhuuu.work/2020/10/28/Netty/Netty-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</id>
    <published>2020-10-28T10:05:24.000Z</published>
    <updated>2020-10-29T01:35:15.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-06-核心组件"><a href="#Netty-06-核心组件" class="headerlink" title="Netty-06-核心组件"></a>Netty-06-核心组件</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>本文注重讲解Netty的核心组成</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png" alt="mark"></p><h2 id="1-Bootstrap、ServerBootstrap"><a href="#1-Bootstrap、ServerBootstrap" class="headerlink" title="1. Bootstrap、ServerBootstrap"></a>1. Bootstrap、ServerBootstrap</h2><ul><li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类</li></ul><p><strong>常见方法：</strong></p><table><thead><tr><th>方法名称</th><th>方法介绍</th></tr></thead><tbody><tr><td><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code></td><td>该方法用于服务器端，用来设置两个EventLoop</td></tr><tr><td><code>public B group(EventLoopGroup group)</code></td><td>该方法用于客户端，用来设置一个EventLoop</td></tr><tr><td><code>public B channel(Class&lt;? extends C&gt; channelClass)</code></td><td>该方法用来设置一个服务器端的通道实现</td></tr><tr><td><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code></td><td>用来给 ServerChannel 添加配置</td></tr><tr><td><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code></td><td>用来给接收到的通道添加配置</td></tr><tr><td><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code></td><td>该方法用来设置业务处理类（自定义的 handler）</td></tr><tr><td><code>public ChannelFuture bind(int inetPort)</code></td><td>该方法用于服务器端，用来设置占用的端口号</td></tr><tr><td><code>public ChannelFuture connect(String inetHost, int inetPort)</code></td><td>该方法用于客户端，用来连接服务器</td></tr></tbody></table><a id="more"></a><h2 id="2-Future、ChannelFuture"><a href="#2-Future、ChannelFuture" class="headerlink" title="2. Future、ChannelFuture"></a>2. Future、ChannelFuture</h2><ul><li><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFuture</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</li></ul><p><strong>常见的方法有</strong></p><table><thead><tr><th>方法名</th><th>方法介绍</th></tr></thead><tbody><tr><td><code>Channel channel()</code></td><td>返回当前正在进行 IO 操作的通道</td></tr><tr><td><code>ChannelFuture sync()</code></td><td>等待异步操作执行完毕，相当于将阻塞在当前。</td></tr></tbody></table><h2 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. Channel</h2><ul><li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p></li><li><p>通过<code>Channel</code> 可获得当前网络连接的通道的状态</p></li><li><p>通过<code>Channel</code> 可获得 网络连接的配置参数 （例如接收缓冲区大小）</p></li><li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，<strong>异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</strong></p></li><li><p><strong>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</strong></p></li><li><p><strong>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应</strong></p></li></ul><p><strong>常用的 <code>Channel</code> 类型</strong></p><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td><code>NioSocketChannel</code></td><td>异步的客户端 TCP Socket 连接。</td></tr><tr><td><code>NioServerSocketChannel</code></td><td>异步的服务器端 TCP Socket 连接</td></tr><tr><td><code>NioDatagramChannel</code></td><td>异步的 UDP 连接。</td></tr><tr><td><code>NioSctpChannel</code></td><td>异步的客户端 Sctp 连接。</td></tr><tr><td><code>NioSctpServerChannel</code></td><td>异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</td></tr></tbody></table><h2 id="4-Seletor"><a href="#4-Seletor" class="headerlink" title="4. Seletor"></a>4. Seletor</h2><ul><li><p><strong><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</strong></p></li><li><p>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询(<code>Select</code>) 这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以<strong>很简单地使用一个线程高效地管理多个 <code>Channel</code></strong></p></li><li><p>同时，<code>Netty</code>中对<code>selector</code>中的<code>selectedKey</code>集合进行了替换，它替换成了一个它自己实现的一个<code>set</code>集合，这样效率更高。</p></li></ul><h2 id="5-ChannelHandler"><a href="#5-ChannelHandler" class="headerlink" title="5. ChannelHandler"></a>5. ChannelHandler</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><ul><li><strong><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>(业务处理链)中的下一个处理程序。</strong></li><li><strong><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</strong></li><li>我们经常需要<strong>自定义一个<code>Handler</code> 类去继承<code>ChannelInboundHandlerAdapter</code> ，然后通过相应方法实现业务逻辑，来看看有哪些方法需要重写</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/224217480.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道注册事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道取消注册事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道就绪事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelInactive()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道读取数据事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道数据读取完毕事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireUserEventTriggered(Object)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelWritabilityChanged()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道发生异常事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>再来回顾一下类图</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/224217480.png" alt="mark"></p><ul><li><code>ChannelInboundHandler</code> 用于处理入站 I/O 事件。</li><li><code>ChannelOutboundHandler</code> 用于处理出站 I/O 操作。</li></ul><p><strong>适配器</strong></p><ul><li><code>ChannelInboundHandlerAdapter</code> 用于处理入站 I/O 事件。</li><li><code>ChannelOutboundHandlerAdapter</code> 用于处理出站 I/O 操作。</li><li><code>ChannelDuplexHandler</code> 用于处理入站和出站事件。</li></ul><h2 id="7-Pipeline-和-ChannelPipeline"><a href="#7-Pipeline-和-ChannelPipeline" class="headerlink" title="7. Pipeline 和 ChannelPipeline"></a>7. Pipeline 和 ChannelPipeline</h2><ul><li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。(也可以这样理解：<code>ChannelPipeline</code> 是 保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作)</li><li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li><li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><p><strong>组成关系</strong></p><ul><li>一个 <code>Channel</code> 包含了一个 <code>ChannelPipeline</code>，而 <code>ChannelPipeline</code> 中又维护了一个由 <code>ChannelHandlerContext</code> 组成的<strong>双向链表</strong>，并且每个 <code>ChannelHandlerContext</code> 中又关联着一个 <code>ChannelHandler</code></li><li><strong>入站事件和出站事件在一个双向链表中</strong>，入站事件会从链表 <code>head</code> 往后传递到最后一个入站的 <code>handler</code>，出站事件会从链表 <code>tail</code> 往前传递到最前一个出站的 <code>handler</code>，两种类型的 <code>handler</code> 互不干扰</li></ul><p><strong>常用方法：</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>ChannelPipeline addFirst(ChannelHandler... handlers)</code></td><td>把一个业务处理类（handler）添加到链中的第一个位置</td></tr><tr><td>ChannelPipeline addLast(ChannelHandler… handlers)</td><td>把一个业务处理类（handler）添加到链中的最后一个位置</td></tr></tbody></table><h2 id="8-ChannelOption"><a href="#8-ChannelOption" class="headerlink" title="8. ChannelOption"></a>8. ChannelOption</h2><ul><li><code>Netty</code> 在创建 <code>Channel</code> 实例后,一般都需要设置 <code>ChannelOption</code> 参数。</li></ul><p><strong>ChannelOption 参数如下</strong></p><p><code>ChannelOption.SO_BACKLOG</code></p><ul><li><strong>对应 TCP/IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。</strong></li><li>服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户端来的时候，<strong>服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定了队列的大小。</strong></li></ul><p><code>ChannelOption.SO_KEEPALIVE</code></p><ul><li><strong>一直保持TCP连接活动的状态</strong></li></ul><h2 id="9-EventLoopGroup-和-NioEventLoopGroup"><a href="#9-EventLoopGroup-和-NioEventLoopGroup" class="headerlink" title="9. EventLoopGroup 和 NioEventLoopGroup"></a>9. EventLoopGroup 和 NioEventLoopGroup</h2><ul><li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，Netty为了更好的利用多核CPU资源，一般会有多个<code>EventLoop</code> 同时工作，每个<code>EventLoop</code>维护着一个Selector 实例</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/092123789.png" alt="mark"></p><ul><li><code>EventLoopGroup</code> 提供 next 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code>来处理任务。<ul><li>在 Netty 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和<code>WorkerEventLoopGroup</code>。</li></ul></li><li>通常一个服务端口即一个<code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和 一个<code>EventLoop</code> 线程。<ul><li>BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理</li></ul></li><li>BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护者一个注册了ServerSocketChannel 的Selector 实例BossEventLoop 不断轮询 Selector 将连接事件分离出来<ul><li>通常是 OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup</li><li>WorkerEventLoopGroup 会由 next 选择其中一个EventLoop 来讲这个SocketChannel 注册到其维护的Selector 并对和后续的IO事件进行处理</li></ul></li></ul><p><strong>常用方法：</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>public NioEventLoopGroup()</code></td><td>构造方法</td></tr><tr><td><code>public Future&lt;?&gt; shutdownGracefully()</code></td><td>断开连接，关闭线程</td></tr></tbody></table><h2 id="10-ByteBuf"><a href="#10-ByteBuf" class="headerlink" title="10. ByteBuf"></a>10. ByteBuf</h2><ul><li><strong>Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类</strong></li></ul><p><strong>常用方法</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>public static ByteBuf copiedBuffer(CharSequence string, Charset charset)</code></td><td>通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）</td></tr></tbody></table><ul><li><strong>使用举例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ByteBuf</span></span><br><span class="line"><span class="comment">//1、创建对象，该对象包含一个数组，是一个byte[10]</span></span><br><span class="line"><span class="comment">//2、在netty的buffer中，写入数据后再读取数据不需要使用 flip 进行反转</span></span><br><span class="line"><span class="comment">// 底层维护了 readerIndex 和 writeIndex</span></span><br><span class="line"><span class="comment">//往buffer中写的范围为 [writeIndex, capacity)</span></span><br><span class="line"><span class="comment">//往buffer中可读的范围为 [readerIndex, writeIndex)。使用 buf.readByte() 会往后移动 readerIndex 指针，使用 buf.getByte(i) 通过索引获取就不会移动该指针</span></span><br><span class="line">ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    byteBuf.writeByte(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取该buf的大小</span></span><br><span class="line"><span class="keyword">int</span> capacity = byteBuf.capacity();</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteBuf.capacity(); i++) &#123;</span><br><span class="line">    System.out.println(byteBuf.getByte(i));</span><br><span class="line">    System.out.println(byteBuf.readByte());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"><span class="comment">//将content转成字符串</span></span><br><span class="line">String c = <span class="keyword">new</span> String(content, StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">//数组偏移量</span></span><br><span class="line"><span class="keyword">int</span> offset = byteBuf.arrayOffset();</span><br><span class="line"><span class="comment">//获取读取偏移量</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = byteBuf.readerIndex();</span><br><span class="line"><span class="comment">//获取写偏移量</span></span><br><span class="line"><span class="keyword">int</span> writerIndex = byteBuf.writerIndex();</span><br><span class="line"><span class="comment">//获取容量</span></span><br><span class="line"><span class="keyword">int</span> capacity = byteBuf.capacity();</span><br><span class="line"><span class="comment">//获取可读取的字节数</span></span><br><span class="line"><span class="keyword">int</span> readableBytes = byteBuf.readableBytes();</span><br><span class="line"><span class="comment">//通过索引获取某个位置的字节</span></span><br><span class="line"><span class="keyword">byte</span> aByte = byteBuf.getByte(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//获取Buf中某个范围的字符序列</span></span><br><span class="line">CharSequence charSequence = byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-06-核心组件&quot;&gt;&lt;a href=&quot;#Netty-06-核心组件&quot; class=&quot;headerlink&quot; title=&quot;Netty-06-核心组件&quot;&gt;&lt;/a&gt;Netty-06-核心组件&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本文注重讲解Netty的核心组成&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Bootstrap、ServerBootstrap&quot;&gt;&lt;a href=&quot;#1-Bootstrap、ServerBootstrap&quot; class=&quot;headerlink&quot; title=&quot;1. Bootstrap、ServerBootstrap&quot;&gt;&lt;/a&gt;1. Bootstrap、ServerBootstrap&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt; 意思是引导，一个 &lt;code&gt;Netty&lt;/code&gt; 应用通常由一个 &lt;code&gt;Bootstrap&lt;/code&gt; 开始，主要作用是配置整个 &lt;code&gt;Netty&lt;/code&gt; 程序，串联各个组件，&lt;code&gt;Netty&lt;/code&gt; 中 &lt;code&gt;Bootstrap&lt;/code&gt; 类是客户端程序的启动引导类，&lt;code&gt;ServerBootstrap&lt;/code&gt; 是服务端启动引导类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见方法：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;方法介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于服务器端，用来设置两个EventLoop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public B group(EventLoopGroup group)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于客户端，用来设置一个EventLoop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public B channel(Class&amp;lt;? extends C&amp;gt; channelClass)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用来设置一个服务器端的通道实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public &amp;lt;T&amp;gt; B option(ChannelOption&amp;lt;T&amp;gt; option, T value)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来给 ServerChannel 添加配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public &amp;lt;T&amp;gt; ServerBootstrap childOption(ChannelOption&amp;lt;T&amp;gt; childOption, T value)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来给接收到的通道添加配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ServerBootstrap childHandler(ChannelHandler childHandler)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用来设置业务处理类（自定义的 handler）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ChannelFuture bind(int inetPort)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于服务器端，用来设置占用的端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ChannelFuture connect(String inetHost, int inetPort)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于客户端，用来连接服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty-07-群聊系统实现</title>
    <link href="http://zhuuu.work/2020/10/28/Netty/Netty-07-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhuuu.work/2020/10/28/Netty/Netty-07-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-28T10:05:24.000Z</published>
    <updated>2020-11-02T01:59:19.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-07-群聊系统实现"><a href="#Netty-07-群聊系统实现" class="headerlink" title="Netty-07-群聊系统实现"></a>Netty-07-群聊系统实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>编写一个Netty 群聊系统，实现客户端和服务端之间的数据简单通信（非阻塞）</li><li>实现多人群聊</li><li>服务器端： 可以检测用户上线，离线，并实现消息的转发</li><li>客户端：通过channel 可以无阻塞发送消息给其他用户，同时可以接受其他用户发送来的消息（由）服务器转发得到</li><li>目的 ： 进一步理解Netty 非阻塞网络编程机制</li></ul><a id="more"></a><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1. 服务端代码"></a>1. 服务端代码</h2><h3 id="1-1-启动类"><a href="#1-1-启动类" class="headerlink" title="1.1 启动类"></a>1.1 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写run 方法，处理客户端请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>,128)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>,<span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"----- netty 服务端启动 -----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 监听关闭事件</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>);</span><br><span class="line">        groupChatServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Handler"><a href="#1-2-Handler" class="headerlink" title="1.2 Handler"></a>1.2 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个channel组，管理所有的channel</span></span><br><span class="line">    <span class="comment">// GlobalEventExecutor.INSTANCE 是全局事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法表示连接建立，一旦建立连接就第一个被执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">// 该方法会将channelGroup 中所有的channel 遍历，并发送消息而不需要我们自己去遍历</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"加入了聊天"</span>);</span><br><span class="line">        <span class="comment">// 将当前的Channel 加入到 channelGroup</span></span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel 处于活动状态，提示XXX已经上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" "</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"上线了~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel 断开连接，将xx客户端离开信息推送给当前在线用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" "</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"离线了~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// channel 关闭后会自动remove掉</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() +<span class="string">" "</span>+ sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"离开了\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前channelGroup大小 ："</span> + channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据进行消息的转发</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前的channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历channelGroup 根据不同的情况回显不同的消息</span></span><br><span class="line">        channelGroup.forEach(item -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (item != channel)&#123;</span><br><span class="line">                item.writeAndFlush(<span class="string">"[客户]"</span> + channel.remoteAddress() + <span class="string">"发送了消息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                item.writeAndFlush(<span class="string">"[自己]发送了消息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2. 客户端代码"></a>2. 客户端代码</h2><h3 id="2-1-客户端代码"><a href="#2-1-客户端代码" class="headerlink" title="2.1 客户端代码"></a>2.1 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(eventExecutors)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入Handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// connect 事件</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">// 得到channel,打印本地地址</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"--------"</span> + channel.localAddress() + <span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端需要输入信息</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">// 通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">"127.0.0.1"</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Handler"><a href="#2-2-Handler" class="headerlink" title="2.2  Handler"></a>2.2  Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-07-群聊系统实现&quot;&gt;&lt;a href=&quot;#Netty-07-群聊系统实现&quot; class=&quot;headerlink&quot; title=&quot;Netty-07-群聊系统实现&quot;&gt;&lt;/a&gt;Netty-07-群聊系统实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写一个Netty 群聊系统，实现客户端和服务端之间的数据简单通信（非阻塞）&lt;/li&gt;
&lt;li&gt;实现多人群聊&lt;/li&gt;
&lt;li&gt;服务器端： 可以检测用户上线，离线，并实现消息的转发&lt;/li&gt;
&lt;li&gt;客户端：通过channel 可以无阻塞发送消息给其他用户，同时可以接受其他用户发送来的消息（由）服务器转发得到&lt;/li&gt;
&lt;li&gt;目的 ： 进一步理解Netty 非阻塞网络编程机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-18-文件基础</title>
    <link href="http://zhuuu.work/2020/10/24/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-18-%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhuuu.work/2020/10/24/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-18-%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-24T02:00:53.000Z</published>
    <updated>2020-10-30T02:03:25.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-18-文件基础"><a href="#操作系统-18-文件基础" class="headerlink" title="操作系统-18-文件基础"></a>操作系统-18-文件基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092059126.png" alt="mark"></p><a id="more"></a><h2 id="1-文件的属性"><a href="#1-文件的属性" class="headerlink" title="1. 文件的属性"></a>1. 文件的属性</h2><ul><li><strong>文件名</strong><br>主要是给用户看，同一个目录下不允许重名文件</li><li><strong>标识符</strong><br>一个系统内各文件标识符唯一，对用户毫无可读性，给操作系统看的</li><li><strong>类型</strong><br>文件扩展名</li><li><strong>位置</strong><br>文件存放路径，给用户看的，在外存中的地址用户是看不到的</li><li><strong>大小</strong></li><li><strong>创建时间</strong></li><li><strong>上次修改/访问时间</strong></li><li><strong>所有者信息</strong></li><li><strong>保护信息</strong></li></ul><h2 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2. 文件的逻辑结构"></a>2. 文件的逻辑结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092304381.png" alt="mark"></p><h3 id="2-1-无结构文件"><a href="#2-1-无结构文件" class="headerlink" title="2.1 无结构文件"></a>2.1 无结构文件</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092424194.png" alt="mark"></p><h3 id="2-2-有结构文件"><a href="#2-2-有结构文件" class="headerlink" title="2.2 有结构文件"></a>2.2 有结构文件</h3><ul><li><p>又叫做 记录式 文件，<strong>比如数据库表，由一组相似的记录组成</strong></p></li><li><p>记录是一组相关的数据线的集合，<strong>每条记录有一个数据项可作为关键字</strong></p></li><li><p>根据记录的长度是否相等，可以分为</p><ul><li><strong>定长记录</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092629157.png" alt="mark"></p><ul><li><strong>可变长记录</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092639472.png" alt="mark">****</p><p><strong>有结构文件的逻辑结构</strong></p><h4 id="2-2-1-顺序文件"><a href="#2-2-1-顺序文件" class="headerlink" title="2.2.1 顺序文件"></a>2.2.1 顺序文件</h4><ul><li><p><strong>链式存储</strong><br>逻辑上相邻的记录，<strong>在物理上离散存储</strong>。<br>​无论是定长/可变长记录，都无法实现随机存取，只能从链头开始遍历</p></li><li><p><strong>顺序存储</strong></p><p>逻辑上相邻的记录，在物理上也相邻。<br>没有说明的情况下，顺序文件指采用顺序存储的顺序文件</p><ul><li><p><strong>可变长记录</strong><br>无法实现随机存取</p></li><li><p><strong>定长记录</strong><br>可以实现随机存储。如果采用串结构(记录顺序与关键字无关)，无法快速找到某个关键字对应的记录，如果采用顺序结构(记录按关键字排序的)，可以使用折半查找快速找到记录</p></li></ul></li></ul><h4 id="2-2-2-索引文件"><a href="#2-2-2-索引文件" class="headerlink" title="2.2.2 索引文件"></a>2.2.2 索引文件</h4><ul><li><strong>索引表本身是定长记录的顺序文件</strong>，</li><li>索引表项包含索引号，长度，指针，<strong>真正的记录可以在物理上离散存储</strong>。</li><li><strong>索引号可以是关键字</strong>，这样就能折半查找加快检索速度，用于对信息处理及时性要求高的场合，解决了顺序文件增删不便的问题 可以用不同的数据项建立多个索引表</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092917082.png" alt="mark"></p><h4 id="2-2-3-索引顺序文件"><a href="#2-2-3-索引顺序文件" class="headerlink" title="2.2.3 索引顺序文件"></a>2.2.3 索引顺序文件</h4><ul><li><strong>将记录分组，每一个组对应一个索引表项</strong> </li><li><strong>检索记录时先检索索引表，找到分组，再顺序查找分组</strong> </li><li>记录过多时，可以建立多级索引表 记录N的表，平均查找次数是N/2</li></ul><ol><li><strong>索引文件的缺点</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093155169.png" alt="mark"></p><p><strong>索引顺序文件的效率分析：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093318355.png" alt="mark"></p><ul><li><strong>多级索引顺序文件</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093407395.png" alt="mark"></p><h2 id="3-文件的目录结构"><a href="#3-文件的目录结构" class="headerlink" title="3. 文件的目录结构"></a>3. 文件的目录结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093521886.png" alt="mark"></p><h3 id="3-1-文件控制块"><a href="#3-1-文件控制块" class="headerlink" title="3.1 文件控制块"></a>3.1 文件控制块</h3><ul><li><strong>一个FCB 对应一个文件，一个FCB就是一个目录项</strong>，</li><li><strong>FCB的有序集合叫“文件目录”</strong> </li><li>FCB包含了文件的基本信息，存取控制信息，使用信息等等，最重要的是文件名、文件存放的物理地址 对目录的操作:搜索、创建文件、删除文件、显示文件、修改文件</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093627660.png" alt="mark"></p><ul><li><strong>对目录的操作分类</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093700128.png" alt="mark"></p><h3 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 目录结构</h3><h4 id="3-2-1-单级目录结构"><a href="#3-2-1-单级目录结构" class="headerlink" title="3.2.1 单级目录结构"></a>3.2.1 单级目录结构</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093735243.png" alt="mark"></p><h4 id="3-2-2-两级目录结构"><a href="#3-2-2-两级目录结构" class="headerlink" title="3.2.2 两级目录结构"></a>3.2.2 两级目录结构</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093830141.png" alt="mark"></p><h4 id="3-2-3-多级目录结构-树形目录结构"><a href="#3-2-3-多级目录结构-树形目录结构" class="headerlink" title="3.2.3 多级目录结构(树形目录结构)"></a>3.2.3 多级目录结构(树形目录结构)</h4><ul><li><p>共享不方便</p></li><li><p>从根目录出发的路径叫做<strong>绝对路径</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094017394.png" alt="mark"></p><ul><li>从当前目录出发的路径叫做<strong>相对路径</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094026527.png" alt="mark"></p><h4 id="3-2-4-无环图目录结构"><a href="#3-2-4-无环图目录结构" class="headerlink" title="3.2.4 无环图目录结构"></a>3.2.4 无环图目录结构</h4><ul><li>树形目录结构能够便于实现文件分类，但是不利于文件共享</li><li><strong>为此在树形目录结构的基础上增加一些指向同一节点的有向边</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094101496.png" alt="mark"></p><h3 id="3-3-索引节点"><a href="#3-3-索引节点" class="headerlink" title="3.3 索引节点"></a>3.3 索引节点</h3><ul><li><strong>FCB  的问题</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094317250.png" alt="mark"></p><ul><li>存放在磁盘上的索引节点叫做<strong>磁盘索引节点</strong></li><li>当文件被打开的时候，磁盘索引节点复制到<strong>内存索引节点</strong>中</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094516179.png" alt="mark"></p><h2 id="4-文件的基本操作"><a href="#4-文件的基本操作" class="headerlink" title="4. 文件的基本操作"></a>4. 文件的基本操作</h2><ul><li><strong>创建文件(creat)</strong><ul><li>在外存中找到文件所需的<strong>空间</strong></li><li>根据<strong>文件路径找到对应的目录</strong>，创建文件对应的目录项</li></ul></li></ul><ul><li><strong>删除文件(delete)</strong><ul><li>根据文件路径找到对应的目录文件，找到文件名对应的目录项</li><li>回收文件占用的磁盘块</li><li>删除目录项</li></ul></li></ul><ul><li><strong>打开文件(open)</strong><ul><li>根据路径找到目录文件，找到文件名对应的目录项，检测用户的权限</li><li>将目录项复制到该进程在内存中的<strong>打开文件表</strong>中，返回<strong>表目编号</strong>(<strong>索引号/文件描述符FD</strong>)</li></ul></li></ul><ul><li><strong>关闭文件(close)</strong><ul><li>删除进程的打开文件表的对应项</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count -= 1 (归零时删除该项)</li></ul></li></ul><ul><li><strong>读文件(read)</strong><ul><li>需要提供进程<strong>打开文件表中的索引号</strong>，读入的数据量，数据在内存中存放的位置</li><li>从读指针指向的外存位置读取指定大小的数据到指定的内存区域</li></ul></li></ul><ul><li><strong>写文件(write)</strong><ul><li>需要提供打开文件表中的索引号，写出的数据量，写回外存的数据位置(写指针指向)</li></ul></li></ul><h2 id="5-文件共享"><a href="#5-文件共享" class="headerlink" title="5. 文件共享"></a>5. 文件共享</h2><h3 id="5-1-基于索引节点的共享（硬链接）"><a href="#5-1-基于索引节点的共享（硬链接）" class="headerlink" title="5.1 基于索引节点的共享（硬链接）"></a>5.1 基于索引节点的共享（硬链接）</h3><ul><li>索引节点里面放了一个链接计数器 count </li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094159031.png" alt="mark"></p><h3 id="5-2-基于符号链的共享（软链接）"><a href="#5-2-基于符号链的共享（软链接）" class="headerlink" title="5.2 基于符号链的共享（软链接）"></a>5.2 基于符号链的共享（软链接）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094226319.png" alt="mark"></p><ul><li>系统会创建一个<strong>Link 类型的新文件</strong><ul><li><strong>新文件的路径名</strong>只被视为是符号链</li><li>在利用符号链实现文件共享时候<ul><li><strong>只有文件的拥有</strong>者才拥有指向其索引节点的指针</li><li><strong>共享该文件的其他用户</strong>只有该为文件的路径名</li></ul></li></ul></li></ul><h2 id="6-文件保护"><a href="#6-文件保护" class="headerlink" title="6. 文件保护"></a>6. 文件保护</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094509107.png" alt="mark"></p><ol><li><strong>口令保护</strong></li><li><strong>加密保护</strong></li><li><strong>访问控制</strong></li></ol><h2 id="7-文件的系统层次结构"><a href="#7-文件的系统层次结构" class="headerlink" title="7. 文件的系统层次结构"></a>7. 文件的系统层次结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094625764.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094641719.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-18-文件基础&quot;&gt;&lt;a href=&quot;#操作系统-18-文件基础&quot; class=&quot;headerlink&quot; title=&quot;操作系统-18-文件基础&quot;&gt;&lt;/a&gt;操作系统-18-文件基础&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092059126.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Netty-05-异步模型</title>
    <link href="http://zhuuu.work/2020/10/24/Netty/Netty-05-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B/"/>
    <id>http://zhuuu.work/2020/10/24/Netty/Netty-05-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-24T00:05:24.000Z</published>
    <updated>2020-10-28T14:23:00.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-05-异步模型"><a href="#Netty-05-异步模型" class="headerlink" title="Netty-05-异步模型"></a>Netty-05-异步模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文注重讲解Netty的<strong>异步模型</strong> 和 <strong>任务的队列</strong></li></ul><h2 id="1-任务队列"><a href="#1-任务队列" class="headerlink" title="1. 任务队列"></a>1. 任务队列</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png" alt="mark"></p><ul><li>任务队列由<code>NioEventLoop</code> 维护并且不断执行，当我们收到请求之后，在当前的 <code>channel</code> 中对应的 <code>pipeline</code>中的各个 <code>Hanlder</code>进行业务的处理和请求的过滤。</li><li>当某些业务需要消费大量事件的时候，我们可以将这些任务提交到由 <code>NioEventLoop</code> 维护的 <code>taskQueue</code> 或者 <code>ScheduleTaskQueue</code>中， 让当前的 NioEventLoop 线程在空闲的时候去执行这些任务。</li><li><strong>下面将介绍提交任务的三种方式:</strong></li></ul><a id="more"></a><h3 id="1-1-用户程序自定义的普通任务"><a href="#1-1-用户程序自定义的普通任务" class="headerlink" title="1.1 用户程序自定义的普通任务"></a>1.1 用户程序自定义的普通任务</h3><ul><li>该方式会将任务提交到<code>taskQueue</code>队列中。提交到该队列中的任务会按照提交顺序依次执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelHandlerContext.channel().eventLoop().execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-2-用户自定的定时任务"><a href="#1-2-用户自定的定时任务" class="headerlink" title="1.2 用户自定的定时任务"></a>1.2 用户自定的定时任务</h3><ul><li>该方式会将任务提交到<code>scheduleTaskQueue</code>定时任务队列中。该队列是底层是优先队列<code>PriorityQueue</code>实现的，固该队列中的任务会按照时间的先后顺序定时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelHandlerContext.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="1-3-为其他的-EventLoop-线程对应的-Channel添加任务"><a href="#1-3-为其他的-EventLoop-线程对应的-Channel添加任务" class="headerlink" title="1.3 为其他的 EventLoop 线程对应的 Channel添加任务"></a>1.3 为其他的 EventLoop 线程对应的 Channel添加任务</h3><ul><li><strong>可以在<code>ChannelInitializer</code>中，将刚创建的各个<code>Channel</code>以及对应的标识加入到统一的集合中去</strong></li><li>然后可以根据表示获取 Channel 对应的 NioEventLoop,然后就可以调用<code>execute()</code>或者<code>schedule()</code>方法。</li></ul><h2 id="2-异步模型"><a href="#2-异步模型" class="headerlink" title="2. 异步模型"></a>2. 异步模型</h2><h3 id="2-1-异步的概念"><a href="#2-1-异步的概念" class="headerlink" title="2.1 异步的概念"></a>2.1 异步的概念</h3><ul><li>异步的概念和同步是相对的，当一个异步过程调用发出后，调用者不能立即的得到结果。实际处理这个调用的组件在完成后，<strong>通过状态，通知和回调来通知调用者</strong></li><li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind</code>、<code>Write</code>、<code>Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li><li>调用者并不能立即获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机构获取IO 的操作结果。</li></ul><p><strong>机制描述</strong></p><ul><li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code>返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code>去监控方法 <code>fun</code> 的处理过程(即 ： <code>Future-Listener</code> 机制)</li></ul><p><strong>关于 Future 的说明</strong></p><ul><li>表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等.</li><li><code>ChannelFuture</code> 是一个接口 ： <code>public interface ChannelFuture extends Future&lt;Void&gt;</code>。我们可以添加监听器，当监听的事件发生时，就会通知到监听器</li></ul><p><strong>工作原理示意图</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/215425984.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/215442367.png" alt="mark"></p><ul><li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用<code>future</code> 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。</li><li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</li></ul><h3 id="2-2-Future-Listener-机制"><a href="#2-2-Future-Listener-机制" class="headerlink" title="2.2 Future-Listener 机制"></a>2.2 Future-Listener 机制</h3><ul><li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li></ul><p><strong>常用方法如下：</strong></p><table><thead><tr><th>方法名称</th><th>方法作用</th></tr></thead><tbody><tr><td>isDone()</td><td>判断当前操作是否完成</td></tr><tr><td>isSuccess()</td><td>判断已完成的当前操作是否成功</td></tr><tr><td>getCause()</td><td>获取已完成当前操作失败的原因</td></tr><tr><td>isCancelled()</td><td>判断已完成的当前操作是否被取消</td></tr><tr><td>addListener()</td><td>注册监听器，当前操作（Future）已完成，将会通知指定的监听器</td></tr></tbody></table><p><strong>举例说明</strong></p><ul><li>绑定端口操作时异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">           System.out.println(newDate() + <span class="string">": 端口["</span>+ port + <span class="string">"]绑定成功!"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           System.err.println(<span class="string">"端口["</span>+ port + <span class="string">"]绑定失败!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="2-3-HTTP-实战入门"><a href="#2-3-HTTP-实战入门" class="headerlink" title="2.3 HTTP 实战入门"></a>2.3 HTTP 实战入门</h3><p><strong>目标 ：  浏览器访问<code>Netty</code>服务器后，返回<code>HelloWorld</code></strong></p><ol><li><strong>启动器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">TestServerInitializer</span>())</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口号操作</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>自定义ChannelInitializer</strong></p><p><strong>用于给<code>Channel</code>对应的<code>pipeline</code>添加<code>handler</code></strong>。该<code>ChannelInitializer</code>中的代码在<code>SocketChannel</code>被创建时都会执行</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向管道加入处理器</span></span><br><span class="line">        <span class="comment">// 首先得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 加入一个netty提供的HttpServerCodec</span></span><br><span class="line">        <span class="comment">// netty自带的http编码解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">"MyHttpServerCodec"</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 增加自定义handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"MyTestHttpServerHandler"</span>,<span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>自定义Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channelHandlerContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpObject 客户端和服务端互相通讯所使用的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, HttpObject httpObject)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 判断msg 是不是 HttpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(httpObject <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">            System.out.println(<span class="string">"msg 类型 = "</span> + httpObject.getClass());</span><br><span class="line">            System.out.println(<span class="string">"客户端地址："</span> + channelHandlerContext.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取http请求</span></span><br><span class="line">            HttpRequest request = (HttpRequest) httpObject;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从http请求中获取uri</span></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(request.uri());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 过滤http中的请求</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"/favicon.ico"</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">"请求了 favicon.ico，不做响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回复信息给浏览器[http协议]</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">"helloWorld"</span>, CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">// 构造一个http响应回复给浏览器</span></span><br><span class="line">            DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将构建好的response返回给客户端</span></span><br><span class="line">            channelHandlerContext.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-05-异步模型&quot;&gt;&lt;a href=&quot;#Netty-05-异步模型&quot; class=&quot;headerlink&quot; title=&quot;Netty-05-异步模型&quot;&gt;&lt;/a&gt;Netty-05-异步模型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文注重讲解Netty的&lt;strong&gt;异步模型&lt;/strong&gt; 和 &lt;strong&gt;任务的队列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-任务队列&quot;&gt;&lt;a href=&quot;#1-任务队列&quot; class=&quot;headerlink&quot; title=&quot;1. 任务队列&quot;&gt;&lt;/a&gt;1. 任务队列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务队列由&lt;code&gt;NioEventLoop&lt;/code&gt; 维护并且不断执行，当我们收到请求之后，在当前的 &lt;code&gt;channel&lt;/code&gt; 中对应的 &lt;code&gt;pipeline&lt;/code&gt;中的各个 &lt;code&gt;Hanlder&lt;/code&gt;进行业务的处理和请求的过滤。&lt;/li&gt;
&lt;li&gt;当某些业务需要消费大量事件的时候，我们可以将这些任务提交到由 &lt;code&gt;NioEventLoop&lt;/code&gt; 维护的 &lt;code&gt;taskQueue&lt;/code&gt; 或者 &lt;code&gt;ScheduleTaskQueue&lt;/code&gt;中， 让当前的 NioEventLoop 线程在空闲的时候去执行这些任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下面将介绍提交任务的三种方式:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Linux-10-内存页面置换算法</title>
    <link href="http://zhuuu.work/2020/10/22/Linux/Linux-10-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/10/22/Linux/Linux-10-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-22T03:22:53.000Z</published>
    <updated>2020-10-22T12:06:03.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-10-内存页面置换算法"><a href="#Linux-10-内存页面置换算法" class="headerlink" title="Linux-10-内存页面置换算法"></a>Linux-10-内存页面置换算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><a id="more"></a><h2 id="1-缺页异常"><a href="#1-缺页异常" class="headerlink" title="1. 缺页异常"></a>1. 缺页异常</h2><p>在了解内存页面置换算法前，我们得先谈一下<strong>缺页异常（缺页中断）</strong>。</p><p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p><ul><li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li><li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li></ul><p>我们来看一下缺页中断的处理流程，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142400418.png" alt="mark"></p><ol><li>在 CPU 里访问一条 <code>Load M</code> 指令，然后 <code>CPU</code> 会去找 M 所对应的页表项。</li><li>如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。</li><li>操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。</li><li>找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。</li><li>页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。</li><li>最后，CPU 重新执行导致缺页异常的指令。</li></ol><p>上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p><ul><li>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页<ul><li>如果该物理页有被修改过（脏页），则把它换出到磁盘</li><li>然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。</li></ul></li></ul><p>这里提一下，<strong>页表项</strong>通常有如下图的字段：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142756318.png" alt="mark"></p><ul><li><em>状态位</em>：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。</li><li><em>访问字段</em>：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。</li><li><em>修改位</em>：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。</li><li><em>硬盘地址</em>：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li></ul><h2 id="2-虚拟内存管理"><a href="#2-虚拟内存管理" class="headerlink" title="2. 虚拟内存管理"></a>2. 虚拟内存管理</h2><p>这里整理了虚拟内存的管理整个流程，你可以从下面这张图看到：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142914008.jpg" alt="mark"></p><ul><li><p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong></p></li><li><p>也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。</p></li></ul><h2 id="3-常见的页面置换算法"><a href="#3-常见的页面置换算法" class="headerlink" title="3. 常见的页面置换算法"></a>3. 常见的页面置换算法</h2><p>那其算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种：</p><ul><li>最佳页面置换算法（<em>OPT</em>）</li><li>先进先出置换算法（<em>FIFO</em>）</li><li>最近最久未使用的置换算法（<em>LRU</em>）</li><li>时钟页面置换算法（<em>Lock</em>）</li><li>最不常用置换算法（<em>LFU</em>）</li></ul><h3 id="3-1-最佳页面置换算法"><a href="#3-1-最佳页面置换算法" class="headerlink" title="3.1 最佳页面置换算法"></a>3.1 最佳页面置换算法</h3><ul><li>最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</li><li>所以，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。</li><li>我们举个例子，假设一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143450166.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>7</code> 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 <code>4</code> 次。</li><li>这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。</li><li>所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。</li></ul><h3 id="3-2-先进先出置换算法"><a href="#3-2-先进先出置换算法" class="headerlink" title="3.2 先进先出置换算法"></a>3.2 先进先出置换算法</h3><ul><li>既然我们无法预知页面在下一次访问前所需的等待时间，那我们可以<strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</li><li>还是以前面的请求的页面序列作为例子，假设使用先进先出置换算法，则过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143610965.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>10</code> 次，页面置换共发生了 <code>7</code> 次，跟最佳页面置换算法比较起来，性能明显差了很多。</li></ul><h3 id="3-3-最近最久未使用置换算法（LRU）"><a href="#3-3-最近最久未使用置换算法（LRU）" class="headerlink" title="3.3 最近最久未使用置换算法（LRU）"></a>3.3 最近最久未使用置换算法（LRU）</h3><ul><li><p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p></li><li><p>这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。</p></li><li><p>还是以前面的请求的页面序列作为例子，假设使用最近最久未使用的置换算法，则过程如下图：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143749910.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>9</code> 次，页面置换共发生了 <code>6</code> 次，跟先进先出置换算法比较起来，性能提高了一些。</li><li>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。</li><li>困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</li><li>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</li></ul><h3 id="3-4-时钟页面置换算法"><a href="#3-4-时钟页面置换算法" class="headerlink" title="3.4 时钟页面置换算法"></a>3.4 时钟页面置换算法</h3><ul><li><p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p></li><li><p>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</p></li></ul><p>该算法的思路是，<strong>把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</strong></p><ul><li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144000359.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144016734.png" alt="mark"></p><p>了解了这个算法的工作方式，就明白为什么它被称为时钟（<em>Clock</em>）算法了</p><h3 id="3-5-最不常用算法（LFU）"><a href="#3-5-最不常用算法（LFU）" class="headerlink" title="3.5 最不常用算法（LFU）"></a>3.5 最不常用算法（LFU）</h3><ul><li>最不常用（<em>LFU</em>）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是<strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</li><li>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</li></ul><p><strong>缺点</strong></p><ul><li>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</li><li>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果<strong>链表长度很大，是非常耗时</strong>的，效率不高。</li><li>LFU 算法<strong>只考虑了频率问题，没考虑时间的问题</strong>，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。<ul><li>那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2</li><li>也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-10-内存页面置换算法&quot;&gt;&lt;a href=&quot;#Linux-10-内存页面置换算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-10-内存页面置换算法&quot;&gt;&lt;/a&gt;Linux-10-内存页面置换算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="内存页面置换" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Netty-04-线程模型</title>
    <link href="http://zhuuu.work/2020/10/19/Netty/Netty-04-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://zhuuu.work/2020/10/19/Netty/Netty-04-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-19T03:05:24.000Z</published>
    <updated>2020-10-24T00:52:11.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-04-线程模型"><a href="#Netty-04-线程模型" class="headerlink" title="Netty-04-线程模型"></a>Netty-04-线程模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="原生NIO存在的问题"><a href="#原生NIO存在的问题" class="headerlink" title="原生NIO存在的问题"></a>原生NIO存在的问题</h3><ul><li>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code> 等。</li><li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。</li><li>开发工作量和难度都非常大：例如客户端面临<strong>断连重连</strong>、<strong>网络闪断</strong>、<strong>半包读写</strong>、<strong>失败缓存</strong>、<strong>网络拥塞和异常流的处理</strong>等等。</li><li>JDK NIO 的 Bug : 例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU</code> 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。</li></ul><h3 id="Netty优点"><a href="#Netty优点" class="headerlink" title="Netty优点"></a>Netty优点</h3><ul><li><strong><code>Netty</code>对<code>JDK</code>自带的<code>NIO</code>的<code>API</code>进行了封装，解决了上述问题。</strong><ul><li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池.</li><li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持</li><li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li></ul></li></ul><a id="more"></a><h2 id="1-I-O线程模型"><a href="#1-I-O线程模型" class="headerlink" title="1. I/O线程模型"></a>1. I/O线程模型</h2><p>目前存在的线程模型主要有：</p><ul><li><strong>传统阻塞I/O服务模型</strong></li><li><strong>Reactor模式</strong></li></ul><p>根据<code>Reactor</code>的数量和处理资源池线程的数量不同，有<strong>如下<code>3</code>种典型的实现</strong></p><ul><li>单<code>Reactor</code>单线程</li><li>单<code>Reactor</code>多线程</li><li>主从<code>Reactor</code>多线程</li></ul><ul><li><code>Netty</code>线程模型主要基于<strong>主从Reactor多线程模型</strong>做了一定的改进，其中主从<code>Reactor</code>多线程模型有多个<code>Reactor</code>。</li></ul><h3 id="1-1-传统阻塞I-O服务模型"><a href="#1-1-传统阻塞I-O服务模型" class="headerlink" title="1.1 传统阻塞I/O服务模型"></a>1.1 传统阻塞I/O服务模型</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/110137563.png" alt="mark"></p><p><strong>图解说明：黄色的框表示对象，蓝色的框表示线程、白色的框表示方法（API）。之后的图相同。</strong></p><h4 id="1-1-1-模型分析"><a href="#1-1-1-模型分析" class="headerlink" title="1.1.1 模型分析"></a>1.1.1 模型分析</h4><p><strong>模型特点：</strong></p><ul><li>采用阻塞<code>IO</code>模式获取输入的数据</li><li>每个链接都需要独立的线程完成数据的输入，业务处理、数据返回。</li></ul><p><strong>问题分析：</strong></p><ul><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在<code>read</code>操作，造成线程资源浪费。</li></ul><h4 id="1-1-2-代码实现"><a href="#1-1-2-代码实现" class="headerlink" title="1.1.2 代码实现"></a>1.1.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">// 2. 如果有客户端前来链接，就创建一个线程与之通信（单独的一个方法）</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 监听等待客户端的连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端请求"</span>);</span><br><span class="line">            <span class="comment">// 创建一个线程与之通信</span></span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 重写Runnable 方法，与客户端进行同i性能</span></span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个handler方法，和客户端通讯，主要进行数据的读取和业务的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">// 循环的读取客户端发送来的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read)); <span class="comment">// 输出客户端发送的数据</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的链接"</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Reactor-模型概述"><a href="#1-2-Reactor-模型概述" class="headerlink" title="1.2 Reactor 模型概述"></a>1.2 Reactor 模型概述</h3><p><strong>针对传统阻塞I/O服务模型的2个缺点，解决方案如下：</strong></p><ul><li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。<code>Reactor</code> 对应的叫法: 1. 反应器模式 2. 分发者模式(<code>Dispatcher</code>) 3. 通知者模式(<code>notifier</code>)</li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li></ul><p><strong>I/O复用结合线程池，就是Reactor模式基本设计思想，如图所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/112628506.png" alt="mark"></p><ul><li><code>Reactor</code> 模式，通过一个或者多个输入同时传递给服务处理器模式（基于事件驱动） </li><li>服务端端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此<code>Reactor</code>模式也叫做<code>Dispatcher</code> 模式</li><li><code>Reactor</code>模式使用的IO多路复用监听事件，收到事件后，分发到某个线程或者进程，这点就是网络服务高并发处理的关键。</li></ul><p><strong>Reactor模式中的核心组成部分：</strong></p><ul><li><code>Reactor</code>：<code>Reactor</code>在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对<code>IO</code>事件作出反应。</li><li><code>Handlers</code>：处理程序执行<code>I/O</code>事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code>通过调度适当的处理程序来响应<code>I/O</code>事件，处理程序执行非阻塞操作。</li></ul><h3 id="1-3-单Reactor-单线程模式"><a href="#1-3-单Reactor-单线程模式" class="headerlink" title="1.3 单Reactor 单线程模式"></a>1.3 单Reactor 单线程模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/113023202.png" alt="mark"></p><p><strong>方案说明：</strong></p><ul><li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 Handler 来响应<ul><li><code>Handler</code> 会完成 <code>Read</code>→业务处理→<code>Send</code> 的完整业务流程</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/094751253.png" alt="mark"></p><h4 id="1-3-1-模型分析"><a href="#1-3-1-模型分析" class="headerlink" title="1.3.1 模型分析"></a>1.3.1 <strong>模型分析</strong></h4><ul><li><strong>优点</strong>：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li><li><strong>缺点</strong>：<ul><li>性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code> 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li></ul></li><li><strong>使用场景</strong>：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code>在业务处理的时间复杂度 <code>O(1)</code> 的情况</li></ul><h4 id="1-3-2-代码实现"><a href="#1-3-2-代码实现" class="headerlink" title="1.3.2 代码实现"></a>1.3.2 代码实现</h4><blockquote><p>这里面我为了简便，我将Reactor和Acceptor和Handler三个对象搞成了方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> PORT = <span class="number">6666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对客户端进行监听事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="comment">// 返回值大于0表示有客户端产生事件</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 取出产生事件的channel</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    <span class="comment">// 对事件遍历</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey next = iterator.next();</span><br><span class="line">                        <span class="comment">// 将key进行分发</span></span><br><span class="line">                        dispatch(next);</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">            <span class="comment">// 如果是连接事件</span></span><br><span class="line">            accept(key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 其他事件</span></span><br><span class="line">            handler(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立新的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对请求进行处理，接收消息--业务处理--返回消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            StringBuilder msg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (channel.read(buffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                msg.append(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"接收到消息："</span> + msg.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            String ok = <span class="string">"OK"</span>;</span><br><span class="line">            buffer.put(ok.getBytes());</span><br><span class="line">            <span class="comment">//这个flip非常重要哦，是将position置0，limit置于position的位置，</span></span><br><span class="line">            <span class="comment">// 以便下面代码进行写入操作能够正确写入buffer中的所有数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">"离线了"</span>);</span><br><span class="line">                <span class="comment">//取消该通道的注册并关闭通道，这里非常重要，没有这一步的话当客户端断开连接就会不断抛出IOException</span></span><br><span class="line">                <span class="comment">//是因为，select会一直产生该事件。</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test test = <span class="keyword">new</span> test();</span><br><span class="line">        test.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有更牛逼更完整的<code>Reactor</code>单线程模型的代码案例：</strong><a href="https://www.cnblogs.com/hama1993/p/10611229.html" target="_blank" rel="noopener">https://www.cnblogs.com/hama1993/p/10611229.html</a></p><h3 id="1-4-单Reactor-多线程模式"><a href="#1-4-单Reactor-多线程模式" class="headerlink" title="1.4 单Reactor 多线程模式"></a>1.4 单Reactor 多线程模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/095400913.png" alt="mark"></p><p><strong>方案说明：</strong></p><ul><li><code>Reactor</code> 对象通过<code>select</code> 监控客户端请求事件, 收到事件后，通过<code>dispatch</code>进行分发</li><li>如果建立连接请求, 则右<code>Acceptor</code> 通过accept 处理连接请求, 然后创建一个<code>Handler</code>对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由<code>reactor</code>分发调用连接对应的<code>handler</code> 来处理</li><li>handler 只负责响应事件，不做具体的业务处理, 通过<code>read</code> 读取数据后，会分发给后面的<code>worker</code>线程池的某个线程处理业务</li><li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给<code>handler</code></li><li><code>handler</code>收到响应后，通过<code>send</code> 将结果返回给<code>client</code></li></ul><h4 id="1-4-1-模型分析"><a href="#1-4-1-模型分析" class="headerlink" title="1.4.1 模型分析"></a>1.4.1 模型分析</h4><ul><li><strong>优点</strong>：可以充分的利用多核<code>cpu</code> 的处理能力</li><li><strong>缺点</strong>：多线程数据共享和访问比较复杂， <code>reactor</code> 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈.</li></ul><h4 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h4><ul><li><code>ReadHandler</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadHandler</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//处理读请求</span></span><br><span class="line">            doRead(sc);</span><br><span class="line">            <span class="comment">//处理完读请求，将通道注册为写</span></span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SocketChannel ssc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"读取数据，然后做一些数据处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在ReadHandler中，doRead(sc)，方法是同步的，而一般读到一个请求要经历解析请求信息，然后交到对应的service处理业务等等操作，非常耗时，此时将doRead进行异步处理，将能提高服务器资源的使用，提高性能。</li><li>所以单Reactor单线程模型的实现，就是将单线程模型中的Handler中的数据处理异步处理，并引入线程池管理这些线程，这样dispatch将专注于事件分发，而各自handler专注于各自的事件处理。</li></ul><ul><li><strong>单Reactor多线程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单Reactor多线程模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneReactorMultiThreadMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个线程池，然后启动MultiReacor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPool.getPool().init(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> MultiReactor(<span class="number">8089</span>).run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>MultiReactor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel servChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiReactor</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            servChannel = ServerSocketChannel.open();</span><br><span class="line">            servChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            servChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">1024</span>);</span><br><span class="line">            SelectionKey sk = servChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            stop=<span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">"The time server is start in port : "</span> + port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select(<span class="number">1000</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line">                SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        disptach(key);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            <span class="keyword">if</span> (key.channel() != <span class="keyword">null</span>)</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disptach</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiAcceptor(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiReadHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiWriteHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>MultiAcceptor</strong> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiAcceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiAcceptor</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>MultiReadHandler</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiReadHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiReadHandler</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//使用线程池，异步处理读请求</span></span><br><span class="line">            ThreadPool.getPool().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    doRead(sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理完读请求，将通道注册为写</span></span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SocketChannel ssc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"读取数据，然后做一些数据处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>线程池</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例-线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPool pool = <span class="keyword">new</span> ThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> init=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPool</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!init)&#123;</span><br><span class="line">            executorService=Executors.newFixedThreadPool(size);</span><br><span class="line">            init=<span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"the thread pool had inited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPool <span class="title">getPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(init)&#123;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"the thread pool is not inited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-主从Reactor模式"><a href="#1-5-主从Reactor模式" class="headerlink" title="1.5 主从Reactor模式"></a>1.5 主从Reactor模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/094348642.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/094725334.png" alt="mark"></p><p><strong>方案说明</strong></p><ul><li><code>Reactor</code>主线程 <code>MainReactor</code> 对象就只注册一个用于监听连接请求的<code>ServerSocketChannel</code>，通过<code>select</code> 监听连接事件, 收到事件后，通过<code>Acceptor</code> 处理连接事件</li><li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 通过<code>accept</code>获取新的连接，并将连接注册到<code>SubReactor</code></li><li><code>subreactor</code> 将连接加入到连接队列进行监听,并创建<code>handler</code>进行各种事件处理</li><li>当有新事件发生时， <code>subreactor</code> 就会调用对应的<code>handler</code>处理</li><li><code>handler</code> 通过<code>read</code> 读取数据，分发给后面的<code>worker</code> 线程处理</li><li><code>worker</code> 线程池分配独立的<code>worker</code> 线程进行业务处理，并返回结果</li><li>handler<code>收到响应的结果后，再通过</code>send<code>将结果返回给</code>client</li><li>Reactor<code>主线程可以对应多个</code>Reactor<code>子线程, 即</code>MainRecator<code>可以关联多个</code>SubReactor</li></ul><h4 id="1-5-1-模型分析"><a href="#1-5-1-模型分析" class="headerlink" title="1.5.1 模型分析"></a>1.5.1 模型分析</h4><ul><li><strong>优点</strong>：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li><strong>优点</strong>：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据</li><li><strong>缺点</strong>：编程复杂度较高</li><li><strong>结合实例</strong>：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li></ul><h4 id="1-5-2-代码实现"><a href="#1-5-2-代码实现" class="headerlink" title="1.5.2 代码实现"></a>1.5.2 代码实现</h4><ul><li>主从Reactor多线程模型，将使用两个selector，一个主selector专门维护accept事件，当接收到accept事件，将该连接交给从selector，从selector维护该连接的read和write事件。</li><li>主从selector的方式，将连接和数据处理完全分开维护，将大大提高并发量。</li><li>[参考博客][<a href="https://www.cnblogs.com/eason-ou/p/11912010.html]" target="_blank" rel="noopener">https://www.cnblogs.com/eason-ou/p/11912010.html]</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主从Reactor多线程模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAndSubReactorMultiThreadMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个线程池，然后创建一个主Reactor，并加入一个从Reactor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPool.getPool().init(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> MainReactor(<span class="number">8089</span>).addSub(<span class="keyword">new</span> SubReactor()).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>主Reactor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主Reactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainReactor</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护一个从Reactor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SubReactor subReactor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel servChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainReactor</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            servChannel = ServerSocketChannel.open();</span><br><span class="line">            servChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            servChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">1024</span>);</span><br><span class="line">            SelectionKey sk = servChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            stop=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.port=port;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加子Reactor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subReactor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainReactor <span class="title">addSub</span><span class="params">(SubReactor subReactor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subReactor=subReactor;</span><br><span class="line">        <span class="keyword">this</span>.subReactor.run();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主reactor开始启动了,监听端口："</span>+port+<span class="string">"......."</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select(<span class="number">1000</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line">                SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        disptach(key);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            <span class="keyword">if</span> (key.channel() != <span class="keyword">null</span>)</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disptach</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 主Reactor只关心Accept事件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiAcceptor(key).addSub(<span class="keyword">this</span>.subReactor).run();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果未使用了从Reactor</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.subReactor==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiReadHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiWriteHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>从Reactor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Reactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubReactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = SelectorProvider.provider().openSelector();</span><br><span class="line">            stop=<span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将主Reactor中的Channel注册到从Reactor中的selector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sc.register(selector,SelectionKey.OP_READ|SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPool.getPool().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"从reactor开始启动了。。。。。"</span>);</span><br><span class="line">                <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        selector.select(<span class="number">1000</span>);</span><br><span class="line">                        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line">                        SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            key = it.next();</span><br><span class="line">                            it.remove();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                disptach(key);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    <span class="keyword">if</span> (key.channel() != <span class="keyword">null</span>)</span><br><span class="line">                                        key.channel().close();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        t.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disptach</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从Reactor只关心读和写事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiReadHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiWriteHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>acceptor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiAcceptor</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SubReactor subReactor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiAcceptor</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiAcceptor <span class="title">addSub</span><span class="params">(SubReactor subReactor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subReactor=subReactor;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(subReactor==<span class="keyword">null</span>)&#123;</span><br><span class="line">                Selector selector = selectionKey.selector();</span><br><span class="line">                SelectionKey sk = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"accept"</span>);</span><br><span class="line">                subReactor.register(sc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ReadHandler</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiReadHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiReadHandler</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//使用线程池，异步处理读请求</span></span><br><span class="line">            ThreadPool.getPool().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    doRead(sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理完读请求，将通道注册为写</span></span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SocketChannel ssc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"读取数据，然后做一些数据处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>WriteHandler</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiWriteHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiWriteHandler</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SocketChannel sc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理写。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//使用线程池，异步处理写请求</span></span><br><span class="line">            ThreadPool.getPool().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    doWrite(sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//写完后，将通道注册为读</span></span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>线程池</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例-线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPool pool = <span class="keyword">new</span> ThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> init=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPool</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!init)&#123;</span><br><span class="line">            executorService=Executors.newFixedThreadPool(size);</span><br><span class="line">            init=<span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"the thread pool had inited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPool <span class="title">getPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(init)&#123;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"the thread pool is not inited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Netty-线程模型"><a href="#2-Netty-线程模型" class="headerlink" title="2. Netty 线程模型"></a>2. Netty 线程模型</h2><h3 id="2-1-主从Reactor进阶"><a href="#2-1-主从Reactor进阶" class="headerlink" title="2.1 主从Reactor进阶"></a>2.1 主从Reactor进阶</h3><ul><li><code>Netty</code>主要是基于主从<code>Reactor</code>多线程模式做了一定的改进，其中主从<code>Reactor</code>都有单一的一个变成了多个。下面是简单的改进图。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/095946610.png" alt="mark"></p><ul><li>如图所示，增加了<code>BossGroup</code>来维护多个主<code>Reactor</code>，主<code>Reactor</code>还是只关注连接的<code>Accept</code>；增加了<code>WorkGroup</code>来维护多个从<code>Reactor</code>，从<code>Reactor</code>将接收到的请求交给<code>Handler</code>进行处理。</li><li>在主<code>Reactor</code>中接收到<code>Accept</code>事件，获取到对应的<code>SocketChannel</code>，<code>Netty</code>会将它进一步封装成<code>NIOSocketChannel</code>对象，这个封装后的对象还包含了该<code>Channel</code>对应的<code>SelectionKey</code>、通信地址等详细信息</li><li><code>Netty</code>会将装个封装后的<code>Channel</code>对象注册到<code>WorkerGroup</code>中的从<code>Reactor</code>中。</li><li>当<code>WorkerGroup</code>中的从<code>Reactor</code>监听到事件后，就会将之交给与此<code>Reactor</code>对应的<code>Handler</code>进行处理。</li></ul><p><strong>稍微详细图如下</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/100035114.png" alt="mark"></p><ul><li><p><code>Netty</code>将<code>Selector</code>以及<code>Selector</code>相关的事件及任务封装了<code>NioEventLoop</code>，这样<code>BossGroup</code>就可以通过管理<code>NioEventLoop</code>去管理各个<code>Selector</code>。</p></li><li><p>同时，<code>Netty</code>模型中主要存在两个大的线程池组<code>BossGroup</code>和<code>WorkerGroup</code>，用于管理主<code>Reactor</code>线程和从<code>Reactor</code>线程。</p></li></ul><h3 id="2-2-Netty-模型"><a href="#2-2-Netty-模型" class="headerlink" title="2.2 Netty 模型"></a>2.2 Netty 模型</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/122455038.png" alt="mark"></p><p><strong>图中详细解释</strong></p><ul><li><p><code>Netty</code>抽象出两组线程池，</p><ul><li><code>BossGroup</code>专门负责接收客户端的连接，</li><li><code>WorkerGroup</code>专门负责网络的读写</li></ul></li><li><p><code>BossGroup</code>和<code>WorkerGroup</code>类型的本质都是<code>NioEventLoopGroup</code>类型。</p></li><li><p><code>NioEventLoopGroup</code>相当于一个线程管理器（类似于<code>ExecutorServevice</code>），它下面维护很多个<code>NioEventLoop</code>线程。</p><ul><li>在初始化这两个线程组的时候，默认会在每个<code>Group</code>中生成<code>CPU*2</code>个<code>NioEventLoop</code>线程</li><li>当<code>n</code>个连接来了，<code>Group</code>默认会按照连接请求的顺序分别将这些连接分给各个<code>NioEventLoop</code>去处理。</li><li>同时<code>Group</code>还负责管理<code>EventLoop</code>的生命周期。</li></ul></li><li><p><code>NioEventLoop</code>表示一个不断循环的执行处理任务的线程</p><ul><li><strong>它维护了一个线程和任务队列</strong></li><li>每个<code>NioEventLoop</code>都包含一个<code>Selector</code>，用于监听绑定在它上面的<code>socket</code>通讯。</li><li>每个<code>NioEventLoop</code>相当于<code>Selector</code>，负责处理多个<code>Channel</code>上的事件</li><li>每增加一个请求连接，<code>NioEventLoopGroup</code>就将这个请求依次分发给它下面的</li><li><code>NioEventLoop</code>处理。</li></ul></li><li><p><strong>每个<code>Boss NioEventLoop</code>循环执行的步骤有3步：</strong></p><ul><li>轮询<code>accept</code>事件</li><li>处理<code>accept</code>事件，与<code>client</code>建立连接，生成<code>NioSocketChannel</code>，并将其注册到某个<code>Worker NioEventLoop</code>的<code>selector</code>上。</li><li>处理任务队列到任务，即<code>runAllTasks</code></li></ul></li><li><p><strong>每个<code>Worker NioEventLoop</code>循环执行的步骤：</strong></p><ul><li>轮询<code>read</code>，<code>write</code>事件</li><li>处理<code>I/O</code>事件，即<code>read</code>，<code>write</code>事件，在对应的<code>NioSocketChannel</code>中进行处理</li><li>处理任务队列的任务，即<code>runAllTasks</code></li></ul></li><li><p><strong>每个 <code>Worker NioEventLoop</code>处理业务时，会使用<code>pipeline</code>（管道）</strong></p><ul><li><code>pipeline</code>中维护了一个<code>ChannelHandlerContext</code>链表</li><li><code>ChannelHandlerContext</code>则保存了<code>Channel</code>相关的所有上下文信息，同时关联一个<code>ChannelHandler</code>对象。</li><li>如图所示，<code>Channel</code>和<code>pipeline</code>一一对应，<code>ChannelHandler</code>和<code>ChannelHandlerContext</code>一一对应。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><h3 id="2-3-ChannelHandler"><a href="#2-3-ChannelHandler" class="headerlink" title="2.3 ChannelHandler"></a>2.3 ChannelHandler</h3><ul><li><code>ChannelHandler</code>是一个接口，负责处理或拦截<code>I/O</code>操作，并将其转发到<code>Pipeline</code>中的下一个处理<code>Handler</code>进行处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">                                               I&#x2F;O Request</span><br><span class="line">                                          via Channel or</span><br><span class="line">                                      ChannelHandlerContext</span><br><span class="line">                                                    |</span><br><span class="line">+---------------------------------------------------+---------------+</span><br><span class="line">|                           ChannelPipeline         |               |</span><br><span class="line">|                                                  \|&#x2F;              |</span><br><span class="line">|    +---------------------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">|               |                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  .               |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">|        [ method call]                       [method call]         |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">|               .                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">|               |                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">                |                                  \|&#x2F;</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">|               |                                   |               |</span><br><span class="line">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">|                                                                   |</span><br><span class="line">|  Netty Internal I&#x2F;O Threads (Transport Implementation)            |</span><br><span class="line">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="3-Netty-入门代码实例"><a href="#3-Netty-入门代码实例" class="headerlink" title="3. Netty 入门代码实例"></a>3. Netty 入门代码实例</h2><ol><li><strong>服务器端</strong></li></ol><ul><li><strong>服务端启动器代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NettyPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//1、创建两个线程组，bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2、bossGroup 只是处理连接请求，真正的和客户端业务处理，会交给 workerGroup 完成</span></span><br><span class="line">        <span class="comment">//3、两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4、bossGroup 和 workerGroup 含有的子线程（NioEventLoop）个数为实际 cpu 核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup worderGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置，配置</span></span><br><span class="line">            bootstrap.group(bossGroup, worderGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) //使用 <span class="title">NioServerSocketChannel</span> 作为服务器的通道实现</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128) //设置线程队列得到连接个数</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>) //设置保持活动连接状态</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123; <span class="comment">//为accept channel的pipeline预添加的handler</span></span><br><span class="line">                        <span class="comment">//给 pipeline 添加处理器，每当有连接accept时，就会运行到此处。</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">//给我们的 workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"........服务器 is ready......"</span>);</span><br><span class="line">            <span class="comment">//绑定一个端口并且同步，生成了一个ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器（并绑定端口）</span></span><br><span class="line">            ChannelFuture future = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            worderGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>服务器端处理器代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NettyPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *读取客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象，含有 管道pipeline，通道channel，地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 就是客户端发送的数据，默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器读取线程："</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"server ctx = "</span> + ctx);</span><br><span class="line">        <span class="comment">// 看看Channel 和 PipelLine的瓜西</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将msg 转换成一个ByteBuf ，比较NIO的ByteBuffer 性能的提高</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"客户端发来的消息是 + "</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"客户端的地址是 + "</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 它是 write + flush ，将数据写入到缓存buffer，并将buffer中的数据flush进入通道</span></span><br><span class="line">        <span class="comment">// 一般来讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello 客户端！"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常，一般是关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>客户端</strong></li></ol><ul><li><strong>客户端的启动器代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NettyPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 客户端需要一个事件循环组</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建启动器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">            <span class="comment">// 注意： 客户端使用的不是ServerBootStrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">// 设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>) // 设置客户端通道的是实现类(使用反射实现)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">// 加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"----- 客户端 is Ready----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动客户端去连接服务器端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">// 给监听的通道关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>客户端的处理器代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NettyPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client is + "</span> + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello Server ~！ "</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取的事件的时候，就会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"服务器回复的消息是："</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务器的地址是 + "</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生异常的关闭处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考博客</strong> ： <a href="https://www.cnblogs.com/eason-ou/p/11912010.html" target="_blank" rel="noopener">https://www.cnblogs.com/eason-ou/p/11912010.html</a></p><p>​                    <a href="https://blog.csdn.net/Danny_idea/article/details/89286195" target="_blank" rel="noopener">https://blog.csdn.net/Danny_idea/article/details/89286195</a>    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-04-线程模型&quot;&gt;&lt;a href=&quot;#Netty-04-线程模型&quot; class=&quot;headerlink&quot; title=&quot;Netty-04-线程模型&quot;&gt;&lt;/a&gt;Netty-04-线程模型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;原生NIO存在的问题&quot;&gt;&lt;a href=&quot;#原生NIO存在的问题&quot; class=&quot;headerlink&quot; title=&quot;原生NIO存在的问题&quot;&gt;&lt;/a&gt;原生NIO存在的问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 &lt;code&gt;Selector&lt;/code&gt;、&lt;code&gt;ServerSocketChannel&lt;/code&gt;、&lt;code&gt;SocketChannel&lt;/code&gt;、&lt;code&gt;ByteBuffer&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;需要具备其他的额外技能：要熟悉 &lt;code&gt;Java&lt;/code&gt; 多线程编程，因为 &lt;code&gt;NIO&lt;/code&gt; 编程涉及到 &lt;code&gt;Reactor&lt;/code&gt; 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。&lt;/li&gt;
&lt;li&gt;开发工作量和难度都非常大：例如客户端面临&lt;strong&gt;断连重连&lt;/strong&gt;、&lt;strong&gt;网络闪断&lt;/strong&gt;、&lt;strong&gt;半包读写&lt;/strong&gt;、&lt;strong&gt;失败缓存&lt;/strong&gt;、&lt;strong&gt;网络拥塞和异常流的处理&lt;/strong&gt;等等。&lt;/li&gt;
&lt;li&gt;JDK NIO 的 Bug : 例如臭名昭著的 &lt;code&gt;Epoll Bug&lt;/code&gt;，它会导致 &lt;code&gt;Selector&lt;/code&gt; 空轮询，最终导致 &lt;code&gt;CPU&lt;/code&gt; 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Netty优点&quot;&gt;&lt;a href=&quot;#Netty优点&quot; class=&quot;headerlink&quot; title=&quot;Netty优点&quot;&gt;&lt;/a&gt;Netty优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Netty&lt;/code&gt;对&lt;code&gt;JDK&lt;/code&gt;自带的&lt;code&gt;NIO&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;进行了封装，解决了上述问题。&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;设计优雅：适用于各种传输类型的统一 &lt;code&gt;API&lt;/code&gt; 阻塞和非阻塞 &lt;code&gt;Socket&lt;/code&gt;；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池.&lt;/li&gt;
&lt;li&gt;安全：完整的 &lt;code&gt;SSL/TLS&lt;/code&gt; 和 &lt;code&gt;StartTLS&lt;/code&gt; 支持&lt;/li&gt;
&lt;li&gt;高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-16-内存扩充</title>
    <link href="http://zhuuu.work/2020/10/19/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-16-%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85/"/>
    <id>http://zhuuu.work/2020/10/19/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-16-%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85/</id>
    <published>2020-10-19T03:00:53.000Z</published>
    <updated>2020-10-23T01:20:10.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-16-内存扩充"><a href="#操作系统-16-内存扩充" class="headerlink" title="操作系统-16-内存扩充"></a>操作系统-16-内存扩充</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113853923.png" alt="mark"></p><a id="more"></a><h2 id="1-覆盖技术"><a href="#1-覆盖技术" class="headerlink" title="1. 覆盖技术"></a>1. 覆盖技术</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113907728.png" alt="mark"></p><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113936749.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/114009295.png" alt="mark"></p><h2 id="2-交换技术"><a href="#2-交换技术" class="headerlink" title="2. 交换技术"></a>2. 交换技术</h2><ol><li><strong>概念</strong></li></ol><ul><li>内存紧张时，把进程暂时换出到外存 </li><li>见：进程的<strong>中级调度(内存调度)</strong>，挂起态，七状态模型 磁盘分为对换区(swap)和文件区，前者连续分配追求<code>I/O</code>速度，后者离散分配追求存储空间利用率 </li><li>优先换出阻塞进程、低优先级进程（可能导致饥饿）、还要考虑进程在内存的驻留时间，</li><li><code>PCB</code>不会换出</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/114115334.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/115956949.png" alt="mark"></p><h2 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3. 虚拟内存"></a>3. 虚拟内存</h2><ul><li><p><strong>传统存储方式的缺点</strong></p><p><strong>连续分配/非连续分配</strong></p><ul><li><p><strong>一次性</strong><br>作业必须一次性全部装入内存后才能开始运行。大作业无法运行,多道程序并发度下降。</p></li><li><p><strong>驻留性</strong><br>作业在运行期间一直驻留在内存，内存中驻留大量的暂时用不到的数据，浪费了宝贵的内存资源。</p></li></ul></li></ul><ul><li><strong>局部性原理</strong><ul><li>时间局部性<br>现在访问的指令、数据在不久后很可能再次访问</li><li>空间局部性<br>现在访问的内存单元周围的内存空间很可能在不久之后访问</li><li>高速缓存<br>频繁访问的数据放到更高速的储存器中</li></ul></li></ul><ul><li><p><strong>虚拟内存的定义和特征</strong></p><p>程序不需要全部装入内存即可运行，运行时根据需要动态调入数据，内存不够时，换出一些数据到外存</p><ul><li><p><strong>多次性</strong><br>作业无需在运行时一次装入内存，而是允许分多次调用</p></li><li><p><strong>对换性</strong><br>作业无需在运行时常驻内存，允许作业换入、换出</p></li><li><p><strong>虚拟性</strong><br>从逻辑上扩充了内存容量，用户看到的容量，远大于实际容量</p></li></ul></li></ul><h3 id="3-1-请求分页"><a href="#3-1-请求分页" class="headerlink" title="3.1 请求分页"></a>3.1 请求分页</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/085952774.png" alt="mark"></p><ul><li><strong>请求分页</strong><br>访问的信息不存在时，操作系统负责将需要的信息从外存调入内存</li></ul><ul><li><strong>页表机制</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170504815.png" alt="mark"></p><p><strong>页面置换概念</strong></p><ul><li>内存空间不足时，将内存中暂时不用的信息换到外存 页面的换入换出需要磁盘I/O，时间开销是很大的，<strong>缺页率越小越好</strong></li></ul><ul><li><strong>缺页中断</strong><ul><li>访问的页面不存在时，产生缺页中断(属于<strong>内中断的故障</strong> fault)，</li><li>操作系统缺页中断处理程序中断，进程<strong>放到阻塞队列</strong>，待调页完成后将进程唤醒，放到就绪队列 </li><li>如果<strong>内存有空闲块</strong>，则为进程分配一个空闲块，将缺页装入其中，并修改页表相应页表项 </li><li>如果<strong>内存没有空闲块，由页面置换算法</strong>选择一个页面淘汰(若该页面在内存期间被修改过，则需要先将其写回外存)，腾出一个空间再装入缺页 一条指令执行期间，可能产生多次缺页中断</li></ul></li></ul><p><strong>地址变换机构</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170623996.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/090606347.png" alt="mark"></p><p><strong>页面置换算法（具体内容请看下一篇博客）</strong></p><ul><li><strong>最佳置换算法(OPT)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170419565.png" alt="mark"></p><ul><li><strong>先进先出置换算法(FIFO)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170426988.png" alt="mark"></p><ul><li><strong>最近最久未使用算法(LRU)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170331530.png" alt="mark"></p><ul><li><strong>时钟置换算法(CLOCK)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170432349.png" alt="mark"></p><ul><li><strong>改进型时钟置换算法</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170438711.png" alt="mark"></p><ul><li><strong>小结：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170312379.png" alt="mark"></p><p><strong>页面分配策略</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091112009.png" alt="mark"></p><ol><li><strong>驻留集</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091352567.png" alt="mark"></p><ul><li>固定分配局部置换</li><li>可变分配局部置换</li><li>可变分配全局置换</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091451976.png" alt="mark"></p><ol start="2"><li><strong>何时调入页面</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091518574.png" alt="mark"></p><ol start="3"><li><strong>何处调入页面</strong></li></ol><ul><li>系统拥有足够的兑换区空间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091646646.png" alt="mark"></p><ul><li>系统缺少足够的兑换区空间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091655387.png" alt="mark"></p><ul><li>UNIX方式</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091825055.png" alt="mark"></p><ol start="4"><li><strong>抖动现象</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091858809.png" alt="mark"></p><ol start="5"><li><strong>工作集</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091925610.png" alt="mark"></p><p><strong>页面分配策略小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091255298.png" alt="mark"></p><h3 id="3-2-请求分段"><a href="#3-2-请求分段" class="headerlink" title="3.2 请求分段"></a>3.2 请求分段</h3><ul><li>书上无具体详解</li></ul><h3 id="3-3-请求段页式"><a href="#3-3-请求段页式" class="headerlink" title="3.3 请求段页式"></a>3.3 请求段页式</h3><ul><li>书上无具体说明</li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-16-内存扩充&quot;&gt;&lt;a href=&quot;#操作系统-16-内存扩充&quot; class=&quot;headerlink&quot; title=&quot;操作系统-16-内存扩充&quot;&gt;&lt;/a&gt;操作系统-16-内存扩充&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113853923.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-15-内存的分配和回收</title>
    <link href="http://zhuuu.work/2020/10/19/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-15-%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6/"/>
    <id>http://zhuuu.work/2020/10/19/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-15-%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6/</id>
    <published>2020-10-19T03:00:53.000Z</published>
    <updated>2020-10-21T03:16:54.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-15-内存的分配和回收"><a href="#操作系统-15-内存的分配和回收" class="headerlink" title="操作系统-15-内存的分配和回收"></a>操作系统-15-内存的分配和回收</h1><h2 id="1-连续分配管理方式"><a href="#1-连续分配管理方式" class="headerlink" title="1. 连续分配管理方式"></a>1. 连续分配管理方式</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/111935038.png" alt="mark"></p><a id="more"></a><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/111947265.png" alt="mark"></p><h3 id="1-1-单一连续分配"><a href="#1-1-单一连续分配" class="headerlink" title="1.1 单一连续分配"></a>1.1 单一连续分配</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112300340.png" alt="mark"></p><h3 id="1-2-固定分区分配"><a href="#1-2-固定分区分配" class="headerlink" title="1.2 固定分区分配"></a>1.2 固定分区分配</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112340583.png" alt="mark"></p><p><strong>数据结构</strong></p><ol><li><strong>分区说明表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112436485.png" alt="mark"></p><h3 id="1-3-动态分区分配"><a href="#1-3-动态分区分配" class="headerlink" title="1.3 动态分区分配"></a>1.3 动态分区分配</h3><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112628598.png" alt="mark"></p><ol start="2"><li><strong>动态分区遇到的问题</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112739289.png" alt="mark"></p><p><strong>（1）系统要用怎样的数据结构记录内存的使用情况呢？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112823281.png" alt="mark"></p><p><strong>（2）当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112900513.png" alt="mark"></p><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112930125.png" alt="mark"></p><p><strong>1.首次适应算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112948127.png" alt="mark"></p><p><strong>2.最佳适应算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113116950.png" alt="mark"></p><p><strong>3.最坏（大）适应算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113107332.png" alt="mark"></p><p><strong>4.邻近适应算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113156318.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113226216.png" alt="mark"></p><h4 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h4><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113333983.png" alt="mark"></p><ol start="2"><li><strong>解决方式 ： 紧凑技术</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113359367.png" alt="mark"></p><h2 id="2-非连续分配管理方式"><a href="#2-非连续分配管理方式" class="headerlink" title="2. 非连续分配管理方式"></a>2. 非连续分配管理方式</h2><h3 id="2-1-基本分页存储管理"><a href="#2-1-基本分页存储管理" class="headerlink" title="2.1 基本分页存储管理"></a>2.1 基本分页存储管理</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/094401416.png" alt="mark"></p><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/094436003.png" alt="mark"></p><ol start="2"><li><strong>地址结构</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/094758265.png" alt="mark"></p><ul><li><strong>为什么页面大小一般设为2的整数次幂？</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/094747360.png" alt="mark"></p><ol start="3"><li><strong>基本地址转换</strong></li></ol><p><strong>两个基本要素</strong></p><ul><li><strong>页面的起始地址</strong></li><li><strong>页面的偏移量</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/095459685.png" alt="mark"></p><ul><li>首先需要建立一张<strong>页表</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/095610966.png" alt="mark"></p><ul><li><strong>计算页表项的起始地址</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/095927512.png" alt="mark"></p><p><strong>基本地址转换流程小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100102276.png" alt="mark"></p><p><strong>文字描述</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100131838.png" alt="mark"></p><p><strong>基本地址转换例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100218167.png" alt="mark"></p><p><strong>页表项的注意事项</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100515245.png" alt="mark"></p><ol start="4"><li><strong>具有快表的地址变化机构</strong></li></ol><ul><li>局部性原理<ul><li><strong>时间局部性:</strong> 如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) </li><li><strong>空间局部性</strong>: 一旦程序访问了某个存储单元,在不久之后,其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的）</li></ul></li></ul><ul><li><strong>快表的概念</strong><ul><li>又称联想寄存器<strong>(TLB</strong>) ,是一种访问速度比内存快很多的<strong>高速缓冲存储器</strong>,用来存放当前访问的若干页表项,以加速地址变换的过程。与此对应,<strong>内存中的页表常称为慢表</strong>。</li></ul></li></ul><ul><li><strong>地址变化的过程</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100837299.png" alt="mark"></p><ol start="5"><li><strong>两级页表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/103445218.png" alt="mark"></p><ul><li>单级页表存在的问题<ul><li>页表需要很大的空间</li><li>局部性原理</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/104258447.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/104434834.png" alt="mark"></p><ul><li><strong>二级页表的地址结构</strong><ul><li>对页表再次进行分组</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/104612245.png" alt="mark"></p><ul><li><strong>二级页表的地址结构及对应关系</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/104813276.png" alt="mark"></p><ul><li><strong>二级页表的地址转换</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105119924.png" alt="mark"></p><p><strong>上面的部分我们解决了问题一，接下来是问题二，这里简单叙述一下，后面的文章会继续深入剖析。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105220284.png" alt="mark"></p><p><strong>注意事项</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105235918.png" alt="mark"></p><h3 id="2-2-基本分段存储管理"><a href="#2-2-基本分段存储管理" class="headerlink" title="2.2 基本分段存储管理"></a>2.2 基本分段存储管理</h3><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105357143.png" alt="mark"></p><ul><li><strong>分页管理方式</strong> ： 从计算机角度出发考虑设计的，目的是提高内存的利用率，提供计算机的性能。</li><li><strong>分段管理方式：</strong> 从用户和程序员角度出发，以满足方便编程，信息共享和保护，动态增长和动态链接的需要</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105649509.png" alt="mark"></p><ol start="2"><li><strong>分段的逻辑地址结构</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105717517.png" alt="mark"></p><ul><li><strong>段号的位数</strong> ： 决定了每个进程最多可以分成几个段</li><li><strong>段内地址</strong> ： 决定了每个段的最大长度可以是多少</li></ul><ol start="3"><li><strong>段表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105919071.png" alt="mark"></p><ol start="4"><li><strong>分段的地址变换</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110028224.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110032527.png" alt="mark"></p><ul><li><strong>分段和分页的对比</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110548592.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110614987.png" alt="mark"></p><ul><li><strong>分段实现信息的共享</strong><ul><li>不能被修改的代码是可以数据共享的</li><li>可修改的代码是不能数据共享的</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110651736.png" alt="mark"></p><ul><li><strong>分页不能实现数据共享的理由</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110839480.png" alt="mark"></p><h3 id="2-3-段页式存储管理"><a href="#2-3-段页式存储管理" class="headerlink" title="2.3 段页式存储管理"></a>2.3 段页式存储管理</h3><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110918201.png" alt="mark"></p><ul><li><strong>分段和分页的优缺点分析</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110955811.png" alt="mark"></p><ol start="2"><li><strong>分段 + 分页 = 段页式管理</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/111053497.png" alt="mark"></p><ol start="3"><li><strong>段页式管理的逻辑地址结构</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/111131508.png" alt="mark"></p><ol start="4"><li><strong>段页式存储的段表，页表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/111415851.png" alt="mark"></p><ul><li><strong>每个段对应一个段表项</strong><ul><li>段号</li><li>页表长度</li><li>页面存放的块号</li></ul></li><li><strong>每个页对应一个页表项</strong><ul><li>页号</li><li>页面存放的内存块号</li></ul></li></ul><ol start="5"><li><strong>段页式管理的地址转换过程</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/111616858.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-15-内存的分配和回收&quot;&gt;&lt;a href=&quot;#操作系统-15-内存的分配和回收&quot; class=&quot;headerlink&quot; title=&quot;操作系统-15-内存的分配和回收&quot;&gt;&lt;/a&gt;操作系统-15-内存的分配和回收&lt;/h1&gt;&lt;h2 id=&quot;1-连续分配管理方式&quot;&gt;&lt;a href=&quot;#1-连续分配管理方式&quot; class=&quot;headerlink&quot; title=&quot;1. 连续分配管理方式&quot;&gt;&lt;/a&gt;1. 连续分配管理方式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/111935038.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-844-比较含退格的字符串</title>
    <link href="http://zhuuu.work/2020/10/19/Leetcode/Leetcode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/10/19/Leetcode/Leetcode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-10-19T01:52:53.000Z</published>
    <updated>2020-10-19T01:23:29.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-844-比较含退格的字符串"><a href="#Leetcode-844-比较含退格的字符串" class="headerlink" title="Leetcode-844-比较含退格的字符串"></a>Leetcode-844-<a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">比较含退格的字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-双指针"><a href="#方法-：-双指针" class="headerlink" title="方法 ： 双指针"></a>方法 ： 双指针</h2><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。<strong>因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</strong></p><p>具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><ul><li><p>若该字符为<strong>退格符</strong>，则我们需要多删除一个普通字符，我们让 skip 加 1；</p></li><li><p>若该字符为普通字符：</p><ul><li>若 skip 为 0，则说明当前字符不需要删去；</li><li>若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1。</li></ul></li></ul><p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092038861.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092057182.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092127922.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = S.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = T.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录退格的变量</span></span><br><span class="line">        <span class="keyword">int</span> skipS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> skipT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 处理字符串S</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i) == <span class="string">'#'</span>)&#123; <span class="comment">//若该字符为退格符，则我们需要多删除一个普通字符，让skip 加1；</span></span><br><span class="line">                    skipS++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>)&#123; <span class="comment">// 若该字符为普通字符</span></span><br><span class="line">                    <span class="comment">//若skip不为0，则说明当前字符需要删去，让skip 减 1。同时向后退一格</span></span><br><span class="line">                    skipS--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//skip 为 0，则说明当前字符不需要删去；</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理字符串T</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T.charAt(j) == <span class="string">'#'</span>)&#123; <span class="comment">//若该字符为退格符，则我们需要多删除一个普通字符，让skip 加1；</span></span><br><span class="line">                    skipT++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipT--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123; <span class="comment">// 退完格之后两字符串能够各自确定一个字符</span></span><br><span class="line">                <span class="keyword">if</span> (S.charAt(i) != T.charAt(j)) &#123; <span class="comment">// 然后将这两个字符进行比较</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123; <span class="comment">// 遍历完字符串</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入下一次循环</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-844-比较含退格的字符串&quot;&gt;&lt;a href=&quot;#Leetcode-844-比较含退格的字符串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-844-比较含退格的字符串&quot;&gt;&lt;/a&gt;Leetcode-844-&lt;a href=&quot;https://leetcode-cn.com/problems/backspace-string-compare/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;比较含退格的字符串&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果对空文本输入退格字符，文本继续为空。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：S &amp;#x3D; &amp;quot;ab#c&amp;quot;, T &amp;#x3D; &amp;quot;ad#c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：S 和 T 都会变成 “ac”。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：S &amp;#x3D; &amp;quot;ab##&amp;quot;, T &amp;#x3D; &amp;quot;c#d#&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：S 和 T 都会变成 “”。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：S &amp;#x3D; &amp;quot;a##c&amp;quot;, T &amp;#x3D; &amp;quot;#a#c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：S 和 T 都会变成 “c”。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：S &amp;#x3D; &amp;quot;a#c&amp;quot;, T &amp;#x3D; &amp;quot;b&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：S 会变成 “c”，但 T 仍然是 “b”。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-019-删除链表的倒数第N个节点</title>
    <link href="http://zhuuu.work/2020/10/18/Leetcode/Leetcode-019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2020/10/18/Leetcode/Leetcode-019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2020-10-18T11:52:53.000Z</published>
    <updated>2020-10-18T01:06:59.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-019-删除链表的倒数第N个节点"><a href="#Leetcode-019-删除链表的倒数第N个节点" class="headerlink" title="Leetcode-019-删除链表的倒数第N个节点"></a>Leetcode-019-<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><h2 id="方法：两次遍历"><a href="#方法：两次遍历" class="headerlink" title="方法：两次遍历"></a>方法：两次遍历</h2><ul><li>首先从头节点开始对链表进行一次遍历，得到链表长度L</li><li>随后我们再从头节点开始对链表进行一次遍历，当遍历到链表的第L - n + 1个节点时，他就是我们需要删除的节点</li><li>为了和提题目中的n保持一致，节点的编号从1开始，头节点为编号1的节点。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/090557372.png" alt="mark"></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dummynode: 将next指针指向链表的头节点，这样一来就不需要对头节点进行特殊的判断</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表进行删除</span></span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>;++i)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur.next = cur.next.next; <span class="comment">// 断开链表</span></span><br><span class="line">        ListNode ans = dummy.next; <span class="comment">// 返回断开后的新头节点</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O（L） L是链表的长度</li><li>空间复杂度 ： O  (1)    没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-019-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#Leetcode-019-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-019-删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;Leetcode-019-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除链表的倒数第N个节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 &lt;em&gt;n&lt;/em&gt; 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n &amp;#x3D; 2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定的 &lt;em&gt;n&lt;/em&gt; 保证是有效的。&lt;/p&gt;
&lt;h2 id=&quot;方法：两次遍历&quot;&gt;&lt;a href=&quot;#方法：两次遍历&quot; class=&quot;headerlink&quot; title=&quot;方法：两次遍历&quot;&gt;&lt;/a&gt;方法：两次遍历&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先从头节点开始对链表进行一次遍历，得到链表长度L&lt;/li&gt;
&lt;li&gt;随后我们再从头节点开始对链表进行一次遍历，当遍历到链表的第L - n + 1个节点时，他就是我们需要删除的节点&lt;/li&gt;
&lt;li&gt;为了和提题目中的n保持一致，节点的编号从1开始，头节点为编号1的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/090557372.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-14-内存管理</title>
    <link href="http://zhuuu.work/2020/10/18/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-14-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/18/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-14-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-18T08:00:53.000Z</published>
    <updated>2020-10-18T02:51:26.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-14-内存管理"><a href="#操作系统-14-内存管理" class="headerlink" title="操作系统-14-内存管理"></a>操作系统-14-内存管理</h1><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统-14-内存管理&quot;&gt;&lt;a href=&quot;#操作系统-14-内存管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-14-内存管理&quot;&gt;&lt;/a&gt;操作系统-14-内存管理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;参考书籍：《王道考研计算机操作系统》&lt;/st
      
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-13-内存基础</title>
    <link href="http://zhuuu.work/2020/10/17/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-13-%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhuuu.work/2020/10/17/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-13-%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-17T08:00:53.000Z</published>
    <updated>2020-10-18T02:50:53.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-13-内存基础"><a href="#操作系统-13-内存基础" class="headerlink" title="操作系统-13-内存基础"></a>操作系统-13-内存基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/165936625.png" alt="mark"></p><h2 id="1-内存的概念"><a href="#1-内存的概念" class="headerlink" title="1. 内存的概念"></a>1. 内存的概念</h2><h3 id="1-1-存储单元"><a href="#1-1-存储单元" class="headerlink" title="1.1 存储单元"></a>1.1 存储单元</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170017151.png" alt="mark"></p><h3 id="1-2-几个常用数量单位-amp-内存地址"><a href="#1-2-几个常用数量单位-amp-内存地址" class="headerlink" title="1.2 几个常用数量单位&amp;内存地址"></a>1.2 几个常用数量单位&amp;内存地址</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170143676.png" alt="mark"></p><h2 id="2-运行的基本原理"><a href="#2-运行的基本原理" class="headerlink" title="2. 运行的基本原理"></a>2. 运行的基本原理</h2><h3 id="2-1-指令的工作原理—操作码-若干参数（可能包含地址参数）"><a href="#2-1-指令的工作原理—操作码-若干参数（可能包含地址参数）" class="headerlink" title="2.1 指令的工作原理—操作码+若干参数（可能包含地址参数）"></a>2.1 指令的工作原理—操作码+若干参数（可能包含地址参数）</h3><ul><li>从X=X+1大致看一下指令的执行过程</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170421561.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170443542.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170525816.png" alt="mark"></p><h3 id="2-2-逻辑地址（相对地址）vs物理地址（绝对地址）"><a href="#2-2-逻辑地址（相对地址）vs物理地址（绝对地址）" class="headerlink" title="2.2 逻辑地址（相对地址）vs物理地址（绝对地址）"></a>2.2 逻辑地址（相对地址）vs物理地址（绝对地址）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170554732.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170606666.png" alt="mark"></p><h3 id="2-3-从写程序到程序运行—编译、链接、装入"><a href="#2-3-从写程序到程序运行—编译、链接、装入" class="headerlink" title="2.3 从写程序到程序运行—编译、链接、装入"></a>2.3 从写程序到程序运行—编译、链接、装入</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170730524.png" alt="mark"></p><h3 id="2-4-装入概念"><a href="#2-4-装入概念" class="headerlink" title="2.4 装入概念"></a>2.4 装入概念</h3><ol><li><strong>错误示范</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170825742.png" alt="mark"></p><p><strong>不修改装入模块中的指令地址就直接装入内存的话：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170847140.png" alt="mark"></p><h2 id="3-装入的三种方式"><a href="#3-装入的三种方式" class="headerlink" title="3. 装入的三种方式"></a>3. 装入的三种方式</h2><h4 id="①绝对装入"><a href="#①绝对装入" class="headerlink" title="①绝对装入"></a>①绝对装入</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170930278.png" alt="mark"></p><h4 id="②静态重定位"><a href="#②静态重定位" class="headerlink" title="②静态重定位"></a>②静态重定位</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171028325.png" alt="mark"></p><h4 id="③-动态重定位"><a href="#③-动态重定位" class="headerlink" title="③ 动态重定位"></a>③ 动态重定位</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171035408.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171103248.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171129064.png" alt="mark"></p><h2 id="4-链接的三种方式"><a href="#4-链接的三种方式" class="headerlink" title="4. 链接的三种方式"></a>4. 链接的三种方式</h2><h4 id="①-静态链接"><a href="#①-静态链接" class="headerlink" title="① 静态链接"></a>① 静态链接</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171203244.png" alt="mark"></p><h4 id="②-装入时动态链接"><a href="#②-装入时动态链接" class="headerlink" title="② 装入时动态链接"></a>② 装入时动态链接</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171238658.png" alt="mark"></p><h4 id="③-运行时动态链接"><a href="#③-运行时动态链接" class="headerlink" title="③ 运行时动态链接"></a>③ 运行时动态链接</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171253814.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统-13-内存基础&quot;&gt;&lt;a href=&quot;#操作系统-13-内存基础&quot; class=&quot;headerlink&quot; title=&quot;操作系统-13-内存基础&quot;&gt;&lt;/a&gt;操作系统-13-内存基础&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-12-死锁</title>
    <link href="http://zhuuu.work/2020/10/17/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-12-%E6%AD%BB%E9%94%81/"/>
    <id>http://zhuuu.work/2020/10/17/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-12-%E6%AD%BB%E9%94%81/</id>
    <published>2020-10-17T06:00:53.000Z</published>
    <updated>2020-10-17T08:43:06.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-12-死锁"><a href="#操作系统-12-死锁" class="headerlink" title="操作系统-12-死锁"></a>操作系统-12-死锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154418323.png" alt="mark"></p><a id="more"></a><h2 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1. 死锁的概念"></a>1. 死锁的概念</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154457617.png" alt="mark"></p><h2 id="2-四个必要条件"><a href="#2-四个必要条件" class="headerlink" title="2. 四个必要条件"></a>2. 四个必要条件</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154548072.png" alt="mark"></p><p>同时什么时候会发生死锁呢？</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154729905.png" alt="mark"></p><h2 id="3-死锁的处理策略"><a href="#3-死锁的处理策略" class="headerlink" title="3. 死锁的处理策略"></a>3. 死锁的处理策略</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154757012.png" alt="mark"></p><h3 id="3-1-预防死锁"><a href="#3-1-预防死锁" class="headerlink" title="3.1 预防死锁"></a>3.1 预防死锁</h3><p><strong>① 破坏互斥条件</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154820963.png" alt="mark"></p><p><strong>② 破坏不可剥夺条件</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154906684.png" alt="mark"></p><p><strong>③ 破坏请求和保持条件</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154924096.png" alt="mark"></p><p><strong>④ 破坏循环等待条件</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154949485.png" alt="mark"></p><h3 id="3-2-避免死锁"><a href="#3-2-避免死锁" class="headerlink" title="3.2 避免死锁"></a>3.2 避免死锁</h3><p><strong>① 什么是安全序列？</strong></p><p><strong>不成功的案例</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155027567.png" alt="mark"></p><p><strong>成功的案例</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155055359.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155134524.png" alt="mark"></p><p><strong>② 安全序列、安全状态、不安全状态、死锁之间的联系</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155239988.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155256144.png" alt="mark"></p><p><strong>③ 避免系统进入不安全状态——银行家算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155316874.png" alt="mark"></p><ul><li><strong>安全的例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155527891.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155608913.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155652128.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155757001.png" alt="mark"></p><ul><li><strong>不安全的例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155814061.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155837858.png" alt="mark"></p><p><strong>代码实现</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155856072.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/160310215.png" alt="mark"></p><h3 id="3-3-检测解除死锁"><a href="#3-3-检测解除死锁" class="headerlink" title="3.3 检测解除死锁"></a>3.3 检测解除死锁</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/163619748.png" alt="mark"></p><p><strong>① 死锁的检测</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/163702333.png" alt="mark"></p><ul><li>举个例子，可以消除所有边，即无死锁发生</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164041521.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164110167.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164117093.png" alt="mark"></p><ul><li>举个例子，不可消除所有边，即产生死锁</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164139437.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164147784.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164202551.png" alt="mark"></p><p><strong>检测死锁的算法：死锁定理</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164211773.png" alt="mark"></p><p><strong>② 死锁的解除</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164301428.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-12-死锁&quot;&gt;&lt;a href=&quot;#操作系统-12-死锁&quot; class=&quot;headerlink&quot; title=&quot;操作系统-12-死锁&quot;&gt;&lt;/a&gt;操作系统-12-死锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154418323.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="进程互斥" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>Netty-03-零拷贝</title>
    <link href="http://zhuuu.work/2020/10/16/Netty/Netty-03-%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://zhuuu.work/2020/10/16/Netty/Netty-03-%E9%9B%B6%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-10-16T03:05:24.000Z</published>
    <updated>2020-10-19T01:38:56.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-03-零拷贝"><a href="#Netty-03-零拷贝" class="headerlink" title="Netty-03-零拷贝"></a>Netty-03-零拷贝</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java程序中，常用的零拷贝有 mmap（内存映射）和 sendFile。</p><p>零拷贝不仅仅带来更少的数据复制，还能减少线程的上下文切换，减少CPU缓存伪共享以及无CPU校验和计算。</p><h2 id="1-传统的IO读写"><a href="#1-传统的IO读写" class="headerlink" title="1. 传统的IO读写"></a>1. 传统的IO读写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092714165.png" alt="mark"></p><ul><li><strong>三次内核态用户态切换</strong></li><li><strong>四次拷贝</strong><ul><li>DMA</li><li>kernel buffer - &gt; user buffer</li><li>user buffer -&gt; socket buffer</li><li>DMA</li></ul></li></ul><a id="more"></a><h2 id="2-mmap-优化"><a href="#2-mmap-优化" class="headerlink" title="2. mmap 优化"></a>2. mmap 优化</h2><p><strong>mmap优化的IO读写：</strong></p><ul><li><strong>mmap通过内存映射</strong>，将文件映射到内核缓冲区，同时，用户空间可以共享内存空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。</li><li><strong>需要进行3次上下文切换，3次数据拷贝。</strong></li><li>适合小数据量的读写。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092904500.png" alt="mark"></p><h2 id="3-sendFile-优化"><a href="#3-sendFile-优化" class="headerlink" title="3. sendFile 优化"></a>3. sendFile 优化</h2><ul><li>Linux2.1 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到<code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换。</li><li>需要3次上下文切换和最少2次数据拷贝。</li><li>适合大文件的传输。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092941352.png" alt="mark"></p><ul><li>而 Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socket Buffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092953049.png" alt="mark"></p><p><strong>注：这里其实有一次CPU拷贝，<code>kernel buffer -&gt; socket buffer</code>。但是，拷贝的信息很少，只拷贝了数据的长度、偏移量等关键信息，消耗低，可以忽略不计。</strong></p><h2 id="4-NIO中的零拷贝（transferTo）"><a href="#4-NIO中的零拷贝（transferTo）" class="headerlink" title="4. NIO中的零拷贝（transferTo）"></a>4. <strong>NIO中的零拷贝（transferTo）</strong></h2><ul><li><strong>客户端</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOzerocopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到一个文件的channel</span></span><br><span class="line">        FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="string">"a.zip"</span>).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在linux中一个transfer函数就可以完成传输</span></span><br><span class="line">        <span class="comment">// 在windows中调用一次transferTo 只能发送8M，就需要把数据分段传输</span></span><br><span class="line">        <span class="comment">// transferTo 底层使用到了零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = channel.transferTo(<span class="number">0</span>, channel.size(), socketChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束发送</span></span><br><span class="line">        System.out.println(<span class="string">"发送的总的字节数："</span> + transferCount + <span class="string">" 耗时："</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-03-零拷贝&quot;&gt;&lt;a href=&quot;#Netty-03-零拷贝&quot; class=&quot;headerlink&quot; title=&quot;Netty-03-零拷贝&quot;&gt;&lt;/a&gt;Netty-03-零拷贝&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java程序中，常用的零拷贝有 mmap（内存映射）和 sendFile。&lt;/p&gt;
&lt;p&gt;零拷贝不仅仅带来更少的数据复制，还能减少线程的上下文切换，减少CPU缓存伪共享以及无CPU校验和计算。&lt;/p&gt;
&lt;h2 id=&quot;1-传统的IO读写&quot;&gt;&lt;a href=&quot;#1-传统的IO读写&quot; class=&quot;headerlink&quot; title=&quot;1. 传统的IO读写&quot;&gt;&lt;/a&gt;1. 传统的IO读写&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;File file = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;string&quot;&gt;&quot;test.txt&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RandomAccessFile raf = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RandomAccessFile(file, &lt;span class=&quot;string&quot;&gt;&quot;rw&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) file.length()];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;raf.read(arr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Socket socket = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerSocket(&lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;).accept();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;socket.getOutputStream().write(arr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092714165.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;三次内核态用户态切换&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;四次拷贝&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;DMA&lt;/li&gt;
&lt;li&gt;kernel buffer - &amp;gt; user buffer&lt;/li&gt;
&lt;li&gt;user buffer -&amp;gt; socket buffer&lt;/li&gt;
&lt;li&gt;DMA&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
      <category term="零拷贝" scheme="http://zhuuu.work/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-11-经典进程同步互斥问题</title>
    <link href="http://zhuuu.work/2020/10/16/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/10/16/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-16T00:00:53.000Z</published>
    <updated>2020-10-17T07:06:51.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-11-经典进程同步互斥问题"><a href="#操作系统-11-经典进程同步互斥问题" class="headerlink" title="操作系统-11-经典进程同步互斥问题"></a>操作系统-11-经典进程同步互斥问题</h1><h2 id="1-消费者-生产者问题"><a href="#1-消费者-生产者问题" class="headerlink" title="1. 消费者-生产者问题"></a>1. 消费者-生产者问题</h2><p><strong>1. 问题描述</strong></p><ul><li>系统中有<code>一组生产者进程</code>和<code>一组消费者进程</code>，生产者进程每次<code>生产一个</code>产品放入缓冲区，消费者进程每次从缓冲区中<code>取出一个</code>产品并使用。(注: 这里的“产品”理解为某种数据)</li><li>生产者、消费者<code>共享</code>一个初始为空、大小为n的<code>缓冲区</code>。</li><li>只有缓冲区<code>没满</code>时，<code>生产者</code>才能把产品<code>放入</code>缓冲区，否则必须等待。</li><li>只有缓冲区<code>不空</code>时，<code>消费者</code>才能从中<code>取出</code>产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须<code>互斥</code>地访问。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091536548.png" alt="mark"></p><a id="more"></a><ol start="2"><li><strong>问题分析</strong></li></ol><ul><li><strong>1)关系分析</strong>。生产者和消费者对缓冲区互斥访问是<code>互斥关系</code>，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后,消费者才能消费，它们也是<code>同步关系</code>。</li><li><strong>2)整理思路</strong>。根据各进程的操作流程确定P、V操作的大致顺序。<br>生产者每次要消耗(P）一个空闲缓冲区，并生产(V)一个产品。<br>消费者每次要消耗(P）一个产品，并释放一个空闲缓冲区(V)。<br>往缓冲区放入/取走产品需要互斥。</li><li><strong>3)信号量设置。</strong>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。( 互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091728863.png" alt="mark"></p><ol start="3"><li><strong>实现</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091816753.png" alt="mark"></p><p><strong>注意 ： 实现互斥的P操作一定要在实现同步的P操作之后（否则会有死锁问题）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092337577.png" alt="mark"></p><p><strong>单生产者-消费者回顾</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092555328.png" alt="mark"></p><h2 id="2-多生产者-消费者问题"><a href="#2-多生产者-消费者问题" class="headerlink" title="2. 多生产者-消费者问题"></a>2. 多生产者-消费者问题</h2><ol><li><strong>问题描述</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/142657247.png" alt="mark"></p><ol start="2"><li><strong>问题分析</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/142750028.png" alt="mark"></p><ol start="3"><li><strong>实现方式</strong></li></ol><p><strong>① 有mutex</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/142951274.png" alt="mark"></p><p><strong>② 无mutex</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/143000426.png" alt="mark"></p><p><strong>为什么有mutex和没有mutex一样呢？</strong></p><ul><li>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、 orange、 plate 三个同步信号量中最多只有一个是1。</li><li>因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</li></ul><p><strong>如果有两个盘子plate</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/143354331.png" alt="mark"></p><ol start="4"><li><h5 id="知识总结与重要考点"><a href="#知识总结与重要考点" class="headerlink" title="知识总结与重要考点"></a>知识总结与重要考点</h5></li></ol><p><code>总结</code>:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，<code>这不是绝对的</code>，要具体问题具体分析。</p><p><code>建议</code>:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，·<code>实现互斥的P操作一定要在实现同步的P操作之后</code>·，否则可能引起·<code>“死锁”</code>·。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/143729758.png" alt="mark"></p><h2 id="3-吸烟者问题"><a href="#3-吸烟者问题" class="headerlink" title="3. 吸烟者问题"></a>3. 吸烟者问题</h2><ol><li><strong>问题描述</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092714018.png" alt="mark"></p><ol start="2"><li><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5></li></ol><ul><li><strong>本质是单生产者 - 多消费者的问题</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093058018.png" alt="mark"></p><ol start="3"><li><strong>实现方法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093158353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093214151.png" alt="mark"></p><p><strong>回顾 :</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093805017.png" alt="mark"></p><h2 id="4-读者写者问题"><a href="#4-读者写者问题" class="headerlink" title="4. 读者写者问题"></a>4. 读者写者问题</h2><ol><li><strong>问题描述</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/143934790.png" alt="mark"></p><ol start="2"><li><strong>问题分析</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/144022559.png" alt="mark"></p><ol start="3"><li><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5></li></ol><p><strong>① 给count加mutex互斥访问</strong></p><ul><li>这里说一下为什么要加mutex。</li><li>比如：当count=0时，第一个读者进程执行到p(rw),rw=0,假设此时时间片到了，切换到第二个读者进程,第二个进程发现count=0,则执行p(rw)，但是此时rw=0，于是第二个进程被堵在p（rw）这里，同理，后面的可能会有多个进程堵在p(rw)，只有当第一个进程再次获得时间片，执行count++,让count不为0，然后其他进程就可以直接绕过if直接进行count++来访问文件，但是第三个读者进程和后面的几个可能堵在p(rw)的多个读者进程则必须得等count–为0后才可以再次和写进程竞争来访问文件，对count的访问没有做到一气呵成，会导致本来一些进程一直堵在p（rw）。</li></ul><p><strong>② 加一个w实现“读写公平法”</strong></p><ul><li>在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有 一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在写进程<code>“饿死”</code>的情况。</li><li>若希望写进程优先，<code>即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行</code>。</li><li>为此，增加一个信号量并在上面程序的<code>writer()</code>和 <code>reader()</code>函数中各增加一对PV操作，就可以得到写进程优先的解决程序。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/145521452.png" alt="mark"></p><ol start="4"><li><h5 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/145551296.png" alt="mark"></p><h2 id="5-哲学家进餐问题"><a href="#5-哲学家进餐问题" class="headerlink" title="5. 哲学家进餐问题"></a>5. 哲学家进餐问题</h2><ol><li><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/145634639.png" alt="mark"></p><ol start="2"><li><h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/145759644.png" alt="mark"></p><ol start="3"><li><h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5></li></ol><ul><li><strong>实现一：最多允许四个哲学家同时进餐</strong></li><li><strong>实现二：</strong><ul><li><strong>奇数号哲学家先拿左边的筷子，再拿右边的筷子</strong></li><li><strong>偶数号哲学家先拿右边的筷子，再拿左边的筷子</strong></li></ul></li><li><strong>实现三：仅当一名哲学家左右两边筷子都可用的时候才允许拿起筷子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/150150502.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/150153963.png" alt="mark"></p><p><strong>例子</strong></p><p><strong>实现三：仅当一名哲学家左右两边筷子都可用的时候才允许拿起筷子</strong> 为例</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/150440432.png" alt="mark"></p><ol start="4"><li><strong>总结和回顾</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/150635987.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-11-经典进程同步互斥问题&quot;&gt;&lt;a href=&quot;#操作系统-11-经典进程同步互斥问题&quot; class=&quot;headerlink&quot; title=&quot;操作系统-11-经典进程同步互斥问题&quot;&gt;&lt;/a&gt;操作系统-11-经典进程同步互斥问题&lt;/h1&gt;&lt;h2 id=&quot;1-消费者-生产者问题&quot;&gt;&lt;a href=&quot;#1-消费者-生产者问题&quot; class=&quot;headerlink&quot; title=&quot;1. 消费者-生产者问题&quot;&gt;&lt;/a&gt;1. 消费者-生产者问题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统中有&lt;code&gt;一组生产者进程&lt;/code&gt;和&lt;code&gt;一组消费者进程&lt;/code&gt;，生产者进程每次&lt;code&gt;生产一个&lt;/code&gt;产品放入缓冲区，消费者进程每次从缓冲区中&lt;code&gt;取出一个&lt;/code&gt;产品并使用。(注: 这里的“产品”理解为某种数据)&lt;/li&gt;
&lt;li&gt;生产者、消费者&lt;code&gt;共享&lt;/code&gt;一个初始为空、大小为n的&lt;code&gt;缓冲区&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;只有缓冲区&lt;code&gt;没满&lt;/code&gt;时，&lt;code&gt;生产者&lt;/code&gt;才能把产品&lt;code&gt;放入&lt;/code&gt;缓冲区，否则必须等待。&lt;/li&gt;
&lt;li&gt;只有缓冲区&lt;code&gt;不空&lt;/code&gt;时，&lt;code&gt;消费者&lt;/code&gt;才能从中&lt;code&gt;取出&lt;/code&gt;产品，否则必须等待。&lt;/li&gt;
&lt;li&gt;缓冲区是临界资源，各进程必须&lt;code&gt;互斥&lt;/code&gt;地访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091536548.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="进程互斥" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-530-二叉搜索树的最小绝对值</title>
    <link href="http://zhuuu.work/2020/10/12/Leetcode/Leetcode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC/"/>
    <id>http://zhuuu.work/2020/10/12/Leetcode/Leetcode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC/</id>
    <published>2020-10-12T04:52:53.000Z</published>
    <updated>2020-10-12T02:16:35.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-530-二叉搜索树的最小绝对差"><a href="#Leetcode-530-二叉搜索树的最小绝对差" class="headerlink" title="Leetcode-530-二叉搜索树的最小绝对差"></a>Leetcode-530-<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">二叉搜索树的最小绝对差</a></h1><p><strong>题目描述：</strong></p><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 <span class="number">1</span>，其中 <span class="number">2</span> 和 <span class="number">1</span> 的差的绝对值为 <span class="number">1</span>（或者 <span class="number">2</span> 和 <span class="number">3</span>）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中至少有 2 个节点。</li></ul><a id="more"></a><h2 id="思路-中序遍历"><a href="#思路-中序遍历" class="headerlink" title="思路 :中序遍历"></a>思路 :中序遍历</h2><ul><li><strong>看到二叉搜索树，就能想到中序遍历。</strong></li><li>遍历一个二叉树，会访问每一个节点，拿节点做一些事情。</li><li>而中序遍历，它对于每一个节点，都先访问处理它的左子树中的节点，再访问处理它本身，再访问处理它的右子树中的节点。</li></ul><ul><li><strong>由于二叉搜索树的性质，中序遍历访问处理的节点值的大小是递增的。</strong></li><li><strong>题目要求任意两个节点的最小的差值，它肯定发生在递增排列后，相邻的节点值之间。</strong></li></ul><p><strong>优化 ：</strong> <strong>我们用一个变量，保存上一个访问处理的节点值</strong>，<strong>求出当前访问的节点值与它之差，挑战最小的纪录，更小就更新。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>; <span class="comment">//pre 用于保存前一个root.val</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 中序遍历</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans,root.val - pre);</span><br><span class="line">            pre = root.val; <span class="comment">// pre更新为当前节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ：</strong> O(n) 其中n是二叉搜索树节点的个数。每个节点在中序遍历中只会被访问一次。因此总的时间复杂度是O(n)</li><li><strong>空间复杂度</strong> ： O(n) 递归函数递归栈使用的深度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-530-二叉搜索树的最小绝对差&quot;&gt;&lt;a href=&quot;#Leetcode-530-二叉搜索树的最小绝对差&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-530-二叉搜索树的最小绝对差&quot;&gt;&lt;/a&gt;Leetcode-530-&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树的最小绝对差&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最小绝对差为 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;，其中 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的差的绝对值为 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;（或者 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树中至少有 2 个节点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>背包问题-合集</title>
    <link href="http://zhuuu.work/2020/10/12/LeetcodeExplore/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/10/12/LeetcodeExplore/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%90%88%E9%9B%86/</id>
    <published>2020-10-12T02:52:53.000Z</published>
    <updated>2020-10-12T01:45:07.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题-合集"><a href="#背包问题-合集" class="headerlink" title="背包问题-合集"></a>背包问题-合集</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背包问题-合集&quot;&gt;&lt;a href=&quot;#背包问题-合集&quot; class=&quot;headerlink&quot; title=&quot;背包问题-合集&quot;&gt;&lt;/a&gt;背包问题-合集&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="背包问题" scheme="http://zhuuu.work/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-303-区域和检索</title>
    <link href="http://zhuuu.work/2020/10/09/Leetcode/Leetcode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/"/>
    <id>http://zhuuu.work/2020/10/09/Leetcode/Leetcode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/</id>
    <published>2020-10-09T01:52:53.000Z</published>
    <updated>2020-10-08T02:25:26.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-303-区域和检索-数组不可变"><a href="#Leetcode-303-区域和检索-数组不可变" class="headerlink" title="Leetcode-303-区域和检索 - 数组不可变"></a>Leetcode-303-<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设数组不可变。<br>会多次调用 sumRange 方法。</p><a id="more"></a><h2 id="思路-：-前缀和"><a href="#思路-：-前缀和" class="headerlink" title="思路 ： 前缀和"></a>思路 ： 前缀和</h2><ul><li>一上来我们不说前缀和这个思路，先说个普通的暴力解法</li></ul><p><strong>暴力解法</strong></p><ul><li>每次调用 <code>sumrange</code> 时，我们都使用for循环将索引 i 到 j 之间的每个元素相加。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    data = nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">        sum += data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：每次查询的时间 O(n)，每个 sumrange 查询需要 O(n)时间。</li><li>空间复杂度：O(1)，请注意，data 是对 nums 的引用，不是它的副本。</li></ul><p><strong>前缀和</strong></p><ul><li>假设我们预先计算了从数字 0 到 k的累积和。我们可以用这个信息得出 <code>sum(i，j)</code>吗？</li><li>让我们将 s<strong>u</strong>m[k] 定义为<code>nums[0⋯k−1]</code> 的累积和（包括这两个值）：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/102327279.png" alt="mark"></p><ul><li>现在，我们可以计算 <code>sumrange</code>如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/102342287.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sum[0] = 0</span></span><br><span class="line">    <span class="comment">// sum[] 数组用于计算前缀和</span></span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算索引下标区间内的求和公式</span></span><br><span class="line">    <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>注意，在上面的代码中，我们插入了一个虚拟 0 作为 sum 数组中的第一个元素。这个技巧可以避免在 <code>sumrange</code> 函数中进行额外的条件检查。</li></ul><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：每次查询的时间 O(1)，</p><ul><li>O(N)预计算时间。由于累积和被缓存，每个<code>sumrange</code>都可以用 O(1)时间计算。</li></ul></li><li><p>空间复杂度：O(n).</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-303-区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#Leetcode-303-区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-303-区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;Leetcode-303-&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区域和检索 - 数组不可变&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定 nums &amp;#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(0, 2) -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(2, 5) -&amp;gt; -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(0, 5) -&amp;gt; -3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;你可以假设数组不可变。&lt;br&gt;会多次调用 sumRange 方法。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>java8-新特性-lambda</title>
    <link href="http://zhuuu.work/2020/10/08/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-lambda/"/>
    <id>http://zhuuu.work/2020/10/08/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-lambda/</id>
    <published>2020-10-08T14:30:53.000Z</published>
    <updated>2020-11-19T14:53:26.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8-新特性-lambda"><a href="#java8-新特性-lambda" class="headerlink" title="java8-新特性-lambda"></a>java8-新特性-lambda</h1><h2 id="前言（从一个案例来引入优化）"><a href="#前言（从一个案例来引入优化）" class="headerlink" title="前言（从一个案例来引入优化）"></a>前言（从一个案例来引入优化）</h2><ol><li><strong>创建员工类</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java8-新特性-lambda&quot;&gt;&lt;a href=&quot;#java8-新特性-lambda&quot; class=&quot;headerlink&quot; title=&quot;java8-新特性-lambda&quot;&gt;&lt;/a&gt;java8-新特性-lambda&lt;/h1&gt;&lt;h2 id=&quot;前言（从一个案例来引入优化）&quot;&gt;&lt;a href=&quot;#前言（从一个案例来引入优化）&quot; class=&quot;headerlink&quot; title=&quot;前言（从一个案例来引入优化）&quot;&gt;&lt;/a&gt;前言（从一个案例来引入优化）&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建员工类&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Employee&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; salary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; salary)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.salary = salary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSalary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; salary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setSalary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; salary)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.salary = salary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="lambda表达式" scheme="http://zhuuu.work/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="java8" scheme="http://zhuuu.work/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1038-把二叉搜索树转换为累加树</title>
    <link href="http://zhuuu.work/2020/10/08/Leetcode/Leetcode-1038-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/10/08/Leetcode/Leetcode-1038-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</id>
    <published>2020-10-08T07:52:53.000Z</published>
    <updated>2020-10-29T01:07:53.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1038-把二叉搜索树转换为累加树"><a href="#Leetcode-1038-把二叉搜索树转换为累加树" class="headerlink" title="Leetcode-1038-把二叉搜索树转换为累加树"></a>Leetcode-1038-<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></h1><h2 id="思路：反向中序遍历"><a href="#思路：反向中序遍历" class="headerlink" title="思路：反向中序遍历"></a>思路：反向中序遍历</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换成累加树（Greater Sum Tree），使得每个节点的<code>node</code> 的新值等于原书中大于等于<code>node.val</code> 的值之和。</li></ul><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/085842282.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：root &#x3D; [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：root &#x3D; [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：root &#x3D; [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure><h2 id="方法-反向中序遍历"><a href="#方法-反向中序遍历" class="headerlink" title="方法 : 反向中序遍历"></a>方法 : 反向中序遍历</h2><ul><li><strong>关于二叉搜索树的问题，第一个想到的就是中序遍历</strong>，这是二叉搜索树的一个非常重要的性质</li><li><strong>二叉搜索树的中序遍历是一个递增的有序序列</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/090116634.png" alt="mark"></p><p>观察<strong>累加前中序遍历</strong>和<strong>累加后中序遍历</strong>，我们会发现，其实后者就是前者的一个从后的累加结果。</p><p>那么问题就迎刃而解了，我们秩序反向中序遍历即可，并且把每次的节点值进行累加，就能得到最终的累加树。并且保证了这样只会访问每个节点一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstToGst</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 1. 如果是叶子节点的话</span></span><br><span class="line">            <span class="comment">// 进行反向的中序遍历</span></span><br><span class="line">            bstToGst(root.right); <span class="comment">// 递归右子树</span></span><br><span class="line">            sum = sum + root.val; <span class="comment">// 累加</span></span><br><span class="line">            root.val = sum; <span class="comment">// 更新节点的值</span></span><br><span class="line">            bstToGst(root.left); <span class="comment">// 递归左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-1038-把二叉搜索树转换为累加树&quot;&gt;&lt;a href=&quot;#Leetcode-1038-把二叉搜索树转换为累加树&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1038-把二叉搜索树转换为累加树&quot;&gt;&lt;/a&gt;Leetcode
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="中序遍历" scheme="http://zhuuu.work/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-10-进程同步和互斥</title>
    <link href="http://zhuuu.work/2020/10/08/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/"/>
    <id>http://zhuuu.work/2020/10/08/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/</id>
    <published>2020-10-08T06:00:53.000Z</published>
    <updated>2020-10-08T14:04:23.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-10-进程同步和互斥"><a href="#操作系统-10-进程同步和互斥" class="headerlink" title="操作系统-10-进程同步和互斥"></a>操作系统-10-进程同步和互斥</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135327192.png" alt="mark"></p><a id="more"></a><h2 id="1-同步和互斥的概念"><a href="#1-同步和互斥的概念" class="headerlink" title="1. 同步和互斥的概念"></a>1. 同步和互斥的概念</h2><h3 id="1-1-进程同步"><a href="#1-1-进程同步" class="headerlink" title="1.1 进程同步"></a>1.1 进程同步</h3><ul><li><code>同步也称为直接制约关系。</code></li><li>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系,如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。</li><li>一个简单的例子来理解这个概念。</li><li>例如，让系统计算1 + 2x3，假设系统产生两个进程: 一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后,但实际上操作系统具有<code>异步性</code>,若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。</li></ul><blockquote><p>异步性：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p></blockquote><h3 id="1-2-进程互斥"><a href="#1-2-进程互斥" class="headerlink" title="1.2 进程互斥"></a>1.2 进程互斥</h3><ul><li><code>互斥，亦称间接制约关系</code>。<code>进程互斥</code>指当一个进程访问某临界资源时，另一个想要访问该<code>临界资源</code>的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li><li>在这里需复习一下<code>临界资源</code>的概念。</li><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135625431.png" alt="mark"></p><ul><li>为了禁止两个进程同时进入<code>临界区</code>，需遵循以下准则</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135640762.png" alt="mark"></p><h2 id="2-临界区进程互斥的实现方法"><a href="#2-临界区进程互斥的实现方法" class="headerlink" title="2. 临界区进程互斥的实现方法"></a>2. 临界区进程互斥的实现方法</h2><h3 id="2-1-软件实现方法"><a href="#2-1-软件实现方法" class="headerlink" title="2.1 软件实现方法"></a>2.1 软件实现方法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135912018.png" alt="mark"></p><ul><li>软件实现方法的思想：在进入区设置并检查一些标志 来标明是否有进程在临界区中,若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</li><li><code>入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</code></li></ul><ol><li><strong>单标志法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140023554.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140108733.png" alt="mark"></p><ol start="2"><li><strong>双标志先检查法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140538012.png" alt="mark"></p><ol start="3"><li><strong>双标志后检查法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140659932.png" alt="mark"></p><ol start="4"><li><strong>Peterson 算法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140915268.png" alt="mark"></p><h3 id="2-2-硬件实现方法"><a href="#2-2-硬件实现方法" class="headerlink" title="2.2 硬件实现方法"></a>2.2 硬件实现方法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141220331.png" alt="mark"></p><ol><li><strong>中断屏蔽</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141252814.png" alt="mark"></p><ol start="2"><li><strong><code>TestAndSet</code>指令</strong></li></ol><ul><li>执行<strong>TSL指令时</strong>，它的内部运转逻辑：<ul><li><strong>假设lock现在为false</strong>，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等</li><li><strong>假设lock为true</strong>，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141754753.png" alt="mark"></p><ol start="3"><li><strong>swap 指令</strong></li></ol><ul><li>old是每个进程都要进行的一步，都必须将<code>old=true</code></li><li>分析一下这样做的原因：<ul><li>因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化<code>old=true</code>，然后进入while循环进行交换，<strong>如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，</strong></li><li>同时因为交换，<code>lock=old=true</code>上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,<strong>当我使用完临界资源，则将<code>lock=false</code>,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142115031.png" alt="mark"></p><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142208661.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142319507.png" alt="mark"></p><h3 id="3-1-整型信号量"><a href="#3-1-整型信号量" class="headerlink" title="3.1 整型信号量"></a>3.1 整型信号量</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142307160.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142412015.png" alt="mark"></p><h3 id="3-2-记录型信号量"><a href="#3-2-记录型信号量" class="headerlink" title="3.2 记录型信号量"></a>3.2 记录型信号量</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142544410.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142843431.png" alt="mark"></p><ul><li><strong>一个案例：打印机资源为2访问</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142932870.png" alt="mark"></p><h3 id="3-3-信号量机制实现进程同步和互斥"><a href="#3-3-信号量机制实现进程同步和互斥" class="headerlink" title="3.3 信号量机制实现进程同步和互斥"></a>3.3 信号量机制实现进程同步和互斥</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143121739.png" alt="mark"></p><h4 id="3-3-1-互斥"><a href="#3-3-1-互斥" class="headerlink" title="3.3.1 互斥"></a>3.3.1 互斥</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143219225.png" alt="mark"></p><h4 id="3-3-2-同步"><a href="#3-3-2-同步" class="headerlink" title="3.3.2 同步"></a>3.3.2 同步</h4><ul><li>想象一下四则运算的顺序，加减乘除；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143432682.png" alt="mark"></p><ul><li>要想理解这一部分知识，必须知道P、V操作的内部实现原理</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143455765.png" alt="mark"></p><h4 id="3-3-3-前驱关系"><a href="#3-3-3-前驱关系" class="headerlink" title="3.3.3 前驱关系"></a>3.3.3 前驱关系</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/144126344.png" alt="mark"></p><h2 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220151031.png" alt="mark"></p><h3 id="4-1-为什么要引入管程？"><a href="#4-1-为什么要引入管程？" class="headerlink" title="4.1 为什么要引入管程？"></a>4.1 为什么要引入管程？</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220216654.png" alt="mark"></p><h3 id="4-2-管程的基本组成"><a href="#4-2-管程的基本组成" class="headerlink" title="4.2 管程的基本组成"></a>4.2 管程的基本组成</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220241848.png" alt="mark"></p><h3 id="4-3-管程实现消费者生产者问题"><a href="#4-3-管程实现消费者生产者问题" class="headerlink" title="4.3 管程实现消费者生产者问题"></a>4.3 管程实现消费者生产者问题</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220333491.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220352798.png" alt="mark"></p><h3 id="4-4-java中的管程"><a href="#4-4-java中的管程" class="headerlink" title="4.4 java中的管程"></a>4.4 java中的管程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220416205.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-10-进程同步和互斥&quot;&gt;&lt;a href=&quot;#操作系统-10-进程同步和互斥&quot; class=&quot;headerlink&quot; title=&quot;操作系统-10-进程同步和互斥&quot;&gt;&lt;/a&gt;操作系统-10-进程同步和互斥&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135327192.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="进程互斥" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>partition-合集</title>
    <link href="http://zhuuu.work/2020/10/07/LeetcodeExplore/partition-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/10/07/LeetcodeExplore/partition-%E5%90%88%E9%9B%86/</id>
    <published>2020-10-07T02:52:53.000Z</published>
    <updated>2020-10-07T07:33:36.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="partition-合集"><a href="#partition-合集" class="headerlink" title="partition-合集"></a>partition-合集</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/101823939.png" alt="mark"></p><h2 id="1-什么是-partition-？"><a href="#1-什么是-partition-？" class="headerlink" title="1. 什么是 partition ？"></a>1. 什么是 partition ？</h2><p>我们在学习 快速排序 的时候知道，可以选择一个标定元素（称为 pivot ，一般而言随机选择），然后通过一次扫描，把数组分成三个部分：</p><ul><li>第 1 部分严格小于 pivot 元素的值；</li><li>第 2 部分恰好等于 pivot 元素的值；</li><li>第 3 部分严格大于 pivot 元素的值。</li><li>第 2 部分元素就是排好序以后它们应该在的位置，接下来只需要递归处理第 1 部分和第 3 部分的元素。</li></ul><p>经过一次扫描把整个数组分成 3 个部分，正好符合当前问题的场景。写对这道题的方法是：把循环不变量的定义作为注释写出来，然后再编码。</p><a id="more"></a><h2 id="2-Leetcode-75-颜色分类-（荷兰旗问题）"><a href="#2-Leetcode-75-颜色分类-（荷兰旗问题）" class="headerlink" title="2. Leetcode-75. 颜色分类 （荷兰旗问题）"></a>2. Leetcode-<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a> （荷兰旗问题）</h2><p><strong>题目描述</strong></p><ul><li>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</li><li>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</li></ul><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h3 id="2-1-循环不变量"><a href="#2-1-循环不变量" class="headerlink" title="2.1 循环不变量"></a>2.1 循环不变量</h3><p><strong>循环不变量</strong>：声明的变量在遍历的过程中需要保持定义不变。</p><h3 id="2-2-循环不变量的设计原则"><a href="#2-2-循环不变量的设计原则" class="headerlink" title="2.2 循环不变量的设计原则"></a>2.2 循环不变量的设计原则</h3><ul><li>说明：设计循环不变量的原则是 <strong>不重不漏</strong>。</li></ul><p><strong>本题的分界线定义（变量定义）</strong></p><ul><li>len 是数组的长度；</li><li><strong>变量 zero</strong> 是前两个子区间的<strong>分界点</strong>，一个是闭区间，另一个就必须是开区间；</li><li><strong>变量 i 是循环变量</strong>，一般设置为开区间，表示 i 之前的元素是遍历过的；</li><li><strong>two 是另一个分界线</strong>，我设计成闭区间。</li></ul><p><strong>循环不变量定</strong>义如下：</p><ul><li>所有在子区间 [0, zero) 的元素都等于 0；</li><li>所有在子区间 [zero, i) 的元素都等于 1；</li><li>所有在子区间 [two, len - 1] 的元素都等于 2。</li></ul><p>于是<strong>编码要解决以下三个问题</strong>：</p><ul><li>变量初始化应该如何定义；</li><li>在遍历的时候，是先加减还是先交换；</li><li>什么时候循环终止。</li></ul><p><strong>处理这三个问题，完全看循环不变量的定义。</strong></p><ul><li>编码的时候，<code>**zero</code> 和 <code>two</code> 初始化的值就应该保证上面的三个子区间全为空；**</li><li>在遍历的过程中，「下标先加减再交换」、还是「先交换再加减」就看初始化的时候变量在哪里；</li><li><strong>退出循环的条件也看上面定义的循环不变量，在<code>i == two</code> 成立的时候</strong>，上面的三个子区间就正好 <strong>不重不漏 地覆盖了整个数组</strong>，并且给出的性质成立，题目的任务也就完成了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// all in [0, zero) = 0</span></span><br><span class="line">        <span class="comment">// all in [zero, i) = 1</span></span><br><span class="line">        <span class="comment">// all in [two, len - 1] = 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环终止的条件的 i == two 那么循环可以继续等待的条件是 i &lt; two</span></span><br><span class="line">        <span class="comment">// 为了保证初始化的时候[0,zero) 为空  , 设置 zero = 0；</span></span><br><span class="line">        <span class="comment">// 所以下面遍历到 0 的时候，先交换，再加</span></span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证初始化的时候[two, len - 1] 为空 设置 two = len</span></span><br><span class="line">        <span class="comment">// 所以下面遍历到2的时候，先减 在交换</span></span><br><span class="line">        <span class="keyword">int</span> two = len;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 i == two 上面的三个子区间正好覆盖了全部数组</span></span><br><span class="line">        <span class="comment">// 因为 循环可以继续的条件是 i  &lt; two</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; two)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,i,zero);</span><br><span class="line">                zero++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                two--;</span><br><span class="line">                swap(nums,i,two);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)，这里 N是输入数组的长度；</li><li>空间复杂度：O(N)。</li></ul><p><strong>这种做法是在 Java 的 JDK 的源码中 <code>Arrays.sort()</code> 中学到的。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/102513784.png" alt="mark"></p><h2 id="3-复习-partition习题"><a href="#3-复习-partition习题" class="headerlink" title="3. 复习 partition习题"></a>3. 复习 partition习题</h2><h3 id="3-1-「力扣」第-215-题：数组中的第-K-个最大元素（中等）"><a href="#3-1-「力扣」第-215-题：数组中的第-K-个最大元素（中等）" class="headerlink" title="3.1 「力扣」第 215 题：数组中的第 K 个最大元素（中等）"></a>3.1 「力扣」第 215 题：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第 K 个最大元素</a>（中等）</h3><p><strong>题目描述</strong></p><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/144137037.png" alt="mark"></p><p><strong>解法一 ： 优先队列</strong></p><ul><li>这是直接明了的方法 使用 最小堆去做</li><li>虽然与本系列无关，但仍然是最快捷简单的方法</li></ul><p><strong>思路分析</strong> [参考链接][<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/]" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/]</a></p><ul><li><p>优先队列的思路是很朴素的。因为第 K 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以<strong>维护一个有 K 个元素的最小堆：</strong></p><p>1、如果当前堆不满，直接添加；</p><p>2、堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新都到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。</p></li><li><p>说明：这里最合适的操作其实是 replace，即直接把新读进来的元素放在堆顶，然后执行下沉（siftDown）操作。Java 当中的 <code>PriorityQueue</code> 没有提供这个操作，只好先 <code>poll()</code>再 <code>offer()</code>。</p></li></ul><ul><li><strong>思路1</strong>：把 <code>len</code>个元素都放入一个最小堆中，然后再 <code>pop()</code>出 len - k 个元素，此时最小堆只剩下 k 个元素，堆顶元素就是数组中的第 k 个最大元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一个含有len个元素的最小堆，默认是最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 len 个元素都放入一个最小堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后再 pop() 出 len - k 个元素，此时最小堆只剩下 k 个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len - k;i++)&#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 堆顶元素就是数组中的第 k 个最大元素。</span></span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路 2：综合考虑以上两种情况，总之都是为了节约空间复杂度。即 <code>k</code> 较小的时候使用最小堆，<code>k</code> 较大的时候使用最大堆。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 k 的不同，选最大堆和最小堆，目的是让堆中的元素更小</span></span><br><span class="line">    <span class="comment">// 思路 1：k 要是更靠近 0 的话，此时 k 是一个较大的数，用最大堆</span></span><br><span class="line">    <span class="comment">// 例如在一个有 6 个元素的数组里找第 5 大的元素</span></span><br><span class="line">    <span class="comment">// 思路 2：k 要是更靠近 len 的话，用最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以分界点就是 k = len - k</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= len - k) &#123;</span><br><span class="line">            <span class="comment">// System.out.println("使用最小堆");</span></span><br><span class="line">            <span class="comment">// 特例：k = 1，用容量为 k 的最小堆</span></span><br><span class="line">            <span class="comment">// 使用一个含有 k 个元素的最小堆</span></span><br><span class="line">            PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                minHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">                Integer topEle = minHeap.peek();</span><br><span class="line">                <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; topEle) &#123;</span><br><span class="line">                    minHeap.poll();</span><br><span class="line">                    minHeap.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// System.out.println("使用最大堆");</span></span><br><span class="line">            <span class="keyword">assert</span> k &gt; len - k;</span><br><span class="line">            <span class="comment">// 特例：k = 100，用容量为 len - k + 1 的最大堆</span></span><br><span class="line">            <span class="keyword">int</span> capacity = len - k + <span class="number">1</span>;</span><br><span class="line">            PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(capacity, (a, b) -&gt; b - a);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">                maxHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = capacity; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">                Integer topEle = maxHeap.peek();</span><br><span class="line">                <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; topEle) &#123;</span><br><span class="line">                    maxHeap.poll();</span><br><span class="line">                    maxHeap.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二 ： 暴力</strong></p><ul><li>最简单同时也一定是最容易编码的，编码成功的几率最高，可以用这个最简单思路编码的结果和其它思路编码的结果进行比对，验证高级算法的正确性；</li><li>在数据规模小、对时间复杂度、空间复杂度要求不高的时候，简单问题简单做；</li></ul><p>题目要求我们找到“数组排序后的第 k个最大的元素，而不是第 k个不同的元素” ，</p><ul><li>语义是从右边往左边数第 k个元素（从 1开始），那么从左向右数是第几个呢，我们列出几个找找规律就好了。</li><li>一共 6 个元素，找第 2 大，索引是 44；</li><li>一共 6个元素，找第 4 大，索引是 2。</li></ul><p>因此，升序排序以后，<strong>目标元素的索引是 <code>len - k</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[len - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(NlogN)，这里 NN 是数组的长度，算法的性能消耗主要在排序，JDK 默认使用快速排序，因此时间复杂度为 O(NlogN)。</li><li><strong>空间复杂度</strong>：O(1)，这里是原地排序，没有借助额外的辅助空间。</li></ul><p><strong>解法三 ： partition</strong></p><ul><li>学习过 “快速排序” 的朋友，一定知道一个操作叫 partition，它是 “分而治之” 思想当中 “分” 的那一步。</li><li><strong>经过 partition 操作以后，每一次都能排定一个元素，并且这个元素左边的数都不大于它，这个元素右边的数都不小于它，并且我们还能知道排定以后的元素的索引</strong>。</li><li>于是可以应用 “减而治之”（分治思想的特例）的思想，把问题规模转化到一个更小的范围里。</li></ul><p><strong>思路  ： 借助 partition 操作定位到最终排定以后索引为 <code>len - k</code> 的那个元素</strong></p><blockquote><p>快速排序虽然快，但是如果实现得不好，在遇到特殊测试用例的时候，时间复杂度会变得很高。如果你使用 partition 的方法完成这道题，时间排名不太理想，可以考虑一下是什么问题，这个问题很常见。</p></blockquote><p>以下的描述基于 “快速排序” 算法知识的学习，如果忘记的朋友们可以翻一翻自己的《数据结构与算法》教材，复习一下，partition 过程、分治思想和 “快速排序” 算法的优化。</p><ul><li>分析：我们在学习 “快速排序” 的时候，接触的第 1 个操作就是 partition（切分），简单介绍如下：</li><li>partition（切分）操作，使得：<ul><li>对于某个索引 j，nums[j] 已经排定，即 nums[j] 经过 partition（切分）操作以后会放置在它 “最终应该放置的地方”；</li><li><code>nums[left]</code>到 <code>nums[j - 1]</code> 中的所有元素都不大于<code>nums[j]</code>；</li><li><code>nums[j + 1]</code>到 <code>nums[right]</code> 中的所有元素都不小于 <code>nums[j]</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/151535827.png" alt="mark"></p><ul><li><p><strong><code>partition</code>（切分）操作总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次 <code>partition（切分）</code>操作就能缩小搜索的范围，这样的思想叫做 “减而治之”（是 “分而治之” 思想的特例）。</strong></p></li><li><p>切分过程可以不借助额外的数组空间，仅通过交换数组元素实现</p></li></ul><p><strong>代码一 ： 正常的pivot</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据题意，第k大元素索引是len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums,left,right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(index == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &lt; target)&#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置</span></span><br><span class="line"><span class="comment">    * 在遍历过程中保持循环不变量的语义</span></span><br><span class="line"><span class="comment">    * 1、[left + 1, j] &lt; nums[left]</span></span><br><span class="line"><span class="comment">    * 2、(j, i] &gt;= nums[left]</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span>;i &lt;= right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; pivot)&#123;</span><br><span class="line">                <span class="comment">// 小于pivot的元素都交换到pivot前面</span></span><br><span class="line">                j++;</span><br><span class="line">                swap(nums,j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在之前的遍历过程中，满足[left + 1,j] &lt; pivot 并且 (j,i] &gt;= pivot</span></span><br><span class="line">        swap(nums,j,left);</span><br><span class="line">        <span class="comment">// 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，这里 N 是数组的长度</li><li><strong>空间复杂度</strong>：O(1)，原地排序，没有借助额外的辅助空间。</li></ul><p><strong>代码二： random随机化pivot</strong></p><blockquote><p><strong>注意：本题必须随机初始化 <code>pivot</code> 元素，否则通过时间会很慢，因为测试用例中有极端测试用例。</strong></p></blockquote><ul><li><p><strong>为了应对极端测试用例，使得递归树加深，</strong>可以在循环一开始的时候，随机交换第 1个元素与它后面的任意 1 个元素的位置；</p></li><li><p>说明：最极端的是顺序数组与倒序数组，此时递归树画出来是链表，时间复杂度是 O(N^2) 根本达不到减治的效果。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在区间 [left, right] 这个区间执行 partition 操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomIndex = left + <span class="number">1</span> + random.nextInt(right - left);</span><br><span class="line">            swap(nums, left, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码三 : 使用双指针，将与 <code>pivot</code> 相等的元素等概论地分到 <code>pivot</code> 最终排定位置的两边。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomIndex = left + <span class="number">1</span> + random.nextInt(right - left);</span><br><span class="line">            swap(nums, left, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将等于 pivot 的元素分散到两边</span></span><br><span class="line">        <span class="comment">// [left, lt) &lt;= pivot</span></span><br><span class="line">        <span class="comment">// (rt, right] &gt;= pivot</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lt = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rt = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= rt &amp;&amp; nums[lt] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= rt &amp;&amp; nums[rt] &gt; pivot) &#123;</span><br><span class="line">                rt--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lt &gt; rt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, lt, rt);</span><br><span class="line">            lt++;</span><br><span class="line">            rt--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(nums, left, rt);</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;partition-合集&quot;&gt;&lt;a href=&quot;#partition-合集&quot; class=&quot;headerlink&quot; title=&quot;partition-合集&quot;&gt;&lt;/a&gt;partition-合集&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/101823939.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-什么是-partition-？&quot;&gt;&lt;a href=&quot;#1-什么是-partition-？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是 partition ？&quot;&gt;&lt;/a&gt;1. 什么是 partition ？&lt;/h2&gt;&lt;p&gt;我们在学习 快速排序 的时候知道，可以选择一个标定元素（称为 pivot ，一般而言随机选择），然后通过一次扫描，把数组分成三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 1 部分严格小于 pivot 元素的值；&lt;/li&gt;
&lt;li&gt;第 2 部分恰好等于 pivot 元素的值；&lt;/li&gt;
&lt;li&gt;第 3 部分严格大于 pivot 元素的值。&lt;/li&gt;
&lt;li&gt;第 2 部分元素就是排好序以后它们应该在的位置，接下来只需要递归处理第 1 部分和第 3 部分的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过一次扫描把整个数组分成 3 个部分，正好符合当前问题的场景。写对这道题的方法是：把循环不变量的定义作为注释写出来，然后再编码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="partition" scheme="http://zhuuu.work/tags/partition/"/>
    
      <category term="循环不变量" scheme="http://zhuuu.work/tags/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-09-进程调度算法</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-06T07:22:53.000Z</published>
    <updated>2020-10-07T04:05:21.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-09-进程调度算法"><a href="#Linux-09-进程调度算法" class="headerlink" title="Linux-09-进程调度算法"></a>Linux-09-进程调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><ul><li>进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。</li><li>当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</li></ul><p>什么时候会发生 CPU 调度呢？通常有以下情况：</p><ol><li>当进程从运行状态转到等待状态；</li><li>当进程从运行状态转到就绪状态；</li><li>当进程从等待状态转到就绪状态；</li><li>当进程从运行状态转到终止状态；</li></ol><p>其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。</p><ul><li><strong>非抢占式</strong>的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。</li><li>而<strong>抢占式调度</strong>，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</li></ul><a id="more"></a><ul><li>你可能会好奇为什么第 3 种情况也会发生 CPU 调度呢？<ul><li>假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态</li><li>一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度。</li></ul></li></ul><ul><li>那第 2 种状态通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU。</li></ul><p>调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程正在使用 CPU 的时间和 I/O 时间。</p><p>接下来，说说常见的调度算法：</p><ul><li>先来先服务调度算法</li><li>最短作业优先调度算法</li><li>高响应比优先调度算法</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法</li></ul><h2 id="1-进程调度算法"><a href="#1-进程调度算法" class="headerlink" title="1. 进程调度算法"></a>1. 进程调度算法</h2><h3 id="1-1-先来先服务调度算法"><a href="#1-1-先来先服务调度算法" class="headerlink" title="1.1 先来先服务调度算法"></a>1.1 先来先服务调度算法</h3><ul><li>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（First Come First Severd, FCFS）算法</strong>了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114729145.jpg" alt="mark"></p><ul><li>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></li></ul><p><strong>缺点：</strong></p><ul><li>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。（<strong>不会导致饥饿的产生</strong>）</li><li>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153514117.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153527091.png" alt="mark"></p><h3 id="1-2-最短作业优先调度算法"><a href="#1-2-最短作业优先调度算法" class="headerlink" title="1.2 最短作业优先调度算法"></a>1.2 最短作业优先调度算法</h3><ul><li><strong>最短作业优先（Shortest Job First, SJF）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114846841.jpg" alt="mark"></p><p><strong>缺点：</strong></p><ul><li>这显然对长作业不利，很容易造成一 种极端现象。（<strong>进程饥饿</strong>）</li><li>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153545137.png" alt="mark"></p><p><strong>非抢占式—SJF</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153623881.png" alt="mark"></p><p><strong>抢占式—SJF(SRTN)</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153635107.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153640245.png" alt="mark"></p><h3 id="1-3-高响应比优先调度算法"><a href="#1-3-高响应比优先调度算法" class="headerlink" title="1.3 高响应比优先调度算法"></a>1.3 高响应比优先调度算法</h3><ul><li>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</li><li>那么，<strong>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法</strong>主要是权衡了短作业和长作业。</li><li><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135439932.png" alt="mark"></p><p>从上面的公式，可以发现：</p><ul><li><p><strong>如果两个进程的「等待时间」相同时</strong>，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</p></li><li><p><strong>如果两个进程「要求的服务时间」相同时</strong>，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</p></li><li><p><strong>不会导致饥饿</strong></p></li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153711214.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153719376.png" alt="mark"></p><p><strong>上面三种算法注重的是进程调度的性能</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120514747.png" alt="mark"></p><hr><p><strong>下面三种算法注重的是用户交互的功能和性能的综合</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120440278.png" alt="mark"></p><h3 id="1-4-时间片轮转调度算法"><a href="#1-4-时间片轮转调度算法" class="headerlink" title="1.4 时间片轮转调度算法"></a>1.4 时间片轮转调度算法</h3><ul><li>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135825753.png" alt="mark"></p><p><strong>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长；</li></ul><p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><p><strong>小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115816124.png" alt="mark"></p><p><strong>例题分析</strong></p><ul><li><strong>时间片为2举例</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115903072.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115911628.png" alt="mark"></p><ul><li><strong>以时间片为5举例</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115927677.png" alt="mark"></p><ul><li><strong>可能出现的问题，比如与FCFS对比</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115941047.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120001175.png" alt="mark"></p><h3 id="1-5-最高优先级调度算法"><a href="#1-5-最高优先级调度算法" class="headerlink" title="1.5 最高优先级调度算法"></a>1.5 最高优先级调度算法</h3><ul><li>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</li><li>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法</strong>。</li></ul><p>进程的优先级可以分为，静态优先级或动态优先级：</p><ul><li><strong>静态优先级</strong>：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li><strong>动态优先级</strong>：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式</p><ul><li><strong>非抢占式</strong>：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li><strong>抢占式</strong>：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p><strong>缺点：</strong></p><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><p><strong>小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120040368.png" alt="mark"></p><ul><li><strong>非抢占式例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120142289.png" alt="mark"></p><ul><li><strong>抢占式例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120158415.png" alt="mark"></p><ul><li><strong>优先级原则</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120213748.png" alt="mark"></p><h3 id="1-6-多级反馈队列调度算法"><a href="#1-6-多级反馈队列调度算法" class="headerlink" title="1.6 多级反馈队列调度算法"></a>1.6 多级反馈队列调度算法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120242696.png" alt="mark"></p><ul><li><strong>多级反馈队列（Multilevel Feedback Queue）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</li></ul><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/140252098.png" alt="mark"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li><strong>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行</strong>。</li><li>如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；(<strong>抢占式</strong>)</li></ul><p><strong>缺点：</strong></p><ul><li><strong>会导致进程饥饿</strong></li></ul><p><strong>小结：</strong></p><p>可以发现，对于<strong>短作业</strong>可能可以在第一级队列很快被处理完。</p><p>对于<strong>长作业</strong>，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120339197.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120356739.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120402334.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120409886.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120414590.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120423613.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120430247.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-09-进程调度算法&quot;&gt;&lt;a href=&quot;#Linux-09-进程调度算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-09-进程调度算法&quot;&gt;&lt;/a&gt;Linux-09-进程调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。&lt;/li&gt;
&lt;li&gt;当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候会发生 CPU 调度呢？通常有以下情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当进程从运行状态转到等待状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从等待状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到终止状态；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非抢占式&lt;/strong&gt;的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;抢占式调度&lt;/strong&gt;，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-08-进程调度</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-08-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-08-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</id>
    <published>2020-10-06T07:20:53.000Z</published>
    <updated>2020-10-06T07:32:24.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-08-进程调度"><a href="#操作系统-08-进程调度" class="headerlink" title="操作系统-08-进程调度"></a>操作系统-08-进程调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152620848.png" alt="mark"></p><a id="more"></a><h2 id="1-进程调度的时机"><a href="#1-进程调度的时机" class="headerlink" title="1. 进程调度的时机"></a>1. 进程调度的时机</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152708655.png" alt="mark"></p><p><strong>那么什么时候不能进行进程调度呢？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152758459.png" alt="mark"></p><h2 id="2-进程调度的方式"><a href="#2-进程调度的方式" class="headerlink" title="2. 进程调度的方式"></a>2. 进程调度的方式</h2><ul><li><strong>所谓进程调度方式</strong>，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153113771.png" alt="mark"></p><h2 id="3-进程的切换"><a href="#3-进程的切换" class="headerlink" title="3. 进程的切换"></a>3. 进程的切换</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153208197.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-08-进程调度&quot;&gt;&lt;a href=&quot;#操作系统-08-进程调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统-08-进程调度&quot;&gt;&lt;/a&gt;操作系统-08-进程调度&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152620848.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-07-CPU调度</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-07-CPU%E8%B0%83%E5%BA%A6/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-07-CPU%E8%B0%83%E5%BA%A6/</id>
    <published>2020-10-06T07:00:53.000Z</published>
    <updated>2020-10-06T07:25:55.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-07-CPU调度"><a href="#操作系统-07-CPU调度" class="headerlink" title="操作系统-07-CPU调度"></a>操作系统-07-CPU调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152136370.png" alt="mark"></p><h2 id="1-调度的基本概念"><a href="#1-调度的基本概念" class="headerlink" title="1. 调度的基本概念"></a>1. 调度的基本概念</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152233238.png" alt="mark"></p><a id="more"></a><h2 id="2-调度的三个层次"><a href="#2-调度的三个层次" class="headerlink" title="2. 调度的三个层次"></a>2. 调度的三个层次</h2><h5 id="（1）高级调度（-作业调度）"><a href="#（1）高级调度（-作业调度）" class="headerlink" title="（1）高级调度（ 作业调度）"></a>（1）高级调度（ 作业调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152300101.png" alt="mark"></p><h5 id="（2）中级调度（内存调度）"><a href="#（2）中级调度（内存调度）" class="headerlink" title="（2）中级调度（内存调度）"></a>（2）中级调度（内存调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152329541.png" alt="mark"></p><h5 id="（3）进程的挂起状态与七状态模型"><a href="#（3）进程的挂起状态与七状态模型" class="headerlink" title="（3）进程的挂起状态与七状态模型"></a>（3）进程的挂起状态与七状态模型</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152353463.png" alt="mark"></p><h5 id="（4）低级调度（进程调度）"><a href="#（4）低级调度（进程调度）" class="headerlink" title="（4）低级调度（进程调度）"></a>（4）低级调度（进程调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152402582.png" alt="mark"></p><h5 id="三层调度的联系和对比"><a href="#三层调度的联系和对比" class="headerlink" title="三层调度的联系和对比"></a>三层调度的联系和对比</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152427705.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-07-CPU调度&quot;&gt;&lt;a href=&quot;#操作系统-07-CPU调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统-07-CPU调度&quot;&gt;&lt;/a&gt;操作系统-07-CPU调度&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152136370.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-调度的基本概念&quot;&gt;&lt;a href=&quot;#1-调度的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 调度的基本概念&quot;&gt;&lt;/a&gt;1. 调度的基本概念&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152233238.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-018-四数之和</title>
    <link href="http://zhuuu.work/2020/10/05/Leetcode/Leetcode-018-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/10/05/Leetcode/Leetcode-018-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-10-05T11:52:53.000Z</published>
    <updated>2020-10-06T12:33:44.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-18-四数之和"><a href="#Leecode-18-四数之和" class="headerlink" title="Leecode-18. 四数之和"></a>Leecode-<a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h1><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路（同leetcode015 所以这里不再阐述 有15题基础看代码就秒懂了）</strong></p><ul><li>首先对排序后的数组进行遍历，固定一个nums[i] 。</li><li>其次使用一个指针L指向 <code>i + 1</code> 的位置，一个指针R指向 <code>nums.length - 1</code>的位置，同时计算<code>nums[i] + nums[L] + nums[R]</code>,计算这三个数的和是否等于0</li><li>细节条件一定要注意<ul><li>如果<code>nums[i] &gt; 0</code> ，那么这三个数的和比不可能等于0</li><li>如果<code>nums[i] == nums[i -1]</code> ,则说明该数字重复，会导致结果的重复，所以应该跳过</li><li>当sum == 0的时候，如果<code>nums[L] == nums[L+1]</code>,则会导致结果的重复，应该跳过，(L++)</li><li>当sum == 0的时候，如果<code>nums[R] == nums[R - 1]</code>,则会导致结果的重复，应该跳过，(R–)</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li><strong>首先进行排序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100358932.png" alt="mark"></p><ol start="2"><li><strong>第一轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100418544.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100451353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100458185.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100504327.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100511291.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100527129.png" alt="mark"></p><ol start="3"><li><strong>第二轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100538257.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100548763.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100554929.png" alt="mark"></p><ol start="4"><li><strong>第三轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100609939.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100615721.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 双指针遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[len - <span class="number">3</span>] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j  &lt; len - <span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="comment">// 剪枝操作</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 双指针操作</span></span><br><span class="line">                <span class="keyword">int</span> left  = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到对应的结果</span></span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去重操作</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去重操作</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        <span class="comment">// 和小于target</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 和大于target</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(fourSum(arr,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度</strong>：O（n^3） 排序O(nlogn) + 循环O（n^3） = O(n^3)</p></li><li><p><strong>空间复杂度</strong>：O(n)，其中 n 是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组 nums，实际情况中不一定允许，因此也可以看成使用了一个额外的<strong>数组存储了数组nums 的副本并排序</strong>，空间复杂度为 O(n)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-18-四数之和&quot;&gt;&lt;a href=&quot;#Leecode-18-四数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-18. 四数之和&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;18. 四数之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案中不可以包含重复的四元组。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定数组 nums &amp;#x3D; [1, 0, -1, 0, -2, 2]，和 target &amp;#x3D; 0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;满足要求的四元组集合为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1,  0, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-2, -1, 1, 2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-2,  0, 0, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-06-线程</title>
    <link href="http://zhuuu.work/2020/10/05/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/10/05/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-10-05T02:00:53.000Z</published>
    <updated>2020-10-04T10:59:25.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-06-线程"><a href="#操作系统-06-线程" class="headerlink" title="操作系统-06-线程"></a>操作系统-06-线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185326649.png" alt="mark"></p><a id="more"></a><h2 id="1-为什么要引入线程？"><a href="#1-为什么要引入线程？" class="headerlink" title="1. 为什么要引入线程？"></a>1. 为什么要引入线程？</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185358306.png" alt="mark"></p><ul><li>为了方便于理解，我打开了我的任务管理器，可以看出chrome一个进程，下面有很多分支，可以把这些分支当做线程看待，PID即进程和线程都有的标识符。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185415092.png" alt="mark"></p><h2 id="2-线程的定义"><a href="#2-线程的定义" class="headerlink" title="2. 线程的定义"></a>2. 线程的定义</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185431932.png" alt="mark"></p><ul><li>资源分配、调度<br>传统进程机制中，<strong>进程是资源分配、调度的基本单位</strong><br><strong>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</strong></li><li>并发性<br>传统进程机制，只能进程间并发<br>现在各线程之间也能并发</li><li>系统开销<br>传统进程并发，需要<strong>切换进程的运行环境，系统开销大</strong><br><strong>同一个进程内的线程间并发，不需要切换环境，开销小</strong></li></ul><h2 id="3-线程的属性"><a href="#3-线程的属性" class="headerlink" title="3. 线程的属性"></a>3. 线程的属性</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185546111.png" alt="mark"></p><p>内核线程是处理机调度的单位，线程几乎不拥有系统资源，同一个进程的线程间共享进程资源，各个线程可以占用不同的CPU。 线程有自己的ID，线程控制块TCP，线程也有就绪、阻塞、运行三种基本状态。 同一进程内的线程通信无需系统干预，线程切换不会引起进程切换，系统开销很小。 不同进程的线程切换会导致进程切换。</p><h2 id="4-线程的实现方式"><a href="#4-线程的实现方式" class="headerlink" title="4. 线程的实现方式"></a>4. 线程的实现方式</h2><p><strong>用户级线程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185636034.png" alt="mark"></p><p><strong>内核级线程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185659747.png" alt="mark"></p><p><strong>组合方式</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185720348.png" alt="mark"></p><h2 id="5-多线程模型"><a href="#5-多线程模型" class="headerlink" title="5. 多线程模型"></a>5. 多线程模型</h2><p><strong>多对一模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185810274.png" alt="mark"></p><p><strong>一对一模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185824641.png" alt="mark"></p><p><strong>多对多模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185839178.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-06-线程&quot;&gt;&lt;a href=&quot;#操作系统-06-线程&quot; class=&quot;headerlink&quot; title=&quot;操作系统-06-线程&quot;&gt;&lt;/a&gt;操作系统-06-线程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185326649.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>好文阅读-01-后端学习路线</title>
    <link href="http://zhuuu.work/2020/10/04/recommendation/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB-01-%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://zhuuu.work/2020/10/04/recommendation/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB-01-%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2020-10-04T10:32:24.000Z</published>
    <updated>2020-10-04T14:30:00.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好文阅读-01-后端学习路线"><a href="#好文阅读-01-后端学习路线" class="headerlink" title="好文阅读-01-后端学习路线"></a>好文阅读-01-后端学习路线</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>说到后端开发，难免会遇到各种所谓高大上的「关键词 」，对于我们应届生小白，难免会觉得比较陌生，因为在学校确实比较少遇见这些所谓高大上的东西，那么今天就带着学习的态度和大家分享这些看似可以装逼可以飞的带逼格的关键词吧。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/152056275.jpg" alt="mark"></p><a id="more"></a><h2 id="1-分布式"><a href="#1-分布式" class="headerlink" title="1. 分布式"></a>1. 分布式</h2><blockquote><p>在学校里的项目中，一个 Web 系统可能咋们一个人就搞定，因为几乎不考虑并发量，性能咋样，所谓「<strong>过得去</strong> 」足矣，但是为了面试考虑，我们又不得不找点类似<strong>秒杀系统</strong>作为我们简历的支撑项目(即使已经烂大街)。那么先问你第一个问题，为什么就采用了<strong>分布式</strong>的方案落地这个项目？</p></blockquote><ul><li>当一个人或者几十个使用你的系统，哎呀我去，请求秒回，效果倍棒，于是乎简历砰砰写上却多么牛X，当面试官就会问你你这项目做了啥，测试过没，并发量如何，性能如何？你就…..</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/155639381.gif" alt="mark"></p><ul><li>当访问系统的用户越来越多，可是我们的系统资源有限，所以需要更多的 <strong>CPU</strong> 和<strong>内存</strong>去处理用户的计算请求，当然也就要求更大的<strong>网络带宽</strong>去处理数据的传输，也需要更多的磁盘空间存储数据。资源不够，消耗过度，服务器崩溃，系统也就不干活了，那么在这样的情况怎么处理？</li></ul><h3 id="1-1-垂直伸缩"><a href="#1-1-垂直伸缩" class="headerlink" title="1.1 垂直伸缩"></a>1.1 垂直伸缩</h3><blockquote><p>纵向生长。通过提升<strong>单台</strong>服务器的<strong>计算处理</strong>能力来抵抗更大的请求访问量。比如使用更快频率的CPU，更快的网卡，塞更多的磁盘等。其实这样的处理方式在电信，银行等企业比较常见，让摩托车变为小汽车，更强大的计算机，处理能力也就越强，但是对于运维而言也就越来越复杂。那真的就这样花钱买设备就完事了？</p></blockquote><ul><li>当然不，单台服务器的计算处理能力是有限的，而且也会严重受到计算机硬件水平的制约。</li></ul><h3 id="1-2-水平伸缩"><a href="#1-2-水平伸缩" class="headerlink" title="1.2 水平伸缩"></a>1.2 水平伸缩</h3><blockquote><p>一台机器处理不过来，我就用多台<strong>廉价</strong>的机器合并同时处理，人多力量大嘛，通过多台服务器构成分布式集群从而提升系统的整体处理能力。这里说到了分布式，那我们看看分布式的成长过程</p></blockquote><p>记住一句话：<strong>系统的技术架构是需求所驱动</strong></p><ul><li>最初的<strong>单体系统</strong>，只需要部分用户访问，</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160035576.png" alt="mark"></p><p>做系统的原因当然是有需求，有价值，可赚钱。</p><p>随着使用系统的用户越来越多，这时候关注的人越来越多，单台服务器扛不住了，关注的人觉得响应真慢，没啥意思，就开始吐槽，但是这一吐槽，导致用户更多，毕竟大家都爱吃瓜。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160108772.gif" alt="mark"></p><ul><li>这样下去不得不进行系统的升级，将<strong>数据库和应用</strong>分离。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160133438.png" alt="mark"></p><p>这样子，咋们将数据库和应用程序分离后，部署在不同的服务器中，从1台服务器变为多台服务器，处理响应更快，内容也够干，访问的用户呈<strong>指数增长</strong>，这多台服务器都有点扛不住了，怎么办？</p><p>加一个<strong>缓存</strong>吧，我们不每次从数据库中读取数据，而将应用程序需要的数据暂存在<strong>缓冲</strong>中。缓存呢，又分为<strong>本地缓存</strong>和<strong>分布式的缓存</strong>。分布式缓存，顾名思义，使用多台服务器构成集群，存储更多的数据并提供缓存服务，从而提升缓存的能力。</p><ul><li><strong>加了缓存哪些好处？</strong></li></ul><p>应用程序不再直接访问数据库，提升访问效率。因为缓存内容在内存中，不用每次连接存放磁盘中的数据库，</p><p>系统越来越火，于是考虑将应用服务器也作为<strong>集群</strong>。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160223826.png" alt="mark"></p><h2 id="2-缓存架构"><a href="#2-缓存架构" class="headerlink" title="2. 缓存架构"></a>2. 缓存架构</h2><blockquote><p>干啥啥不行，缓存第一名。不吹牛，缓存应用在计算机的各个角落。<strong>缓存</strong>可说是软件技术中的的杀手锏，无论是程序代码使用buffer，还是网络架构中使用缓存，虚拟机也会使用大量的缓存。其实最初在CPU中也就开始使用缓存。缓存分为两种，一种是<strong>通读缓存</strong>，一种是<strong>旁路缓存</strong></p></blockquote><h3 id="2-1-通读缓存"><a href="#2-1-通读缓存" class="headerlink" title="2.1 通读缓存"></a>2.1 通读缓存</h3><ul><li>假设当前应用程序获取数据，如果数据存在于通读缓存中就直接返回。如果不存在于通读缓存，那么就访问数据源，同时将数据存放于缓存中。下次访问就直接从缓存直接获取。比较常见的为<strong>CDN</strong>和<strong>反向代理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160318763.png" alt="mark"></p><p><strong>CDN</strong></p><blockquote><p>CDN称为内容分发网络。想象我们京东购物的时候，假设我们在成都，如果买的东西在成都仓库有就直接给我们寄送过来，可能半天就到了，用户体验也非常好，就不用从北京再寄过来。同样的道理，用户就可以近距离获得自己需要的数据，既提高了响应速度，又节约了网络带宽和服务器资源。</p></blockquote><h3 id="2-2-旁路缓存"><a href="#2-2-旁路缓存" class="headerlink" title="2.2 旁路缓存"></a>2.2 旁路缓存</h3><ul><li>应用程序需要自己从数据源读取数据，然后将这个数据写入到<strong>旁路缓存</strong>中。</li><li>这样，下次应用程序需要数据的时候，就可以通过旁路缓存直接获得数据了</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160429403.png" alt="mark"></p><p><strong>缓存的好处</strong></p><ul><li>因为大部分缓存的数据存储在内存中，相比于硬盘或者从网络中获取效率更高，响应时间更快，性能更好</li><li>通过 <strong>CDN</strong> 等通读缓存可以降低服务器的负载能力。</li><li>因为缓存通常会记录计算结果。如果缓存命中直接返回，否则需要进行大量的运算。所以使用缓存也减少了<strong>CPU</strong> 的计算消耗，加快处理速度</li></ul><p><strong>缓存缺点</strong></p><ul><li><p>我们缓存的数据来自源数据，如果源数据被修改了，俺么缓存数据很肯能也是被修改过的，成为脏数据，所以怎么办？</p></li><li><p>过期失效</p></li></ul><blockquote><p>在每次写入缓存数据的时候标记失效时间，读取数据的时候检查数据是否失效，如果失效了就重新从数据源获取数据。、</p></blockquote><ul><li>失效通知</li></ul><blockquote><p>应用程序在更新数据源的时候，通知清除缓存中的数据。</p></blockquote><p><strong>是不是数据使用缓存都有意义呢？</strong></p><ul><li>非也，通常放入缓存中的数据都是带有热点的数据，比如当日热卖商品，或者热门吃瓜新闻，这样将数据存放在缓存中，会被多次读取，从而缓存的命中率也会比较高</li></ul><h2 id="3-异步架构"><a href="#3-异步架构" class="headerlink" title="3. 异步架构"></a>3. 异步架构</h2><blockquote><p>在前面中，通过缓存实际上很多时候是解决了读的问题，加快了读取数据的能力。因为缓存通常很难保证数据的持久性和一致性，所以我们通常不会将数据直接写入缓存中，而是写入 RDBMAS 等数据中，那如何提升系统的<strong>写操作性能</strong>呢？</p></blockquote><p><strong>场景：</strong></p><blockquote><p>此时假设两个系统分别为A,B，其中A系统<strong>依赖</strong>B系统，两者通信采用<strong>远程调用</strong>的方式，此时如果B系统出故障，很可能引起A系统出故障。</p><p>从而不得不单独进行升级，怎么办？</p></blockquote><ul><li>使用<strong>消息队列</strong>的异步架构，也称为事件驱动模型。</li></ul><p><strong>异步相对于同步</strong>而言，同步通常是当应用程序调用服务的时候，不得不阻塞等待服务期完成，此时CPU空闲比较浪费，直到返回服务结果后才会继续执行。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160754809.png" alt="mark"></p><p><strong>同步举例子：</strong></p><blockquote><p>举个例子，小蓝今天想在系统中加一个发邮件的功能，通过SMTP和远程服务器通信，但是远程服务器有很多邮件需要等待发送呢，当前邮件就可能等待比较长时间才能发送成功，发送成功后反馈与应用程序。这个过程中，远程服务器发送邮件的时候，应用程序就阻塞，准确的说是执行应用程序的线程阻塞。</p></blockquote><blockquote><p>这样阻塞带来什么问题“？</p></blockquote><ul><li>不能释放占用的系统资源，导致系统资源不足，影响系统性能</li><li>无法快速给用户响应结果</li></ul><blockquote><p>但是在实际情况中，我们发送邮件，并不需要得到发送结果。比如用户注册，发送账号激活邮件，无论邮件是否发送成功都会收到”返回邮件已经发送，请查收邮件确认激活”，怎样才能让应用程序不阻塞？</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160906353.png" alt="mark"></p><p>此时就比较清晰了，调用者将消息发送给消息队列直接返回，应用程序收到返回以后继续执行，快读响应用户释放资源。有专门的消费队列程序从中消息队列取出数据并进行消费。如果远程服务出现故障，只会传递给消费者程序而不会影响到应用程序。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161031308.png" alt="mark"></p><h3 id="3-1-消息队列模型"><a href="#3-1-消息队列模型" class="headerlink" title="3.1 消息队列模型"></a>3.1 消息队列模型</h3><ul><li>消息队列模型中通常有三个角色，分别为<strong>生产者</strong>，<strong>消息队列</strong>和<strong>消费者</strong>。</li><li>生产者产生数据封装为消息发送给消息队列，专门的消费程序从消息队列中取出数据，消费数据。</li><li>在我看来，消息队列主要是缓冲消息，等待消费者消费。其中<strong>消费的方式分为两种</strong></li></ul><ol><li><strong>点对点</strong></li></ol><blockquote><p>对生产者多消费者的情况。一个消息被一个消费者消费</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161152869.png" alt="mark"></p><p>上述的发邮件例子就是典型的点对点模式。互不干扰，其中某个服务出现问题不会印象到全局</p><ol start="2"><li><strong>订阅模式</strong></li></ol><blockquote><p>开发人员在消息队列中设置主题，生产者往相应的主题发送数据，消费者从对应的主题中消费数据，每个消费者按照自己业务逻辑分别进行计算</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161242379.png" alt="mark"></p><p>这个比较好理解，比如在用户注册的时候，我们将注册信息放入主题用户中，消费者订阅了这个主题，可能有构造短信消息的消费者，也有推广产品的消费者，都可以根据自己业务逻辑进行数据处理。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161351841.png" alt="mark"></p><p><strong>使用异步模型的优点</strong></p><ul><li>快速响应</li></ul><blockquote><p>不在需要等待。生产者将数据发送消息队列后，可继续往下执行，不虚等待耗时的消费处理</p></blockquote><ul><li>削峰填谷(需要修改)</li></ul><blockquote><p>互联网产品会在不同的场景其并发请求量不同。互联网应用的访问压力随时都在变化，系统的访问高峰和低谷的并发压力可能也有非常大的差距。如果按照压力最大的情况部署服务器集群，那么服务器在绝大部分时间内都处于<strong>闲置状态</strong>。但利用消息队列，我们可以将需要处理的消息放入消息队列，而消费者可以控制消费速度，因此能够降低系统访问高峰时压力，而在访问低谷的时候还可以继续消费消息队列中<br>未处理的消息，保持系统的资源利用率</p></blockquote><ul><li>降低耦合</li></ul><blockquote><p>如果调用是同步，如果调用是同步的，那么意味着调用者和被调用者必然存在依赖，一方面是代码上的依赖，应用程序需要依赖发送邮件相关的代码，如果需要修改发送邮件的代码，就必须修改应用程序，而且如果要增加新的功能</p></blockquote><p><strong>那么目前主要的消息队列有哪些，其有缺点是什么？</strong>(好好记下这个高频题目啦)</p><h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h2><blockquote><p>一台机器扛不住了，需要多台机器帮忙，既然使用多台机器，就希望不要把压力都给一台机器，所以需要一种或者多种策略分散高并发的计算压力，从而引入负载均衡，那么到底是如何分发到不同的服务器的呢？</p></blockquote><ol><li><strong>砸钱</strong></li></ol><blockquote><p>最初实现负载均衡采取的方案很直接，直接上硬件，当然也就比较贵，互联网的普及，和各位科学家的无私奉献，各个企业开始部署自己的方案，从而出现负载均衡服务器</p></blockquote><ol start="2"><li><strong>HTTP重定向负载均衡</strong></li></ol><ul><li>也属于比较直接，当HTTP请求叨叨负载均衡服务器后，使用一套负载均衡算法计算到后端服务器的地址，然后将新的地址给用户浏览器，浏览器收到重定向响应后发送请求到新的应用服务器从而实现负载均衡，如下图所示</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222128709.png" alt="mark"></p><p>优点：</p><ul><li>简单，如果是java开发工程师，只需要servlet中几句代码即可</li></ul><p>缺点：</p><ul><li>加大请求的工作量。第一次请求给负载均衡服务器，第二次请求给应用服务器</li><li>因为要先计算到应用服务器的 IP 地址，所以 IP 地址可能暴露在公网，既然暴露在了公网还有什么安全可言</li></ul><ol start="3"><li><strong>DNS负载均衡</strong></li></ol><blockquote><p>了解计算机网络的你应该很清楚如何获取 IP 地址，其中比较常见的就是 DNS 解析获取 IP 地址。用户通过浏览器发起HTTP请求的时候，DNS 通过对域名进行即系得到 IP 地址，用户委托协议栈的 IP 地址简历 HTTP 连接访问真正的服务器。这样不同的用户进行域名解析将会获取不同的IP地址从而实现负载均衡</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222244275.png" alt="mark"></p><p>乍一看，和HTTP重定向的方案不是很相似吗而且还有 DNS 解析这一步骤，也会解析出 IP 地址，不一样的暴露？每次都需要解析吗，当然不，通常本机就会有缓存，在实际的工程项目中通常是怎么样的呢</p><ul><li>通过 DNS 解析获取负载均衡集群某台服务器的地址</li><li><strong>负载均衡服务器再一次获取某台应用服务器</strong>，这样子就不会将应用服务器的 IP 地址暴露在官网了</li></ul><ol start="4"><li><strong>反向代理负载均衡</strong></li></ol><blockquote><p>这里典型的就是Nginx提供的反向代理和负载均衡功能。用户的请求直接叨叨反向代理服务器，服务器先看本地是缓存过，有直接返回，没有则发送给后台的应用服务器处理。</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222406909.png" alt="mark"></p><ol start="5"><li><strong>IP负载均衡</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222457447.png" alt="mark"></p><ul><li>注意，这种方案通常属于内核级别，如果数据比较小还好，但是大部分情况是图片等资源文件，这样负载均衡服务器会出现响应或者请求过大所带来的瓶颈</li></ul><ol start="6"><li><strong>数据链路负载均衡</strong></li></ol><blockquote><p>它可以解决因为数据量太大而导致负载均衡服务器带宽不足这个问题。怎么实现的呢。它不修改数据包的IP地址，而是更改mac地址。应用服务器和负载均衡服务器使用相同的虚拟IP</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222553607.png" alt="mark"></p><p>以上介绍了几种负载均衡的方式，但是很重要的<strong>负载均衡算法却没有设计，其中包含了轮询，随机</strong></p><h2 id="5-数据存储"><a href="#5-数据存储" class="headerlink" title="5. 数据存储"></a>5. 数据存储</h2><ul><li>公司存在的价值在于流量，流量需要数据，可想而知数据的存储，数据的高可用可说是公司的灵魂。那么改善数据的存储都有哪些手段或方法呢？</li></ul><ol><li><strong>数据主从复制</strong></li></ol><blockquote><p>主从复制比较好理解，需要使用两个数据库存储一样的数据。</p><p>其原理为当应用程序A发送更新命令到主服务器的时候，数据库会将这条命令同步记录到Binlog中，然后其他线程会从Binlog中读取并通过远程通讯的方式复制到另外服务器。服务器收到这更新日志后加入到自己Relay Log中，</p><p>然后SQL执行线程从Relay Log中读取次日志并在本地数据库执行一遍，从而实现主从数据库同样的数据。</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222817995.png" alt="mark"></p><ul><li>主从复制可以方便进行读写分离，可以使用一主多从的方式保证高可用，如果从数据库A挂了，可以将读操作迁移到从数据库完成高可用。</li><li>但是如果主数据库挂了咋搞，那就Mysql的主主复制。可是不管上面说的那种方式都不是提升它的存储能力，这就需要进行<strong>数据库的分片</strong>了</li></ul><ol start="2"><li><strong>数据库分片</strong></li></ol><blockquote><p>将一张表分成若干片，其中每一片都包含一部分行记录，然后将每一片存储在不同的服务器中，这样就实现一张表存放在多台服务器中，哪都有哪些分片存储的方案？</p></blockquote><ul><li>最开始使用<strong>“硬编码”</strong>的方式，此方式从字面上可以理解为直接在代码中指定。假定表为用户表，通过ID的奇偶存放在不同的服务器上，如下图</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222949802.png" alt="mark"></p><p>这种方式的<strong>缺点</strong>很明显，当需要增加服务器的时候，就需要改动代码，这就不友好了。比较常见的数据库分片算法是通过余数Hash算法，根据主键ID和服务器的数量取模，根据余数确定服务器</p><p><strong>参考博客</strong> ： <a href="https://mp.weixin.qq.com/s/co6ZiALBCUHxc-8SpcKxPw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/co6ZiALBCUHxc-8SpcKxPw</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;好文阅读-01-后端学习路线&quot;&gt;&lt;a href=&quot;#好文阅读-01-后端学习路线&quot; class=&quot;headerlink&quot; title=&quot;好文阅读-01-后端学习路线&quot;&gt;&lt;/a&gt;好文阅读-01-后端学习路线&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;说到后端开发，难免会遇到各种所谓高大上的「关键词 」，对于我们应届生小白，难免会觉得比较陌生，因为在学校确实比较少遇见这些所谓高大上的东西，那么今天就带着学习的态度和大家分享这些看似可以装逼可以飞的带逼格的关键词吧。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/152056275.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后端学习路线" scheme="http://zhuuu.work/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
      <category term="好文阅读" scheme="http://zhuuu.work/tags/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-05-进程通信</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-05-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-05-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-10-04T09:00:53.000Z</published>
    <updated>2020-10-04T08:57:56.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-05-进程通信"><a href="#操作系统-05-进程通信" class="headerlink" title="操作系统-05-进程通信"></a>操作系统-05-进程通信</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151330566.png" alt="mark"></p><ul><li>很明显，在这一场面试中， 张三在<strong>进程间通信</strong>这一块没复习好，虽然列出了进程间通信的方式，但这只是表面功夫，<strong>应该需要进一步了解每种通信方式的优缺点及应用场景。</strong></li></ul><a id="more"></a><h2 id="1-思维导图"><a href="#1-思维导图" class="headerlink" title="1. 思维导图"></a>1. 思维导图</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151432253.png" alt="mark"></p><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><ul><li><strong>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151456483.png" alt="mark"></p><p>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？</p><h3 id="2-1-管道"><a href="#2-1-管道" class="headerlink" title="2.1 管道"></a>2.1 管道</h3><p><strong>匿名管道</strong></p><ul><li>如果你学过 Linux 命令，那你肯定很熟悉「<code>|</code>」这个竖线。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps auxf | grep mysql</span><br></pre></td></tr></table></figure><ul><li>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。<ul><li>同时，我们得知上面这种管道是没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</li></ul></li></ul><p><strong>命名管道</strong></p><ul><li>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。<ul><li>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo myPipe</span><br></pre></td></tr></table></figure><ul><li><code>myPipe</code>就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure><ul><li>接下来，我们往 myPipe 这个管道写入数据：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello&quot; &gt; myPipe  &#x2F;&#x2F; 将数据写进管道</span><br><span class="line">                         &#x2F;&#x2F; 停住了 ...</span><br></pre></td></tr></table></figure><ul><li><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p></li><li><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; myPipe  &#x2F;&#x2F; 读取管道里的数据</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p></li><li><p>我们可以看出，<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p></li></ul><blockquote><p>那管道如何创建呢，背后原理是什么？</p></blockquote><p><strong>匿名管道</strong>的创建，需要通过下面这个系统调用：</p><p><code>int pipe(int fd[2])</code></p><ul><li>这里表示创建一个匿名管道，并返回了两个描述符，<ul><li>一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。</li><li>注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163516413.png" alt="mark"></p><ul><li>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</li><li>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</li><li>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163605213.png" alt="mark"></p><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 <code>fd[0]</code>，只保留写入的<code>fd[1]</code>；</li><li>子进程关闭写入的<code>fd[1]</code>，只保留读取的<code>fd[0]</code>；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163701458.png" alt="mark"></p><p><strong>所以说如果需要双向通信，则应该创建两个管道。</strong></p><ul><li>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，<strong>但是在我们 shell 里面并不是这样的。</strong><ul><li>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163801175.png" alt="mark"></p><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p><strong>小结：</strong></p><ul><li><p><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p></li><li><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p></li><li><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p></li></ul><h3 id="2-2-消息队列"><a href="#2-2-消息队列" class="headerlink" title="2.2 消息队列"></a>2.2 消息队列</h3><ul><li>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</li><li>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</li><li>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，<strong>消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。</strong></li><li>如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</li><li>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</li><li>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</li></ul><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><ul><li><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</li><li><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</li></ul><h3 id="2-3-共享内存"><a href="#2-3-共享内存" class="headerlink" title="2.3 共享内存"></a>2.3 共享内存</h3><ul><li>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</li><li>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</li><li><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164240759.png" alt="mark"></p><h3 id="2-4-信号量"><a href="#2-4-信号量" class="headerlink" title="2.4 信号量"></a>2.4 信号量</h3><ul><li>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</li><li>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</li></ul><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p><strong>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</strong></p><p><strong>互斥访问</strong></p><ul><li>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164357574.png" alt="mark"></p><p>具体的过程如下：</p><ul><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p><strong>同步访问</strong></p><ul><li>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</li><li>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这<strong>两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</strong></li></ul><p>那么这时候，就可以用信号量来实现多<strong>进程同步的方式，我们可以初始化信号量为 <code>0</code>。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164459468.png" alt="mark"></p><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><h3 id="2-5-信号"><a href="#2-5-信号" class="headerlink" title="2.5 信号"></a>2.5 信号</h3><ul><li>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164625864.png" alt="mark"></p><ul><li>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</li><li><strong>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p><strong>1. 运行在 shell 终端的进程</strong>，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p><strong>2. 如果进程在后台运行</strong>，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p><strong>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</strong></p><ul><li><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的<code>SIGTERM</code>信号，就是终止进程的意思。<code>Core</code>的意思是<code>Core Dump</code>，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p></li></ul><h3 id="2-6-Socket"><a href="#2-6-Socket" class="headerlink" title="2.6 Socket"></a>2.6 Socket</h3><ul><li><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p></li><li><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p></li></ul><p><code>int socket(int domain, int type, int protocal)</code></p><p><strong>三个参数分别代表：</strong></p><ul><li><code>domain</code> 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</li><li><code>type</code>参数用来指定通信特性，比如 <code>SOCK_STREAM</code>表示的是字节流，对应<code>TCP</code>、<code>SOCK_DGRAM</code>表示的是数据报，对应 <code>UDP</code>、<code>SOCK_RAW</code>表示的是原始套接字；</li><li><code>protocal</code> 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p><strong>根据创建 socket 类型的不同，通信的方式也就不同：</strong></p><ul><li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p><strong>接下来，简单说一下这三种通信的编程模式。</strong></p><h4 id="2-6-1-针对-TCP-协议通信的-socket-编程模型"><a href="#2-6-1-针对-TCP-协议通信的-socket-编程模型" class="headerlink" title="2.6.1 针对 TCP 协议通信的 socket 编程模型"></a>2.6.1 针对 TCP 协议通信的 socket 编程模型</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/165037742.png" alt="mark"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h4 id="2-6-2-针对-UDP-协议通信的-socket-编程模型"><a href="#2-6-2-针对-UDP-协议通信的-socket-编程模型" class="headerlink" title="2.6.2 针对 UDP 协议通信的 socket 编程模型"></a>2.6.2 针对 UDP 协议通信的 socket 编程模型</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/165208111.png" alt="mark"></p><ul><li>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</li><li>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个<code>socket</code> 多台机器就可以任意通信，因此每一个 <code>UDP</code> 的 <code>socket</code>都需要 bind。</li></ul><p>另外，每次通信时，调用<code>sendto</code> 和 <code>recvfrom</code>，都要传入目标主机的 IP 地址和端口。</p><h4 id="2-6-3-针对本地进程间通信的-socket-编程模型"><a href="#2-6-3-针对本地进程间通信的-socket-编程模型" class="headerlink" title="2.6.3 针对本地进程间通信的 socket 编程模型"></a>2.6.3 针对本地进程间通信的 socket 编程模型</h4><p>本地 socket  被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，<strong>可以支持「字节流」和「数据报」两种协议；</strong></li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><h3 id="3-1-进程的通信方式"><a href="#3-1-进程的通信方式" class="headerlink" title="3.1 进程的通信方式"></a>3.1 进程的通信方式</h3><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><ul><li><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</li><li><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</li></ul><ul><li><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></li></ul><ul><li><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p></li><li><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p></li></ul><ul><li>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</li></ul><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><h3 id="3-2-线程的通信方式"><a href="#3-2-线程的通信方式" class="headerlink" title="3.2 线程的通信方式"></a>3.2 线程的通信方式</h3><p><strong>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</strong></p><ul><li><p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p></li><li><p>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</p></li><li><p>同步的方式，可保证线程 A 应在线程 B 之前执行；</p></li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-05-进程通信&quot;&gt;&lt;a href=&quot;#操作系统-05-进程通信&quot; class=&quot;headerlink&quot; title=&quot;操作系统-05-进程通信&quot;&gt;&lt;/a&gt;操作系统-05-进程通信&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151330566.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很明显，在这一场面试中， 张三在&lt;strong&gt;进程间通信&lt;/strong&gt;这一块没复习好，虽然列出了进程间通信的方式，但这只是表面功夫，&lt;strong&gt;应该需要进一步了解每种通信方式的优缺点及应用场景。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程通信" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-04-进程控制</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-04-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-04-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-10-04T06:00:53.000Z</published>
    <updated>2020-10-04T07:11:03.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-04-进程控制"><a href="#操作系统-04-进程控制" class="headerlink" title="操作系统-04-进程控制"></a>操作系统-04-进程控制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>什么是进程控制？<br>进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简而言之就是实现进程状态切换。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150250419.png" alt="mark"></p><a id="more"></a><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150328172.png" alt="mark"></p><ul><li><strong>使用原语进行实现</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150428635.png" alt="mark"></p><ul><li><strong>大致流程</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150533562.png" alt="mark"></p><blockquote><p>这里说明一下调度和切换的区别：<br><code>调度</code>是指决定资源分配给哪个进程的行为，是一种决策行为<br><code>切换</code>是指实际分配的行为，是执行行为<br>一般来说现有资源调度，后有进程切换</p></blockquote><h2 id="2-进程控制相关原语"><a href="#2-进程控制相关原语" class="headerlink" title="2. 进程控制相关原语"></a>2. 进程控制相关原语</h2><p>进程控制会导致进程状态的转换。<strong>无论哪个原语,要做的无非三类事情:</strong> </p><ol><li><p><strong>更新PCB中的信息</strong>(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)    </p><p>a.所有的进程控制原语一定都会修改进程状态标志    </p><p>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境    </p><p>c.某进程开始运行前必然要恢复期运行环境 </p></li><li><p><strong>将PCB插入合适的队列</strong> </p></li><li><p><strong>分配/回收资源</strong></p></li></ol><p>以下针对每种原语进行说明：</p><ul><li><p><strong>进程创建</strong></p><ul><li><p>创建原语<br>1.申请空白PCB<br>​2.为新进程分配所需资源<br>3.初始化PCB<br>4.将PCB插入就绪队列​</p></li><li><p>引发事件<br>1.分时系统，用户登录<br>2.多道批处理系统，新的作业提交到内存<br>3.用户向操作系统提取请求<br>4.用户进程自动请求创建子进程​</p></li></ul></li><li><p><strong>进程终止</strong></p><ul><li><p>撤销原语<br>1.从PCB集合找到终止进程的PCB<br>2.若进程正在运行，立即剥夺CPU，将CPU分配给其它进程<br>3.终止其所有子进程<br>4.回收资源给父进程或者操作系统<br>5.删除PCB​​</p></li><li><p>引发事件<br>1.正常结束<br>2.异常结束<br>3.外界干预​</p></li></ul></li><li><p><strong>进程阻塞</strong></p><ul><li><p>阻塞原语<br>1.找到进程对于的PCB<br>2.保护进程运行现场，设置PCB状态为阻塞态，暂停进程运行<br>3.将PCB插入对应的事件等待队列</p></li><li><p>引发事件<br>1.需要等待系统分配某种资源<br>2.需要等待相互合作的其它进程完成工作</p></li></ul></li><li><p><strong>进程唤醒</strong></p><ul><li><p>唤醒原语<br>1.在事件等待队列中找到PCB<br>​2.将其从等待队列移除，设置进程为就绪态<br>3.将PCB插入就绪队列，等待被调度</p></li><li><p>引发原因<br>因何事阻塞，因何事唤醒<br>阻塞和唤醒成对出现</p></li></ul></li><li><p><strong>进程切换</strong></p><ul><li><p>切换原语<br>1.保存运行环境到PCB<br>2.PCB移入相应队列<br>3.选择另一个PCB执行，更新其PCB<br>4.根据PCB恢复新进程的运行环境​</p></li><li><p>引发原因<br>1.当前进程时间片用完<br>2.更高优先级进程达到<br>3.当前进程主动阻塞<br>4.当前进程终止​</p></li></ul></li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-04-进程控制&quot;&gt;&lt;a href=&quot;#操作系统-04-进程控制&quot; class=&quot;headerlink&quot; title=&quot;操作系统-04-进程控制&quot;&gt;&lt;/a&gt;操作系统-04-进程控制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是进程控制？&lt;br&gt;进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简而言之就是实现进程状态切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150250419.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-03-进程状态</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-03-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-03-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</id>
    <published>2020-10-04T05:00:53.000Z</published>
    <updated>2020-10-04T07:01:02.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-03-进程状态"><a href="#操作系统-03-进程状态" class="headerlink" title="操作系统-03-进程状态"></a>操作系统-03-进程状态</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇博客介绍了进程的定义和特性等等</li><li>本篇单独开篇就是讲进程的状态，因为是个重要的知识点得单独说</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145220849.png" alt="mark"></p><a id="more"></a><h2 id="1-进程的状态"><a href="#1-进程的状态" class="headerlink" title="1. 进程的状态"></a>1. 进程的状态</h2><ul><li><strong>运行状态(Running)</strong><br>占有CPU，并在CPU上运行<br>单核处理器一个时刻只有一个进程处于运行态，双核两个</li><li><strong>就绪状态(Ready)</strong><br>进程已经具备一切运行条件，除了没有空闲CPU，导致暂时不能运行<br>万事俱备，只差CPU</li><li><strong>阻塞状态(Waiting/Blocked)</strong><br>等待某一事件而暂时不能运行，比如等待操作系统分配打印机、等待磁盘读写<br>为了提高CPU利用效率，进程需要先准备好其它所需资源，才能得到CPU的服务</li><li>创建状态(New)<br>操作系统为该进程分配所需内存等系统资源，为其创建、初始化PCB(分配PID等等)</li><li>终止状态(Terminated)<br>进程运行结束，或者出现Bug导致无法继续执行，操作系统需要撤销进程<br>完成资源回收，撤销PCB​</li></ul><p><strong>注意 ：</strong> </p><ul><li><strong>基本状态：运行、就绪、阻塞/等待态</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145824038.png" alt="mark"></p><ul><li>创建态和结束态</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145834883.png" alt="mark"></p><p><strong>创建态</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145927447.png" alt="mark"></p><p><strong>结束态</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145954012.png" alt="mark"></p><h2 id="2-进程状态之间的转换"><a href="#2-进程状态之间的转换" class="headerlink" title="2. 进程状态之间的转换"></a>2. 进程状态之间的转换</h2><ul><li>进程一共有如下5种状态，那么他们之间如何实现切换呢？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145456852.png" alt="mark"></p><ul><li>来一张形象生动的图片感受一下5种状态之间的切换</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150053112.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-03-进程状态&quot;&gt;&lt;a href=&quot;#操作系统-03-进程状态&quot; class=&quot;headerlink&quot; title=&quot;操作系统-03-进程状态&quot;&gt;&lt;/a&gt;操作系统-03-进程状态&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇博客介绍了进程的定义和特性等等&lt;/li&gt;
&lt;li&gt;本篇单独开篇就是讲进程的状态，因为是个重要的知识点得单独说&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145220849.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-02-进程管理</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-04T04:00:53.000Z</published>
    <updated>2020-10-04T06:49:57.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-02-进程管理"><a href="#操作系统-02-进程管理" class="headerlink" title="操作系统-02-进程管理"></a>操作系统-02-进程管理</h1><h2 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1. 进程的定义"></a>1. 进程的定义</h2><ol><li><strong>程序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143830157.png" alt="mark"></p><ol start="2"><li><strong>进程</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143852853.png" alt="mark"></p><ul><li>进程和程序的区别和联系：</li></ul><blockquote><p>区别：<br>(1) 进程是动态的;程序是静态的。<br>(2) 进程有独立性，能并发执行;程序不能并发执行。<br>(3) 二者无一一对应关系。<br>(4) 进程异步运行，会相互制约;程序不具备此特征。<br>但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。<br>(5) 组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。<br>(6) 程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。<br>(7) 进程由程序段、数据段和PCB构成,会占用系统如CPU、内存等运行资源。<br>(8) 一个程序可以启动多个进程来共同完成。<br>联系：进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。</p></blockquote><a id="more"></a><p><strong>进程定义</strong></p><ul><li>程序段、数据段、PCB三部分组成了进程实体(进程映像) 。<ul><li>一般情况下,我们把进程实体就简称为进程,</li><li>例如,所谓创建进程,实质上是创建进程实体中的PCB;</li><li>而撤销进程,实质上是撤销进程实体中的PCB.</li><li><strong>注意: PCB是进程存在的唯一标志!</strong>从不同的角度,进程可以有不同的定义,比较传统典型的定义有:<ul><li>1,进程是程序的一次执行过程。 </li><li>2,进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 </li><li>3,进程是具有独立功能的程序在数据集合上运行的过程,它是<strong>系统进行资源分配和调度的一个独立单位（强调“动态性”）</strong> </li><li>引入进程实体的概念后,可把进程定义为:进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位。</li></ul></li></ul></li></ul><h2 id="2-进程的组成"><a href="#2-进程的组成" class="headerlink" title="2. 进程的组成"></a>2. 进程的组成</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144324116.png" alt="mark"></p><ul><li><p><strong>程序段</strong><br>存放程序代码本身</p></li><li><p><strong>数据段</strong><br>存放程序运行过程中处理的各种数据</p></li><li><p><strong>PCB</strong></p><p>进程管理所需的数据都放在这里<br>​PCB是进程存在的唯一标志</p><ul><li><p>进程描述信息</p><ul><li><p>进程标识符 PID</p></li><li><p>用户标识符 UID</p></li><li><p>父进程 PID</p></li><li><p>子进程 PID</p></li></ul></li><li><p>进程控制和管理信息</p><ul><li><p>进程优先级</p></li><li><p>进程当前状态</p></li><li><p>进程阻塞原因</p></li><li><p>进程同步和通信机制</p></li><li><p>其它调度所需的信息</p></li></ul></li><li><p>资源分配清单</p><ul><li><p>程序段指针</p></li><li><p>数据段指针</p></li><li><p>外设资源</p></li></ul></li><li><p>处理器现场信息</p><ul><li>各种寄存器的值<br>进程切换时需要把当前进程的运行状态保存在PCB里面<br>比如程序计数器的值记录了当前程序执行到那一句了，通用寄存器，程序状态字寄存器，栈指针等等</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144521644.png" alt="mark"></p><p><strong>注意</strong></p><ul><li>而其中最重要的就是<code>进程控制块PCB</code>（Process Control Block）</li><li>在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。</li><li>所以说，PCB是进程存在的唯一标志。</li></ul><h2 id="3-进程的组织方式"><a href="#3-进程的组织方式" class="headerlink" title="3. 进程的组织方式"></a>3. 进程的组织方式</h2><h3 id="3-1-链接方式"><a href="#3-1-链接方式" class="headerlink" title="3.1 链接方式"></a>3.1 链接方式</h3><ul><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向个个队列的指针</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144740393.png" alt="mark"></p><h3 id="3-2-索引方式"><a href="#3-2-索引方式" class="headerlink" title="3.2 索引方式"></a>3.2 索引方式</h3><ul><li>根据进程状态不同，建立几张索引表</li><li>操作系统持有指向各索引表的指针</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144755298.png" alt="mark"></p><h2 id="4-进程的特征"><a href="#4-进程的特征" class="headerlink" title="4. 进程的特征"></a>4. 进程的特征</h2><ul><li><strong>动态性</strong><br><strong>最基本特征</strong>。进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li>并发性<br>内存中有多个进程实体，各进程可以并行执行</li><li>独立性<br>进程是能独立运行、获得资源、接受调度的基本单位</li><li>异步性<br>各进程按各自独立的、不可预测的速度向前推进，异步性会导致并发程序执行结果的不确定性，操作系统要提供“进程同步机制”来解决异步问题</li><li>结构性<br>每一个进程都会配置PCB</li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-02-进程管理&quot;&gt;&lt;a href=&quot;#操作系统-02-进程管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-02-进程管理&quot;&gt;&lt;/a&gt;操作系统-02-进程管理&lt;/h1&gt;&lt;h2 id=&quot;1-进程的定义&quot;&gt;&lt;a href=&quot;#1-进程的定义&quot; class=&quot;headerlink&quot; title=&quot;1. 进程的定义&quot;&gt;&lt;/a&gt;1. 进程的定义&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;程序&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143830157.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143852853.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程和程序的区别和联系：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;区别：&lt;br&gt;(1) 进程是动态的;程序是静态的。&lt;br&gt;(2) 进程有独立性，能并发执行;程序不能并发执行。&lt;br&gt;(3) 二者无一一对应关系。&lt;br&gt;(4) 进程异步运行，会相互制约;程序不具备此特征。&lt;br&gt;但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。&lt;br&gt;(5) 组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。&lt;br&gt;(6) 程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。&lt;br&gt;(7) 进程由程序段、数据段和PCB构成,会占用系统如CPU、内存等运行资源。&lt;br&gt;(8) 一个程序可以启动多个进程来共同完成。&lt;br&gt;联系：进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-977-有序数组的平方</title>
    <link href="http://zhuuu.work/2020/10/03/Leetcode/Leetcode-976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/"/>
    <id>http://zhuuu.work/2020/10/03/Leetcode/Leetcode-976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-03T07:52:53.000Z</published>
    <updated>2020-12-01T01:45:54.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-976-三角形的最大周长"><a href="#Leetcode-976-三角形的最大周长" class="headerlink" title="Leetcode-976-三角形的最大周长"></a>Leetcode-976-<a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/" target="_blank" rel="noopener">三角形的最大周长</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p><p>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[2,1,2]</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[1,2,1]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[3,2,3,4]</span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：[3,6,2,3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-数学"><a href="#思路-：-数学" class="headerlink" title="思路  ： 数学"></a>思路  ： 数学</h2><p><strong>1. 为什么只需要判断 a + b &gt; c ?</strong></p><p>正常情况下，对于三条边长，判断能否组成三角形需要判断任何两条边长相加都大于其余的一条边长，即：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b &gt; <span class="built_in">c</span> &amp;&amp; a + <span class="built_in">c</span> &gt; b &amp;&amp; b + <span class="built_in">c</span> &gt; a</span><br></pre></td></tr></table></figure><p>而如果已知<code>a&lt;=b&lt;=c</code>，那么必然有：</p><ol><li><code>a + c &gt; b</code>，因为<code>c &gt;= b</code>，那c加上一个正数一定就比b大了。而题目里说所数都&gt;=1，所以c加上a一定比b大。</li><li><code>b + c &gt; a</code>，因为b和c至少跟a一样大<code>(b&gt;=a, c&gt;=a)</code>，加起来的结果至少有<code>2a</code>，即 <code>b+c &gt;= 2a &gt; a</code>所以最终只需要判断<code>a + b &gt; c</code>即可。</li></ol><p><strong>2. 为什么只需要判断数组中相邻的三个数？</strong></p><p><strong>在固定最后一个数 A[i] 时，前两个数需不需要再往前找呢？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 A[i-2] + A[i-1] &lt;&#x3D; A[i] ，这三个数一定不能构成三角形，而A[i-3]以及更往前的数，都小于等于A[i-2]，所以再往前取任何两个数只会让相加的值更小，就更不能满足 A[j] + A[k] &gt; A[i]了 (j&lt;i-2, k&lt;i-1, j&lt;k)。所以如果相邻的数构不成三角形，就不需要再固定第三个数并往前找两个数了。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 A[i-2] + A[i-1] &gt; A[i]，这三个数可以构成三角形，再往前找只会让周长变短，所以也不用再往前了。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 对数组进行排序</span></span><br><span class="line">        Arrays.sort(A);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. a + b &gt; c 假定 a &lt;= b &lt;= c</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = A.length - <span class="number">1</span>;i &gt;= <span class="number">2</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i - <span class="number">2</span>] + A[i - <span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> A[i - <span class="number">2</span>] + A[i - <span class="number">1</span>] + A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p><strong>时间复杂度</strong> ： <code>O(nlogn)</code></p></li><li><p><strong>空间复杂度</strong>：  <code>O (logn)</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-976-三角形的最大周长&quot;&gt;&lt;a href=&quot;#Leetcode-976-三角形的最大周长&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-976-三角形的最大周长&quot;&gt;&lt;/a&gt;Leetcode-976-&lt;a href=&quot;https://leetcode-cn.com/problems/largest-perimeter-triangle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;三角形的最大周长&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定由一些正数（代表长度）组成的数组 &lt;code&gt;A&lt;/code&gt;，返回由其中三个长度组成的、&lt;strong&gt;面积不为零&lt;/strong&gt;的三角形的最大周长。&lt;/p&gt;
&lt;p&gt;如果不能形成任何面积不为零的三角形，返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[2,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[3,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[3,6,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-977-有序数组的平方</title>
    <link href="http://zhuuu.work/2020/10/03/Leetcode/Leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <id>http://zhuuu.work/2020/10/03/Leetcode/Leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</id>
    <published>2020-10-03T07:52:53.000Z</published>
    <updated>2020-10-03T12:16:53.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges"><a href="#Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges" class="headerlink" title="Leecode-977. 有序数组的平方https://leetcode-cn.com/problems/rotting-oranges/)"></a>Leecode-<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a>)</h1><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><p><strong>题目描述</strong></p><ul><li>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">-10000 &lt;&#x3D; A[i] &lt;&#x3D; 10000</span><br><span class="line">A 已按非递减顺序排序。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>思路： 双指针</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || (length = A.length) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 一遍数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(A[i] * A[i] &gt; A[j] * A[j])&#123;</span><br><span class="line">                temp = A[i] * A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = A[j] * A[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result[k--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges&quot;&gt;&lt;a href=&quot;#Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges&quot; class=&quot;headerlink&quot; title=&quot;Leecode-977. 有序数组的平方https://leetcode-cn.com/problems/rotting-oranges/)&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://leetcode-cn.com/problems/squares-of-a-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;977. 有序数组的平方&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotting-oranges/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/rotting-oranges/&lt;/a&gt;)&lt;/h1&gt;&lt;h2 id=&quot;思路：双指针&quot;&gt;&lt;a href=&quot;#思路：双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：双指针&quot;&gt;&lt;/a&gt;思路：双指针&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一个按非递减顺序排序的整数数组 &lt;code&gt;A&lt;/code&gt;，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[-4,-1,0,3,10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[0,1,9,16,100]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[-7,-3,2,3,11]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,9,9,49,121]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;提示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10000 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A 已按非递减顺序排序。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-01-概述</title>
    <link href="http://zhuuu.work/2020/10/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/10/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-10-03T04:00:53.000Z</published>
    <updated>2020-10-03T04:01:13.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-01-概述"><a href="#操作系统-01-概述" class="headerlink" title="操作系统-01-概述"></a>操作系统-01-概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>是系统最基本最核心的软件，属于系统软件</li><li>控制和管理整个计算机的硬件和软件资源</li><li>合理的组织、调度计算机的工作与资源的分配</li><li>为用户和其它软件提供方便的接口和环境</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/103437449.png" alt="mark"></p><a id="more"></a><h2 id="1-基本特征"><a href="#1-基本特征" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h2><ol><li><strong>并发</strong></li></ol><ul><li><code>并发</code>：两个或多个事件在同一<code>时间间隔内</code>发生，这些事件在宏观上是同时发生的，在微观上是交替发生的， 操作系统的并发性指系统中同时存在着多个运行的程序</li><li><code>并行</code>：两个或多个事件在同一<code>时刻</code>发生</li><li>一个单核(CPU)同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</li></ul><ol start="2"><li><strong>共享</strong></li></ol><ul><li>互斥共享<br>同一个时间段只允许一个进程访问资源(摄像头/麦克风)</li><li>同时共享<br>允许一个时间段多个进程“同时”(宏观上)访问某些资源（微观上是分时共享），比如硬盘读写</li></ul><ol start="3"><li><strong>虚拟</strong></li></ol><ul><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的,而逻辑上对应物(后者)是用户感受到的。<ul><li><strong>空分复用</strong>(虚拟储存技术)<ul><li>物理4GB内存，用户看来远大于4GB</li></ul></li><li><strong>时分复用</strong>(虚拟处理器技术)<ul><li>一个CPU看上去是几个CPU,多个程序并发运行</li></ul></li></ul></li></ul><ol start="4"><li><strong>异步</strong></li></ol><ul><li>异步是指,在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,是走走停停（等待资源进程阻塞）,以不可预知的速度向前推异步性。</li></ul><h2 id="2-发展和分类"><a href="#2-发展和分类" class="headerlink" title="2. 发展和分类"></a>2. 发展和分类</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105010362.png" alt="mark"></p><ol><li><p><strong>手工操作阶段</strong>(IO靠纸带打孔，资源利用率低)</p></li><li><p><strong>批处理阶段</strong></p><ul><li><p>单道批处理系统<br>引入了脱机输入/输出技术（磁带），通过监督程序（操作系统雏形）控制作业输入输出</p><p>外围机负责把输入纸带录入磁带</p><p>缓解了人机速度矛盾，提高了资源利用率，但是CPU是串行的，大量CPU时间浪费在I/O等待上</p></li><li><p>多道批处理系统<br>磁带往内存输入多道程序，并发执行，输入、计算、输出互不干扰</p><p>操作系统诞生，引入了中断技术，资源利用率大幅上升，但是缺少人机交互功能，用户响应时间长（用户提交作业之后只能等待作业完成）</p></li></ul></li><li><p><strong>分时操作系统</strong></p><ul><li>分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务,各个用户可通过终端与计算机进行交互。</li><li>主要优点:用户请求可以被即时响应,解决了人机交互问题。允许多个用户同时使用一台计算机,并且用户对计算机的操作相互独立,感受不到别人的存在。</li><li>主要缺点:不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的,循环地为每个用户/作业服务一个时间片,不区分任务的紧急性。</li></ul></li></ol><ol start="4"><li><strong>网络操作系统</strong><ul><li>网络操作系统:是伴随着计算机网络的发展而诞生的,能把网络中各个计算机有机地结合起来,实现数据传送等功能,实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信。(如: Windows NT就是一种典型的网络操作系统,网站服务器就可以使用)</li></ul></li></ol><ol start="5"><li><strong>分布式操作系统</strong><ul><li>分布式操作系统:主要特点是分布性和并行性。系统中的各台计算机地位相同,任何工作都可以分布在这些计算机上,由它们并行、协同完成这个任务。</li></ul></li></ol><ol start="6"><li><p><strong>PC操作系统</strong></p><ul><li><p>Windows10</p></li><li><p>MacOS</p></li><li><p>Ubuntu</p></li></ul></li></ol><p><strong>小结：发展历程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105106471.png" alt="mark"></p><h2 id="3-运行机制和体系结构"><a href="#3-运行机制和体系结构" class="headerlink" title="3. 运行机制和体系结构"></a>3. 运行机制和体系结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105349798.png" alt="mark"></p><h3 id="3-1-运行机制"><a href="#3-1-运行机制" class="headerlink" title="3.1 运行机制"></a>3.1 运行机制</h3><ul><li><p><strong>指令</strong></p><ul><li><p><strong>特权指令</strong></p><ul><li>内存清零指令</li></ul></li><li><p><strong>非特权指令</strong></p><ul><li>加减乘除运算指令</li></ul></li></ul></li></ul><ul><li><p><strong>处理器状态</strong></p><ul><li><p><strong>核心态(目管态)</strong></p><ul><li>PSW=0，<strong>运行执行特权指令</strong><br>PSW 程序状态字寄存器，通过标志位标识处理器的运行状态</li></ul></li><li><p><strong>用户态(目态)</strong></p><ul><li>PSW=1，<strong>只能使用非特权指令</strong></li></ul></li></ul></li></ul><ul><li><p><strong>程序</strong></p><ul><li><p><strong>应用程序</strong><br>为了安全，运行在用户态</p></li><li><p><strong>内核程序</strong><br>系统管理者，运行在核心态</p></li></ul></li></ul><h3 id="3-2-体系结构"><a href="#3-2-体系结构" class="headerlink" title="3.2 体系结构"></a>3.2 体系结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/112129093.png" alt="mark"></p><ul><li><strong>大内核</strong><br>将操作系统的主要功能模块都作为系统内核，运行在核心态<br>高性能，但是内核代码庞大难以维护</li><li><strong>微内核</strong><br>只把基本概念保留在内核<br>功能少，功能清晰方便维护，但是需要频繁的在核心态和用户态之间切换，性能低</li></ul><h3 id="3-3-OS内核结构"><a href="#3-3-OS内核结构" class="headerlink" title="3.3 OS内核结构"></a>3.3 OS内核结构</h3><ul><li><p><strong>时钟管理</strong></p><ul><li>用于计时</li><li>通过时钟中断的管理,可以实现进程的切换</li></ul></li><li><p><strong>中断处理</strong></p></li><li><p><strong>原语</strong></p><ul><li>运行时间短，调用频繁，原子性运行只能一气呵成，不可中断</li></ul></li><li><p><strong>系统资源管理</strong></p><p>有的操作系统不把这个作为“内核功能”（微内核）</p><ul><li><p>进程管理</p></li><li><p>储存器管理</p></li><li><p>设备管理</p></li></ul></li></ul><h2 id="4-中断和异常"><a href="#4-中断和异常" class="headerlink" title="4. 中断和异常"></a>4. 中断和异常</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/112855093.png" alt="mark"></p><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><ul><li>发生了中断,就意味着需要操作系统介入,开展管理工作。 </li><li>由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要<strong>使用特权指令</strong>,<strong>因此CPU要从用户态转为核心态</strong>。 </li><li>中断可以使CPU从用户态切换为核心态,使操作系统获得计算机的控制权。有了中断才能实现多道程序并发执行。 </li><li><strong>中断是CPU从用户态-&gt;核心态切换的唯一途径。</strong> </li><li><strong>核心态-&gt;用户态切换只需要执行一个特权指令</strong>，<code>将PSW设置为0</code></li></ul><h3 id="4-2-中断分类"><a href="#4-2-中断分类" class="headerlink" title="4.2 中断分类"></a>4.2 中断分类</h3><ul><li><p><strong>内中断(异常/例外/陷入)</strong></p><p><strong>信号来源CPU内部，与当前执行的指令有关</strong></p><ul><li><p>自愿中断(指令中断)<br>系统调用时使用的访管指令(陷入指令/trap指令)</p></li><li><p>强迫中断</p><ul><li><p>硬件故障<br>缺页错误</p></li><li><p>软件中断<br>除0错误</p></li></ul></li></ul></li><li><p><strong>外中断(狭义中断)</strong></p><p><strong>信号来源CPU外部，与当前执行的指令无关</strong></p><ul><li><p>外设请求<br>外设(比如打印机)I/O操作完成发出中断信号<br>键盘输入一个字符</p></li><li><p>人工干预<br>用户强制终止一个进程</p></li></ul></li></ul><h3 id="4-3-中断处理的过程"><a href="#4-3-中断处理的过程" class="headerlink" title="4.3 中断处理的过程"></a>4.3 中断处理的过程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/114138459.png" alt="mark"></p><p><strong>大致处理过程</strong></p><ul><li>Step 1:执行完每个指令之后, CPU都要检查当前是否有外部中断信号 </li><li>Step 2:如果检测到外部中断信号,则需要保护被中断进程的CPU环境(如程序状态字Psw、程序计数器PC、各种通用寄存器) </li><li>Step 3:根据中断信号类型转入相应的中断处理程序(进入核心态) </li><li>Step 4:恢复原进程的CPU环境并退出中断,返回原进程继续往下执行</li></ul><h2 id="5-系统调用"><a href="#5-系统调用" class="headerlink" title="5. 系统调用"></a>5. 系统调用</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/114523218.png" alt="mark"></p><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><ul><li>“系统调用”是操作系统提供给应用程序(程序员/编程人员)使用的接口,可以理解为一种可供应用程序调用的特殊函数,应用程序可以<strong>发出系统调用请求来获得操作系统的服务</strong>。 </li><li>应用程序通过系统调用请求操作系统的服务。 系统中的各种共享资源都由操作系统统一掌管,因此在用户程序中,凡是与资源有关的操作(如存储分配、1/0操作、文件管理等) ,都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成。</li><li><strong>这样可以保证系统的稳定性和安全性,防止用户进行非法操作。</strong> </li><li><strong>系统调用相关的处理需要在核心态下完成。</strong></li></ul><h3 id="5-2-系统调用和库函数的区别"><a href="#5-2-系统调用和库函数的区别" class="headerlink" title="5.2 系统调用和库函数的区别"></a>5.2 系统调用和库函数的区别</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/115154503.png" alt="mark"></p><h3 id="5-3-系统调用过程"><a href="#5-3-系统调用过程" class="headerlink" title="5.3 系统调用过程"></a>5.3 系统调用过程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/115353845.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-01-概述&quot;&gt;&lt;a href=&quot;#操作系统-01-概述&quot; class=&quot;headerlink&quot; title=&quot;操作系统-01-概述&quot;&gt;&lt;/a&gt;操作系统-01-概述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;是系统最基本最核心的软件，属于系统软件&lt;/li&gt;
&lt;li&gt;控制和管理整个计算机的硬件和软件资源&lt;/li&gt;
&lt;li&gt;合理的组织、调度计算机的工作与资源的分配&lt;/li&gt;
&lt;li&gt;为用户和其它软件提供方便的接口和环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/103437449.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
