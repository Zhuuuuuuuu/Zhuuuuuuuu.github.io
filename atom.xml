<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱酱酱的学习博客</title>
  <icon>https://www.gravatar.com/avatar/336d255f627c733c7a50883547bcec06</icon>
  <subtitle>From Zero to Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuuu.work/"/>
  <updated>2020-07-26T13:00:06.000Z</updated>
  <id>http://zhuuu.work/</id>
  
  <author>
    <name>Zhuuu</name>
    <email>353446503@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-739-每日温度</title>
    <link href="http://zhuuu.work/20020/06/12/Leetcode/Leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>http://zhuuu.work/20020/06/12/Leetcode/Leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</id>
    <published>+020020-06-12T07:24:53.000Z</published>
    <updated>2020-07-26T13:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-739-每日温度"><a href="#Leecode-739-每日温度" class="headerlink" title="Leecode-739-每日温度"></a>Leecode-739-<a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h1><p><strong>题目描述：</strong></p><p><strong>本质</strong> ： 找到数组中第一个大于该元素数字的索引 ，并返回索引差值</p><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温 列表长度的范围是<code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在<code>[30, 100]</code>范围内的整数。</p><a id="more"></a><p><strong>解法思路：单调递减栈</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205146576.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205229904.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205245835.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205259273.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205320457.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205337913.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205344516.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 单调递减栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">                ret[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈为空的话</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)，</strong>其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</li><li><strong>空间复杂度：O(n)，</strong>其中 n是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-739-每日温度&quot;&gt;&lt;a href=&quot;#Leecode-739-每日温度&quot; class=&quot;headerlink&quot; title=&quot;Leecode-739-每日温度&quot;&gt;&lt;/a&gt;Leecode-739-&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每日温度&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本质&lt;/strong&gt; ： 找到数组中第一个大于该元素数字的索引 ，并返回索引差值&lt;/p&gt;
&lt;p&gt;根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。&lt;/p&gt;
&lt;p&gt;例如，给定一个列表&lt;code&gt;temperatures = [73, 74, 75, 71, 69, 72, 76, 73]&lt;/code&gt;，你的输出应该是 &lt;code&gt;[1, 1, 4, 2, 1, 1, 0, 0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;提示：气温 列表长度的范围是&lt;code&gt;[1, 30000]&lt;/code&gt;。每个气温的值的均为华氏度，都是在&lt;code&gt;[30, 100]&lt;/code&gt;范围内的整数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://zhuuu.work/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-异常</title>
    <link href="http://zhuuu.work/2020/09/07/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/"/>
    <id>http://zhuuu.work/2020/09/07/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/</id>
    <published>2020-09-07T09:34:38.000Z</published>
    <updated>2020-09-07T12:11:38.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-异常"><a href="#Java-基础-异常" class="headerlink" title="Java-基础-异常"></a>Java-基础-异常</h1><h2 id="1-什么是异常？"><a href="#1-什么是异常？" class="headerlink" title="1. 什么是异常？"></a>1. 什么是异常？</h2><ul><li><p>事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用<strong>空的引用</strong>、<strong>数组下标越界</strong>、<strong>内存溢出错误</strong>等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。</p></li><li><p><strong>假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果</strong>。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，<strong>通过异常机制来处理程序运行期间出现的错误</strong>。通过异常机制，我们可以更好地提升程序的健壮性。</p></li><li><p>在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。java中的处理就是中断处理。</p></li></ul><p>　<strong>在Java中，异常类的结构层次图如下图所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/145710336.png" alt="mark"></p><a id="more"></a><p><strong>异常的分类：</strong></p><ul><li><p>在Java中异常被当做对象来处理，根类是<code>java.lang.Throwable</code>类，在Java中定义了很多异常类（如<code>OutOfMemoryError、NullPointerException</code>、<code>IndexOutOfBoundsException</code>等），这些异常类分为两大类：<code>Error</code>和<code>Exception</code>。</p></li><li><p><code>Exception</code>类的异常包括<code>checked exception</code>和<code>unchecked exception</code>（<code>unchecked exception</code>也称运行时异常<code>RuntimeException</code>，当然这里的运行时异常并不是前面我所说的运行期间的异常，只是Java中用运行时异常这个术语来表示，Exception类的异常都是在运行期间发生的）。</p><ul><li><code>unchecked exception</code>（非检查异常），也称运行时异常<code>（RuntimeException）</code>，比如常见的<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</li><li><code>checked exception</code>（检查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），<code>java</code>编译器强制程序员必须进行捕获处理，比如常见的<code>IOExeption</code>和<code>SQLException</code>。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过</li></ul></li><li><p>在Java中，所有异常类的父类是<code>Throwable</code>类，</p><ul><li>Error类是error类型异常的父类，</li><li>Exception类是exception类型异常的父类，<ul><li>RuntimeException类是所有运行时异常的父类</li><li>RuntimeException以外的并且继承Exception的类是非运行时异常。</li><li>典型的<code>RuntimeException</code>包括<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> <code>InterrupterException</code>等。</li><li>典型的非<code>RuntimeException</code>包括<code>IOException</code>、<code>SQLException</code>等。</li></ul></li></ul></li></ul><h2 id="2-Java中如何处理异常？"><a href="#2-Java中如何处理异常？" class="headerlink" title="2. Java中如何处理异常？"></a>2. Java中如何处理异常？</h2><ul><li>在Java中如果需要处理异常，必须先对异常进行捕获，然后再对异常情况进行处理。如何对可能发生异常的代码进行异常捕获和处理呢？使用try和catch关键字即可，如下面一段代码所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">  <span class="keyword">if</span>(!file.exists())</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(被try块包围的代码说明这段代码可能会发生异常，一旦发生异常，异常便会被catch捕获到，然后需要在catch块中进行异常处理。)</p><ul><li>在Java中还提供了另一种异常处理方式即抛出异常，顾名思义，也就是说一旦发生异常，我把这个异常抛出去，让调用者去进行处理，自己不进行具体的处理，此时需要用到throw和throws关键字。　</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            createFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><ul><li>这段代码和上面一段代码的区别是，在实际的createFile方法中并没有捕获异常，而是用throws关键字声明抛出异常，</li><li>即告知这个方法的调用者此方法可能会抛出<code>IOException</code>。那么在main方法中调用<code>createFile</code>方法的时候，采用try…catch块进行了异常捕获处理。</li></ul><ul><li>当然还可以采用throw关键字手动来抛出异常对象。下面看一个例子：然后在catch块中进行捕获。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            System.out.println(getDataByIndex(-<span class="number">1</span>,data));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDataByIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组下标越界"</span>);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>也就说在Java中进行异常处理的话，对于可能会发生异常的代码，可以选择三种方法来进行异常处理：<ul><li>对代码块用<code>try..catch</code>进行异常捕获处理；</li><li>在 该代码的方法体外用<strong>throws进行抛出声明</strong>，告知此方法的调用者这段代码可能会出现这些异常，你需要谨慎处理。<ul><li>如果声明抛出的异常是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。</li><li>如果声明抛出的异常是运行时异常，此方法的调用者可以选择地进行异常捕获处理。</li></ul></li><li>在代码块用throw手动抛出一个异常对象，此时也有两种情况，<strong>跟throw中的类似</strong>：<ul><li>如果抛出的异常对象是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。</li><li>如果抛出的异常对象是运行时异常，此方法的调用者可以选择地进行异常捕获处理。</li></ul></li></ul></li></ul><ul><li>如果最终将异常抛给<code>main</code>方法，则相当于交给<code>jvm</code>自动处理，此时<code>jvm</code>会简单地打印异常信息）<strong>同时是中断处理</strong></li></ul><p><strong>未完待续：</strong></p><p><strong>参考博客 ：</strong> <a href="https://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3769804.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-异常&quot;&gt;&lt;a href=&quot;#Java-基础-异常&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-异常&quot;&gt;&lt;/a&gt;Java-基础-异常&lt;/h1&gt;&lt;h2 id=&quot;1-什么是异常？&quot;&gt;&lt;a href=&quot;#1-什么是异常？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是异常？&quot;&gt;&lt;/a&gt;1. 什么是异常？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用&lt;strong&gt;空的引用&lt;/strong&gt;、&lt;strong&gt;数组下标越界&lt;/strong&gt;、&lt;strong&gt;内存溢出错误&lt;/strong&gt;等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果&lt;/strong&gt;。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，&lt;strong&gt;通过异常机制来处理程序运行期间出现的错误&lt;/strong&gt;。通过异常机制，我们可以更好地提升程序的健壮性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。java中的处理就是中断处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　&lt;strong&gt;在Java中，异常类的结构层次图如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/145710336.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="异常总结" scheme="http://zhuuu.work/tags/%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://zhuuu.work/2020/09/05/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://zhuuu.work/2020/09/05/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-09-05T00:02:27.000Z</published>
    <updated>2020-09-10T03:40:59.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么要使用分布式锁呢？</p><p>在<code>Nginx</code>实现负载均衡服务器集群时会产生很多问题，在提高并发的同时，服务器也会产生非常多的问题例如，这些问题应该一一的考虑到。</p><ul><li><strong>分布式Session一致性</strong></li><li><strong>分布式全局ID生成方案</strong></li><li>分布式事务解决方案</li><li>分布式任务调度平台</li><li>分布式配置中心</li><li><strong>分布式锁多种实现方案</strong></li><li>分布式日志收集系统</li><li>各种网站跨域请求解决方案</li><li>高并发下服务降级与限流实战</li><li>……</li></ul><p>本次就先以分布式锁来探讨一下分布式场景下的使用与注意事项，和为什么要使用分布式锁。</p><a id="more"></a><ul><li><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。<strong>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）</strong></p></li><li><p><strong>最多只能同时满足两项</strong>。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都<strong>需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</strong></p></li><li><p>在很多场景中，我们为了<strong>保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等</strong>。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行</p></li><li><p>在单机环境中，<code>Java</code>中其实提供了很多并发处理相关的<code>API</code>，但是这些API在分布式场景中就无能为力了。也就是说单纯的<code>Java Api</code>并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案。</p></li></ul><h2 id="为什么要使用分布式锁？"><a href="#为什么要使用分布式锁？" class="headerlink" title="为什么要使用分布式锁？"></a>为什么要使用分布式锁？</h2><ul><li>原因：采用了集群的部署方案</li></ul><p><strong>如何在单台机器上生成唯一的订单号</strong></p><ul><li>UUID、时间戳、redis等。。。</li></ul><p>其实有一种取巧的解决方案，可以适当的避免突然的高并发下的服务宕机（或反应慢）的尴尬场景。</p><ul><li><strong>可以使用<code>redis</code>提前生成150W订单号（假设是在下单场景下）</strong><ul><li>提前生成好150W订单号，存放在<code>redis</code>中，当客户端下单之后，直接到<code>redis</code>中取对应的订单号即可，</li><li>因为<code>redis</code>本身是单线程的，如果<code>redis</code>还只剩下50W个订单号的时候，在继续生产100W个订单号。（这种技巧视业务场景而定，一般我们在面对需求或者发生的问题时，可以从根源下手，这种情况明显就是针对在高并发场景下能一定程度的提高程序的响应速度。提高了整个程序的健壮性。）</li></ul></li></ul><p><strong>那么如果在集群环境下使用<code>UUID</code>的方式安全嘛？</strong></p><ul><li><p>答案是肯定的，<strong>肯定是不安全的</strong>，大概率是会出现重复的<code>ID</code>的。所以<strong>这个时候就提出了分布式锁。</strong></p></li><li><p>可想而知，在多线程下我们可以简单的使用<code>Lock</code>或者<code>synchronized</code>来实现安全性，但是在分布式场景下，这些就显得力不从心了。因为这个时候在微服务场景下，很有可能同一个服务分别安装在不同的服务器上，这样的话，传统的加锁方式根本不可能保证数据的最终一致性。所以分布式锁就诞生了。</p></li></ul><p>针对分布式锁的实现，目前比较常用的有以下几种方案：</p><ul><li><strong>基于数据库实现分布式锁</strong></li><li><strong>基于缓存（redis，memcached，tair）实现分布式锁</strong></li><li><strong>基于Zookeeper实现分布式锁</strong></li></ul><p>在分析这几种实现方案之前我们先来想一下，我们需要的分布式锁应该是怎么样的？（这里以方法锁为例，资源锁同理）</p><ul><li>可以保证在分布式部署的应用集群中，<strong>同一个方法在同一时间只能被一台机器上的一个线程执行</strong>。</li><li>有<strong>高可用的获取锁和释放锁功能</strong></li><li>获取锁和释放锁的性能要好</li><li>这把锁要是一把<strong>可重入锁</strong>（避免死锁）</li><li>这把锁<strong>最好是一把阻塞锁（</strong>根据业务需求考虑要不要这条）</li></ul><h2 id="1-基于数据库实现分布式锁"><a href="#1-基于数据库实现分布式锁" class="headerlink" title="1. 基于数据库实现分布式锁"></a>1. 基于数据库实现分布式锁</h2><h3 id="1-1-基于数据表"><a href="#1-1-基于数据表" class="headerlink" title="1.1 基于数据表"></a>1.1 基于数据表</h3><ul><li>要实现分布式锁，最简单的方式可能就是直接<strong>创建一张锁表</strong>，然后通过操作该表中的数据来实现了。</li><li><strong>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，</strong></li><li><strong>想要释放锁的时候就删除这条记录。</strong></li></ul><p>创建这样一张数据库表：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091537484.png" alt="mark"></p><p>当我们想要锁住某个方法时，执行以下SQL：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091612208.png" alt="mark"></p><p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091905207.png" alt="mark"></p><ul><li><p>上面这种简单的实现有以下几个问题：</p><ul><li>这把锁强<strong>依赖数据库的可用性</strong>，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把<strong>锁没有失效时间</strong>，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把<strong>锁是非重入的</strong>，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li><li>这把锁<strong>只能是非阻塞的</strong>，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li></ul></li><li><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul></li></ul><h3 id="1-2-基于数据库的排他锁"><a href="#1-2-基于数据库的排他锁" class="headerlink" title="1.2 基于数据库的排他锁"></a>1.2 基于数据库的排他锁</h3><ul><li>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</li><li>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于<code>MySql</code>的<code>InnoDB</code>引擎，可以使用以下方法来实现加锁操作：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-092752416.png" alt="mark"></p><ul><li>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁</li><li>这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。</li><li>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</li></ul><p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-092938397.png" alt="mark"></p><p>通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p><strong>问题：</strong></p><ul><li>但是还是无法直接解决数据库单点和可重入问题。</li><li>这里还可能存在另外一个问题，虽然我们对<code>method_name</code> 使用了唯一索引，并且显示使用<code>for update</code>来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</li><li>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</li></ul><p><strong>总结</strong>：</p><ul><li>这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</li></ul><h3 id="1-3-乐观锁"><a href="#1-3-乐观锁" class="headerlink" title="1.3 乐观锁"></a>1.3 乐观锁</h3><ul><li>乐观锁假设认为数据一般情况下不会造成冲突，<strong>只有在进行数据的提交更新时</strong>，才会检测数据的冲突情况，如果发现冲突了，则返回错误信息</li></ul><p>实现方式：</p><ul><li><p><strong>时间戳</strong>（timestamp）记录机制实现：<strong>给数据库表增加一个时间戳字段类型的字段</strong>，当读取数据时，将<code>timestamp</code>字段的值一同读出，数据每更新一次，<strong>timestamp也同步更新</strong></p></li><li><p>当对数据做提交更新操作时，检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，若相等，则更新，否则认为是失效数据。</p></li><li><p><strong>同样也可以使用version的方式</strong></p></li></ul><p>性能对比</p><p>（1） 悲观锁实现方式是独占数据，其它线程需要等待，不会出现修改的冲突，能够保证数据的一致性，但是依赖数据库的实现，且在线程较多时出现等待造成效率降低的问题。一般情况下，对于数据很敏感且读取频率较低的场景，可以采用悲观锁的方式</p><p>（2） 乐观锁可以多线程同时读取数据，若出现冲突，也可以依赖上层逻辑修改，能够保证高并发下的读取，适用于读取频率很高而修改频率较少的场景</p><p>（3） 由于库存回写数据属于敏感数据且读取频率适中，所以建议使用悲观锁优化</p><h2 id="2-基于Redis来实现分布式锁"><a href="#2-基于Redis来实现分布式锁" class="headerlink" title="2. 基于Redis来实现分布式锁"></a>2. 基于Redis来实现分布式锁</h2><ul><li>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。</li></ul><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li><strong>互斥性。在任意时刻，只有一个客户端能持有锁。</strong></li><li><strong>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</strong></li><li><strong>具有容错性。只要大部分的<code>redis</code>节点正常运行，客户端就可以加锁和解锁。</strong></li><li><strong>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</strong></li></ol><p>可以看到，我们加锁就一行代码：<strong>jedis.set(String key, String value, String nxxx, String expx, int time)</strong>，这个set()方法一共有五个形参：</p><p>可以看到，我们加锁就一行代码：<strong>jedis.set(String key, String value, String nxxx, String expx, int time)</strong>，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p><strong>总的来说</strong></p><ul><li>执行上面的set() 方法就会导致两种结果<ul><li>当前没有锁（key不存在），那么就进行加锁的操作，并对锁设置有效期，同时<code>value</code>表示加锁的客户端</li><li>已有锁存在，不做任何操作。</li></ul></li></ul><ul><li><strong>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性</strong></li><li><strong>其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</strong></li><li><strong>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</strong></li></ul><p><strong>解锁操作：</strong></p><ul><li>首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）</li></ul><p><strong>总结：</strong></p><ul><li><p>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，</p></li><li><p>同时，很多缓存服务都是<strong>集群部署</strong>的，可以避免单点问题。</p></li><li><p>并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如<code>redis</code>的setnx方法等。</p></li><li><p>并且，这些缓存服务也都提供了<strong>对数据的过期自动删除的支持</strong>，可以直接设置超时时间来控制锁的释放。</p></li></ul><h2 id="3-基于Zookeeper-实现分布式锁"><a href="#3-基于Zookeeper-实现分布式锁" class="headerlink" title="3. 基于Zookeeper 实现分布式锁"></a>3. 基于Zookeeper 实现分布式锁</h2><ul><li>基于<code>zookeeper</code><strong>临时有序节点</strong>可以实现的分布式锁。</li><li><strong>大致思想</strong><ul><li>每个客户端对某个方法加锁时，在<code>zookeeper</code>上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。</li><li><strong>判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。</strong></li><li><strong>当释放锁的时候，只需将这个瞬时节点删除即可。</strong></li><li>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</li></ul></li></ul><p>来看下Zookeeper能不能解决前面提到的问题。</p><ul><li><p><strong>锁无法释放？</strong>使用<code>Zookeeper</code>可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p></li><li><p><strong>非阻塞锁？</strong>  使用<code>Zookeeper</code>可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，<code>Zookeeper</code>会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p></li><li><p><strong>不可重入？</strong>使用<code>Zookeeper</code>也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p></li><li><p><strong>单点问题？</strong>使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p></li></ul><p>可以直接使用zookeeper第三方库<a href="https://curator.apache.org/" target="_blank" rel="noopener">Curator</a>客户端，这个客户端中封装了一个可重入的锁服务。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-094429707.png" alt="mark"></p><ul><li>Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。</li><li>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。</li><li>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。</li></ul><p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。</p><p>这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p><p><strong>总结</strong></p><ul><li><p>使用Zookeeper实现分布式锁的优点</p></li><li><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p></li><li><p>使用Zookeeper实现分布式锁的缺点</p></li><li><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p></li></ul><h2 id="4-三种方案的比较"><a href="#4-三种方案的比较" class="headerlink" title="4. 三种方案的比较"></a>4. 三种方案的比较</h2><p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><h4 id="从理解的难易程度角度（从低到高）"><a href="#从理解的难易程度角度（从低到高）" class="headerlink" title="从理解的难易程度角度（从低到高）"></a>从理解的难易程度角度（从低到高）</h4><p>数据库 &gt; 缓存 &gt; Zookeeper</p><h4 id="从实现的复杂性角度（从低到高）"><a href="#从实现的复杂性角度（从低到高）" class="headerlink" title="从实现的复杂性角度（从低到高）"></a>从实现的复杂性角度（从低到高）</h4><p>Zookeeper &gt;= 缓存 &gt; 数据库</p><h4 id="从性能角度（从高到低）"><a href="#从性能角度（从高到低）" class="headerlink" title="从性能角度（从高到低）"></a>从性能角度（从高到低）</h4><p>缓存 &gt; Zookeeper &gt;= 数据库</p><h4 id="从可靠性角度（从高到低）"><a href="#从可靠性角度（从高到低）" class="headerlink" title="从可靠性角度（从高到低）"></a>从可靠性角度（从高到低）</h4><p>Zookeeper &gt; 缓存 &gt; 数据库</p><p><strong>参考博客：</strong> <a href="https://www.jianshu.com/p/a44c1c47bcee" target="_blank" rel="noopener">https://www.jianshu.com/p/a44c1c47bcee</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为什么要使用分布式锁呢？&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Nginx&lt;/code&gt;实现负载均衡服务器集群时会产生很多问题，在提高并发的同时，服务器也会产生非常多的问题例如，这些问题应该一一的考虑到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式Session一致性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式全局ID生成方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分布式事务解决方案&lt;/li&gt;
&lt;li&gt;分布式任务调度平台&lt;/li&gt;
&lt;li&gt;分布式配置中心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式锁多种实现方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分布式日志收集系统&lt;/li&gt;
&lt;li&gt;各种网站跨域请求解决方案&lt;/li&gt;
&lt;li&gt;高并发下服务降级与限流实战&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次就先以分布式锁来探讨一下分布式场景下的使用与注意事项，和为什么要使用分布式锁。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式锁" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-347-前K个高频元素</title>
    <link href="http://zhuuu.work/2020/08/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2020/08/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2020-08-29T07:51:53.000Z</published>
    <updated>2020-09-09T11:06:05.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-347-Top-K-Frequent-Elements"><a href="#Leecode-347-Top-K-Frequent-Elements" class="headerlink" title="Leecode-347-Top K Frequent Elements"></a>Leecode-347-<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Top K Frequent Elements</a></h1><h2 id="思路：堆"><a href="#思路：堆" class="headerlink" title="思路：堆"></a>思路：堆</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong>高的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>这里题目描述中对时间复杂度做出了要求 ，需要在 O(n log n)的限制。</li></ul><p><strong>Solution : 粗暴排序法</strong></p><ul><li>最简单粗暴的思路就是 <strong>使用排序算法对元素按照频率由高到低进行排序</strong>，然后再取前 k 个元素。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/150737778.png" alt="mark"></p><ul><li>可以发现，使用常规的诸如冒泡，选择，甚至快速排序都不满足要求，它们的时间复杂度要求必须优于O(nlogn)</li></ul><ul><li><p><strong>时间复杂度：O(nlogn)</strong>，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，排序算法时间复杂度为 O(nlogn)；因此整体时间复杂度为 O(nlogn)。</p></li><li><p><strong>空间复杂度：O（n）</strong> ，需要Map来存储n个键值对</p></li></ul><p><strong>接下来我们介绍遇到TopK问题最常用的方法：最大堆或者最小堆</strong></p><p><strong>本题使用的是最小堆</strong></p><p><strong>Solution : 最小堆</strong></p><ul><li>题目最终需要返回的是前k个频率最大的元素。可以想到借助堆这种数据结构，对于k频率之后的元素不用再去处理，进一步优化时间复杂度</li><li>举个例子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/151221418.png" alt="mark"></p><p>具体的操作流程为：</p><ul><li><p>借助<strong>哈希表</strong>来建立数字和其出现次数之间的映射，遍历一遍数组统计元素的频率</p></li><li><p>维护一个元素数目是 k 的最小堆</p></li><li><p>每次都将新的元素和堆顶元素（堆中频率最小的元素）进行比较</p></li><li><p>如果新的元素频率比堆顶的元素大，则弹出堆顶的元素，将新的元素添加进堆中</p></li><li><p>最终，堆中的K个元素就是前 k 个高频元素。</p></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(a) - map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次将新的元素和堆顶元素（堆中频率最小的元素）进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; map.get(pq.peek()))&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出最小堆中的元素</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            res.add(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-347-Top-K-Frequent-Elements&quot;&gt;&lt;a href=&quot;#Leecode-347-Top-K-Frequent-Elements&quot; class=&quot;headerlink&quot; title=&quot;Leecode-347-Top K Frequent Elements&quot;&gt;&lt;/a&gt;Leecode-347-&lt;a href=&quot;https://leetcode-cn.com/problems/top-k-frequent-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Top K Frequent Elements&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：堆&quot;&gt;&lt;a href=&quot;#思路：堆&quot; class=&quot;headerlink&quot; title=&quot;思路：堆&quot;&gt;&lt;/a&gt;思路：堆&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;k&lt;/strong&gt;高的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1,1,1,2,2,3], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。&lt;/li&gt;
&lt;li&gt;你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。&lt;/li&gt;
&lt;li&gt;你可以按任意顺序返回答案。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="TopK算法题" scheme="http://zhuuu.work/tags/TopK%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-try-catch</title>
    <link href="http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-try-catch/"/>
    <id>http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-try-catch/</id>
    <published>2020-08-28T08:39:38.000Z</published>
    <updated>2020-08-28T07:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-try-catch"><a href="#Java-基础-try-catch" class="headerlink" title="Java-基础-try-catch"></a>Java-基础-try-catch</h1><h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p><strong>绕口令开始</strong></p><p><strong>1、不管有没有异常，<code>finally</code>中的代码都会执行</strong><br><strong>2、当<code>try、catch</code>中有<code>return</code>时，<code>finally</code>中的代码依然会继续执行</strong><br><strong>3、<code>finally</code>是在<code>return</code>后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。</strong><br><strong>4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</strong><br><strong>5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">先执行try中的语句，包括return后面的表达式，</span><br><span class="line">有异常时,先执行catch中的语句，包括return后面的表达式,</span><br><span class="line">然后执行finally中的语句,如果finally里面有return语句，会提前退出，</span><br><span class="line">最后执行try中的return，有异常时执行catch中的return。</span><br><span class="line"></span><br><span class="line">在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的。编译器把finally中的return语句标识为一个warning.</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-举例分析"><a href="#2-举例分析" class="headerlink" title="2. 举例分析"></a>2. 举例分析</h2><ol><li>案例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 try</span><br><span class="line">执行 finally</span><br><span class="line">主方法返回 ：try</span><br></pre></td></tr></table></figure><p><strong>结论：执行try 到了return的时候会去检测finally。finally块存在会先执行finally块的内容，再return。</strong></p><p><strong>案例二：假设finally里面也有return呢？执行的是哪个return？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 <span class="keyword">try</span></span><br><span class="line">执行<span class="keyword">finally</span></span><br><span class="line">主方法返回 ：<span class="keyword">finally</span></span><br></pre></td></tr></table></figure><p><strong>结论：如果finally里面存在return，将直接返回。不再跳回try块的return。</strong></p><p><strong>案例三：catch也是一样的道理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行 <span class="keyword">try</span></span><br><span class="line">执行 <span class="keyword">catch</span></span><br><span class="line">执行<span class="keyword">finally</span></span><br><span class="line">主方法返回 ：<span class="keyword">finally</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-try-catch&quot;&gt;&lt;a href=&quot;#Java-基础-try-catch&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-try-catch&quot;&gt;&lt;/a&gt;Java-基础-try-catch&lt;/h1&gt;&lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;绕口令开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、不管有没有异常，&lt;code&gt;finally&lt;/code&gt;中的代码都会执行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2、当&lt;code&gt;try、catch&lt;/code&gt;中有&lt;code&gt;return&lt;/code&gt;时，&lt;code&gt;finally&lt;/code&gt;中的代码依然会继续执行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;3、&lt;code&gt;finally&lt;/code&gt;是在&lt;code&gt;return&lt;/code&gt;后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;先执行try中的语句，包括return后面的表达式，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有异常时,先执行catch中的语句，包括return后面的表达式,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后执行finally中的语句,如果finally里面有return语句，会提前退出，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最后执行try中的return，有异常时执行catch中的return。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的。编译器把finally中的return语句标识为一个warning.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="try-catch-finally" scheme="http://zhuuu.work/tags/try-catch-finally/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-线程中断</title>
    <link href="http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</id>
    <published>2020-08-28T08:38:38.000Z</published>
    <updated>2020-08-28T14:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-线程中断"><a href="#Java-基础-线程中断" class="headerlink" title="Java-基础-线程中断"></a>Java-基础-线程中断</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Thread提供了interrupt方法，中断线程的执行：</p><ul><li>如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出<code>InterruptedException</code>,同时清除线程的中断状态;</li><li>如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；</li><li>如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心 interrupt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">         checkAccess();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这个方法不会清除中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-源码实现"><a href="#2-源码实现" class="headerlink" title="2. 源码实现"></a>2. 源码实现</h2><ul><li>之前在分析Thread.start的时候曾经提到，JavaThread有三个成员变量:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于synchronized同步块和Object.wait() </span></span><br><span class="line">ParkEvent * _ParkEvent ; </span><br><span class="line"><span class="comment">//用于Thread.sleep() </span></span><br><span class="line">ParkEvent * _SleepEvent ; </span><br><span class="line"><span class="comment">//用于unsafe.park()/unpark(),供java.util.concurrent.locks.LockSupport调用， </span></span><br><span class="line"><span class="comment">//因此它支持了java.util.concurrent的各种锁、条件变量等线程同步操作,是concurrent的实现基础 </span></span><br><span class="line">Parker* _parker;</span><br></pre></td></tr></table></figure><ul><li>初步猜测interrupt实现应该与此有关系；<br>interrupt方法的源码也在jvm.cpp文件:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Interrupt"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before we operate</span></span><br><span class="line">  oop java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;threadObj()</span> </span>== java_thread ? NULL : Threads_lock);</span><br><span class="line">  <span class="comment">// We need to re-resolve the java_thread, since a GC might have happened during the</span></span><br><span class="line">  <span class="comment">// acquire of the lock</span></span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != NULL) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><ul><li>JVM_Interrupt对参数进行了校验，然后直接调用Thread::interrupt:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  trace(<span class="string">"interrupt"</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Thread::interrupt调用os::interrupt方法实现,os::interrupt方法定义在os_linux.cpp:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取系统native线程对象</span></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">    osthread-&gt;set_interrupted(<span class="literal">true</span>);</span><br><span class="line">   <span class="comment">//内存屏障，使osthread的interrupted状态对其它线程立即可见</span></span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    <span class="comment">//前文说过，_SleepEvent用于Thread.sleep,线程调用了sleep方法，则通过unpark唤醒</span></span><br><span class="line">    ParkEvent * <span class="keyword">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">    <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;unpark() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//_parker用于concurrent相关的锁，此处同样通过unpark唤醒</span></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">  <span class="comment">//synchronized同步块和Object.wait() 唤醒</span></span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由此可见，interrupt其实就是通过ParkEvent的unpark方法唤醒对象；另外要注意：</strong></p><ul><li>object.wait、Thread.sleep和Thread.join会抛出InterruptedException并清除中断状态；</li><li>Lock.lock()方法不会响应中断，Lock.lockInterruptibly()方法则会响应中断并抛出异常，区别在于park()等待被唤醒时lock会继续执行park()来等待锁，而 lockInterruptibly会抛出异常；</li><li>synchronized被唤醒后会尝试获取锁，失败则会通过循环继续park()等待，因此实际上是不会被interrupt()中断的;</li><li>一般情况下，抛出异常时，会清空Thread的interrupt状态，在编程时需要注意；</li></ul><h2 id="3-网络中断相关"><a href="#3-网络中断相关" class="headerlink" title="3. 网络中断相关"></a>3. 网络中断相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>其中blocker是Thread的成员变量,Thread提供了blockedOn方法可以设置blocker:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">           blocker = b;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>如果一个nio通道实现了InterruptibleChannel接口，就可以响应interrupt()中断，其原理就在InterruptibleChannel接口的抽象实现类AbstractInterruptibleChannel的方法begin()中:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread target)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (!open)</span><br><span class="line">                               <span class="keyword">return</span>;</span><br><span class="line">                           open = <span class="keyword">false</span>;</span><br><span class="line">                           interrupted = target;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               AbstractInterruptibleChannel.<span class="keyword">this</span>.implCloseChannel();</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       blockedOn(interruptor);<span class="comment">//设置当前线程的blocker为interruptor</span></span><br><span class="line">       Thread me = Thread.currentThread();</span><br><span class="line">       <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">           interruptor.interrupt(me);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> AsynchronousCloseException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       blockedOn(<span class="keyword">null</span>);<span class="comment">//设置当前线程的blocker为null</span></span><br><span class="line">       Thread interrupted = <span class="keyword">this</span>.interrupted;</span><br><span class="line">      <span class="comment">//如果发生中断，Thread.interrupt方法会调用Interruptible的interrupt方法，</span></span><br><span class="line">     <span class="comment">//设置this.interrupted为当前线程</span></span><br><span class="line">       <span class="keyword">if</span> (interrupted != <span class="keyword">null</span> &amp;&amp; interrupted == Thread.currentThread()) &#123;</span><br><span class="line">           interrupted = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ClosedByInterruptException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!completed &amp;&amp; !open)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AsynchronousCloseException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class java.nio.channels.Channels.WritableByteChannelImpl</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            out.write(buf, <span class="number">0</span>, bytesToWrite);</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(bytesToWrite &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class java.nio.channels.Channels.ReadableByteChannelImpl</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            bytesRead = in.read(buf, <span class="number">0</span>, bytesToRead);</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(bytesRead &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>以上述代码为例，nio通道的ReadableByteChannel每次执行阻塞方法read()前，都会执行begin()，把Interruptible回调接口注册到当前线程上。当线程中断时，Thread.interrupt()触发回调接口Interruptible关闭io通道,导致read方法返回，最后在finally块中执行end()方法检查中断标记，抛出ClosedByInterruptException;</li></ul><p><strong>Selector的实现类似：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread ignore)</span> </span>&#123;</span><br><span class="line">                        AbstractSelector.<span class="keyword">this</span>.wakeup();</span><br><span class="line">                    &#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        AbstractInterruptibleChannel.blockedOn(interruptor);</span><br><span class="line">        Thread me = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">            interruptor.interrupt(me);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractInterruptibleChannel.blockedOn(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.class EPollSelectorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            pollWrapper.poll(timeout);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            end();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到当发生中断时会调用wakeup方法唤醒poll方法，但并不会抛出中断异常；</p><h2 id="4-通过interrupted-关闭线程"><a href="#4-通过interrupted-关闭线程" class="headerlink" title="4. 通过interrupted()关闭线程"></a>4. 通过interrupted()关闭线程</h2><ul><li>总所周知，<code>Thread.stop, Thread.suspend, Thread.resume</code> 都已经被废弃了。因为它们太暴力了，是不安全的，这种暴力中断线程是一种不安全的操作，举个栗子来说明其可能造成的问题：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopThread thread = <span class="keyword">new</span> StopThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 休眠1秒，确保线程进入运行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 暂停线程</span></span><br><span class="line">        thread.stop();</span><br><span class="line"><span class="comment">//      thread.interrupt();</span></span><br><span class="line">        <span class="comment">// 确保线程已经销毁</span></span><br><span class="line">        <span class="keyword">while</span> (thread.isAlive()) &#123; &#125;</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        thread.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这是一个同步原子操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ++x;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 休眠3秒,模拟耗时操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"x="</span> + x + <span class="string">" y="</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，run方法里是一个同步的原子操作，x和y必须要共同增加，然而这里如果调用thread.stop()方法强制中断线程，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">0</span></span><br></pre></td></tr></table></figure><p> 没有异常，也破坏了我们的预期。如果这种问题出现在我们的程序中，会引发难以预期的异常。因此这种不安全的方式很早就被废弃了。取而代之的是interrupt()，上述代码如果采用thread.interrupt()方法，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">1</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ThreadTest$StopThread.run(ThreadTest.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure><p> <strong>x=1,y=1 这个结果是符合我们的预期，同时还抛出了个异常，这个异常下文详说。</strong></p><p><strong>interrupt() 它基于「一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。」思想，是一个比较温柔的做法，它更类似一个标志位。其实作用不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</strong></p><p><strong>interrupt() 并不能真正的中断线程，这点要谨记。需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就需要这样做：</strong></p><ol><li>在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。</li><li>在调用阻塞方法时正确处理InterruptedException异常。（例如：catch异常后就结束线程。）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心 interrupt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">         checkAccess();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这个方法不会清除中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>首先讲 interrupt() 方法：</strong></p><ol><li>interrupt 中断操作时，非自身打断需要先检测是否有中断权限，这由jvm的安全机制配置；</li><li>如果线程处于<code>sleep, wait, join</code>等状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常；</li><li>如果线程处于I/O阻塞状态，将会抛出ClosedByInterruptException（IOException的子类）异常；</li><li>如果线程在Selector上被阻塞，select方法将立即返回；</li><li>如果非以上情况，将直接标记 interrupt 状态；</li></ol><p><strong>注意：interrupt 操作不会打断所有阻塞，只有上述阻塞情况才在jvm的打断范围内，如处于锁阻塞的线程，不会受 interrupt 中断；</strong></p><p><strong>等待情况下中断，抛出异常后线程恢复非中断状态，即 interrupted = false</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"1"</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread has been interrupt!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"isInterrupted: "</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread has been interrupt!</span><br><span class="line">isInterrupted: <span class="keyword">false</span></span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure><p><strong>调用Thread.interrupted() 方法后线程恢复非中断状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"1"</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"first :"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"second:"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first :<span class="keyword">true</span></span><br><span class="line">second:<span class="keyword">false</span></span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure><p><strong>上述两种隐含的状态恢复操作，是符合常理的，因为线程标记为中断后，用户没有真正中断线程，必然将其恢复为false。理论上Thread.interrupted()调用后，如果已中断，应该执行退出操作，不会重复调用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-线程中断&quot;&gt;&lt;a href=&quot;#Java-基础-线程中断&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-线程中断&quot;&gt;&lt;/a&gt;Java-基础-线程中断&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Thread提供了interrupt方法，中断线程的执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出&lt;code&gt;InterruptedException&lt;/code&gt;,同时清除线程的中断状态;&lt;/li&gt;
&lt;li&gt;如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；&lt;/li&gt;
&lt;li&gt;如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 核心 interrupt 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; != Thread.currentThread()) &lt;span class=&quot;comment&quot;&gt;// 非本线程，需要检查权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         checkAccess();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (blockerLock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         Interruptible b = blocker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (b != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             interrupt0();           &lt;span class=&quot;comment&quot;&gt;// 仅仅设置interrupt标志位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             b.interrupt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);    &lt;span class=&quot;comment&quot;&gt;// 调用如 I/O 操作定义的中断方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     interrupt0();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; currentThread().isInterrupted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 这个方法不会清除中断状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isInterrupted(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; ClearInterrupted)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="线程中断" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-05-网络层</title>
    <link href="http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-05-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-05-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2020-08-27T04:45:24.000Z</published>
    <updated>2020-08-27T09:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-05-网络层"><a href="#计算机网络-05-网络层" class="headerlink" title="计算机网络-05-网络层"></a>计算机网络-05-网络层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（<code>Address Resolution Protocol</code>）</li><li>网际控制报文协议 ICMP（<code>Internet Control Message Protocol</code>）</li><li>网际组管理协议 IGMP（<code>Internet Group Management Protocol</code>）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145836206.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145806629.png" alt="mark"></p><a id="more"></a><h2 id="1-IP首部格式"><a href="#1-IP首部格式" class="headerlink" title="1. IP首部格式"></a>1. IP首部格式</h2><ul><li><p><strong>版本</strong>   : 有 4（<code>IPv4</code>）和 6（<code>IPv6</code>）两个值；</p></li><li><p><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度</strong>   : 包括首部长度和数据部分长度。</p></li><li><p><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p></li><li><p><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-150110526.png" alt="mark"></p><h2 id="2-IP-地址编址方式"><a href="#2-IP-地址编址方式" class="headerlink" title="2. IP 地址编址方式"></a>2. IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-155800467.png" alt="mark"></p><h3 id="2-2-子网划分"><a href="#2-2-子网划分" class="headerlink" title="2.2 子网划分"></a>2.2 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><h3 id="2-3-无分类"><a href="#2-3-无分类" class="headerlink" title="2.3 无分类"></a>2.3 无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="3-地址解析协议-ARP协议"><a href="#3-地址解析协议-ARP协议" class="headerlink" title="3. 地址解析协议 ARP协议"></a>3. 地址解析协议 ARP协议</h2><ul><li>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-160941278.png" alt="mark"></p><ul><li>ARP 实现由 IP 地址得到 MAC 地址。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161128364.png" alt="mark"></p><ul><li><strong>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</strong></li><li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161409408.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161422234.png" alt="mark"></p><h2 id="4-网际控制报文协议-ICMP"><a href="#4-网际控制报文协议-ICMP" class="headerlink" title="4. 网际控制报文协议 ICMP"></a>4. 网际控制报文协议 ICMP</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161731437.png" alt="mark"></p><ul><li>ICMP 报文分为差错报告报文和询问报文。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161929687.png" alt="mark"></p><h3 id="4-1-Ping"><a href="#4-1-Ping" class="headerlink" title="4.1 Ping"></a>4.1 Ping</h3><ul><li>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</li><li>Ping 的原理是通过向目的主机发送<code>ICMP Echo</code>请求报文，目的主机收到之后会发送 <code>Echo</code>回答报文。<code>Ping</code> 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</li></ul><h3 id="4-2-Traceroute"><a href="#4-2-Traceroute" class="headerlink" title="4.2 Traceroute"></a>4.2 Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="5-网络地址转换-NAT"><a href="#5-网络地址转换-NAT" class="headerlink" title="5. 网络地址转换 NAT"></a>5. 网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162506572.png" alt="mark"></p><h2 id="6-虚拟网络-VPN"><a href="#6-虚拟网络-VPN" class="headerlink" title="6. 虚拟网络 VPN"></a>6. 虚拟网络 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162739534.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162754293.png" alt="mark"></p><h2 id="7-路由器"><a href="#7-路由器" class="headerlink" title="7. 路由器"></a>7. 路由器</h2><h3 id="7-1-路由器结构"><a href="#7-1-路由器结构" class="headerlink" title="7.1 路由器结构"></a>7.1 路由器结构</h3><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-170149630.png" alt="mark"></p><h3 id="7-2-路由分组转发流程"><a href="#7-2-路由分组转发流程" class="headerlink" title="7.2 路由分组转发流程"></a>7.2 路由分组转发流程</h3><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-170414340.png" alt="mark"></p><h3 id="7-3-路由选择协议"><a href="#7-3-路由选择协议" class="headerlink" title="7.3 路由选择协议"></a>7.3 路由选择协议</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的<strong>自治系统 AS</strong>，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p><strong>可以把路由选择协议划分为两大类：</strong></p><ul><li><strong>自治系统内部的路由选择：RIP 和 OSPF</strong></li><li><strong>自治系统间的路由选择：BGP</strong></li></ul><h3 id="1-内部网关协议-RIP"><a href="#1-内部网关协议-RIP" class="headerlink" title="1. 内部网关协议 RIP"></a>1. 内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-OSPF"><a href="#2-内部网关协议-OSPF" class="headerlink" title="2. 内部网关协议 OSPF"></a>2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3 id="3-外部网关协议BGP"><a href="#3-外部网关协议BGP" class="headerlink" title="3. 外部网关协议BGP"></a>3. 外部网关协议BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-171655956.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-05-网络层&quot;&gt;&lt;a href=&quot;#计算机网络-05-网络层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-05-网络层&quot;&gt;&lt;/a&gt;计算机网络-05-网络层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址解析协议 ARP（&lt;code&gt;Address Resolution Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;网际控制报文协议 ICMP（&lt;code&gt;Internet Control Message Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;网际组管理协议 IGMP（&lt;code&gt;Internet Group Management Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145836206.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145806629.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="ip" scheme="http://zhuuu.work/tags/ip/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-06-数据链路层</title>
    <link href="http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-06-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-06-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-08-27T04:45:24.000Z</published>
    <updated>2020-08-28T02:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-06-数据链路层"><a href="#计算机网络-06-数据链路层" class="headerlink" title="计算机网络-06-数据链路层"></a>计算机网络-06-数据链路层</h1><h2 id="前言-链路层的基本问题"><a href="#前言-链路层的基本问题" class="headerlink" title="前言 : 链路层的基本问题"></a>前言 : 链路层的基本问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-093935934.png" alt="mark"></p><a id="more"></a><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h3><ul><li><p>透明表示一个实际存在的事物看起来好像不存在一样。</p></li><li><p>帧使用首部和尾部进行定界，<strong>如果帧的数据部分含有和首部尾部相同的内容</strong>，那么帧的开始和结束位置就会被错误的判定。</p></li><li><p>需要在数据部分出现首部尾部相同的内容前面插入转义字符。<strong>如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符</strong>。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，<strong>用户察觉不到转义字符的存在</strong>。</p></li></ul><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h3><ul><li>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</li></ul><h1 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h1><h2 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h2><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h2 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h2><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h1 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h1><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为   <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-095659471.png" alt="mark"></p><h1 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h1><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100345698.png" alt="mark"></p><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100434363.png" alt="mark"></p><h1 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h1><ul><li>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</li><li>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</li></ul><h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100818521.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-06-数据链路层&quot;&gt;&lt;a href=&quot;#计算机网络-06-数据链路层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-06-数据链路层&quot;&gt;&lt;/a&gt;计算机网络-06-数据链路层&lt;/h1&gt;&lt;h2 id=&quot;前言-链路层的基本问题&quot;&gt;&lt;a href=&quot;#前言-链路层的基本问题&quot; class=&quot;headerlink&quot; title=&quot;前言 : 链路层的基本问题&quot;&gt;&lt;/a&gt;前言 : 链路层的基本问题&lt;/h2&gt;&lt;h3 id=&quot;1-封装成帧&quot;&gt;&lt;a href=&quot;#1-封装成帧&quot; class=&quot;headerlink&quot; title=&quot;1. 封装成帧&quot;&gt;&lt;/a&gt;1. 封装成帧&lt;/h3&gt;&lt;p&gt;将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-093935934.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="mac地址" scheme="http://zhuuu.work/tags/mac%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-04-抓包</title>
    <link href="http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-04-%E6%8A%93%E5%8C%85/"/>
    <id>http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-04-%E6%8A%93%E5%8C%85/</id>
    <published>2020-08-27T04:02:24.000Z</published>
    <updated>2020-08-27T06:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-04-抓包"><a href="#计算机网络-04-抓包" class="headerlink" title="计算机网络-04-抓包"></a>计算机网络-04-抓包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="1-抓包的作用"><a href="#1-抓包的作用" class="headerlink" title="1. 抓包的作用"></a>1. 抓包的作用</h2><p>在日常工作中，我们经常会用到抓包工具，看看前后台的数据传输、分析分析协议内容之类的。对于抓包工具在测试中的使用粗略归纳了几点：</p><p><strong>1.从功能测试角度，通过抓包查看隐藏字段</strong></p><ul><li>Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 C RSF 攻击，防网络爬虫，以及一些其他用途。<br> 这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。</li></ul><p><strong>2. 通过抓包工具了解协议内容，方便开展接口和性能测试</strong></p><ul><li>性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；<br> 接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。</li></ul><p><strong>3. 需要通过抓包工具，检查数据加密</strong></p><ul><li>安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。</li></ul><p><strong>4. 处理前后端 bug 归属之争</strong></p><ul><li>在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么 可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。</li></ul><p><strong>5. 通过抓包分析，可以更好的理解整个系统</strong></p><ul><li>经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。</li></ul><a id="more"></a><h2 id="2-中间人攻击"><a href="#2-中间人攻击" class="headerlink" title="2. 中间人攻击"></a>2. 中间人攻击</h2><p>首先fiddler截获客户端浏览器发送给服务器的https请求， 此时还未建立握手。</p><p>第一步， fiddler向服务器发送请求进行握手， 获取到服务器的CA证书， 用根证书公钥进行解密， 验证服务器数据签名， 获取到服务器CA证书公钥。</p><p>第二步， fiddler伪造自己的CA证书， 冒充服务器证书传递给客户端浏览器， 客户端浏览器做跟fiddler一样的事。</p><p>第三步， 客户端浏览器生成https通信用的对称密钥， 用fiddler伪造的证书公钥加密后传递给服务器， 被fiddler截获。</p><p>第四步， fiddler将截获的密文用自己伪造证书的私钥解开， 获得https通信用的对称密钥。</p><p>第五步， fiddler将对称密钥用服务器证书公钥加密传递给服务器， 服务器用私钥解开后建立信任， 握手完成， 用对称密钥加密消息， 开始通信。</p><p>第六步， fiddler接收到服务器发送的密文， 用对称密钥解开， 获得服务器发送的明文。再次加密， 发送给客户端浏览器。</p><p>第七步， 客户端向服务器发送消息， 用对称密钥加密， 被fidller截获后， 解密获得明文。</p><p>由于fiddler一直拥有通信用对称密钥， 所以在整个https通信过程中信息对其透明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-04-抓包&quot;&gt;&lt;a href=&quot;#计算机网络-04-抓包&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-04-抓包&quot;&gt;&lt;/a&gt;计算机网络-04-抓包&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;1-抓包的作用&quot;&gt;&lt;a href=&quot;#1-抓包的作用&quot; class=&quot;headerlink&quot; title=&quot;1. 抓包的作用&quot;&gt;&lt;/a&gt;1. 抓包的作用&lt;/h2&gt;&lt;p&gt;在日常工作中，我们经常会用到抓包工具，看看前后台的数据传输、分析分析协议内容之类的。对于抓包工具在测试中的使用粗略归纳了几点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.从功能测试角度，通过抓包查看隐藏字段&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 C RSF 攻击，防网络爬虫，以及一些其他用途。&lt;br&gt; 这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 通过抓包工具了解协议内容，方便开展接口和性能测试&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；&lt;br&gt; 接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 需要通过抓包工具，检查数据加密&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 处理前后端 bug 归属之争&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么 可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 通过抓包分析，可以更好的理解整个系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--41-数据流中的中位数</title>
    <link href="http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2020-08-26T07:15:53.000Z</published>
    <updated>2020-09-09T04:23:13.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–41-数据流中的中位数"><a href="#剑指offer–41-数据流中的中位数" class="headerlink" title="剑指offer–41-数据流中的中位数"></a>剑指offer–41-<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-两个堆"><a href="#思路-两个堆" class="headerlink" title="思路 : 两个堆"></a><strong>思路 : 两个堆</strong></h2><p><strong>待优化的思路1：快排</strong></p><ul><li>其中位数的计算方法：首先对数组执行排序（使用O<em>(</em>N<em>log</em>N) 时间），然后返回中间元素即可（使用 O(1)时间）。</li><li>针对本题，根据以上思路，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。此方法的时间复杂度为 O(N)，其中包括： 查找元素插入位置O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。</li></ul><p><strong>思路2： 两个堆</strong></p><ul><li>事实上，我们只关心在中间的那两个数（或者一个数），其它数没有必要进行 “比较” 和 “交换” 的操作。</li><li>在我们学习过的数据结构里，堆就有类似的性质，每次都从堆里得到一个 “最值” 而其它元素无需排序，这样就可以以O(logN) 的复杂度每次都从堆中取出最值。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111604101.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111617276.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111821068.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-112110039.png" alt="mark"></p><p><strong>总结：</strong></p><ul><li><strong>为了找到添加新数据以后，数据流的中位数，我们让这个新数据在大顶堆和小顶堆中都走了一遍。而为了让大顶堆的元素多 1 个，我们让从小顶堆中又拿出一个元素“送回”给大顶堆；</strong></li><li>将元素放入优先队列以后，优先队列会以对数时间复杂度自行调整，把“最优值”放入堆顶，这是使用优先队列解决这个问题的原因。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前大顶堆和小顶堆的元素个数之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxheap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minheap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">        minheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        maxheap.offer(num);</span><br><span class="line">        minheap.add(maxheap.poll());</span><br><span class="line">        <span class="comment">// 如果两个堆合起来的元素个数是奇数，小顶堆要拿出堆顶元素给大顶堆</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            maxheap.add(minheap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (maxheap.peek() + minheap.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) maxheap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度：</strong>O(logN) 优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的，综上时间复杂度是 O(logN) 级别的。</li><li><strong>空间复杂度：</strong>O(N) 占用堆的大小</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;a href=&quot;#剑指offer–41-数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;/a&gt;剑指offer–41-&lt;a href=&quot;https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据流中的中位数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;[2,3,4] 的中位数是 3&lt;/p&gt;
&lt;p&gt;[2,3] 的中位数是 (2 + 3) / 2 = 2.5&lt;/p&gt;
&lt;p&gt;设计一个支持以下两种操作的数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void addNum(int num) - 从数据流中添加一个整数到数据结构中。&lt;/li&gt;
&lt;li&gt;double findMedian() - 返回目前所有元素的中位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[1],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,null,1.50000,null,2.00000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,2.00000,null,2.50000]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--52-两个链表的第一个公共节点</title>
    <link href="http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--56-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--56-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2020-08-26T07:12:53.000Z</published>
    <updated>2020-08-26T11:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–52-两个链表的第一个公共节点"><a href="#剑指offer–52-两个链表的第一个公共节点" class="headerlink" title="剑指offer–52-两个链表的第一个公共节点"></a>剑指offer–52-<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191825466.png" alt="mark"></p><p>在节点 c1 开始相交。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191838788.png" alt="mark"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-192018933.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-192115537.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路：</p><ul><li><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p></li><li><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = headA;</span><br><span class="line">        ListNode l2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            <span class="comment">// 我走过你走的路</span></span><br><span class="line">            l1 = l1 == <span class="keyword">null</span>? headB:l1.next;</span><br><span class="line">           <span class="comment">//  你走过我走的路</span></span><br><span class="line">            l2 = l2 == <span class="keyword">null</span>? headA:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 所以我们才能相遇</span></span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O（n + m）</strong></li><li><strong>空间复杂度:O(1)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–52-两个链表的第一个公共节点&quot;&gt;&lt;a href=&quot;#剑指offer–52-两个链表的第一个公共节点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–52-两个链表的第一个公共节点&quot;&gt;&lt;/a&gt;剑指offer–52-&lt;a href=&quot;https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个链表的第一个公共节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入两个链表，找出它们的第一个公共节点。&lt;/p&gt;
&lt;p&gt;如下面的两个链表&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191825466.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在节点 c1 开始相交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191838788.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>Linux-03-PV</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-03-PV/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-03-PV/</id>
    <published>2020-08-25T08:52:53.000Z</published>
    <updated>2020-08-25T05:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-03-PV"><a href="#Linux-03-PV" class="headerlink" title="Linux-03-PV"></a>Linux-03-PV</h1><h2 id="1-疑惑解答"><a href="#1-疑惑解答" class="headerlink" title="1. 疑惑解答"></a>1. 疑惑解答</h2><p>进程通常分为就绪、运行和阻塞三个工作状态。三种状态在某些条件下可以转换，三者之间的转换关系如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-131907370.png" alt="mark"></p><p>进程三个状态之间的转换就是靠PV操作来控制的。PV操作主要就是P操作、V操作和信号量。其中信号量起到了至关重要的作用。</p><a id="more"></a><p><strong>信号量</strong></p><p>信号量是最早出现的用来解决进程同步与互斥问题的机制。　</p><ul><li>信号量由一个值和一个指针组成，指针指向等待该信号量的进程。信号量的值表示相应资源的使用情况。</li><li>信号量<code>S&gt;=0</code>时，S表示可用资源的数量。执行一次P操作意味着请求分配一个资源，因此S的值减1；</li><li>当<code>S&lt;0</code>时，表示已经没有可用资源，S的绝对值表示当前等待该资源的进程数。请求者必须等待其他进程释放该类资源，才能继续运行。而执行一个V操作意味着释放一个资源，因此S的值加1；</li><li>若S&lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。</li></ul><p>注意，信号量的值只能由PV操作来改变。</p><p><strong><em>\</em>关于PV操作容易产生的一些疑问：**</strong></p><p><strong>1，S大于0那就表示有临界资源可供使用，为什么不唤醒进程？</strong></p><ul><li>S大于0的确表示有临界资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒。</li></ul><p><strong>2，S小于0应该是说没有临界资源可供使用，为什么还要唤醒进程？</strong></p><ul><li>V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S&lt;0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。</li><li>比如，有两个某类资源，四个进程A、B、C、D要用该类资源，最开始S=2，当A进入，S=1，当B进入S=0，表明该类资源刚好用完， 当C进入时S=-1，表明有一个进程被阻塞了，D进入，S=-2。当A用完该类资源时，进行V操作，S=-1，释放该类资源，因为S&lt;0，表明有进程阻塞在该类资源上，于是唤醒一个。</li></ul><p><strong>3，如果是互斥信号量的话，应该设置信号量S=1，但是当有5个进程都访问的话，最后在该信号量的链表里会有4个在等待，也是说S=-4，那么第一个进程执行了V操作使S加1，释放了资源，下一个应该能够执行，但唤醒的这个进程在执行P操作时因S&lt;0，也还是执行不了，这是怎么回事呢？</strong></p><ul><li>当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区，并不需要执行P操作了，当执行完了临界区的程序后，就执行V操作。</li></ul><p><strong>4，S的绝对值表示等待的进程数，同时又表示临界资源，这到底是怎么回事？</strong></p><p>当信号量S小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目.S大于0时表示可用的临界资源数。注意在不同情况下所表达的含义不一样。当等于0时，表示刚好用完。</p><h2 id="2-PV操作"><a href="#2-PV操作" class="headerlink" title="2. PV操作"></a>2. PV操作</h2><p><strong>临界区：</strong>我们把并发进程中与共享变量有关的程序段称为临界区。</p><p><strong>信号量S</strong>：信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</p><p>​    <strong>P操作P（S）</strong>：将信号量S减去1，若结果小于0，则把调用P（S）的进程置成等待信号量S的状态。即为请求资源。</p><p>​    <strong>V操作V（S）</strong>：将信号量S加上1，若结果不大于0，则释放一个等待信号量S的进程。即为释放资源。</p><p>正如老师上课时所举的父亲给孩子吃苹果的例子一样，假如一个盘子只能放一个苹果，父亲往盘子里放了一个苹果。如果儿子吃了（<strong>V操作</strong>），父亲才可以接着放（<strong>P操作</strong>）；如果儿子不吃，那父亲就不能放苹果，只能等着。</p><p><strong>伪代码如下</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Procedure P (Var S：Semaphore)</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">S：=S - 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> S&lt;0 <span class="keyword">then</span> W(S) </span><br><span class="line"></span><br><span class="line">end; &#123; P &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Procedure V (Var S：Semaphore)</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">S：=S + 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> S&lt; = 0 <span class="keyword">then</span> R(S) </span><br><span class="line"></span><br><span class="line">end; &#123; V &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#       W(S)：表示把调用P（S）的进程置成等待信号量S的状态。</span></span><br><span class="line"><span class="comment">#R(S)：表示释放一个等待信号量S的进程。</span></span><br></pre></td></tr></table></figure><h3 id="2-1-进程互斥"><a href="#2-1-进程互斥" class="headerlink" title="2.1 进程互斥"></a>2.1 进程互斥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    利用信号量和PV操作实现进程互斥的一般模型是：</span><br><span class="line">进程P1              进程P2           ……          进程Pn</span><br><span class="line">……                  ……                           ……</span><br><span class="line">P（S）；              P（S）；                         P（S）；</span><br><span class="line">临界区；             临界区；                        临界区；</span><br><span class="line">V（S）；              V（S）；                        V（S）；</span><br><span class="line">……                  ……            ……           ……</span><br></pre></td></tr></table></figure><pre><code>其中信号量S用于互斥，初值为1。使用PV操作实现进程互斥时应该注意的是：（1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。（2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。（3）互斥信号量的初值一般为1。</code></pre><h3 id="2-2-进程同步"><a href="#2-2-进程同步" class="headerlink" title="2.2 进程同步"></a>2.2 进程同步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">利用信号量和PV操作实现进程同步</span><br><span class="line">PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。</span><br><span class="line"></span><br><span class="line">    使用PV操作实现进程同步时应该注意的是：</span><br><span class="line"></span><br><span class="line">    （1）分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。</span><br><span class="line">    （2）信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。</span><br><span class="line">    （3）同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-03-PV&quot;&gt;&lt;a href=&quot;#Linux-03-PV&quot; class=&quot;headerlink&quot; title=&quot;Linux-03-PV&quot;&gt;&lt;/a&gt;Linux-03-PV&lt;/h1&gt;&lt;h2 id=&quot;1-疑惑解答&quot;&gt;&lt;a href=&quot;#1-疑惑解答&quot; class=&quot;headerlink&quot; title=&quot;1. 疑惑解答&quot;&gt;&lt;/a&gt;1. 疑惑解答&lt;/h2&gt;&lt;p&gt;进程通常分为就绪、运行和阻塞三个工作状态。三种状态在某些条件下可以转换，三者之间的转换关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-131907370.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程三个状态之间的转换就是靠PV操作来控制的。PV操作主要就是P操作、V操作和信号量。其中信号量起到了至关重要的作用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程通信方式" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-04-僵尸进程,孤儿进程</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-04-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B,%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-04-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B,%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-08-25T08:52:53.000Z</published>
    <updated>2020-09-03T01:19:12.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-04-僵尸进程-孤儿进程"><a href="#Linux-04-僵尸进程-孤儿进程" class="headerlink" title="Linux-04-僵尸进程,孤儿进程"></a>Linux-04-僵尸进程,孤儿进程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用<code>wait()</code>或者<code>waitpid()</code>系统调用取得子进程的终止状态</li></ul><p>　　<strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p>　　<strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><a id="more"></a><h2 id="1-问题和危害"><a href="#1-问题和危害" class="headerlink" title="1. 问题和危害"></a>1. 问题和危害</h2><p><strong>僵尸进程的危害</strong></p><ul><li><p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号<code>the process ID</code>,退出状态<code>the termination status of the process</code>,运行时间<code>the amount of CPU time taken by the process</code>等)。直到父进程通过<code>wait / waitpid</code>来取时才释放。 </p></li><li><p><strong>如果进程不调用wait / waitpid的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p></li></ul><p><strong>孤儿进程的危害</strong></p><ul><li><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，<code>init</code>进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地<code>wait()</code>它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，<code>init</code>进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></li></ul><p><strong>僵尸进程危害的场景</strong></p><ul><li><p>例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短</p></li><li><p>但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵尸进程，倘若用<code>ps</code>命令查看的话，就会看到很多状态为Z的进程。</p></li><li><p>严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）</p></li><li><p>枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被<code>init</code>进程接管，<code>init</code>进程会<code>wait()</code>这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。</p></li></ul><h2 id="2-问题演示"><a href="#2-问题演示" class="headerlink" title="2. 问题演示"></a>2. 问题演示</h2><p>孤儿进程测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="comment">//创建一个进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am the child process.\n"</span>);</span><br><span class="line">        <span class="comment">//输出进程ID和父进程ID</span></span><br><span class="line">        printf(<span class="string">"pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        printf(<span class="string">"I will sleep five seconds.\n"</span>);</span><br><span class="line">        <span class="comment">//睡眠5s，保证父进程先退出</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        printf(<span class="string">"pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        printf(<span class="string">"child process is exited.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am father process.\n"</span>);</span><br><span class="line">        <span class="comment">//父进程睡眠1s，保证子进程输出进程id</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        printf(<span class="string">"father process is  exited.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/090940937.png" alt="mark"></p><p>僵尸进程测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am child process.I am exiting.\n"</span>);</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"I am father process.I will sleep two seconds\n"</span>);</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//输出进程信息</span></span><br><span class="line">    system(<span class="string">"ps -o pid,ppid,state,tty,command"</span>);</span><br><span class="line">    printf(<span class="string">"father process is exiting.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091128821.png" alt="mark"></p><p>僵尸进程测试2：父进程循环创建子进程，子进程退出，造成多个僵尸进程，程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    <span class="comment">//循环创建子进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork error:"</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"I am a child process.\nI am exiting.\n"</span>);</span><br><span class="line">            <span class="comment">//子进程退出，成为僵尸进程</span></span><br><span class="line">            exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//父进程休眠20s继续创建子进程</span></span><br><span class="line">            sleep(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091246352.png" alt="mark"></p><h2 id="3-问题的解决方法"><a href="#3-问题的解决方法" class="headerlink" title="3. 问题的解决方法"></a>3. 问题的解决方法</h2><p><strong>（1）通过信号机制</strong></p><p>　　子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="comment">//创建捕捉子进程退出信号</span></span><br><span class="line">    signal(SIGCHLD,sig_child);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am child process,pid id %d.I am exiting.\n"</span>,getpid());</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"I am father process.I will sleep two seconds\n"</span>);</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//输出进程信息</span></span><br><span class="line">    system(<span class="string">"ps -o pid,ppid,state,tty,command"</span>);</span><br><span class="line">    printf(<span class="string">"father process is exiting.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     pid_t        pid;</span><br><span class="line">     <span class="keyword">int</span>        stat;</span><br><span class="line">     <span class="comment">//处理僵尸进程</span></span><br><span class="line">     <span class="keyword">while</span> ((pid = waitpid(-<span class="number">1</span>, &amp;stat, WNOHANG)) &gt;<span class="number">0</span>)</span><br><span class="line">            printf(<span class="string">"child %d terminated.\n"</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091458045.png" alt="mark"></p><p><strong>（2）fork两次</strong><br>　　《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    <span class="comment">//创建第一个子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一个子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程再创建子进程</span></span><br><span class="line">        printf(<span class="string">"I am the first child process.pid:%d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork error:"</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个子进程退出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"first procee is exited.\n"</span>);</span><br><span class="line">            exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二个子进程</span></span><br><span class="line">        <span class="comment">//睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        printf(<span class="string">"I am the second child process.pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程处理第一个子进程退出</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, NULL, <span class="number">0</span>) != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"waitepid error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091537084.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-04-僵尸进程-孤儿进程&quot;&gt;&lt;a href=&quot;#Linux-04-僵尸进程-孤儿进程&quot; class=&quot;headerlink&quot; title=&quot;Linux-04-僵尸进程,孤儿进程&quot;&gt;&lt;/a&gt;Linux-04-僵尸进程,孤儿进程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用&lt;code&gt;wait()&lt;/code&gt;或者&lt;code&gt;waitpid()&lt;/code&gt;系统调用取得子进程的终止状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;strong&gt;孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="僵尸进程" scheme="http://zhuuu.work/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="孤儿进程" scheme="http://zhuuu.work/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-459-重复的子字符串</title>
    <link href="http://zhuuu.work/2020/08/25/Leetcode/Leetcode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/08/25/Leetcode/Leetcode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-25T08:35:53.000Z</published>
    <updated>2020-08-25T08:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-459-重复的子字符串"><a href="#Leecode-459-重复的子字符串" class="headerlink" title="Leecode-459. 重复的子字符串"></a>Leecode-<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果您的字符串 S 包含一个重复的子字符串，那么这意味着您可以多次 “移位和换行”`您的字符串，并使其与原始字符串匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：abcabc</span><br><span class="line"></span><br><span class="line">移位一次：cabcab</span><br><span class="line">移位两次：bcabca</span><br><span class="line">移位三次：abcabc</span><br></pre></td></tr></table></figure><p>现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串。</p><p>基于这个思想，可以每次移动k个字符，直到匹配移动 length - 1 次。但是这样对于重复字符串很长的字符串，效率会非常低。在 LeetCode 中执行时间超时了。</p><p>为了避免这种无用的环绕，可以创建一个新的字符串 str，它等于原来的字符串 S 再加上 S 自身，这样其实就包含了所有移动的字符串。</p><p><strong>比如字符串：S = acd，那么 str = S + S = acdacd</strong></p><p><strong>acd 移动的可能：dac、cda。其实都包含在了 str 中了。就像一个滑动窗口</strong></p><p><strong>一开始 acd (acd) ，移动一次 ac(dac)d，移动两次 a(cda)cd。循环结束</strong></p><p><strong>所以可以直接判断 str 中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String str = s + s;</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).contains(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leecode-459-重复的子字符串&quot;&gt;&lt;a href=&quot;#Leecode-459-重复的子字符串&quot; class=&quot;headerlink&quot; title=&quot;Leecode-459. 重复的子字符串&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://lee
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux-02-进程通信方式</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-02-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-02-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2020-08-25T07:52:53.000Z</published>
    <updated>2020-08-25T03:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-02-进程通信方式"><a href="#Linux-02-进程通信方式" class="headerlink" title="Linux-02-进程通信方式"></a>Linux-02-进程通信方式</h1><h2 id="一、管道"><a href="#一、管道" class="headerlink" title="一、管道"></a>一、管道</h2><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p><h3 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</li><li>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</li><li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li></ol><h3 id="2、原型"><a href="#2、原型" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 #include &lt;unistd.h&gt;</span><br><span class="line">2 int pipe(int fd[2]);    &#x2F;&#x2F; 返回值：若成功返回0，失败返回-1</span><br></pre></td></tr></table></figure><p>当一个管道建立时，它会创建两个文件描述符：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-094108517.png" alt="mark"></p><a id="more"></a><p>要关闭管道只需将这两个文件描述符关闭即可。</p><h3 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-094212697.png" alt="mark"></p><p>若要数据流从父进程流向子进程，则关闭父进程的读端（<code>fd[0]</code>）与子进程的写端（<code>fd[1]</code>）；反之，则可以使数据流从子进程流向父进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];  <span class="comment">// 两个文件描述符</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)  <span class="comment">// 创建管道</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create Pipe Error!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)  <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        read(fd[<span class="number">0</span>], buff, <span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、FIFO"><a href="#二、FIFO" class="headerlink" title="二、FIFO"></a>二、FIFO</h2><p>FIFO，也称为命名管道，它是一种文件类型。</p><h3 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>FIFO可以在无关的进程之间交换数据，与无名管道不同。</li><li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li></ol><h3 id="2、原型-1"><a href="#2、原型-1" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 #include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">2 &#x2F;&#x2F; 返回值：成功返回0，出错返回-1</span><br><span class="line">3 int mkfifo(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure><p>其中的 mode 参数与<code>open</code>函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p><p>当 open 一个FIFO时，是否设置非阻塞标志（<code>O_NONBLOCK</code>）的区别：</p><ul><li>若没有指定<code>O_NONBLOCK</code>（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</li><li>若指定了<code>O_NONBLOCK</code>，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</li></ul><h3 id="3、例子-1"><a href="#3、例子-1" class="headerlink" title="3、例子"></a>3、例子</h3><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：</p><p><strong>write_fifo.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;   // exit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;    // O_WRONLY</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;     // time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">time_t</span> tp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">        n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">        <span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>read_fifo.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line">        perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">// 以读打开FIFO</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两个终端里用 gcc 分别编译运行上面两个文件，可以看到输出结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">2</span> I am <span class="number">5954</span> process.</span><br><span class="line"> <span class="number">3</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">4</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">5</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">6</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">7</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">8</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">9</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line"><span class="number">10</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line"><span class="number">11</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line"><span class="number">12</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">2</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">3</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">4</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">5</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">6</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">7</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">8</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">9</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line"><span class="number">10</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line"><span class="number">11</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure><p>上述例子可以扩展成 客户进程—服务器进程 通信的实例，<code>write_fifo</code>的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，<code>read_fifo</code>类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-100921142.png" alt="mark"></p><h2 id="三、消息队列"><a href="#三、消息队列" class="headerlink" title="三、消息队列"></a>三、消息队列</h2><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p><h3 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li><li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li><li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</li></ol><h3 id="2、原型-2"><a href="#2、原型-2" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：</p><ul><li>如果没有与键值key相对应的消息队列，并且flag中包含了<code>IPC_CREAT</code>标志位。</li><li>key参数为<code>IPC_PRIVATE</code>。</li></ul><p>函数<code>msgrcv</code>在读取消息队列时，type参数有下面几种情况：</p><ul><li><code>type == 0</code>，返回队列中的第一个消息；</li><li><code>type &gt; 0</code>，返回队列中消息类型为 type 的第一个消息；</li><li><code>type &lt; 0</code>，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li></ul><p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）</p><h3 id="3、例子-2"><a href="#3、例子-2" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p><p><strong>msg_server.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取消息</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">        msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">        <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">        msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>msg_client.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加消息，类型为888</span></span><br><span class="line">    msg.mtype = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">    msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取类型为777的消息</span></span><br><span class="line">    msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、信号量"><a href="#四、信号量" class="headerlink" title="四、信号量"></a>四、信号量</h2><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><h3 id="1、特点-3"><a href="#1、特点-3" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li><li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li><li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li><li>支持信号量组。</li></ol><h3 id="2、原型-3"><a href="#2、原型-3" class="headerlink" title="2、原型"></a>2、原型</h3><p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。</p><p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf semoparray[], <span class="keyword">size_t</span> numops)</span></span>;</span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>当<code>semget</code>创建新的信号量集合时，必须指定集合中信号量的个数（即<code>num_sems</code>），通常为1； 如果是引用一个现有的集合，则将<code>num_sems</code>指定为 0 。</p><p>在<code>semop</code>函数中，<code>sembuf</code>结构的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short sem_num; <span class="comment">// 信号量组中对应的序号，0～sem_nums-1</span></span><br><span class="line">    short sem_op;  <span class="comment">// 信号量值在一次操作中的改变量</span></span><br><span class="line">    short sem_flg; <span class="comment">// IPC_NOWAIT, SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 sem_op 是一次操作中的信号量的改变量：</p><ul><li><p>若<code>sem_op &gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。</p></li><li><p>若<code>sem_op &lt; 0</code>，请求 sem_op 的绝对值的资源。</p><ul><li><p>如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</p></li><li><p>当相应的资源数不能满足请求时，这个操作与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_flg</span><br></pre></td></tr></table></figure><p>有关。</p><ul><li><p>sem_flg 指定<code>IPC_NOWAIT</code>，则semop函数出错返回<code>EAGAIN</code>。</p></li><li><p>sem_flg 没有指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPC_NOWAIT</span><br></pre></td></tr></table></figure><p>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：</p><ol><li>当相应的资源数可以满足请求，此信号量的semncnt值减1，该信号量的值减去sem_op的绝对值。成功返回；</li><li>此信号量被删除，函数smeop出错返回EIDRM；</li><li>进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的semncnt值减1，函数semop出错返回EINTR</li></ol></li></ul></li></ul></li><li><p>若<code>sem_op == 0</code>，进程阻塞直到信号量的相应值为0：</p><ul><li><p>当信号量已经为0，函数立即返回。</p></li><li><p>如果信号量的值不为0，则依据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_flg</span><br></pre></td></tr></table></figure><p>决定函数动作：</p><ul><li><p>sem_flg指定<code>IPC_NOWAIT</code>，则出错返回<code>EAGAIN</code>。</p></li><li><p>sem_flg没有指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPC_NOWAIT</span><br></pre></td></tr></table></figure><p>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：</p><ol><li>信号量值为0，将信号量的semzcnt的值减1，函数semop成功返回；</li><li>此信号量被删除，函数smeop出错返回EIDRM；</li><li>进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的semncnt值减1，函数semop出错返回EINTR</li></ol></li></ul></li></ul></li></ul><p>在<code>semctl</code>函数中的命令有多种，这里就说两个常用的：</p><ul><li><code>SETVAL</code>：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。</li><li><code>IPC_RMID</code>：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。</li></ul><h3 id="3、例子-3"><a href="#3、例子-3" class="headerlink" title="3、例子"></a>3、例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//    若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//    若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//    释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//    如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id;  <span class="comment">// 信号量集ID</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量集，其中只有一个信号量</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化：初值设为0资源被占用</span></span><br><span class="line">    init_sem(sem_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"Fork Error"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Process child: pid=%d\n"</span>, getpid());</span><br><span class="line">        sem_v(sem_id);  <span class="comment">/*释放资源*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/*父进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(sem_id);   <span class="comment">/*等待资源*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Process father: pid=%d\n"</span>, getpid());</span><br><span class="line">        sem_v(sem_id);   <span class="comment">/*释放资源*/</span></span><br><span class="line">        del_sem(sem_id); <span class="comment">/*删除信号量集*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子如果不加信号量，则父进程会先执行完毕。这里加了信号量让父进程等待子进程执行完以后再执行。</p><h2 id="五、共享内存"><a href="#五、共享内存" class="headerlink" title="五、共享内存"></a>五、共享内存</h2><p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p><h3 id="1、特点-4"><a href="#1、特点-4" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li><li>因为多个进程可以同时操作，所以需要进行同步。</li><li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li></ol><h3 id="2、原型-4"><a href="#2、原型-4" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>当用<code>shmget</code>函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p><p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code>shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p><p><code>shmdt</code>函数是用来断开<code>shmat</code>建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p><p><code>shmctl</code>函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是<code>IPC_RMID</code>（从系统中删除该共享内存）。</p><h3 id="3、例子-4"><a href="#3、例子-4" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面这个例子，使用了【共享内存+信号量+消息队列】的组合来实现服务器进程与客户进程间的通信。</p><ul><li>共享内存用来传递数据；</li><li>信号量用来同步；</li><li>消息队列用来 在客户端修改了共享内存后 通知服务器读取。</li></ul><p><strong>server.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;  // shared memory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;  // semaphore</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;  // message queue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;   // memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(<span class="keyword">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    init_sem(sem_id, <span class="number">1</span>);  <span class="comment">/*初值设为1资源未占用*/</span></span><br><span class="line">    <span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">    <span class="keyword">char</span> *shm;</span><br><span class="line">    <span class="keyword">char</span> data[] = <span class="string">"this is server"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">buf1</span>;</span>  <span class="comment">/*用于删除共享内存*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">buf2</span>;</span>  <span class="comment">/*用于删除消息队列*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span>  <span class="comment">/*消息队列用于通知对方更新了共享内存*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存</span></span><br><span class="line">    <span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Create Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">int</span>)shm == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量</span></span><br><span class="line">    semid = creat_sem(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msgrcv(msqid, &amp;msg, <span class="number">1</span>, <span class="number">888</span>, <span class="number">0</span>); <span class="comment">/*读取类型为888的消息*/</span></span><br><span class="line">        <span class="keyword">if</span>(msg.mtext == <span class="string">'q'</span>)  <span class="comment">/*quit - 跳出循环*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(msg.mtext == <span class="string">'r'</span>)  <span class="comment">/*read - 读共享内存*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            sem_p(semid);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,shm);</span><br><span class="line">            sem_v(semid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除共享内存、消息队列、信号量*/</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, &amp;buf1);</span><br><span class="line">    msgctl(msqid, IPC_RMID, &amp;buf2);</span><br><span class="line">    del_sem(semid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>client.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;  // shared memory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;  // semaphore</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;  // message queue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;   // memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">    <span class="keyword">char</span> *shm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">/*while循环条件*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取共享内存</span></span><br><span class="line">    <span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">int</span>)shm == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取信号量</span></span><br><span class="line">    <span class="keyword">if</span>((semid = semget(key, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*                 IPC                 *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*    Input r to send data to server.  *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*    Input q to quit.                 *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please input command: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Data to send: "</span>);</span><br><span class="line">                sem_p(semid);  <span class="comment">/*访问资源*/</span></span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm);</span><br><span class="line">                sem_v(semid);  <span class="comment">/*释放资源*/</span></span><br><span class="line">                <span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">                <span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">                msg.mtype = <span class="number">888</span>;</span><br><span class="line">                msg.mtext = <span class="string">'r'</span>;  <span class="comment">/*发送消息通知服务器读数据*/</span></span><br><span class="line">                msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">                msg.mtype = <span class="number">888</span>;</span><br><span class="line">                msg.mtext = <span class="string">'q'</span>;</span><br><span class="line">                msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Wrong input!\n"</span>);</span><br><span class="line">                <span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">                <span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当<code>scanf()</code>输入字符或字符串时，缓冲区中遗留下了<code>\n</code>，所以每次输入操作后都需要清空标准输入的缓冲区。但是由于 gcc 编译器不支持<code>fflush(stdin)</code>（它只是标准C的扩展），所以我们使用了替代方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 while((c&#x3D;getchar())!&#x3D;&#39;\n&#39; &amp;&amp; c!&#x3D;EOF);</span><br></pre></td></tr></table></figure><h2 id="五种通讯方式总结"><a href="#五种通讯方式总结" class="headerlink" title="五种通讯方式总结"></a>五种通讯方式总结</h2><p>1.管道：速度慢，容量有限，只有父子进程能通讯   </p><p>2.FIFO：任何进程间都能通讯，但速度慢   </p><p>3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   </p><p>4.信号量：不能传递复杂消息，只能用来同步   </p><p>5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-02-进程通信方式&quot;&gt;&lt;a href=&quot;#Linux-02-进程通信方式&quot; class=&quot;headerlink&quot; title=&quot;Linux-02-进程通信方式&quot;&gt;&lt;/a&gt;Linux-02-进程通信方式&lt;/h1&gt;&lt;h2 id=&quot;一、管道&quot;&gt;&lt;a href=&quot;#一、管道&quot; class=&quot;headerlink&quot; title=&quot;一、管道&quot;&gt;&lt;/a&gt;一、管道&lt;/h2&gt;&lt;p&gt;管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。&lt;/p&gt;
&lt;h3 id=&quot;1、特点&quot;&gt;&lt;a href=&quot;#1、特点&quot; class=&quot;headerlink&quot; title=&quot;1、特点&quot;&gt;&lt;/a&gt;1、特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。&lt;/li&gt;
&lt;li&gt;它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。&lt;/li&gt;
&lt;li&gt;它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2、原型&quot;&gt;&lt;a href=&quot;#2、原型&quot; class=&quot;headerlink&quot; title=&quot;2、原型&quot;&gt;&lt;/a&gt;2、原型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 #include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 int pipe(int fd[2]);    &amp;#x2F;&amp;#x2F; 返回值：若成功返回0，失败返回-1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;当一个管道建立时，它会创建两个文件描述符：&lt;code&gt;fd[0]&lt;/code&gt;为读而打开，&lt;code&gt;fd[1]&lt;/code&gt;为写而打开。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-094108517.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程通信方式" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-12-一对多,多对一，多对多问题</title>
    <link href="http://zhuuu.work/2020/08/25/Mysql/Mysql-12-%E4%B8%80%E5%AF%B9%E5%A4%9A,%E5%A4%9A%E5%AF%B9%E4%B8%80%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/08/25/Mysql/Mysql-12-%E4%B8%80%E5%AF%B9%E5%A4%9A,%E5%A4%9A%E5%AF%B9%E4%B8%80%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-25T06:28:27.000Z</published>
    <updated>2020-08-25T06:50:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-12-一对多-多对一，多对多问题"><a href="#Mysql-12-一对多-多对一，多对多问题" class="headerlink" title="Mysql-12-一对多,多对一，多对多问题"></a>Mysql-12-一对多,多对一，多对多问题</h1><h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p>​    一对一关系示例：</p><ul><li><ul><li>一个学生对应一个学生档案材料，或者每个人都有唯一的身份证编号。</li></ul></li></ul><p>​    一对多关系示例：</p><ul><li><ul><li>一个学生只属于一个班，但是一个班级有多名学生。</li></ul></li></ul><p>​    多对多关系示例：</p><ul><li><ul><li>一个学生可以选择多门课，一门课也有多名学生。</li></ul></li></ul><a id="more"></a><h2 id="2-数据库建表注意"><a href="#2-数据库建表注意" class="headerlink" title="2. 数据库建表注意"></a>2. 数据库建表注意</h2><p><strong>1.一对多关系处理：</strong></p><p>​    <strong>通过学生和班级问题了解一对多：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143534668.png" alt="mark"></p><p><strong>解决方案：</strong></p><ul><li>班级是1端，学生是多端，结合面向对象的思想，1端是父亲，多端是儿子，所以多端具有1端的属性，也就是说多端里面应该放置1端的主键，那么<strong>学生表里面应该放置班级表里面的主键</strong></li></ul><p><strong>2.多对多关系处理：</strong></p><p>  <strong>通过学生选课了解多对多问题的处理：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143627192.png" alt="mark"></p><p><strong>解决方案：</strong></p><ul><li><strong>在多对多中在一个表中添加一个字段就行不通了，所以处理多对多表问题时，就要考虑建立关系表了</strong></li></ul><p><strong>学生表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143739422.png" alt="mark"></p><p><strong>课程表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143932875.png" alt="mark"></p><p><strong>关系表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143947893.png" alt="mark"></p><p>注：所以对于多对多表，通过关系表就建立起了两张表的联系！多对多表时建立主外键后，要先删除约束表内容再删除主表内容</p><p>对于<strong>多对多关系，需要转换成1对多关系</strong>，那么就需要一张中间表来转换，这张中间表里面<strong>需要存放学生表里面的主键和课程表里面的主键</strong>，此时学生与中间表示1对多关系，课程与中间表是1对多关系，学生与课程是多对多关系</p><h2 id="3-解决方案总结"><a href="#3-解决方案总结" class="headerlink" title="3. 解决方案总结"></a>3. 解决方案总结</h2><ol><li><strong>一对一的解决方案</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一对一</span><br><span class="line">一张表的一条记录一定只能与另外一张表的一条记录进行对应，反之亦然。</span><br><span class="line"></span><br><span class="line">学生表：姓名，性别，年龄，身高，体重，籍贯，家庭住址，紧急联系人</span><br><span class="line">其中姓名、性别、年龄、身高，体重属于常用数据，但是籍贯、住址和联系人为不常用数据</span><br><span class="line">如果每次查询都是查询所有数据，不常用的数据就会影响效率，实际又不用</span><br><span class="line"></span><br><span class="line">常用信息表：ID(P)，姓名，性别，年龄，身高，体重</span><br><span class="line">不常用信息表：ID(P)，籍贯，家庭住址，紧急联系人</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">将常用的和不常用的信息分享存储，分成两张表</span><br><span class="line">不常用信息表和常用信息表，保证不常用信息表与常用信息表能够对应上：找一个具有唯一性的</span><br><span class="line">字段来共同连接两张表。</span><br><span class="line">一个常用表中的一条记录永远只能在一张不常用表中匹配一条记录，反之亦然。</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>一对多</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一对多</span><br><span class="line">一张表中有一条记录可以对应另外一张表中的多条记录；但是反过来，另外一张表的一条记录</span><br><span class="line">只能对应第一张表的一条记录，这种关系就是一对多或多对一</span><br><span class="line">母亲与孩子的关系：母亲，孩子两个实体</span><br><span class="line">母亲表：ID(P),名字，年龄，性别</span><br><span class="line">孩子表：ID(P),名字，年龄，性别</span><br><span class="line">以上关系：一个妈妈可以在孩子表中找到多条记录（也可能是一条），但是一个孩子只能找到一个妈妈</span><br><span class="line">是一种典型的一对多的关系。</span><br><span class="line"></span><br><span class="line">但是以上设计：解决了实体的设计表问题，但是没有解决关系问题，孩子找不到母亲，母亲也找不到孩子</span><br><span class="line"></span><br><span class="line">解决方案：在某一张表中增加一个字段，能够找到另外一张表中的记录:在孩子表中增加一个字段</span><br><span class="line">指向母亲表，因为孩子表的记录只能匹配到一条母亲表的记录。</span><br><span class="line">母亲表：ID(P),名字，年龄，性别</span><br><span class="line">孩子表：ID(P),名字，年龄，性别，母亲表ID（母亲表主键）</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>多对多</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">多对多</span><br><span class="line">一对表中（A）的一条记录能够对应另外一张表（B）中的多条记录；同时B表中的一条记录</span><br><span class="line">也能对应A表中的多条记录</span><br><span class="line"></span><br><span class="line">老师和学生</span><br><span class="line">老师表 T_ID(P),姓名，性别</span><br><span class="line">学生表 S_ID(P),姓名，性别</span><br><span class="line">以上设计方案：实现了实体的设计，但是没有维护实体的关系</span><br><span class="line">一个老师教过多个学生，一个学生也被多个老师教过</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决方案：增加一张中间关系表</span><br><span class="line">老师与学生的关系表：ID(P),T_ID,S_ID </span><br><span class="line">老师表与中间表形成一对多的关系，而中间表是多表；维护了能够唯一找到一表的关系；</span><br><span class="line">同样的学生表与中间表也是一个一对多的关系; </span><br><span class="line">学生找老师：找出学生ID---&gt;中间表寻找匹配记录（多条）---&gt;老师表匹配（一条）</span><br><span class="line">老师找学生：找出老师ID---&gt;中间表寻找匹配记录（多条）---&gt;学生表匹配（一条）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-12-一对多-多对一，多对多问题&quot;&gt;&lt;a href=&quot;#Mysql-12-一对多-多对一，多对多问题&quot; class=&quot;headerlink&quot; title=&quot;Mysql-12-一对多,多对一，多对多问题&quot;&gt;&lt;/a&gt;Mysql-12-一对多,多对一，多对多问题&lt;/h1&gt;&lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;​    一对一关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生对应一个学生档案材料，或者每个人都有唯一的身份证编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    一对多关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生只属于一个班，但是一个班级有多名学生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    多对多关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生可以选择多门课，一门课也有多名学生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库建表关系" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-Integer和int</title>
    <link href="http://zhuuu.work/2020/08/23/JavaInterview/Java-%E5%9F%BA%E7%A1%80-Integer%E5%92%8Cint/"/>
    <id>http://zhuuu.work/2020/08/23/JavaInterview/Java-%E5%9F%BA%E7%A1%80-Integer%E5%92%8Cint/</id>
    <published>2020-08-23T09:38:38.000Z</published>
    <updated>2020-08-23T14:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-Integer和int"><a href="#Java-基础-Integer和int" class="headerlink" title="Java-基础-Integer和int"></a>Java-基础-Integer和int</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>int和Integer的区别</strong></p><ul><li><p>Integer的默认值是null，int的默认值是0</p></li><li><p>Integer是int的包装类(引用数据类型 )，int则是java的一种基本数据类型 </p></li><li><p>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </p></li><li><p>Integer变量必须实例化后才能使用，而int变量不需要 </p></li></ul><h2 id="衍生"><a href="#衍生" class="headerlink" title="衍生"></a>衍生</h2><p>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; new Integer(100);</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，<strong>java会自动拆包装为int</strong>，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">int j &#x3D; 100；</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>3、<strong>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false</strong>。（因为 ①当变量值在-128<del>127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②**当变量值在-128</del>127之间时**，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 100;</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br><span class="line">Integer i &#x3D; 128;</span><br><span class="line">Integer j &#x3D; 128;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>对于第4条的原因：<br>java在编译Integer i = 100 ;时，会翻译成为<code>Integer i = Integer.valueOf(100)</code>；，而java API中对Integer类型的valueOf的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)&#123;</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p><p>如果有错误的地方，还请指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-基础-Integer和int&quot;&gt;&lt;a href=&quot;#Java-基础-Integer和int&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-Integer和int&quot;&gt;&lt;/a&gt;Java-基础-Integer和int&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
    
      <category term="Integer" scheme="http://zhuuu.work/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>Redis-16-Redis分布式</title>
    <link href="http://zhuuu.work/2020/08/22/Redis/Redis-16-Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/08/22/Redis/Redis-16-Redis%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2020-08-22T10:32:24.000Z</published>
    <updated>2020-08-26T07:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-16-Redis分布式"><a href="#Redis-16-Redis分布式" class="headerlink" title="Redis-16-Redis分布式"></a>Redis-16-Redis分布式</h1><h2 id="1-为什么用Redis"><a href="#1-为什么用Redis" class="headerlink" title="1. 为什么用Redis?"></a>1. 为什么用Redis?</h2><p>单线程的redis为什么这么快</p><p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。</p><p><strong>回答</strong>:主要是以下三点<br>(一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞<strong>I/O多路复用机制</strong></p><p><strong>关于Redis的 I/O多路复用：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-154227633.png" alt="mark"></p><ul><li>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</li><li>需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库</li></ul><h2 id="2-Redis数据结构应用场景"><a href="#2-Redis数据结构应用场景" class="headerlink" title="2. Redis数据结构应用场景"></a>2. Redis数据结构应用场景</h2><p><strong>redis的数据类型，以及每种数据类型的使用场景</strong></p><p><strong>回答</strong>：一共五种</p><p>(一)String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong>（以及分布式锁）</p><p>(二)hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。就是用这种数据结构存储用户信息，以<code>cookieId</code>作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p><p>(三)list<br>使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</p><p>(四)set<br>因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p><p>另外，就是利用<strong>交集、并集、差集</strong>等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</p><p>(五)<code>sorted set</code><br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>。sorted set可以用来做<strong>延时任务</strong>。最后一个应用就是可以做<strong>范围查找</strong>。</p><h2 id="3-Redis过期策略和内存淘汰机制"><a href="#3-Redis过期策略和内存淘汰机制" class="headerlink" title="3. Redis过期策略和内存淘汰机制"></a>3. Redis过期策略和内存淘汰机制</h2><ul><li>redis的过期策略以及内存淘汰机制</li></ul><p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p><p><strong>回答</strong>:<br>redis采用的是<strong>定期删除+惰性删除策略。</strong></p><p><strong>为什么不用定时删除策略?</strong><br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p><p><strong>定期删除+惰性删除是如何工作的呢?</strong><br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</p><p>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p><p><strong>采用定期删除+惰性删除就没其他问题了么?</strong><br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。</p><p>在redis.conf中有一行配置</p><p># maxmemory-policy volatile-lru</p><p><strong>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</strong><br>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>应该没人用吧。</strong><br>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用，目前项目在用这种。</strong><br>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>应该也没人用吧，你不删最少使用Key,去随机删。</strong><br>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</strong><br>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>依然不推荐</strong><br>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong><br><strong>ps：如果没有设置 <code>expire</code> 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</strong></p><h2 id="4-双写一致性问题"><a href="#4-双写一致性问题" class="headerlink" title="4. 双写一致性问题"></a>4. 双写一致性问题</h2><p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为<strong>最终一致性</strong>和<strong>强一致性</strong>。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p><p><strong>回答</strong>:</p><ul><li>首先，采取正确更新策略，<ul><li>先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li></ul></li></ul><h2 id="5-并发竞争key的问题"><a href="#5-并发竞争key的问题" class="headerlink" title="5. 并发竞争key的问题"></a>5. 并发竞争key的问题</h2><ul><li><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></li></ul><ul><li><strong>回答:</strong>如下所示<br>(1)如果对这个key操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，<strong>要求顺序</strong><br>假设有一个<code>key1</code>,系统A需要将<code>key1</code>设置为<code>valueA</code>,系统B需要将<code>key1</code>设置为<code>valueB</code>,系统C需要将<code>key1</code>设置为<code>valueC</code>.<br>期望按照key1的value值按照 <code>valueA--&gt;valueB--&gt;valueC</code>的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br><span class="line"></span><br><span class="line">那么，假设这会系统B先抢到锁，将key1设置为&#123;valueB 3:05&#125;。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做<span class="built_in">set</span>操作了。以此类推。</span><br><span class="line"></span><br><span class="line">其他方法，比如利用队列，将<span class="built_in">set</span>方法变成串行访问也可以。总之，灵活变通。</span><br></pre></td></tr></table></figure><p><strong>参考博客 ：</strong> <a href="https://blog.csdn.net/tmeng521/article/details/91039391" target="_blank" rel="noopener">https://blog.csdn.net/tmeng521/article/details/91039391</a></p><p>​                    <a href="https://www.cnblogs.com/bigben0123/p/9115597.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigben0123/p/9115597.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis-16-Redis分布式&quot;&gt;&lt;a href=&quot;#Redis-16-Redis分布式&quot; class=&quot;headerlink&quot; title=&quot;Redis-16-Redis分布式&quot;&gt;&lt;/a&gt;Redis-16-Redis分布式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么
      
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="Redis分布式" scheme="http://zhuuu.work/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis-15-mysql和redis缓存不一致</title>
    <link href="http://zhuuu.work/2020/08/22/Redis/Redis-15-mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>http://zhuuu.work/2020/08/22/Redis/Redis-15-mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/</id>
    <published>2020-08-22T10:32:24.000Z</published>
    <updated>2020-09-09T14:38:36.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-15-mysql和redis缓存不一致"><a href="#Redis-15-mysql和redis缓存不一致" class="headerlink" title="Redis-15-mysql和redis缓存不一致"></a>Redis-15-mysql和redis缓存不一致</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>这实际上是个“如果要做的足够精致是非常难的“问题。缓存失效被称为计算机科学里最难的两个问题之一（另外一个是起名字）。</p></li><li><p>先对本题一致性做个说明。这里的不一致是指：假如一个数据访问者同时读取Redis和DB，他能在一段时间里发现二者不一样。</p></li><li><p><strong>不错，如果一份数据放在DB，然后copy到Redis，然后改DB，那么Redis是不会自己魔幻般同步变更的。</strong></p></li><li><p><strong>必须有某种机制告诉Redis该变了。这些机制包括（但不仅仅限于）：</strong></p></li></ul><a id="more"></a><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><ul><li><p>Redis里的数据不立刻更新，等redis里数据自然过期。然后去DB里取，顺带重新set redis。</p></li><li><p>这种用法被称作“Cache Aside”。好处是代码比较简单，坏处是会有一段时间DB和Redis里的数据不一致。</p></li><li><p><strong>这个不一致的时间取决于redis里数据设定的有效期，比如10min。但如果Redis里数据没设置有效期，这招就不灵了。</strong></p></li></ul><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><ul><li>更新DB时总是不直接触碰DB，而是通过代码。而代码做的显式更新DB，然后马上del掉redis里的数据。</li><li>在下次取数据时，模式就恢复到了上一条说的方式。这也算是一种Cache Aside的变体。</li><li>这要做的好处是，数据的一致性会比较好，一般正常情况下，数据不一致的时间会在1s以下，对于绝大部分的场景是足够了。但是有极少几率，由于更新时序，下Redis数据会和DB不一致（这个有文章解释，这里不展开）。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/221825945.png" alt="mark"></p><ul><li><strong>方案1和方案2的做法常规上被称为“Cache“</strong>。</li><li>而且因为1有更新不及时的问题，2有极端情况下数据会不一致的问题，所以常规Cache代码会把1+2组合起来，要求Redis里的数据必须有过期时间，并且不能太长，</li><li>这样即便是不一致也能混过去。同时如果是主动对数据进行更新，Cache的数据更新也会比较及时。</li></ul><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><ul><li><p>并且2并不一定总是行得通。比如OLTP的服务在前面是Cache+DB的模式，而数据是由后台管理系统来更新的，总是不会触碰OLTP服务，更不会动Cache。这时将Redis看作是存储也算是一种方案。就是：</p></li><li><p><strong>Redis里的数据总是不过期，但是有个背景更新任务（“定时执行的代码” 或者 “被队列驱动的代码）读取db，把最新的数据塞给Redis。</strong></p></li><li><p><strong>这种做法将Redis看作是“存储”。</strong>访问者不知道背后的实际数据源，只知道Redis是唯一可以取的数据的地方。当实际数据源更新时，背景更新任务来将数据更新到Redis。这时还是会存在Redis和实际数据源不一致的问题。</p><ul><li>如果是<strong>定时任务</strong>，最长的不一致时长就是更新任务的执行间隔；</li><li>如果是用<strong>类似于队列的方式来更新</strong>，那么不一致时间取决于队列产生和消费的延迟。<ul><li>常用的队列（或等价物）有Redis（怎么还是Redis），Kafka，AMQ，RMQ，binglog，log文件，阿里的canal等。</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/223311394.png" alt="mark"></p><ul><li><strong>这种做法还有一种变体Write Through，写入时直接写DB，DB把数据更新Cache，而读取时读Cache。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/223403561.png" alt="mark"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>以上方式无论如何都会有一段时间Redis和DB会不一致</strong>。实践上，这个不一致时间短则几十ms，长可以到几十分钟。<strong>这种程度的一致性对于很多业务场景都已经足够了</strong></li><li>很多时候，用户无法区分自己读取的是Redis还是DB，只能读取到其中的一个。这时数据看起来直觉上是没问题的就可以接受了。只要不出现，用户先看见了数据是A，然后看到数据是B，之后一刷新，又看到A的尴尬场景就行了。</li><li>但对于有些业务，比如协作文档编辑，电商秒杀的扣库存，银行转账等，以上的做法就不够用了。</li></ul><p><strong>第一种方法</strong></p><ul><li>第一种是不要用Redis，只用DB。或者更直接点说是“只要一个单点的数据源”。这样肯定就没有一致性问题</li><li>代价就是CAP中因为CP被满足，因此A被牺牲掉。这就是为啥银行一系统升级就要停服务的原因。</li></ul><p><strong>第二种方法</strong></p><ul><li>另外一种保证一致性的做法就是用某种分布式协议一致性来做，大致可以归结到<ul><li>SAGA或者TCC - 这两种需要业务代码的大量配合。通过业务代码来补偿一致性。</li><li>2PC, 3PC - 现实当中有XA协议。比如Ehcache是支持XA协议的。但是性能表现不佳，运维也麻烦，我比较少见到实际这么干的。</li><li>基于Paxos或者Raft的分布式锁，然后对Redis和DB进行双写，但是除非客户端和服务器么次都去访问分布式锁，也会有一点点不一致的问题。这实际上相当于将多个地方的一致性控制交给了分布式锁的集中维护。</li></ul></li></ul><p>综上，除了单点DB存储之外的方案，其一致性面临的窘境是</p><ul><li><strong>要么，接受“最终一致”</strong>，但到底多久之后一致，不一致时表现怎么样，有很多种做法。分布式一致性有各种各样的模型，比如线性一致性、顺序一致性等。他们都是在“不一致”和“强一致”之间提供某种折衷。这些折衷大量应用于我们常见的诸多业务之中、如社交、IM、电商不触及钱的地方等</li><li><strong>要么，要求必须强一致。</strong>那么在分布式条件下就要牺牲A。比如访问一个Cache，Cache知道自己的数据不是最新的，就要和DB去Sync，Sync的过程中DB的数据还不能改。期间访问者要不收到一个错误“数据不同步，不能访问”，要不就卡在那里等着同步完成。个人以为，这还不如干脆就不要Cache，在维护强一致的同时，用其他方式来优化访问性能。</li></ul><p><strong>参考博客</strong> ：<a href="https://www.zhihu.com/question/319817091/answer/653985863" target="_blank" rel="noopener">https://www.zhihu.com/question/319817091/answer/653985863</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-15-mysql和redis缓存不一致&quot;&gt;&lt;a href=&quot;#Redis-15-mysql和redis缓存不一致&quot; class=&quot;headerlink&quot; title=&quot;Redis-15-mysql和redis缓存不一致&quot;&gt;&lt;/a&gt;Redis-15-mysql和redis缓存不一致&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这实际上是个“如果要做的足够精致是非常难的“问题。缓存失效被称为计算机科学里最难的两个问题之一（另外一个是起名字）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先对本题一致性做个说明。这里的不一致是指：假如一个数据访问者同时读取Redis和DB，他能在一段时间里发现二者不一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不错，如果一份数据放在DB，然后copy到Redis，然后改DB，那么Redis是不会自己魔幻般同步变更的。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;必须有某种机制告诉Redis该变了。这些机制包括（但不仅仅限于）：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="mysql和redis缓存不一致" scheme="http://zhuuu.work/tags/mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    
      <category term="mysql" scheme="http://zhuuu.work/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-014-最长公共前缀</title>
    <link href="http://zhuuu.work/2020/08/20/Leetcode/Leetcode-014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://zhuuu.work/2020/08/20/Leetcode/Leetcode-014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</id>
    <published>2020-08-20T11:52:53.000Z</published>
    <updated>2020-08-20T05:56:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-014-最长公共前缀"><a href="#Leetcode-014-最长公共前缀" class="headerlink" title="Leetcode-014-最长公共前缀"></a>Leetcode-014-<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">最长公共前缀</a></h1><h2 id="思路：遍历"><a href="#思路：遍历" class="headerlink" title="思路：遍历"></a>思路：遍历</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 横向扫描</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到字符串数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="comment">// 拿到第一个字符串</span></span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两比较，找出最长公共前缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            prefix = longestPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  两两比较，找出最长公共前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longestPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(),str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index))&#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截取字符串</span></span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-014-最长公共前缀&quot;&gt;&lt;a href=&quot;#Leetcode-014-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-014-最长公共前缀&quot;&gt;&lt;/a&gt;Leetcode-014-&lt;a href=&quot;https:/
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>分布式</title>
    <link href="http://zhuuu.work/2020/08/20/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/08/20/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2020-08-20T09:38:38.000Z</published>
    <updated>2020-08-25T07:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1. 分布式锁"></a>1. 分布式锁</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式&quot;&gt;&lt;a href=&quot;#分布式&quot; class=&quot;headerlink&quot; title=&quot;分布式&quot;&gt;&lt;/a&gt;分布式&lt;/h1&gt;&lt;h2 id=&quot;1-分布式锁&quot;&gt;&lt;a href=&quot;#1-分布式锁&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式锁&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="分布式锁" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="分布式事务" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-03-红黑树</title>
    <link href="http://zhuuu.work/2020/08/19/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/08/19/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03-%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-08-19T10:32:24.000Z</published>
    <updated>2020-08-19T07:23:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-03-红黑树"><a href="#数据结构-03-红黑树" class="headerlink" title="数据结构-03-红黑树"></a>数据结构-03-红黑树</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p>数据结构在线生成工具 ： <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><strong>二叉排序树</strong>（Binary Sort Tree）或者是一棵空树；或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点 </li></ol><p><strong>关于红黑树</strong></p><ul><li><p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p></li><li><p>因为一棵由n个结点随机构造的二叉查找树的高度为lgn，所以顺理成章，二叉查找树的一般操作的执行时间为O(lgn)。但二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。</p></li><li><p><strong>红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)，为了保证这个性质，所以红黑树有以下几个特性：</strong></p></li></ul><ol><li><strong>一个节点要么是红的要么就是黑的</strong></li><li><strong>根节点一定是黑色的</strong></li><li><strong>从叶子节点到根节点 黑色节点一定是一致的（黑高）</strong></li><li><strong>不能有两个红色节点相连（叶子节点一定是黑色的）</strong></li><li><strong>一般采用红插法，这样可以保证树不会失衡</strong></li></ol><h2 id="2-红黑树的旋转"><a href="#2-红黑树的旋转" class="headerlink" title="2. 红黑树的旋转"></a>2. 红黑树的旋转</h2><p>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。旋转包括两种：左旋和右旋。如下图所示：</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-03-红黑树&quot;&gt;&lt;a href=&quot;#数据结构-03-红黑树&quot; class=&quot;headerlink&quot; title=&quot;数据结构-03-红黑树&quot;&gt;&lt;/a&gt;数据结构-03-红黑树&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据结构在线生成工具 ： &lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="http://zhuuu.work/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis-14-key有效时间设置</title>
    <link href="http://zhuuu.work/2020/08/19/Redis/Redis-14-key%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <id>http://zhuuu.work/2020/08/19/Redis/Redis-14-key%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/</id>
    <published>2020-08-19T10:32:24.000Z</published>
    <updated>2020-08-19T09:14:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-14-key有效时间设置"><a href="#Redis-14-key有效时间设置" class="headerlink" title="Redis-14-key有效时间设置"></a>Redis-14-key有效时间设置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文对redis的过期处理机制做个简单的概述，让大家有个基本的认识。</li><li><strong>Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的</strong>。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</li></ul><a id="more"></a><h2 id="1-有效时间设置"><a href="#1-有效时间设置" class="headerlink" title="1. 有效时间设置"></a>1. 有效时间设置</h2><p>redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。Expires字典保存了所有键的过期时间，Expires也被称为过期字段。<br>四种处理策略</p><ol><li>EXPIRE 将key的生存时间设置为ttl秒</li><li>PEXPIRE 将key的生成时间设置为ttl毫秒</li><li>EXPIREAT 将key的过期时间设置为timestamp所代表的的秒数的时间戳</li><li>PEXPIREAT 将key的过期时间设置为timestamp所代表的的毫秒数的时间戳</li></ol><p>其实以上几种处理方式都是根据PEXPIREAT来实现的，设置生存时间的时候是redis内部计算好时间之后在内存处理的，最终的处理都会转向PEXPIREAT。<br>1、2两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到redis中。<br>3、4两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。</p><h2 id="2-过期键的删除策略"><a href="#2-过期键的删除策略" class="headerlink" title="2. 过期键的删除策略"></a>2. 过期键的删除策略</h2><p>如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢？？如果不是，那过期后到底什么时候被删除呢？？</p><p>其实有三种不同的删除策略：<br>（1）立即删除。在设置键的过期时间时，创建一个回调事件，当过期时间达到时，由时间处理器自动执行键的删除操作。<br>（2）惰性删除。键过期了就过期了，不管。每次从dict字典中按key取值时，先检查此key是否已经过期，如果过期了就删除它，并返回nil，如果没过期，就返回键值。<br>（3）定时删除。每隔一段时间，对expires字典进行检查，删除里面的过期键。<br>可以看到，第二种为被动删除，第一种和第三种为主动删除，且第一种实时性更高。下面对这三种删除策略进行具体分析。</p><h3 id="2-1-立即删除"><a href="#2-1-立即删除" class="headerlink" title="2.1 立即删除"></a>2.1 立即删除</h3><ul><li><p>立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是<strong>立即删除对cpu是最不友好的</strong>。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力。</p></li><li><p>而且目前redis事件处理器对时间事件的处理方式–无序链表，查找一个key的时间复杂度为O(n),所以并不适合用来处理大量的时间事件。</p></li></ul><h3 id="2-2-惰性删除"><a href="#2-2-惰性删除" class="headerlink" title="2.2 惰性删除"></a>2.2 惰性删除</h3><ul><li><p>惰性删除是指，某个键值过期后，此键值不会马上被删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。所以惰性删除的缺点很明显:<strong>浪费内存</strong>。dict字典和expires字典都要保存这个键值的信息。</p></li><li><p>举个例子，对于一些按时间点来更新的数据，比如log日志，过期后在很长的一段时间内可能都得不到访问，这样在这段时间内就要拜拜浪费这么多内存来存log。<strong>这对于性能非常依赖于内存大小的redis来说，是比较致命的</strong>。</p></li></ul><h3 id="2-3-定时删除"><a href="#2-3-定时删除" class="headerlink" title="2.3 定时删除"></a>2.3 定时删除</h3><ul><li>从上面分析来看，立即删除会短时间内占用大量cpu，惰性删除会在一段时间内浪费内存，所以定时删除是一个折中的办法。</li><li>定时删除是：每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对cpu的影响。另一方面定时删除也有效的减少了因惰性删除带来的内存浪费。</li></ul><p><strong>redis使用的过期键值删除策略是：惰性删除加上定期删除，两者配合使用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-14-key有效时间设置&quot;&gt;&lt;a href=&quot;#Redis-14-key有效时间设置&quot; class=&quot;headerlink&quot; title=&quot;Redis-14-key有效时间设置&quot;&gt;&lt;/a&gt;Redis-14-key有效时间设置&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文对redis的过期处理机制做个简单的概述，让大家有个基本的认识。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的&lt;/strong&gt;。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux-01-网络IO</title>
    <link href="http://zhuuu.work/2020/08/18/Linux/Linux-01-%E7%BD%91%E7%BB%9CIO/"/>
    <id>http://zhuuu.work/2020/08/18/Linux/Linux-01-%E7%BD%91%E7%BB%9CIO/</id>
    <published>2020-08-18T07:52:53.000Z</published>
    <updated>2020-08-30T09:22:47.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-01-网络IO"><a href="#Linux-01-网络IO" class="headerlink" title="Linux-01-网络IO"></a>Linux-01-网络IO</h1><p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1-用户空间与内核空间"><a href="#1-用户空间与内核空间" class="headerlink" title="1. 用户空间与内核空间"></a>1. 用户空间与内核空间</h3><ul><li>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，<strong>它的寻址空间（虚拟存储空间）为4G（2的32次方）</strong>。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</li><li><strong>针对linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），供内核使用，称为内核空间，</strong></li><li><strong>而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间。</strong></li></ul><h3 id="2-进程切换"><a href="#2-进程切换" class="headerlink" title="2. 进程切换"></a>2. 进程切换</h3><ul><li><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol></li></ul><h3 id="3-进程阻塞"><a href="#3-进程阻塞" class="headerlink" title="3. 进程阻塞"></a>3. 进程阻塞</h3><ul><li>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</li></ul><h3 id="4-文件描述符fd"><a href="#4-文件描述符fd" class="headerlink" title="4. 文件描述符fd"></a>4. 文件描述符fd</h3><ul><li>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</li><li><strong>文件描述符在形式上是一个非负整数。实际上，它是一个索引值</strong>，指向<strong>内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</li></ul><h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><ul><li><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<br><strong>1. 等待数据准备 (Waiting for the data to be ready)</strong><br><strong>2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</strong></p></li><li><p><strong>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</strong><br><strong>- 阻塞 I/O（blocking IO）</strong><br><strong>- 非阻塞 I/O（nonblocking IO）</strong><br><strong>- I/O 多路复用（ IO multiplexing）</strong><br><strong>- 信号驱动 I/O（ signal driven IO）</strong><br><strong>- 异步 I/O（asynchronous IO）</strong></p></li></ul><p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><h3 id="1-阻塞-I-O（blocking-IO）"><a href="#1-阻塞-I-O（blocking-IO）" class="headerlink" title="1. 阻塞 I/O（blocking IO）"></a>1. 阻塞 I/O（blocking IO）</h3><ul><li>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-162629646.png" alt="mark"></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。</p><p>这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h3 id="2-非阻塞-I-O（nonblocking-IO）"><a href="#2-非阻塞-I-O（nonblocking-IO）" class="headerlink" title="2. 非阻塞 I/O（nonblocking IO）"></a>2. 非阻塞 I/O（nonblocking IO）</h3><ul><li>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-163037584.png" alt="mark"></p><ul><li>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。</li><li>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。</li><li>用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</li></ul><blockquote><p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p></blockquote><h3 id="3-异步-I-O（asynchronous-IO）"><a href="#3-异步-I-O（asynchronous-IO）" class="headerlink" title="3. 异步 I/O（asynchronous IO）"></a>3. 异步 I/O（asynchronous IO）</h3><ul><li>Linux下的asynchronous IO其实用得很少。先看一下它的流程：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-164148525.png" alt="mark"></p><h3 id="4-I-O-多路复用（-IO-multiplexing）"><a href="#4-I-O-多路复用（-IO-multiplexing）" class="headerlink" title="4. I/O 多路复用（ IO multiplexing）"></a>4. I/O 多路复用（ IO multiplexing）</h3><ul><li><code>IO multiplexing</code>就是我们说的<code>select，poll，epoll</code>，有些地方也称这种IO方式为<code>event driven IO select/epoll</code>的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是<code>select，poll，epoll</code>这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-165609923.png" alt="mark"></p><ul><li><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</li></ul><ul><li><p>所以，I/O 多路复用的特点是<strong>通过一种机制一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p></li><li><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p></li><li><p>在IO multiplexing Model中，实际中，对于每一个<code>socket</code>，一般都设置成为<code>non-blocking</code>，但是，如上图所示，整个用户的<code>process</code>其实是一直被<code>block</code>的。只不过<code>process</code>是被<code>select</code>这个函数<code>block</code>，而不是被<code>socket IO</code>给<code>block</code>。</p></li></ul><h2 id="select-poll-epoll-详解"><a href="#select-poll-epoll-详解" class="headerlink" title="select poll epoll 详解"></a>select poll epoll 详解</h2><p><strong>总结的不错的博客:</strong> <a href="https://blog.csdn.net/jiange_zh/article/details/50811553" target="_blank" rel="noopener">https://blog.csdn.net/jiange_zh/article/details/50811553</a></p><p>(1)select==&gt;时间复杂度O(n)</p><ul><li>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200830/142733029.png" alt="mark"></p><p>(2)poll==&gt;时间复杂度O(n)</p><ul><li>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</li></ul><p>(3)epoll==&gt;时间复杂度O(1)</p><ul><li><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200830/142834510.png" alt="mark"></p><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 </p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><p><strong>epoll的工作方式</strong></p><p>epoll的两种工作方式：<strong>1.水平触发（LT）2.边缘触发（ET）</strong> </p><p><strong>LT模式：</strong></p><ul><li>若就绪的事件一次没有处理完要做的事件，就会一直去处理。</li><li>即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 </li></ul><p><strong>ET模式：</strong></p><ul><li>就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。</li><li>而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。 </li></ul><p>由此可见：ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。<br>注意：ET模式只支持非阻塞的读写：为了保证数据的完整性。</p><p><strong>总结：</strong></p><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-blocking和non-blocking的区别"><a href="#1-blocking和non-blocking的区别" class="headerlink" title="1. blocking和non-blocking的区别"></a>1. blocking和non-blocking的区别</h3><ul><li>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</li></ul><h3 id="2-synchronous-IO和asynchronous-IO的区别"><a href="#2-synchronous-IO和asynchronous-IO的区别" class="headerlink" title="2. synchronous IO和asynchronous IO的区别"></a>2. synchronous IO和asynchronous IO的区别</h3><ul><li>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</li></ul><p><strong>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</strong></p><ul><li><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。<strong>但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</strong></p></li><li><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-01-网络IO&quot;&gt;&lt;a href=&quot;#Linux-01-网络IO&quot; class=&quot;headerlink&quot; title=&quot;Linux-01-网络IO&quot;&gt;&lt;/a&gt;Linux-01-网络IO&lt;/h1&gt;&lt;p&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="多路复用" scheme="http://zhuuu.work/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-XX-Mysql面试总结</title>
    <link href="http://zhuuu.work/2020/08/17/Mysql/Mysql-XX-Mysql%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://zhuuu.work/2020/08/17/Mysql/Mysql-XX-Mysql%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-17T08:02:27.000Z</published>
    <updated>2020-08-17T01:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-XX-Mysql面试总结"><a href="#Mysql-XX-Mysql面试总结" class="headerlink" title="Mysql-XX-Mysql面试总结"></a>Mysql-XX-Mysql面试总结</h1><p><a href="https://www.jianshu.com/p/c189439fb32e" target="_blank" rel="noopener">https://www.jianshu.com/p/c189439fb32e</a> <strong>一定要看</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql-XX-Mysql面试总结&quot;&gt;&lt;a href=&quot;#Mysql-XX-Mysql面试总结&quot; class=&quot;headerlink&quot; title=&quot;Mysql-XX-Mysql面试总结&quot;&gt;&lt;/a&gt;Mysql-XX-Mysql面试总结&lt;/h1&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-interrupt()</title>
    <link href="http://zhuuu.work/2020/08/17/JavaInterview/Java-%E5%9F%BA%E7%A1%80-interrupt()/"/>
    <id>http://zhuuu.work/2020/08/17/JavaInterview/Java-%E5%9F%BA%E7%A1%80-interrupt()/</id>
    <published>2020-08-17T03:38:38.000Z</published>
    <updated>2020-09-07T11:11:15.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-interrupt"><a href="#Java-基础-interrupt" class="headerlink" title="Java-基础-interrupt()"></a>Java-基础-interrupt()</h1><h2 id="1-InterruptedException"><a href="#1-InterruptedException" class="headerlink" title="1. InterruptedException"></a>1. InterruptedException</h2><ul><li>当一个方法后面声明可能会抛出<code>InterruptedException</code>异常时，说明该方法是可能会花一点时间，但是可以取消的方法。</li></ul><ul><li>抛<code>InterruptedException</code>的代表方法有：<ul><li><code>java.lang.Object</code> 类的 wait 方法</li><li><code>java.lang.Thread</code> 类的 sleep 方法</li><li><code>java.lang.Thread</code> 类的 join 方法</li></ul></li></ul><a id="more"></a><p>– 需要花点时间的方法</p><ul><li><p>执行<code>wait</code>方法的线程，会进入等待区等待被<code>notify/notify All</code>。在等待期间，线程不会活动。</p></li><li><p>执行<code>sleep</code>方法的线程，会暂停执行参数内所设置的时间。</p></li><li><p>执行<code>join</code>方法的线程，会等待到指定的线程结束为止。</p></li></ul><p>因此，上面的方法都是需要花点时间的方法。</p><p>– 可以取消的方法</p><ul><li>因为需要花时间的操作会降低程序的响应性，所以可能会取消/中途放弃执行这个方法。</li><li>这里主要是通过interrupt方法来取消。</li></ul><ol><li><strong>sleep方法与interrupt方法</strong></li></ol><ul><li>interrupt方法是Thread类的实例方法，在执行的时候并不需要获取Thread实例的锁定，任何线程在任何时刻，都可以通过线程实例来调用其他线程的interrupt方法。</li><li>当在sleep中的线程被调用interrupt方法时，就会放弃暂停的状态，并抛出<code>InterruptedException</code>异常，这样一来，线程的控制权就交给了捕捉这个异常的catch块了。</li></ul><ol start="2"><li><strong>wait方法和interrupt方法</strong></li></ol><ul><li>当线程调用<code>wait</code>方法后，<strong>线程在进入等待区时，会把锁定解除</strong>。</li><li>当对wait中的线程调用<code>interrupt</code>方法时，<strong>会先重新获取锁定</strong>，再抛出<code>InterruptedException</code>异常，获取锁定之前，无法抛出<code>InterruptedException</code>异常。</li></ul><ol start="3"><li><strong>join方法和interrupt方法</strong></li></ol><ul><li>当线程以join方法等待其他线程结束时，一样可以使用interrupt方法取消。因为join方法不需要获取锁定，故而与sleep一样，会马上跳到catch程序块</li></ul><p><strong>线程中断</strong></p><ul><li>每一个线程都有一个boolean类型的标志，此标志意思是当前的请求是否请求中断，默认为false。</li><li>当一个线程A调用了线程B的interrupt方法时，那么线程B的是否请求的中断标志变为true。而线程B可以调用方法检测到此标志的变化。</li></ul><ol><li><strong>对于阻塞方法（join,sleep,wait）</strong></li></ol><ul><li>如果线程B调用了阻塞方法，如果是否请求中断标志变为了true，那么它会抛出InterruptedException异常。<strong>抛出异常的同时它会将线程B的是否请求中断标志置为false</strong></li></ul><ol start="2"><li><strong>对于非阻塞方法</strong></li></ol><ul><li>可以通过线程B的<code>isInterrupted</code>方法进行检测是否请求中断标志为true还是false</li><li>另外还有一个静态的方法<code>interrupted</code>方法也可以检测标志。但是静态方法它检测完以后会自动的将是否请求中断标志位置为false</li></ul><h2 id="2-interrupt-方法"><a href="#2-interrupt-方法" class="headerlink" title="2. interrupt()方法"></a>2. interrupt()方法</h2><ul><li><strong>interrupt方法其实只是改变了中断状态而已。</strong></li><li><strong>而sleep、wait和join这些方法的内部会不断的检查中断状态的值，从而自己抛出InterruptEdException。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，如果在线程进行其他处理时，调用了它的interrupt方法，线程也不会抛出InterruptedException的，只有当线程走到了sleep, wait, join这些方法的时候，才会抛出InterruptedException。若是没有调用sleep, wait, join这些方法，或者没有在线程里自己检查中断状态，自己抛出InterruptedException，那InterruptedException是不会抛出来的。</span><br></pre></td></tr></table></figure><h2 id="3-isInterrupted-方法"><a href="#3-isInterrupted-方法" class="headerlink" title="3. isInterrupted() 方法"></a>3. isInterrupted() 方法</h2><ul><li>可以用来检查中断状态，并且不会清除</li></ul><h2 id="4-interrupted（）-方法"><a href="#4-interrupted（）-方法" class="headerlink" title="4. interrupted（） 方法"></a>4. interrupted（） 方法</h2><ul><li>可以用来检查并清除中断状态。</li></ul><h2 id="5-InterruptedException-的处理"><a href="#5-InterruptedException-的处理" class="headerlink" title="5. InterruptedException 的处理"></a>5. InterruptedException 的处理</h2><ul><li>现在知道线程可以检测到自身的标志位的变化，但是他只是一个标志，<strong>如果线程本身不处理的话，那么程序还是会执行下去</strong>，就好比，老师在学校叮嘱要好好学习，具体什么时候，如何好好学习还是看自身。</li><li>因此<code>interrupt()</code> 方法并不能立即中断线程，该方法仅仅告诉线程外部已经有中断请求，至于是否中断还取决于线程自己</li></ul><p>简单的了解了什么是阻塞和中断以后，我们就该了解碰到<code>InterruptedException</code>异常该如何处理了。</p><p><strong>一句话：不要不管不顾</strong></p><ul><li><strong>有时候阻塞的方法抛出<code>InterruptedException</code>异常并不合适</strong>，例如在<code>Runnable</code>中调用了可中断的方法，因为你的程序是实现了<code>Runnable</code>接口，然后在重写<code>Runnable</code>接口的<code>run</code>方法的时候，那么子类抛出的异常要小于等于父类的异常。而在<code>Runnable</code>中<code>run</code>方法是没有抛异常的。<strong>所以此时是不能抛出InterruptedException异常</strong>。</li><li>如果<strong>此时你只是记录日志的话</strong>，那么就是一个<strong>不负责任的做法</strong>，<strong>因为在捕获<code>InterruptedException</code>异常的时候自动的将 是否请求中断标志置为了false。</strong></li><li><strong>至少在捕获了<code>InterruptedException</code>异常之后，如果你什么也不想做，那么就将标志重新置为<code>true</code></strong>，<strong>以便栈中更高层的代码能知道中断，并且对中断作出响应。</strong></li></ul><p><strong>捕获到InterruptedException异常后恢复中断状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.queue = queue; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                 Task task = queue.take(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                 task.execute();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">             <span class="comment">// Restore the interrupted status</span></span><br><span class="line">             <span class="comment">// 向上保存中断的状态</span></span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-interrupt&quot;&gt;&lt;a href=&quot;#Java-基础-interrupt&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-interrupt()&quot;&gt;&lt;/a&gt;Java-基础-interrupt()&lt;/h1&gt;&lt;h2 id=&quot;1-InterruptedException&quot;&gt;&lt;a href=&quot;#1-InterruptedException&quot; class=&quot;headerlink&quot; title=&quot;1. InterruptedException&quot;&gt;&lt;/a&gt;1. InterruptedException&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当一个方法后面声明可能会抛出&lt;code&gt;InterruptedException&lt;/code&gt;异常时，说明该方法是可能会花一点时间，但是可以取消的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;抛&lt;code&gt;InterruptedException&lt;/code&gt;的代表方法有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java.lang.Object&lt;/code&gt; 类的 wait 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt; 类的 sleep 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt; 类的 join 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="打断" scheme="http://zhuuu.work/tags/%E6%89%93%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码-01-DI注入</title>
    <link href="http://zhuuu.work/2020/08/16/Spring/Spring%E6%BA%90%E7%A0%81-01-DI%E6%B3%A8%E5%85%A5/"/>
    <id>http://zhuuu.work/2020/08/16/Spring/Spring%E6%BA%90%E7%A0%81-01-DI%E6%B3%A8%E5%85%A5/</id>
    <published>2020-08-16T07:02:24.000Z</published>
    <updated>2020-08-16T08:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码-01-DI注入"><a href="#Spring源码-01-DI注入" class="headerlink" title="Spring源码-01-DI注入"></a>Spring源码-01-DI注入</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>比如提到spring的自动注入作为一个java程序员肯定自信无比了解；但是笔者要说的自动注入可能会和你理解有很大出入。</li><li>自动注入需要相对于手动装配来说；在spring应用程序当中假设你的A类依赖了B类，需要在A类当中提供一个B类的属性，再加上setter，继而在xml当中配置、描述一下这两个类之间的依赖关系。如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；</li><li>这种由程序员自己配置、描述好依赖关系的写法叫做手动装配；看个例子吧；</li></ul><a id="more"></a><h2 id="1-DI装配方式"><a href="#1-DI装配方式" class="headerlink" title="1. DI装配方式"></a>1. DI装配方式</h2><h3 id="1-1-手动装配"><a href="#1-1-手动装配" class="headerlink" title="1.1 手动装配"></a>1.1 手动装配</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.luban.app;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">B b;</span><br><span class="line">public void setB(B b) &#123;</span><br><span class="line">this.b = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.luban.app;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.luban.app.A"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 由程序员手动指定的依赖关系 称为手动装配--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"b"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span>  <span class="attr">class</span>=<span class="string">"com.luban.app.B"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>但是实际开发中手动装配的场景比较少(比如在缺少源码的情况下可能会使用这种手动装配情况)；<br>关于依赖注入的资料可以参考官网</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies</a></li><li>这一章节提到了一个非常重要的知识点，<strong>也是一个常见的spring面试题目。spring有几种依赖注入方式？那么这个问题应该怎么回答呢？</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200816-162155273.png" alt="mark"></p><h3 id="1-2-DI注入两种方式"><a href="#1-2-DI注入两种方式" class="headerlink" title="1.2 DI注入两种方式"></a>1.2 DI注入两种方式</h3><ul><li><p>官网的意思是DI(依赖注入)一共有两种主要的变体（注意会考），分别是基于构造方法的依赖注入和基于setter（setXxxx(…)）的依赖注入</p></li><li><p>不管是手动装配还是自动装配都是基于这两种方式或者变体方式来的；但是这里一定要回答到主要和变体两个名词，因为有的注入方式就不是这两种，而是这两种其中一种的变体方式；比如在一个类的属性上面加@Autowired，这种方式注入属性的方式就是利用了java的反射知识，</p></li><li><p><code>field.set(value,targetObject)</code>;关于这个我在后面的文章中对spring源码解析的时候会说明<code>@Autowired</code>的原理；所以<code>@Autowired</code>这种注入的方式是setter注入方式的一种变体</p></li><li><p>但是这里需要说明的是所谓的setter其实和属性无关，什么意思呢？一般的setter方法会对应一个属性，但是spring的基于setter的注入方式是不需要属性的，仅仅只需要一个setter方法，下面这个例子来说明这个问题.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring源码-01-DI注入&quot;&gt;&lt;a href=&quot;#Spring源码-01-DI注入&quot; class=&quot;headerlink&quot; title=&quot;Spring源码-01-DI注入&quot;&gt;&lt;/a&gt;Spring源码-01-DI注入&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;比如提到spring的自动注入作为一个java程序员肯定自信无比了解；但是笔者要说的自动注入可能会和你理解有很大出入。&lt;/li&gt;
&lt;li&gt;自动注入需要相对于手动装配来说；在spring应用程序当中假设你的A类依赖了B类，需要在A类当中提供一个B类的属性，再加上setter，继而在xml当中配置、描述一下这两个类之间的依赖关系。如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；&lt;/li&gt;
&lt;li&gt;这种由程序员自己配置、描述好依赖关系的写法叫做手动装配；看个例子吧；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
      <category term="Spring源码学习" scheme="http://zhuuu.work/tags/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序-01-堆排序</title>
    <link href="http://zhuuu.work/2020/08/12/Sort/%E6%8E%92%E5%BA%8F-01-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/08/12/Sort/%E6%8E%92%E5%BA%8F-01-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-12T10:32:24.000Z</published>
    <updated>2020-09-01T13:14:24.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-01-堆排序"><a href="#排序-01-堆排序" class="headerlink" title="排序-01-堆排序"></a>排序-01-堆排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</li></ul><h2 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h2><ul><li>堆是具有如下性质的完全二叉树<ul><li>每个节点的值都大于或者等于其左右孩子节点的值，成为大顶堆</li><li>每个节点的值都小于或者等于其左右孩子节点的值，成为小顶堆</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210713650.png" alt="mark"></p><p>同时，将堆中节点按照层级进行编号，将这种逻辑结构映射到数组中就是如下的例子</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210812092.png" alt="mark"></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p><a id="more"></a><h2 id="2-堆排序介绍"><a href="#2-堆排序介绍" class="headerlink" title="2. 堆排序介绍"></a>2. 堆排序介绍</h2><ul><li>堆排序(Heap Sort) 是指利用堆这种数据结构所涉及的一种排序算法。</li><li><strong>将n个无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></li><li><strong>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></li><li><strong>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></li></ul><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/211132796.png" alt="mark"></p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"排序前："</span>+Arrays.toString(arr));</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(<span class="string">"排序前："</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-202023330.gif" alt="mark"></p><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p><a href="https://blog.csdn.net/qq_36186690/article/details/82505569" target="_blank" rel="noopener">https://blog.csdn.net/qq_36186690/article/details/82505569</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p>再简单总结下堆排序的基本思路：</p><p>　　<strong>a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-01-堆排序&quot;&gt;&lt;a href=&quot;#排序-01-堆排序&quot; class=&quot;headerlink&quot; title=&quot;排序-01-堆排序&quot;&gt;&lt;/a&gt;排序-01-堆排序&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆排序是利用&lt;strong&gt;堆&lt;/strong&gt;这种数据结构而设计的一种排序算法，堆排序是一种&lt;strong&gt;选择排序，&lt;/strong&gt;它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-堆&quot;&gt;&lt;a href=&quot;#1-堆&quot; class=&quot;headerlink&quot; title=&quot;1. 堆&quot;&gt;&lt;/a&gt;1. 堆&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆是具有如下性质的完全二叉树&lt;ul&gt;
&lt;li&gt;每个节点的值都大于或者等于其左右孩子节点的值，成为大顶堆&lt;/li&gt;
&lt;li&gt;每个节点的值都小于或者等于其左右孩子节点的值，成为小顶堆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210713650.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时，将堆中节点按照层级进行编号，将这种逻辑结构映射到数组中就是如下的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210812092.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大顶堆：arr[i] &amp;gt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;gt;= arr[2i+2]&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小顶堆：arr[i] &amp;lt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;lt;= arr[2i+2]&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆排序" scheme="http://zhuuu.work/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-11-慢查询优化</title>
    <link href="http://zhuuu.work/2020/08/12/Mysql/Mysql-11-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://zhuuu.work/2020/08/12/Mysql/Mysql-11-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2020-08-12T08:02:27.000Z</published>
    <updated>2020-09-03T12:14:03.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-11-慢查询优化"><a href="#Mysql-11-慢查询优化" class="headerlink" title="Mysql-11-慢查询优化"></a>Mysql-11-慢查询优化</h1><p><strong>注意sql查询慢的原因都是:引起filesort</strong></p><a id="more"></a><h2 id="1-分析慢查询日志"><a href="#1-分析慢查询日志" class="headerlink" title="1. 分析慢查询日志"></a>1. 分析慢查询日志</h2><ul><li><p>直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句</p><p>   例如：执行<code>EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">得到如下结果： 显示结果分析：  </span><br><span class="line"></span><br><span class="line">            table |  type | possible_keys | key |key_len  | ref | rows | Extra  EXPLAIN列的解释：           </span><br><span class="line"></span><br><span class="line">            table                 显示这一行的数据是关于哪张表的           </span><br><span class="line"></span><br><span class="line">           type                  这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL </span><br><span class="line"></span><br><span class="line">            rows                显示需要扫描行数</span><br><span class="line"></span><br><span class="line">            key                   使用的索引</span><br></pre></td></tr></table></figure><h2 id="2-优化一：索引"><a href="#2-优化一：索引" class="headerlink" title="2. 优化一：索引"></a>2. 优化一：索引</h2><ol><li>使用LIKE关键字的查询语句</li></ol><p>​    在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</p><ol start="2"><li>使用多列索引的查询语句</li></ol><p>​    MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</p><!--more--><h2 id="3-优化二-：-表结构"><a href="#3-优化二-：-表结构" class="headerlink" title="3. 优化二 ： 表结构"></a>3. 优化二 ： 表结构</h2><ul><li>合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，<strong>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</strong></li></ul><ol><li><strong>将字段很多的表分解成多个表</strong> </li></ol><p>​    <strong>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</strong>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><ol start="2"><li><strong>增加中间表</strong></li></ol><p>​    <strong>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中</strong>，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</p><h2 id="4-优化三-：-分解关联查询"><a href="#4-优化三-：-分解关联查询" class="headerlink" title="4. 优化三 ： 分解关联查询"></a>4. 优化三 ： 分解关联查询</h2><p>将一个大的查询分解为多个小查询是很有必要的。<strong>(检查自己的sql是不是写错了)</strong></p><p> 很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag </span><br><span class="line">        JOIN tag_post ON tag_id = tag.id</span><br><span class="line">        JOIN post ON tag_post.post_id = post.id</span><br><span class="line">        WHERE tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line">        分解为：</span><br><span class="line"></span><br><span class="line">        SELECT * FROM tag WHERE tag = <span class="string">'mysql'</span>;</span><br><span class="line">        SELECT * FROM tag_post WHERE tag_id = <span class="number">1234</span>;</span><br><span class="line">        SELECT * FROM post WHERE post.<span class="function">id <span class="title">in</span> <span class="params">(<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="5-优化四：-范围查询优化"><a href="#5-优化四：-范围查询优化" class="headerlink" title="5. 优化四： 范围查询优化"></a>5. 优化四： 范围查询优化</h2><ol><li><strong>优化limit分页</strong></li></ol><ul><li>在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</li><li>一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</li></ul><ol start="2"><li><p><strong>索引覆盖</strong></p><p>优化此类查询的一个最简单的方法是<strong>尽可能的使用索引覆盖扫描</strong>，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p>对于下面的查询：</p></li></ol><p>​    select id,title from collect limit 90000,10;</p><p>   该语句存在的<strong>最大问题在于limit M,N中偏移量M太大</strong>（我们暂不考虑筛选字段上要不要添加索引的影响），导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。 <strong>试想，如我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的100条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到100条满足条件的记录了。</strong></p><h3 id="方法一：虑筛选字段（title）上加索引"><a href="#方法一：虑筛选字段（title）上加索引" class="headerlink" title="方法一：虑筛选字段（title）上加索引"></a>方法一：虑筛选字段（title）上加索引</h3><p>​    title字段加索引 （此效率如何未加验证）</p><h3 id="方法二：先查询出主键id值"><a href="#方法二：先查询出主键id值" class="headerlink" title="方法二：先查询出主键id值"></a>方法二：先查询出主键id值</h3><p><code>select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</code></p><p><strong>原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。</strong></p><h3 id="方法三：-“关延迟联”"><a href="#方法三：-“关延迟联”" class="headerlink" title="方法三：\“关延迟联”**"></a>方法三：<strong><em>\</em>“关延迟联”**</strong></h3><p>如果这个表非常大，那么这个查询可以改写成如下的方式：</p><p>   <code>Select news.id, news.description from news inner join (select id from news order by title limit 50000,5) as myNew using(id);</code></p><p>​    这里的<strong><em>\</em>“关延迟联”**</strong>将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。</p><h3 id="方法四：建立复合索引-acct-id和create-time"><a href="#方法四：建立复合索引-acct-id和create-time" class="headerlink" title="方法四：建立复合索引 acct_id和create_time"></a>方法四：建立复合索引 acct_id和create_time</h3><p>  select * from acct_trans_log WHERE  acct_id = 3095  order by create_time desc limit 0,10</p><h2 id="6-优化五：分析具体的SQL联表（子）查询"><a href="#6-优化五：分析具体的SQL联表（子）查询" class="headerlink" title="6. 优化五：分析具体的SQL联表（子）查询"></a>6. 优化五：分析具体的SQL联表（子）查询</h2><p><strong>1、两个表选哪个为驱动表，表面是可以以数据量的大小作为依据，但是实际经验最好交给mysql查询优化器自己去判断。</strong></p><p><strong>例如： select * from a where id in (select id from b );</strong> </p><ul><li>对于这条sql语句它的执行计划其实并不是先查询出b表的所有id,然后再与a表的id进行比较。<br><strong>mysql会把in子查询转换成exists相关子查询</strong>，所以它实际等同于这条sql语句：select * from a where exists(select * from b where b.id=a.id );</li><li><strong>而exists相关子查询的执行原理是</strong>: 循环取出a表的每一条记录与b表进行比较，比较的条件是a.id=b.id . 看a表的每条记录的id是否在b表存在，如果存在就行返回a表的这条记录。</li></ul><p><strong><em>\</em>exists查询有什么弊端？**</strong><br>   由exists执行原理可知，a表(外表)使用不了索引，必须全表扫描，因为是拿a表的数据到b表查。而且必须得使用a表的数据到b表中查（外表到里表中），顺序是固定死的。</p><p><strong><em>\</em>如何优化？**</strong><br>   建索引。但是由上面分析可知，要建索引只能在b表的id字段建，不能在a表的id上，mysql利用不上。</p><p><strong><em>\</em>为什么要反过来？**</strong><br>    因为首先可以肯定的是反过来的结果也是一样的。这样就又引出了一个更细致的疑问：在双方两个表的id字段上都建有索引时，到底是a表查b表的效率高，还是b表查a表的效率高？</p><p><strong><em>\</em>该如何进一步优化？**</strong><br>    把查询修改成inner join连接查询：select * from a inner join b on a.id=b.id; （但是仅此还不够，接着往下看）</p><p><strong><em>\</em>为什么不用left join 和 right join？**</strong><br>    这时候表之间的连接的顺序就被固定住了，比如左连接就是必须先查左表全表扫描，然后一条一条的到另外表去查询，右连接同理。仍然不是最好的选择。</p><p><strong><em>\</em>为什么使用inner join就可以？**</strong><br>    inner join中的两张表，如： a inner join b，但实际执行的顺序是跟写法的顺序没有半毛钱关系的，最终执行也可能会是b连接a，顺序不是固定死的。如果on条件字段有索引的情况下，同样可以使用上索引。</p><p><strong>那我们又怎么能知道a和b什么样的执行顺序效率更高？</strong><br>    你不知道，我也不知道。谁知道？mysql自己知道。让mysql自己去判断（查询优化器）。具体表的连接顺序和使用索引情况，mysql查询优化器会对每种情况做出成本评估，最终选择最优的那个做为执行计划。</p><p>​    <strong>在inner join的连接中,mysql会自己评估使用a表查b表的效率高还是b表查a表高，如果两个表都建有索引的情况下，mysql同样会评估使用a表条件字段上的索引效率高还是b表的。</strong></p><p><strong>利用explain字段查看执行时运用到的key（索引）</strong><br>    <strong>而我们要做的就是：把两个表的连接条件的两个字段都各自建立上索引，然后explain 一下，查看执行计划，看mysql到底利用了哪个索引，最后再把没有使用索引的表的字段索引给去掉就行了。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-11-慢查询优化&quot;&gt;&lt;a href=&quot;#Mysql-11-慢查询优化&quot; class=&quot;headerlink&quot; title=&quot;Mysql-11-慢查询优化&quot;&gt;&lt;/a&gt;Mysql-11-慢查询优化&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注意sql查询慢的原因都是:引起filesort&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-类初始化造成的死锁</title>
    <link href="http://zhuuu.work/2020/08/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%A0%E6%88%90%E7%9A%84%E6%AD%BB%E9%94%81/"/>
    <id>http://zhuuu.work/2020/08/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%A0%E6%88%90%E7%9A%84%E6%AD%BB%E9%94%81/</id>
    <published>2020-08-12T04:38:38.000Z</published>
    <updated>2020-09-06T00:53:57.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-类初始化造成的死锁"><a href="#Java-基础-类初始化造成的死锁" class="headerlink" title="Java-基础-类初始化造成的死锁"></a>Java-基础-类初始化造成的死锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于类初始化有几个关键特性：</p><ul><li>类初始化的过程其实就是执行类构造器方法<clinit>()的过程；</li><li>在子类初始化完成时，虚拟机会保证其父类有初始化完成；</li><li>多线程环境下，虚拟机执行<clinit>()方法会自动加锁；</li></ul><p>在java中，死锁肯定是在多线程环境下产生的。<strong>多个线程同时需要互相持有的某个资源，自己的资源无法释放，别人的资源又无法得到，造成循环依赖</strong>，进而一直阻塞在那里，这样就形成死锁了。</p><a id="more"></a><h2 id="1-两个类初始化互相依赖"><a href="#1-两个类初始化互相依赖" class="headerlink" title="1. 两个类初始化互相依赖"></a>1. 两个类初始化互相依赖</h2><ul><li>最明显的情况是，2个类在不同的线程中初始化，彼此互相依赖，我们来看个例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"class A init."</span>);</span><br><span class="line">            B b = <span class="keyword">new</span> B();</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"method test called in class A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"class B init."</span>);</span><br><span class="line">            A a = <span class="keyword">new</span> A();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"method test called in class B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                A.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;).start();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                B.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">init</span>.</span></span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 第一个线程执行A.test()的时候，开始初始化类A，该线程获得A.class的锁，第二个线程执行B.test()的时候，开始初始化类B，该线程获得B.class的锁。</span><br><span class="line">2. A在初始化过程中执行代码B b = new B()的时候，发现类B还没有初始化完成，于是尝试获得类B.class的锁；</span><br><span class="line">3. 类B在初始化时执行代码A a = new A()，发现类A也没有初始化完成，于是尝试获得类A.class的锁，但A.class锁已被占用，所以该线程会阻塞住，并等待该锁的释放；</span><br><span class="line">4. 同样第一个线程阻塞住并等待B.class锁的释放，这样就造成循环依赖，形成了死锁。</span><br></pre></td></tr></table></figure><ul><li>如果把上面代码改为如下执行方式，会出现什么结果呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A.test();</span><br><span class="line">    B.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终执行结果为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">method</span> <span class="title">test</span> <span class="title">called</span> <span class="title">in</span> <span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"><span class="title">method</span> <span class="title">test</span> <span class="title">called</span> <span class="title">in</span> <span class="title">class</span> <span class="title">B</span></span></span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 乍一看去，好像A初始化时依赖B，B初始化时依赖A，也会造成死锁，但实际上并不会。</span><br><span class="line">2. A、B两个类的初始化都是在同一个线程里执行的，初始化A的时候，该线程会获得A.class锁，初始化B时会获得B.class锁，而在初始化B时又需要A</span><br><span class="line">3. 但是这2个初始化都是在同一个线程里执行的，该线程会同时获得这2个锁，因此并不会发生锁资源的抢占</span><br></pre></td></tr></table></figure><h2 id="2-子类，父类初始化造成死锁"><a href="#2-子类，父类初始化造成死锁" class="headerlink" title="2. 子类，父类初始化造成死锁"></a>2. 子类，父类初始化造成死锁</h2><ul><li>与第一种情况相比，这种情况造成的死锁会更隐蔽一点，但它们实质上都是同样的原因，来看个具体的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Parent init."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parent EMPTY = <span class="keyword">new</span> Child();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test called in class Parent."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Child init."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Child c = <span class="keyword">new</span> Child();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Parent.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent init.</span><br></pre></td></tr></table></figure><p>我们来分析下造成死锁的原因：</p><ul><li>线程t1执行时会触发Child类的初始化，线程t2执行时会触发Parent类的初始化；</li><li>紧接着线程t1持有Child.class锁，t2持有Parent.class锁，t1初始化时需要先初始化其父类Parent</li><li>而类Parent有个常量定义“<strong>public static final Parent EMPTY = new Child();</strong>”，这样类Parent在初始化时需要初始化Child；</li><li>这样线程t1要初始化Parent，尝试获取Parent.class锁，线程t2要初始化Child，尝试获取Child.class锁，彼此互相不能释放资源，因此造成死锁。</li></ul><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><ul><li>在上面这个案例中，我们知道是类初始化时造成了死锁。子类依赖了父类，而父类在初始化过程中又依赖了子类，为了避免这种情况，</li><li>我们采取了预先在主线程中将数据库相关类全部初始化的方式。<br> 在应用入口处，我们作了如下处理：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Class.forName(<span class="string">"AnnouncementInfo"</span>);</span><br><span class="line">Class c2 = Class.forName(<span class="string">"......"</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li><strong>这样在应用启动时，所有相关类都已经初始化完成(一次性分配了所有资源)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-类初始化造成的死锁&quot;&gt;&lt;a href=&quot;#Java-基础-类初始化造成的死锁&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-类初始化造成的死锁&quot;&gt;&lt;/a&gt;Java-基础-类初始化造成的死锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于类初始化有几个关键特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类初始化的过程其实就是执行类构造器方法&lt;clinit&gt;()的过程；&lt;/li&gt;
&lt;li&gt;在子类初始化完成时，虚拟机会保证其父类有初始化完成；&lt;/li&gt;
&lt;li&gt;多线程环境下，虚拟机执行&lt;clinit&gt;()方法会自动加锁；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在java中，死锁肯定是在多线程环境下产生的。&lt;strong&gt;多个线程同时需要互相持有的某个资源，自己的资源无法释放，别人的资源又无法得到，造成循环依赖&lt;/strong&gt;，进而一直阻塞在那里，这样就形成死锁了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="死锁" scheme="http://zhuuu.work/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="循环依赖" scheme="http://zhuuu.work/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-String,StringBuilder,StringBuffer</title>
    <link href="http://zhuuu.work/2020/08/11/JavaInterview/Java-%E5%9F%BA%E7%A1%80-String,StringBuilder,StringBuffer/"/>
    <id>http://zhuuu.work/2020/08/11/JavaInterview/Java-%E5%9F%BA%E7%A1%80-String,StringBuilder,StringBuffer/</id>
    <published>2020-08-11T03:38:38.000Z</published>
    <updated>2020-08-12T10:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-String-StringBuilder-StringBuffer"><a href="#Java-基础-String-StringBuilder-StringBuffer" class="headerlink" title="Java-基础-String,StringBuilder,StringBuffer"></a>Java-基础-String,StringBuilder,StringBuffer</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>java中<code>String、StringBuffer、StringBuilder</code>是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-145020237.png" alt="mark"></p><a id="more"></a><h2 id="1-可变和不可变"><a href="#1-可变和不可变" class="headerlink" title="1. 可变和不可变"></a>1. 可变和不可变</h2><p><strong>1.可变与不可变</strong></p><p>　　<code>String</code>类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。</p><p>　　　　<strong>private final char value[];</strong></p><p>　　<code>StringBuilder与StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。</p><p>　　　　<strong>char[] value;</strong></p><h3 id="1-1-你见到的字符串被改变的？？？（这是一个假象）"><a href="#1-1-你见到的字符串被改变的？？？（这是一个假象）" class="headerlink" title="1.1 你见到的字符串被改变的？？？（这是一个假象）"></a>1.1 <strong>你见到的字符串被改变的？？？（这是一个假象）</strong></h3><ul><li>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 <strong>String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，这样不仅效率低下，而且大量浪费有限的内存空间，所以经常改变内容的字符串最好不要用 String 。</strong>因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-144909950.png" alt="mark"></p><ul><li>我们可以看到，初始String值为“hello”，然后在这个字符串后面加上新的字符串“world”，这个过程是需要重新在栈堆内存中开辟内存空间的，最终得到了“hello world”字符串也相应的需要开辟内存空间，这样短短的两个字符串，却需要开辟三次内存空间，不得不说这是对内存空间的极大浪费。为了应对经常性的字符串相关的操作，就需要使用Java提供的其他两个操作字符串的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。</li></ul><h2 id="2-多线程安全"><a href="#2-多线程安全" class="headerlink" title="2. 多线程安全"></a>2. 多线程安全</h2><ol><li><p>String中的对象是不可变的，也就可以理解为常量，<strong>显然线程安全</strong>。</p></li><li><p>AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。</p></li><li><p><code>StringBuffer</code>对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全的</strong>。看如下源码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);        <span class="comment">//存在 public synchronized int indexOf(String str, int fromIndex) 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>StringBuilder并没有对方法进行加同步锁，所以是<strong>非线程安全的</strong>。</li></ol><h2 id="3-StringBuilder和StringBuffer共同点"><a href="#3-StringBuilder和StringBuffer共同点" class="headerlink" title="3. StringBuilder和StringBuffer共同点"></a>3. StringBuilder和StringBuffer共同点</h2><ul><li>StringBuilder与StringBuffer有公共父类AbstractStringBuilder(<strong>抽象类</strong>)。</li><li><strong>抽象类与接口的其中一个区别</strong>是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。</li><li><code>StringBuilder、StringBuffer</code>的方法都会调用<code>AbstractStringBuilder</code>中的公共方法，如<code>super.append</code>(…)。只是StringBuffer会在方法上加synchronized关键字，进行同步。</li></ul><h2 id="4-字符串常量池"><a href="#4-字符串常量池" class="headerlink" title="4. 字符串常量池"></a>4. 字符串常量池</h2><ul><li>Java中的字符串常量池（<code>String Pool</code>）是存储在Java<strong>堆内存中的字符串池</strong>。我们知道String是java中比较特殊的类，我们可以使用new运算符创建String对象，也可以用双引号（”“）创建字串对象。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-151808077.png" alt="mark"></p><ul><li>之所以有字符串常量池，是因为String在Java中是不可变（immutable）的，它是String interning概念的实现。字符串常量池也是亨元模式（Flyweight）的实例。</li><li>字符串常量池有助于为Java运行时节省大量空间，虽然创建字符串时需要更多的时间。</li><li>当我们使用<strong>双引号创建一个字符串时</strong>，首<strong>先在字符串常量池中查找是否有相同值的字符串，如果发现则返回其引用，否则它会在池中创建一个新的字符串，然后返回新字符串的引用。</strong></li><li>如果使用<strong>new运算符创建字符串，则会强制String类在堆空间中创建一个新的String对象。</strong>我们可以使用intern()方法将其放入字符串常量池或从字符串常量池中查找具有相同的值字符串对象并返回其引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java String Pool example</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s2 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1 == s2 :"</span>+(s1==s2));</span><br><span class="line">        System.out.println(<span class="string">"s1 == s3 :"</span>+(s1==s3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-面试题"><a href="#4-1-面试题" class="headerlink" title="4.1 面试题"></a>4.1 面试题</h3><ul><li>下面语句创建了几个对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><ul><li>在上面的语句中，可能创建1或2个字符串对象。如果池中已经有一个字符串<em>“Cat”</em>，那么堆中只会创建一个字符串<em>“str”</em>。</li><li>如果池中没有字符串字面量<em>“Cat”</em>，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共2个字符串对象。</li></ul><h3 id="4-2-作用"><a href="#4-2-作用" class="headerlink" title="4.2 作用"></a>4.2 作用</h3><ul><li>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。</li><li><strong>为 了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串池，</strong>每当代码创建字符串常量时，JVM会首先检查字符串常量池。如果字符串已经存在池中， 就返回池中的实例引用。</li><li>如果字符串不在池中，就会实例化一个字符串并放到池中。Java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突 进行共享。</li></ul><p><strong>参考博客：</strong></p><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303" target="_blank" rel="noopener">https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-String-StringBuilder-StringBuffer&quot;&gt;&lt;a href=&quot;#Java-基础-String-StringBuilder-StringBuffer&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-String,StringBuilder,StringBuffer&quot;&gt;&lt;/a&gt;Java-基础-String,StringBuilder,StringBuffer&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;java中&lt;code&gt;String、StringBuffer、StringBuilder&lt;/code&gt;是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-145020237.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="String" scheme="http://zhuuu.work/tags/String/"/>
    
      <category term="SringBuilder" scheme="http://zhuuu.work/tags/SringBuilder/"/>
    
      <category term="StringBuffer" scheme="http://zhuuu.work/tags/StringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-HTTPS区别</title>
    <link href="http://zhuuu.work/2020/08/11/NetworkCoding/HTTP-HTTPS%E5%8C%BA%E5%88%AB/"/>
    <id>http://zhuuu.work/2020/08/11/NetworkCoding/HTTP-HTTPS%E5%8C%BA%E5%88%AB/</id>
    <published>2020-08-11T03:02:24.000Z</published>
    <updated>2020-08-28T02:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-HTTPS区别"><a href="#HTTP-HTTPS区别" class="headerlink" title="HTTP-HTTPS区别"></a>HTTP-HTTPS区别</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议</p></li><li><p>申请证书上，HTTPS需要使用ca申请证书</p></li><li><p>对于抓包而言 ，HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议</p></li><li><p>连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443</p></li></ul><a id="more"></a><h2 id="2-HTTPS的通信过程"><a href="#2-HTTPS的通信过程" class="headerlink" title="2. HTTPS的通信过程"></a>2. HTTPS的通信过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-105034140.png" alt="mark"></p><p>https通信时，首先建立ssl层的连接，客户端将ssl版本号和加密组件发到服务器端，服务器端收到后对ssl版本号和加密组件进行匹配，同时将CA证书及密钥发送到客户端。客户端对证书进行验证，验证通过后使用非对称加密对数据通信时的密钥进行协商。协商后得到一致的获得一致的对称加密密钥。然后使用对称加密算法进行TCP连接，后续的过程跟http的过程一致。三次握手，数据交换，四次挥手，通信结束。</p><p>过程如下 ：</p><ol><li>客户端和服务器端通过TCP建立连接。</li><li>客户端向服务器发送HTTPS请求。</li><li>服务器响应请求，并将数字证书发送给客户端，数字证书包括公共秘钥、域名、申请证书的公司。</li><li>客户端收到服务器端的数字证书之后，会验证数字证书的合法性。</li><li>如果公钥合格，那么客户端会生成一个用于进行对称加密的密钥client key，并用服务器的公钥对客户端密钥进行非对称加密。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用私钥对其进行非对称解密，得到客户端秘钥。并使用客户端秘钥进行对称加密，生成密文并发送。</li><li>客户端收到密文，并使用客户端秘钥进行解密，渲染网页。</li></ol><h2 id="3-HTTP的工作过程"><a href="#3-HTTP的工作过程" class="headerlink" title="3. HTTP的工作过程"></a>3. HTTP的工作过程</h2><p>HTTP由请求和响应构成，是一个标准的客户端服务器模型（C/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。</p><ol><li>地址解析。域名系统DNS解析域名得到主机的IP地址</li><li>封装HTTP请求数据包。封装的内容有以上部分结合本机自己的信息。</li><li>封装成TCP包，建立TCP连接（TCP的三次握手）</li><li>客户机发送请求命令。 建立连接后，客户机向服务器发送一个请求</li><li>服务器响应。服务器接到请求后，给予相应的响应信息</li><li>服务器关闭TCP连接。一般Web服务器向浏览器发送了请求数据，它要关闭TCP连接</li><li>客户端解析报文，解析HTML代码，并渲染</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-HTTPS区别&quot;&gt;&lt;a href=&quot;#HTTP-HTTPS区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP-HTTPS区别&quot;&gt;&lt;/a&gt;HTTP-HTTPS区别&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;申请证书上，HTTPS需要使用ca申请证书&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于抓包而言 ，HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="网络编程" scheme="http://zhuuu.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-并发详解</title>
    <link href="http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-08-10T09:38:38.000Z</published>
    <updated>2020-08-10T07:50:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-并发详解"><a href="#Java-基础-并发详解" class="headerlink" title="Java-基础-并发详解"></a>Java-基础-并发详解</h1><h1 id="一、使用线程"><a href="#一、使用线程" class="headerlink" title="一、使用线程"></a>一、使用线程</h1><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><ul><li><strong>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程</strong>，</li><li><strong>因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</strong></li></ul><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><ul><li>需要实现接口中的 run() 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><ul><li>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><ul><li>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</li><li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p><strong>实现接口会更好一些</strong>，因为：</p><ul><li>Java <strong>不支持多重继承，因此继承了 Thread 类就无法继承其它类</strong>，但是可以实现多个接口；</li><li>类可能只要求可执行就行，<strong>继承整个 Thread 类开销过大。</strong></li></ul><h1 id="二、中断"><a href="#二、中断" class="headerlink" title="二、中断"></a>二、中断</h1><ul><li>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</li></ul><h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的 <code>interrupt()</code> 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 <code>InterruptedException</code>，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p><strong>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure><h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><ul><li><strong>调用 Executor 的 shutdown() 方法</strong>会等待线程都执行完毕之后再关闭，</li><li>但是如果调<strong>用的是 shutdownNow() 方法</strong>，则相当于调用每个线程的 interrupt() 方法。</li></ul><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><ul><li>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h1 id="三、互斥同步"><a href="#三、互斥同步" class="headerlink" title="三、互斥同步"></a>三、互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>1. 同步一个代码块</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</strong></p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure><p><strong>2. 同步一个方法</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它和同步代码块一样，作用于同一个对象。</strong></p><p><strong>3. 同步一个类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p><strong>4. 同步一个静态方法</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用于整个类。</strong></p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><ul><li>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。<strong>(底层是AQS)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>1. 锁的实现</strong>  </p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong>  </p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong>  </p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong>  </p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong>  </p><ul><li><strong>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</strong></li></ul><h1 id="四、线程之间的协作"><a href="#四、线程之间的协作" class="headerlink" title="四、线程之间的协作"></a>四、线程之间的协作</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><ul><li><p><strong>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</strong></p></li><li><p>对于以下代码，虽然 b 线程先启动，<strong>但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><ul><li><p><strong>它们都属于 Object 的一部分，而不属于 Thread。</strong></p></li><li><p><strong>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</strong></p></li><li><p><strong>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</strong></p></li><li><p><strong>同时存在虚假唤醒的问题</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p><strong>wait() 和 sleep() 的区别</strong>  </p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><ul><li><p>java.util.concurrent 类库中提供了 <strong>Condition 类</strong>来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p></li><li><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p></li></ul><p><strong>使用 Lock 来获取一个 Condition 对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><h1 id="五、线程状态"><a href="#五、线程状态" class="headerlink" title="五、线程状态"></a>五、线程状态</h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p><h2 id="新建（NEW）"><a href="#新建（NEW）" class="headerlink" title="新建（NEW）"></a>新建（NEW）</h2><ul><li>创建后尚未启动。</li></ul><h2 id="可运行（RUNABLE）"><a href="#可运行（RUNABLE）" class="headerlink" title="可运行（RUNABLE）"></a>可运行（RUNABLE）</h2><ul><li>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要<strong>看底层操作系统的资源调度</strong>。</li></ul><h2 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h2><ul><li>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</li></ul><h2 id="无限期等待（WAITING）"><a href="#无限期等待（WAITING）" class="headerlink" title="无限期等待（WAITING）"></a>无限期等待（WAITING）</h2><p>等待其它线程显式地唤醒。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用  Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h2 id="限期等待（TIMED-WAITING）"><a href="#限期等待（TIMED-WAITING）" class="headerlink" title="限期等待（TIMED_WAITING）"></a>限期等待（TIMED_WAITING）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><h2 id="死亡（TERMINATED）"><a href="#死亡（TERMINATED）" class="headerlink" title="死亡（TERMINATED）"></a>死亡（TERMINATED）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h1 id="六-：-AQS-应用"><a href="#六-：-AQS-应用" class="headerlink" title="六 ： AQS 应用"></a>六 ： AQS 应用</h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><ul><li><p>用来控制一个或者多个线程等待多个线程。</p></li><li><p><strong>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</strong></p></li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><ul><li><strong>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</strong></p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七：其他组件"><a href="#七：其他组件" class="headerlink" title="七：其他组件"></a>七：其他组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future<V> 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future<V> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。<strong>当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">other task is running...</span><br><span class="line">4950</span><br></pre></td></tr></table></figure><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>java.util.concurrent.BlockingQueue</code> 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong>  ：<code>LinkedBlockingQueue、ArrayBlockingQueue</code>（固定长度）</li><li><strong>优先级队列</strong>  ：<code>PriorityBlockingQueue</code></li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><ul><li>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><ul><li>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" width="300px"> </div><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-基础-并发详解&quot;&gt;&lt;a href=&quot;#Java-基础-并发详解&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-并发详解&quot;&gt;&lt;/a&gt;Java-基础-并发详解&lt;/h1&gt;&lt;h1 id=&quot;一、使用线程&quot;&gt;&lt;a href=&quot;#一、使用线程&quot;
      
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="http://zhuuu.work/tags/%E9%94%81/"/>
    
      <category term="并发" scheme="http://zhuuu.work/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-接口和抽象类</title>
    <link href="http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2020-08-10T09:38:38.000Z</published>
    <updated>2020-09-09T08:05:09.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-接口和抽象类"><a href="#Java-基础-接口和抽象类" class="headerlink" title="Java-基础-接口和抽象类"></a>Java-基础-接口和抽象类</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200810-134343284.png" alt="mark"></p><h2 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1. 抽象类"></a>1. 抽象类</h2><h4 id="（1）抽象类的含义"><a href="#（1）抽象类的含义" class="headerlink" title="（1）抽象类的含义"></a>（1）抽象类的含义</h4><p>  包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的（否则，编译器会报错）</p><h4 id="（2）抽象类的点"><a href="#（2）抽象类的点" class="headerlink" title="（2）抽象类的点"></a>（2）抽象类的点</h4><p>1.含有abstract修饰符的class即为抽象类，abstract类不能创建实例对象。<br> 2.含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。<br> 3.abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。<br> 4.如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p><a id="more"></a><h2 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h2><h4 id="（1）接口的含义"><a href="#（1）接口的含义" class="headerlink" title="（1）接口的含义"></a>（1）接口的含义</h4><p>  可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。能有的内容是：static final的静态成员变量、public abstract的抽象方法（可以使用abstract关键字也可以不使用）</p><h4 id="（2）接口的点"><a href="#（2）接口的点" class="headerlink" title="（2）接口的点"></a>（2）接口的点</h4><p>1.接口中的域隐式地是static和final的；<br> 2.接口可以嵌套在类或其他接口中；<br> 3.接口是实现多重继承的途径；<br> 4.接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。<br> 5.接口不能有构造器；<br> 6.接口中不能有main()方法；</p><h2 id="3、语法的区别"><a href="#3、语法的区别" class="headerlink" title="3、语法的区别"></a>3、语法的区别</h2><p>1.普通成员变量：抽象类中可以有普通成员变量，接口中没有普通成员变量（static final变量）；<br> 2.方法：抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法；<br> 3.静态成员变量：抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。<br> 4.静态方法：抽象类中可以包含静态方法，但不能是抽象静态方法；接口中不能包含静态方法（静态的方法不能被覆写）<br> 5.构造方法（静态的）：抽象类可以有构造方法，接口中不能有构造方法；<br> 6.方法访问权限：抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。<br> 7.子类实现和继承： 一个类可以实现多个接口，但只能继承一个抽象类。<br> 8.初始化过程：当一个类在初始化时，要求其父类全部都已经初始化过了；但是一个接口在初始化时，并不要求其父接口全部都完成初始化，只有在真正使用父接口的时候（如引用接口中定义的常量），才会初始化。</p><h2 id="4、应用上的区别"><a href="#4、应用上的区别" class="headerlink" title="4、应用上的区别"></a>4、应用上的区别</h2><p>  接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约；而抽象类在代码实现方面发挥作用，可以实现代码的重用。<br>  例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。</p><h2 id="5-使用接口的原因"><a href="#5-使用接口的原因" class="headerlink" title="5. 使用接口的原因"></a>5. 使用接口的原因</h2><p>1）为了能够向上转型为多个基类型（由此而带来的灵活性）；<br> 2）与使用抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。</p><h2 id="6、问题：使用接口还是抽象类"><a href="#6、问题：使用接口还是抽象类" class="headerlink" title="6、问题：使用接口还是抽象类"></a>6、问题：使用接口还是抽象类</h2><p>答：如果要创建不带任何方法定义和成员变量的基类，就应该选择接口而不是抽象类。抽象类为了代码的复用，接口为了多态性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-接口和抽象类&quot;&gt;&lt;a href=&quot;#Java-基础-接口和抽象类&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-接口和抽象类&quot;&gt;&lt;/a&gt;Java-基础-接口和抽象类&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200810-134343284.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-抽象类&quot;&gt;&lt;a href=&quot;#1-抽象类&quot; class=&quot;headerlink&quot; title=&quot;1. 抽象类&quot;&gt;&lt;/a&gt;1. 抽象类&lt;/h2&gt;&lt;h4 id=&quot;（1）抽象类的含义&quot;&gt;&lt;a href=&quot;#（1）抽象类的含义&quot; class=&quot;headerlink&quot; title=&quot;（1）抽象类的含义&quot;&gt;&lt;/a&gt;（1）抽象类的含义&lt;/h4&gt;&lt;p&gt;  包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的（否则，编译器会报错）&lt;/p&gt;
&lt;h4 id=&quot;（2）抽象类的点&quot;&gt;&lt;a href=&quot;#（2）抽象类的点&quot; class=&quot;headerlink&quot; title=&quot;（2）抽象类的点&quot;&gt;&lt;/a&gt;（2）抽象类的点&lt;/h4&gt;&lt;p&gt;1.含有abstract修饰符的class即为抽象类，abstract类不能创建实例对象。&lt;br&gt; 2.含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。&lt;br&gt; 3.abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。&lt;br&gt; 4.如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="接口" scheme="http://zhuuu.work/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="抽象类" scheme="http://zhuuu.work/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis-13-跳表</title>
    <link href="http://zhuuu.work/2020/08/07/Redis/Redis-13-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/08/07/Redis/Redis-13-%E8%B7%B3%E8%A1%A8/</id>
    <published>2020-08-07T10:32:24.000Z</published>
    <updated>2020-08-07T08:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-13-跳表"><a href="#Redis-13-跳表" class="headerlink" title="Redis-13-跳表"></a>Redis-13-跳表</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先为什么要把mysql索引和redis跳表放在一起讨论呢，因为他们解决的都是同一种问题，用于<strong>解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置（或者对应的value）</strong></li></ul><a id="more"></a><p>现在我们将问题领域边界划分清楚了，就是为了解决数据集合的查找问题。这一块需要考虑哪些问题呢</p><ol><li>需要支持哪些查找方式，单key/多key/范围查找，</li><li>插入/删除效率</li><li>查找效率（即时间复杂度）</li><li>存储大小（空间复杂度）</li></ol><ul><li>我们看下<strong>几种常用的查找结构</strong></li></ul><ol><li><strong>Hash : hash是key,value形式，通过一个散列函数，能够根据key快速找到value</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200807-154119174.png" alt="mark"></p><ol start="2"><li><strong>B+树</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200807-154302337.png" alt="mark"></p><ul><li>B+树首先是有序结构，为了不至于树的高度太高，影响查找效率，在叶子节点上存储的不是单个数据，而是一页数据，提高了查找效率，而为了更好的支持范围查询，B+树在叶子节点冗余了非叶子节点数据，为了支持翻页，叶子节点之间通过指针连接。</li></ul><p><strong>跳表</strong></p><ul><li><strong>跳表是在链表的基础上进行扩展的，为的是实现redis的sorted set数据结构。（Zset）</strong></li><li>level0: 是存储原始数据的，是一个有序链表，每个节点都在链上</li><li>每个节点都在链上 level0+: 通过指针串联起节点，是原始数据的一个子集，level等级越高，串联的数据越少，这样可以显著提高查找效率，</li></ul><p><strong>总结：</strong></p><table><thead><tr><th>数据结构</th><th>实现原理</th><th>key查询方式</th><th>查找效率</th><th>存储大小</th><th>插入、删除效率</th></tr></thead><tbody><tr><td>Hash</td><td>哈希表</td><td>支持单key</td><td>接近O(1)</td><td>小，除了数据没有额外的存储</td><td>O(1)</td></tr><tr><td>B+树</td><td>平衡二叉树扩展而来</td><td>单key,范围，分页</td><td>O(Log(n)</td><td>除了数据，还多了左右指针，以及叶子节点指针</td><td>O(Log(n)，需要调整树的结构，算法比较复杂</td></tr><tr><td>跳表</td><td>有序链表扩展而来</td><td>单key，分页</td><td>O(Log(n)</td><td>除了数据，还多了指针，但是每个节点的指针小于&lt;2,所以比B+树占用空间小</td><td>O(Log(n)，只用处理链表，算法比较简单</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-13-跳表&quot;&gt;&lt;a href=&quot;#Redis-13-跳表&quot; class=&quot;headerlink&quot; title=&quot;Redis-13-跳表&quot;&gt;&lt;/a&gt;Redis-13-跳表&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先为什么要把mysql索引和redis跳表放在一起讨论呢，因为他们解决的都是同一种问题，用于&lt;strong&gt;解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置（或者对应的value）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-泛型擦除</title>
    <link href="http://zhuuu.work/2020/08/05/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    <id>http://zhuuu.work/2020/08/05/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/</id>
    <published>2020-08-05T09:38:38.000Z</published>
    <updated>2020-09-04T08:31:01.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-泛型擦除"><a href="#Java-基础-泛型擦除" class="headerlink" title="Java-基础-泛型擦除"></a>Java-基础-泛型擦除</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>[参考博客][<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html]" target="_blank" rel="noopener">https://www.cnblogs.com/wuqinglong/p/9456193.html]</a></p><ul><li>大家都知道，Java的泛型是伪泛型，<strong>这是因为Java在编译期间，所有的泛型信息都会被擦掉</strong>，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，<strong>使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</strong></li><li><strong>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code></strong>，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，<strong>但是仍然无法在运行时刻出现的类型转换异常的情况</strong>，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</li></ul><a id="more"></a><h2 id="1-通过两个例子证明Java类型的类型擦除"><a href="#1-通过两个例子证明Java类型的类型擦除" class="headerlink" title="1. 通过两个例子证明Java类型的类型擦除"></a>1. 通过两个例子证明Java类型的类型擦除</h2><ol><li><h4 id="原始类型相等"><a href="#原始类型相等" class="headerlink" title="原始类型相等"></a>原始类型相等</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个<code>ArrayList</code>数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过<code>list1</code>对象和<code>list2</code>对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为<code>true</code>。说明泛型类型<code>String</code>和<code>Integer</code>都被擦除掉了，只剩下原始类型。</p><ol start="2"><li><h4 id="通过反射添加其它类型元素"><a href="#通过反射添加其它类型元素" class="headerlink" title="通过反射添加其它类型元素"></a>通过反射添加其它类型元素</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);  <span class="comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span></span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod("add", Object.class).invoke(list, "asd");</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p><h2 id="2-类型擦除后保留的原始类型"><a href="#2-类型擦除后保留的原始类型" class="headerlink" title="2. 类型擦除后保留的原始类型"></a>2. 类型擦除后保留的原始类型</h2><ul><li><p>在上面，两次提到了原始类型，什么是原始类型？</p><p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p></li></ul><p><strong>例3.原始类型Object</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair的原始类型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在<code>Pair&lt;T&gt;</code>中，T 是一个无限定的类型变量，所以用<code>Object</code>替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的<code>Pair</code>，如<code>Pair&lt;String&gt;</code>或<code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的<code>Pair</code>类型了，原始类型都是<code>Object</code>。</p><p><strong>从上面的例2中，我们也可以明白<code>ArrayList&lt;Integer&gt;</code>被擦除类型后，原始类型也变为<code>Object</code>，所以通过反射我们就可以存储字符串了。</strong></p><p>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>那么原始类型就是<code>Comparable</code>。</p><p>要区分原始类型和泛型变量的类型。</p><p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> i = Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        Number f = Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        Object o = Test.add(<span class="number">1</span>, <span class="string">"asd"</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> a = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="keyword">int</span> b = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        Number c = Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例4.Object泛型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">    list.add(<span class="number">1</span>);  </span><br><span class="line">    list.add(<span class="string">"121"</span>);  </span><br><span class="line">    list.add(<span class="keyword">new</span> Date());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-带来的问题和解决方法"><a href="#3-带来的问题和解决方法" class="headerlink" title="3. 带来的问题和解决方法"></a>3. 带来的问题和解决方法</h2><p>因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题，但是也引起来许多新问题，所以，SUN对这些问题做出了种种限制，避免我们发生各种错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-泛型擦除&quot;&gt;&lt;a href=&quot;#Java-基础-泛型擦除&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-泛型擦除&quot;&gt;&lt;/a&gt;Java-基础-泛型擦除&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;[参考博客][&lt;a href=&quot;https://www.cnblogs.com/wuqinglong/p/9456193.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wuqinglong/p/9456193.html]&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大家都知道，Java的泛型是伪泛型，&lt;strong&gt;这是因为Java在编译期间，所有的泛型信息都会被擦掉&lt;/strong&gt;，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，&lt;strong&gt;使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如在代码中定义&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;和&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;等类型，在编译后都会变成&lt;code&gt;List&lt;/code&gt;&lt;/strong&gt;，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，&lt;strong&gt;但是仍然无法在运行时刻出现的类型转换异常的情况&lt;/strong&gt;，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="泛型" scheme="http://zhuuu.work/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-146-LRU缓存机制</title>
    <link href="http://zhuuu.work/2020/08/05/Leetcode/Leetcode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/08/05/Leetcode/Leetcode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2020-08-05T07:52:22.000Z</published>
    <updated>2020-08-09T08:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-146-LRU缓存机制"><a href="#Leecode-146-LRU缓存机制" class="headerlink" title="Leecode-146. LRU缓存机制"></a>Leecode-<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h1><h2 id="思路：递归-迭代"><a href="#思路：递归-迭代" class="headerlink" title="思路：递归/迭代"></a>思路：递归/迭代</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><ul><li>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。</li><li>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><h2 id="方案：-哈希链表"><a href="#方案：-哈希链表" class="headerlink" title="方案： 哈希链表"></a>方案： 哈希链表</h2><ul><li>LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</li><li>注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 缓存容量为 2 *&#x2F;</span><br><span class="line">LRUCache cache &#x3D; new LRUCache(2);</span><br><span class="line">&#x2F;&#x2F; 你可以把 cache 理解成一个队列</span><br><span class="line">&#x2F;&#x2F; 假设左边是队头，右边是队尾</span><br><span class="line">&#x2F;&#x2F; 最近使用的排在队头，久未使用的排在队尾</span><br><span class="line">&#x2F;&#x2F; 圆括号表示键值对 (key, val)</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 1)]</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(2, 2), (1, 1)]</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 1</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 1), (2, 2)]</span><br><span class="line">&#x2F;&#x2F; 解释：因为最近访问了键 1，所以提前至队头</span><br><span class="line">&#x2F;&#x2F; 返回键 1 对应的值 1</span><br><span class="line">cache.put(3, 3);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(3, 3), (1, 1)]</span><br><span class="line">&#x2F;&#x2F; 解释：缓存容量已满，需要删除内容空出位置</span><br><span class="line">&#x2F;&#x2F; 优先删除久未使用的数据，也就是队尾的数据</span><br><span class="line">&#x2F;&#x2F; 然后把新的数据插入队头</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(3, 3), (1, 1)]</span><br><span class="line">&#x2F;&#x2F; 解释：cache 中不存在键为 2 的数据</span><br><span class="line">cache.put(1, 4);    </span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 4), (3, 3)]</span><br><span class="line">&#x2F;&#x2F; 解释：键 1 已存在，把原始值 1 覆盖为 4</span><br><span class="line">&#x2F;&#x2F; 不要忘了也要将键值对提前到队头</span><br></pre></td></tr></table></figure><ul><li>分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。</li><li>因为显然 cache <strong>必须有顺序之分</strong>，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；<strong>如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。</strong></li><li>那么，什么数据结构同时符合上述条件呢？<strong>哈希表查找快，但是数据无固定顺序</strong>；<strong>链表有顺序之分，插入删除快，但是查找慢。</strong>所以结合一下，形成一种新的数据结构：哈希链表。</li><li><strong>LRU 缓存算法的核心数据结构就是哈希链表</strong>，双向链表和哈希表的结合体。这个数据结构长这样：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200805-165923396.png" alt="mark"></p><p><strong>思想很简单，就是借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点。回想刚才的例子，这种数据结构是不是完美解决了 LRU 缓存的需求？</strong></p><p>也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存键值对呢，只存值不就行了？</p><p>想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个可不写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leecode-146-LRU缓存机制&quot;&gt;&lt;a href=&quot;#Leecode-146-LRU缓存机制&quot; class=&quot;headerlink&quot; title=&quot;Leecode-146. LRU缓存机制&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://lee
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="缓存机制" scheme="http://zhuuu.work/tags/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-10-乐观锁和悲观锁</title>
    <link href="http://zhuuu.work/2020/08/03/Mysql/Mysql-10-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://zhuuu.work/2020/08/03/Mysql/Mysql-10-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2020-08-03T08:02:27.000Z</published>
    <updated>2020-09-03T11:39:58.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-10-乐观锁和悲观锁"><a href="#Mysql-10-乐观锁和悲观锁" class="headerlink" title="Mysql-10-乐观锁和悲观锁"></a>Mysql-10-乐观锁和悲观锁</h1><h2 id="1-乐观锁和悲观锁"><a href="#1-乐观锁和悲观锁" class="headerlink" title="1. 乐观锁和悲观锁"></a>1. 乐观锁和悲观锁</h2><p><strong>参考博客 ：</strong></p><p> <a href="https://blog.csdn.net/localhost01/article/details/78720727?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">https://blog.csdn.net/localhost01/article/details/78720727?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight</a></p><p>  <a href="https://blog.csdn.net/L_BestCoder/article/details/79298417" target="_blank" rel="noopener">https://blog.csdn.net/L_BestCoder/article/details/79298417</a></p><p><strong>首先说明，乐观锁和悲观锁都是针对读（select）来说的。</strong></p><p><strong>也就是一句话：读用乐观锁，写用悲观锁。</strong></p><a id="more"></a><h3 id="1-1-乐观锁"><a href="#1-1-乐观锁" class="headerlink" title="1.1 乐观锁"></a>1.1 乐观锁</h3><ul><li>总是认为不会产生并发问题，每次去<strong>取数据的时候总认为不会有其他线程对数据进行修改</strong>，因此不会上锁，但是在<strong>更新时会判断其他线程在这之前有没有对数据进行修改</strong>，</li><li>一般会使用<strong>版本号机制</strong>或<strong>CAS操作实现</strong>。</li><li>乐观锁适用于多读的应用类型，这样可以提高吞吐量</li></ul><ol><li><strong>version方式</strong>：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li></ol><p>   核心SQL代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> x=x+<span class="number">1</span>, <span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>CAS操作方式：</strong>即<code>compare and swap</code> 或者 <code>compare and set</code>，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个<strong>自旋操作</strong>，即不断的重试。</li></ol><h3 id="1-2-悲观锁"><a href="#1-2-悲观锁" class="headerlink" title="1.2 悲观锁"></a>1.2 悲观锁</h3><ul><li>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</li><li>传统的关系型数据库里边就用到了很多这种锁机制，比如<strong>行锁，表锁等，读锁，写锁</strong>等，都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制</li></ul><p><strong>首先说明，乐观锁和悲观锁都是针对读（select）来说的。</strong></p><p>案例：</p><p>某商品，用户购买后库存数应-1，而某两个或多个用户同时购买，此时三个执行程序均同时读得库存为“<strong>n</strong>”，之后进行了一些操作，最后将均执行<em>update table set 库存数=n-1</em>，那么，很显然这是错误的。</p><p>解决：</p><ol><li><p><strong>使用悲观锁</strong>（其实说白了也就是<strong>排他锁</strong>）</p><p>|– 程序A在查询库存数时使用排他锁（select * from table where id=10 for update）</p><p>|– 然后进行后续的操作，包括更新库存数，最后提交事务。</p><p>|– 程序B在查询库存数时，如果A还未释放排他锁，它将等待……</p><p>|– 程序C同B……</p></li><li><p><strong>使用乐观锁</strong>（靠表设计和代码来实现）</p><p>|– 一般是在该商品表添加<strong>version版本</strong>字段或者<strong>timestamp时间戳</strong>字段</p><p>|– 程序A查询后，执行更新变成了：<br><code>*update table set num=num-1 where id=10 and version=23*</code></p><p>这样，保证了修改的数据是和它查询出来的数据是一致的（其他执行程序肯定未进行修改）。当然，如果更新失败，表示在更新操作之前，有其他执行程序已经更新了该库存数，那么就可以尝试<strong>重试</strong>来保证更新成功。为了尽可能避免更新失败，可以合理调整重试次数（阿里巴巴开发手册规定重试次数不低于三次）。</p></li></ol><p>总结：对于以上，可以看得出来乐观锁和悲观锁的区别：</p><ul><li><p>悲观锁实际使用了排他锁来实现（<strong>select \</strong>** for update**）。文章开头说到，innodb加行锁的前提是：必须是通过索引条件来检索数据，否则会切换为表锁。</p><p>因此，悲观锁在未通过索引条件检索数据时，会锁定整张表。导致其他程序不允许“<strong>加锁的查询操作</strong>”，影响吞吐。故如果在查询居多的情况下，推荐使用乐观锁。</p><p>“<strong>加锁的查询操作</strong>”：加过排他锁的数据行在其他事务中是不能修改的，也不能通过<strong>for update</strong>或<strong>lock in share mode</strong>的加锁方式查询，但可以直接通过select …from…查询数据，因为<strong>普通查询没有任何锁机制</strong>。</p></li><li><p>乐观锁更新有可能会失败，甚至是更新几次都失败，这是有风险的。所以如果写入居多，对吞吐要求不高，可使用悲观锁。</p></li></ul><h2 id="2-MVCC"><a href="#2-MVCC" class="headerlink" title="2. MVCC"></a>2. MVCC</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-10-乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#Mysql-10-乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;Mysql-10-乐观锁和悲观锁&quot;&gt;&lt;/a&gt;Mysql-10-乐观锁和悲观锁&lt;/h1&gt;&lt;h2 id=&quot;1-乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#1-乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;1. 乐观锁和悲观锁&quot;&gt;&lt;/a&gt;1. 乐观锁和悲观锁&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;参考博客 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://blog.csdn.net/localhost01/article/details/78720727?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/localhost01/article/details/78720727?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://blog.csdn.net/L_BestCoder/article/details/79298417&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/L_BestCoder/article/details/79298417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先说明，乐观锁和悲观锁都是针对读（select）来说的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是一句话：读用乐观锁，写用悲观锁。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JUC-20-ThreadPoolExecutor</title>
    <link href="http://zhuuu.work/2020/08/03/JUC/JUC-20-ThreadPoolExecutor/"/>
    <id>http://zhuuu.work/2020/08/03/JUC/JUC-20-ThreadPoolExecutor/</id>
    <published>2020-08-03T08:02:24.000Z</published>
    <updated>2020-08-24T09:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUC-20-ThreadPoolExecutor"><a href="#JUC-20-ThreadPoolExecutor" class="headerlink" title="JUC-20-ThreadPoolExecutor"></a>JUC-20-ThreadPoolExecutor</h2><p><a href="https://blog.csdn.net/leilifengxingmw/article/details/79533006" target="_blank" rel="noopener">https://blog.csdn.net/leilifengxingmw/article/details/79533006</a></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JUC-20-ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#JUC-20-ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;JUC-20-ThreadPoolExecutor&quot;&gt;&lt;/a&gt;JUC-20-Thre
      
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>JUC-19-AQS</title>
    <link href="http://zhuuu.work/2020/08/03/JUC/JUC-19-AQS/"/>
    <id>http://zhuuu.work/2020/08/03/JUC/JUC-19-AQS/</id>
    <published>2020-08-03T08:02:24.000Z</published>
    <updated>2020-08-17T02:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-19-AQS"><a href="#JUC-19-AQS" class="headerlink" title="JUC-19-AQS"></a>JUC-19-AQS</h1><h2 id="1-AQS结构"><a href="#1-AQS结构" class="headerlink" title="1. AQS结构"></a>1. AQS结构</h2><ul><li>AQS（AbstractQueuedSynchronizer）是Java众多锁以及并发工具的基础类，底层采用乐观锁，大量采用CAS操作保证其原子性，并且在并发冲突时，采用自旋方法重试。实现了轻量高效的获取锁。</li></ul><h3 id="1-1-信号量"><a href="#1-1-信号量" class="headerlink" title="1.1 信号量"></a>1.1 信号量</h3><ul><li>在AQS中，状态是由volatile state来表示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><ul><li>该属性值表示锁的状态。<ul><li>state为0表示锁未被占用，</li><li>state为1表示锁被线程持有，</li><li>而state大于1表示锁被重入。</li></ul></li></ul><p>而本文分析的是独占锁，那么同一时刻，锁只能被一个线程持有。</p><p>不仅需要记录锁的状态，还需要记录当前获取锁的线程，实现重入。可以通过来记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><h3 id="1-2-等待队列"><a href="#1-2-等待队列" class="headerlink" title="1.2 等待队列"></a>1.2 等待队列</h3><ul><li>等待队列采用悲观锁的思想，表示当前所等待的资源，状态或条件短时间内可能无法满足，而调用<code>park</code>方法（借助操作系统）来完成线程的阻塞。</li><li>在AQS中，队列时一个双端链表，将当前线程包装成某种类型的数据结构扔到等待队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 节点所代表的线程  </span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;    </span><br><span class="line"><span class="comment">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用  </span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;  </span><br><span class="line"><span class="keyword">volatile</span> Node next;  </span><br><span class="line"><span class="comment">// 线程所处的等待锁的状态，初始化时，该值为0。  </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;  </span><br><span class="line"><span class="comment">//队列中节点线程被取消</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">//节点将其前驱节点设置为-1，当前驱节点释放锁后，会自动唤醒该节点。  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;  </span><br><span class="line"><span class="comment">//线程被重新包装为Node节点，并存入Condition队列中。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;  </span><br><span class="line"><span class="comment">//共享锁唤醒风暴时，将0-&gt;PROPAGATE，表示被传播唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;  </span><br><span class="line"><span class="comment">// 该属性用于条件队列或者共享锁 。在Condition队列中，使用其作为指针。</span></span><br><span class="line">Node nextWaiter;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在独占锁下，我们需要关注的就是下面几个参数：</p><ul><li>thread：当前Node所代表的线程；</li><li>waitStatus：表示节点所处的等待状态；</li><li>prev next：节点的前驱和后继</li></ul><h3 id="1-3-CAS操作"><a href="#1-3-CAS操作" class="headerlink" title="1.3 CAS操作"></a>1.3 CAS操作</h3><ul><li>CAS采用乐观锁机制，保证操作的原子性。一般是改变状态或改变指针（引用）指向。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-091408589.png" alt="mark"></p><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>在AQS源码中：</p><ol><li>锁属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//当前持有锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><ol start="2"><li>sync queue相关的属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread属性为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 队尾，新入队的节点</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Node相关属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点所代表的线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程所处的等待锁的状态，初始化时，该值为0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="2-ReentrantLock实现"><a href="#2-ReentrantLock实现" class="headerlink" title="2. ReentrantLock实现"></a>2. ReentrantLock实现</h2><h3 id="2-1-加锁逻辑"><a href="#2-1-加锁逻辑" class="headerlink" title="2.1 加锁逻辑"></a>2.1 加锁逻辑</h3><p><code>ReentrantLock</code>有公平锁和非公平锁两种实现，默认实现非公平锁。但是可配置为公平锁：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock <span class="keyword">lock</span>=<span class="keyword">new</span> ReentrantLock(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>调用公平锁加锁逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//开始加锁，将state修改为1</span></span><br><span class="line">    acquire(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>真正的加锁方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;    </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))   </span><br><span class="line">        selfInterrupt();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. tryAcquire(arg)</strong><br> 该方法由继承AQS的子类实现，为获取锁的具体逻辑；</p><p><strong>2. addWaiter(Node.EXCLUSIVE)</strong><br> 该方法由AQS实现，负责在获取锁失败后调用，将当前请求锁的线程包装成Node并且放到<code>等待队列中</code>，并返回该Node。</p><p><strong>3. acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</strong><br> 该方法由AQS实现。针对上面加入到队列的Node不断尝试两种操作之一：</p><ul><li>若前驱节点是head节点的时候，尝试获取锁；</li><li>调用<code>park</code>将当前线程挂起，线程阻塞。</li></ul><p><strong>4. selfInterrupt</strong><br>该方法由AQS实现。<strong>恢复用户行为。</strong></p><ul><li><p>用户在外界调用<code>t1.interrupt()</code>进行中断。</p></li><li><p>线程在<code>parkAndCheckInterrupt</code>方法被唤醒之后。会调用<code>Thread.interrupted();</code>判断线程的中断标识，而该方法调用完毕会清除中断标识位。</p></li><li><p>而AQS为了不改变用户标识。再次调用<code>selfInterrupt</code>恢复用户行为。</p></li></ul><h3 id="2-2-构建等待队列-addWaiter"><a href="#2-2-构建等待队列-addWaiter" class="headerlink" title="2.2 构建等待队列 addWaiter"></a>2.2 构建等待队列 addWaiter</h3><ul><li>我们使用<code>ReentrantLock</code>独占锁时，等待队列是<code>延迟加载</code>的。</li><li>也就是说<strong>若是线程交替执行</strong>，那么借助<code>信号量（状态）</code>来保证。</li><li>若是<strong>线程并发执行</strong>，就需要将阻塞线程放入到队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个方法可能存在并发问题。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;  </span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);  </span><br><span class="line">    Node pred = tail;  </span><br><span class="line">    <span class="comment">//队列已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        node.prev = pred;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;  </span><br><span class="line">            pred.next = node;  </span><br><span class="line">            <span class="keyword">return</span> node;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//队列不存在</span></span><br><span class="line">    enq(node);  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>队列不存在的情况(初始化队列 enq(Node))</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094601871.png" alt="mark"></p><p>注意，该方法处理<code>CAS</code>操作是原子性的，其他操作都存在并发冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">         Node t = tail;  </span><br><span class="line">         <span class="comment">// 初始化队列 （一个Thread 为null的空node）</span></span><br><span class="line">         <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  </span></span><br><span class="line">             <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))  </span><br><span class="line">                 tail = head;  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">             <span class="comment">// (维护队列 CAS改变队尾)</span></span><br><span class="line">             node.prev = t;  </span><br><span class="line">             <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  </span><br><span class="line">                 t.next = node;  </span><br><span class="line">                 <span class="keyword">return</span> t;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法采用自旋+CAS。CAS是保证同一时刻只有一个线程能成功改变引用的指向。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094805424.png" alt="mark"></p><ul><li><p>根据上面的流程图，sync queue的创建过程。<strong>head节点是<code>new Node()</code>产生的，即其中的属性为默认值。</strong>也就是thread属性为null。也就是说<strong>正在执行的线程也会在<code>sync queue</code>中占据头节点，但是节点中不会保存线程信息。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094839510.png" alt="mark"></p></li></ul><p><strong>尾分叉问题：</strong></p><p>上面已经说了，该方法是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1：可能多个节点的prev指针都指向尾结点，导致尾分叉</span></span><br><span class="line">node.prev = t;  </span><br><span class="line"><span class="comment">//步骤2：但同一时刻，tail引用只会执行一个node。</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  </span><br><span class="line">   <span class="comment">//步骤3：现在环境是线程安全，旧尾结点的后继指针指向新尾结点。</span></span><br><span class="line">   t.next = node;  </span><br><span class="line">   <span class="keyword">return</span> t;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094920922.png" alt="mark"></p><p>执行完<code>步骤2</code>，但<code>步骤3</code>还未执行时，恰好有线程从头节点开始往后遍历。<strong>此时（旧）尾结点中的next域还为null。</strong>它是遍历不到新加进来的尾结点的。这显然是不合理的。</p><p>但此时<code>步骤1</code>是执行成功的，所以<strong>若是tail节点往前遍历，实际上是可以遍历到所有节点的</strong>，这也是为什么在AQS源码中，有时候常常会出现<strong>从尾结点开始逆向遍历链表的情况</strong>。</p><p>那些“分叉”的节点，肯定会入队失败。那么继续自旋，等待所有的线程节点全部入队成功。</p><h3 id="2-3-尝试获取锁-tryAcquire"><a href="#2-3-尝试获取锁-tryAcquire" class="headerlink" title="2.3 尝试获取锁 tryAcquire"></a>2.3 尝试获取锁 tryAcquire</h3><ul><li>根据标志位state，来判断锁是否被占用。此时可能锁未被占用，由于是公平锁，于是会去判断<code>sync queue</code>中是否有人在排队。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();  </span><br><span class="line">    <span class="comment">//获取Lock对象的上锁情况，0-表示无线程持有；1-表示被线程持有；大于1-表示锁被重入</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();  </span><br><span class="line">    <span class="comment">//若此刻无人占有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;    <span class="comment">//判断队列中是否有前辈。若返回false代表没有，开始尝试加锁</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//此刻队列中没有存在前辈，尝试加锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);   <span class="comment">//将当前线程修改为持有锁的线程（后续判断可重入）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//若是当前线程是持有锁的线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  </span><br><span class="line">        <span class="comment">//当前状态+1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;  </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);  </span><br><span class="line">        setState(nextc);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//否则，代表加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法不具有原子性，可能多个线程都觉得自己不需要排队，最终还是依靠外面</span></span><br><span class="line"><span class="comment">//条件上的CAS来保持其原子性。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Node t = tail;   </span><br><span class="line">    Node h = head;  </span><br><span class="line">    Node s;  </span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;  </span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是<code>判断队列中是否存在元素</code>。可能存在以下几种情况：</p><ul><li><strong>此时未维护队列</strong>，<code>h!=t</code>返回false，即无人排队；</li><li>此时队列<strong>只有头节点</strong>（哑结点），<code>h!=t</code>返回false，即无人排队；</li><li>此时队列中<strong>存在2个的节点</strong>。若线程是头结点的后继节点线程（即处理正在办理业务的线程，进来的线程是第一个排队的线程）。那么<code>s.thread != Thread.currentThread()</code>返回false，即可是尝试加锁。</li><li>队列存在<strong>2个以上节点</strong>，且进来的线程不是第一个排队的线程，那么该线程需要乖乖的排队</li></ul><p>当然该方法不是并发安全的方法，即可能存在多个线程觉得自己无需排队，最终还是依靠<code>CAS</code>来争夺锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">    <span class="comment">//线程安全   </span></span><br><span class="line">    setExclusiveOwnerThread(current);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一时刻，只有一个线程可以成功改变state的状态。记录该线程为独占锁线程，一般后续可以重入。</p><p>没成功获取锁那么会调用<code>2.2 中的方法，将该线程加入到阻塞队列中</code>。</p><h3 id="2-4-阻塞线程-acquireQueued"><a href="#2-4-阻塞线程-acquireQueued" class="headerlink" title="2.4 阻塞线程 acquireQueued"></a>2.4 阻塞线程 acquireQueued</h3><ul><li>若执行到该方法，说明<code>addWaiter</code>方法已经成功将该线程包装为Node节点放到了队尾。</li><li>在该方法中依旧尝试获取锁；</li><li>再次获取锁失败后，会将其阻塞；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="comment">//获取node的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  </span><br><span class="line">            <span class="comment">//若前驱节点在办理业务，那么它将再次获取一次锁。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  </span><br><span class="line">                <span class="comment">//获取锁成功，此处便是线程安全。</span></span><br><span class="line">                <span class="comment">//将自己设置为头节点，并将自己设置为哑节点</span></span><br><span class="line">                setHead(node);  </span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC  </span></span><br><span class="line">                failed = <span class="keyword">false</span>;  </span><br><span class="line">                <span class="keyword">return</span> interrupted;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//获取锁失败，将自己挂起。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                parkAndCheckInterrupt())  </span><br><span class="line">                interrupted = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            cancelAcquire(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法时<code>自旋方法</code>，而出口就是获取到锁。若线程获取不到锁，便会将自己阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法时node线程获取锁成功后执行的，故是线程安全的。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;  </span><br><span class="line">    head = node;  </span><br><span class="line">    node.thread = <span class="keyword">null</span>;  </span><br><span class="line">    node.prev = <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-103752407.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//上一个节点的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;  </span><br><span class="line">    <span class="comment">//  Node.SIGNAL==-1</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    <span class="comment">//ws大于0，则说明该节点已经被取消了。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            node.prev = pred = pred.prev;  </span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);  </span><br><span class="line">        pred.next = node;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//CAS变更ws的状态</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是加锁失败开始执行的。也就是一个线程决定挂起之前需要执行的操作。这里就用到了节点中的信号量<code>waitStatus</code>。</p><ol><li>判断前驱节点<code>waitStatus</code>的值，会做出如下操作：<br> 1.1 前驱节点<code>waitStatus</code>若是-1，直接返回true。<br> 1.2 前驱节点<code>waitStatus</code>若大于0，证明前驱节点已被取消，那么在链表中删除前驱节点，直到node的前驱节点的<code>waitStatus</code>不大于0为止。然后返回false<br> 1.3. 若前驱节点<code>waitStatus</code>等于0，使用CAS尝试改变前驱节点<code>waitStatus</code>状态，由0到-1，然后返回false。</li></ol><ol start="2"><li>若是返回true，那么去阻塞该节点，若是返回false，那么继续自旋，继续上述过程，直至该方法返回true为止，方法返回true，便会执行下列方法，阻塞线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//将线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);  </span><br><span class="line">    <span class="comment">//线程被唤起时，查看线程的中断标识（注意，查看完毕后，中断标识归位）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：当前节点在阻塞之前，会将前驱节点的<code>waitStatus</code>设置为-1，就可保证前驱节点在适当的时机唤醒自己。</strong></p><h2 id="3-附录"><a href="#3-附录" class="headerlink" title="3. 附录"></a>3. 附录</h2><h3 id="3-1-CAS对象"><a href="#3-1-CAS对象" class="headerlink" title="3.1 CAS对象"></a>3.1 CAS对象</h3><p>开始我认为对象的CAS算法，实际上会是B对象去覆盖堆内存上的A对象，其实不然。比较交换的是引用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法是获取引用。而非堆上的内存。</span></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        valueOffset = unsafe.objectFieldOffset  </span><br><span class="line">            (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ex); &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-加锁总结"><a href="#4-加锁总结" class="headerlink" title="4. 加锁总结"></a>4. 加锁总结</h2><ol><li>因为AQS的等待队列是延迟加载，只有多个线程并发访问时，才会开始维护队列。</li><li>因为head节点中不包含<code>thread</code>属性的值，又被称为<code>哑节点</code>。</li><li>head是正在办理业务的节点，而他的后继节点是第一个排队节点。</li></ol><blockquote><ol><li>尝试加锁过程</li></ol></blockquote><ol><li>根据status判断当前锁是否被持有，若被持有，直接<code>维护队列</code>；</li><li>若未被持有，判断当前队列是否有节点在排队，若有节点排队，直接<code>维护队列</code>；</li><li>若无节点排队，则通过CAS修改锁状态标识，修改成功代表线程持有该锁；</li><li>使用<code>exclusiveOwnerThread</code>来保存持有锁的线程（解决线程重入）；</li></ol><blockquote><ol start="2"><li>维护队列过程</li></ol></blockquote><p>最终线程的head节点为哑节点。后续线程被组装成node节点，维护在链表中。</p><blockquote><ol start="3"><li>线程阻塞过程</li></ol></blockquote><ol><li>判断node节点是否为head节点的后续节点（第一个排队节点），若是的话，尝试获取锁。若获取到，将其设置为head节点，并将其设置为哑节点；</li><li>在阻塞前，会将自己的前驱节点的<code>waitStatus</code>设置为<code>SIGNAL</code>。以便可以唤醒自己。</li></ol><p><strong>参考博客</strong></p><p><a href="https://www.jianshu.com/p/dcc608274b88" target="_blank" rel="noopener">https://www.jianshu.com/p/dcc608274b88</a></p><p><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017372067</a></p><p><a href="https://www.cnblogs.com/fsmly/p/11274572.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsmly/p/11274572.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC-19-AQS&quot;&gt;&lt;a href=&quot;#JUC-19-AQS&quot; class=&quot;headerlink&quot; title=&quot;JUC-19-AQS&quot;&gt;&lt;/a&gt;JUC-19-AQS&lt;/h1&gt;&lt;h2 id=&quot;1-AQS结构&quot;&gt;&lt;a href=&quot;#1-AQS结构&quot; class
      
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhuuu.work/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>JVM-12-四种引用类型</title>
    <link href="http://zhuuu.work/2020/08/01/JVM_Notes/JVM-12-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhuuu.work/2020/08/01/JVM_Notes/JVM-12-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-08-01T02:38:38.000Z</published>
    <updated>2020-08-04T06:22:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-12-四种引用类型"><a href="#JVM-12-四种引用类型" class="headerlink" title="JVM-12-四种引用类型"></a>JVM-12-四种引用类型</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200804-142140836.png" alt="mark"></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><ul><li><p><strong>在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象</strong>。也就是说，只有对象处于可触及状态，程序才能使用它。这 就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了。</p></li><li><p>但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因 为也许将来还会派用场。<strong>对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃 圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。</strong></p></li><li><p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。<strong>这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用</strong>。</p></li></ul><a id="more"></a><h2 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h2><ul><li><strong>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用</strong>。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。<strong>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Arraylist&lt;String&gt;();</span><br><span class="line">list.add(str);</span><br></pre></td></tr></table></figure><blockquote><p>在list集合里的数据不会释放，即使内存不足也不会</p></blockquote><h2 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h2><ul><li>如果一个对象只具有软引用，那就类似于可有可物的生活用品。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</strong>只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li><li>软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</li></ul><h2 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h2><ul><li>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。<strong>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</strong>不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</li><li>弱引用可以和一个<strong>引用队列</strong>（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object c = <span class="keyword">new</span> Car(); <span class="comment">//只要c还指向car object, car object就不会被回收</span></span><br><span class="line">WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> WeakReference(Car)(car);</span><br></pre></td></tr></table></figure><p>当要获得weak reference引用的object时, 首先需要判断它是否已经被回收:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weakCar.get();</span><br></pre></td></tr></table></figure><p>如果此方法为空, 那么说明weakCar指向的对象已经被回收了.</p><p>下面来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">private</span> String colour;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, String colour)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">    <span class="keyword">this</span>.colour = colour;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getColour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> colour;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColour</span><span class="params">(String colour)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colour = colour;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> colour +<span class="string">"car costs $"</span>+price;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWeakReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Car car = <span class="keyword">new</span> Car(<span class="number">22000</span>,<span class="string">"silver"</span>);</span><br><span class="line">    WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> WeakReference&lt;Car&gt;(car);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(weakCar.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"Object is alive for "</span>+i+<span class="string">" loops - "</span>+weakCar);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Object has been collected."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在上例中, 程序运行一段时间后, 程序打印出”Object has been collected.” 说明, weak reference指向的对象的被回收了.</span><br><span class="line"></span><br><span class="line">如果要想打出的是</span><br><span class="line">Object is alive for “+i+” loops - “+weakCar</span><br><span class="line"></span><br><span class="line">那么只要在这句话前面加上</span><br><span class="line">System.out.println(“car&#x3D;&#x3D;&#x3D;&#x3D; “+car);</span><br><span class="line">因为在此强引用了car对象</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。</strong></p><p>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p><p><strong>这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</strong></p></blockquote><h2 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h2><ul><li>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就<strong>和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</li><li>虚引用与软引用和弱引用的一个区别在于：<strong>虚引用必须和引用队列（ReferenceQueue）联合使用</strong>。</li><li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line"></span><br><span class="line">强引用：</span><br><span class="line">String str &#x3D; “abc”;</span><br><span class="line">list.add(str);</span><br><span class="line">软引用：</span><br><span class="line">如果弱引用对象回收完之后，内存还是报警，继续回收软引用对象</span><br><span class="line">弱引用：</span><br><span class="line">如果虚引用对象回收完之后，内存还是报警，继续回收弱引用对象</span><br><span class="line">虚引用：</span><br><span class="line">虚拟机的内存不够使用，开始报警，这时候垃圾回收机制开始执行System.gc(); String s &#x3D; “abc”;如果没有对象回收了， 就回收没虚引用的对象</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-12-四种引用类型&quot;&gt;&lt;a href=&quot;#JVM-12-四种引用类型&quot; class=&quot;headerlink&quot; title=&quot;JVM-12-四种引用类型&quot;&gt;&lt;/a&gt;JVM-12-四种引用类型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200804-142140836.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象&lt;/strong&gt;。也就是说，只有对象处于可触及状态，程序才能使用它。这 就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因 为也许将来还会派用场。&lt;strong&gt;对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃 圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。&lt;strong&gt;这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="http://zhuuu.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://zhuuu.work/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JUC-18-CAS</title>
    <link href="http://zhuuu.work/2020/07/31/JUC/JUC-18-CAS/"/>
    <id>http://zhuuu.work/2020/07/31/JUC/JUC-18-CAS/</id>
    <published>2020-07-31T08:02:24.000Z</published>
    <updated>2020-08-11T08:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-18-CAS"><a href="#JUC-18-CAS" class="headerlink" title="JUC-18-CAS"></a>JUC-18-CAS</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>CAS<strong>（Compare-and-Swap），即比较并替换</strong>，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题，本文将深入的介绍CAS的原理。</li></ul><p>[参考博客][<a href="https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]</a></p><h2 id="2-CAS"><a href="#2-CAS" class="headerlink" title="2. CAS"></a>2. CAS</h2><h3 id="2-1-一个例子"><a href="#2-1-一个例子" class="headerlink" title="2.1 一个例子"></a>2.1 一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREADS_COUNT);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。</p><p>通过<strong>分析字节码</strong>我们知道，这是因为volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示），在并发的情况下，putstatic指令可能把较小的race值同步回主内存之中，导致我们每次都无法获得想要的结果。那么，应该怎么解决这个问题了？</p><a id="more"></a><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-170802496.png" alt="mark"></p><p><strong>解决方案1：Synchronized</strong></p><ul><li>首先我们想到的是用synchronized来修饰increase方法。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-170849960.png" alt="mark"></p><p>使用synchronized修饰后，increase方法变成了一个原子操作，因此是肯定能得到正确的结果。但是，我们知道，每次自增都进行加锁，性能可能会稍微差了点，有更好的方案吗？</p><p><strong>解决方案2：Atomic</strong></p><ul><li><p>答案当然是有的，这个时候我们可以使用Java并发包原子操作类（Atomic开头），例如以下代码。</p></li><li><p>将例子中的代码稍做修改：race改成使用AtomicInteger定义，“race++”改成使用“<code>race.getAndIncrement()</code>”，<code>AtomicInteger.getAndIncrement()</code>是原子操作，因此我们可以确保每次都可以获得正确的结果，并且在性能上有不错的提升</p></li><li><p><strong>通过方法调用，我们可以发现，<code>getAndIncrement</code>方法调用<code>getAndAddInt</code>方法，最后调用的是compareAndSwapInt方法，即本文的主角CAS，接下来我们开始介绍CAS。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-171109399.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-171128020.png" alt="mark"></p><h3 id="2-2-JDK中的CAS实现"><a href="#2-2-JDK中的CAS实现" class="headerlink" title="2.2 JDK中的CAS实现"></a>2.2 JDK中的CAS实现</h3><ol><li>JDK中提供了CAS支持？</li></ol><ul><li><p>通过调用JNI(<code>java Native interface</code>)</p></li><li><p>java中提供了对CAS的支持，具体在<strong>sun.misc.unsafe类中</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数var1 : 要操作的对象</strong></p><p><strong>参数var2 : 要操作的对象属性地址的偏移量</strong></p><p><strong>参数var4 : 期望值</strong></p><p><strong>参数var6 : 需要更新的新值</strong></p><ul><li>并且<code>compareAndSwapLong</code> 是使用CPU底层指令来实现的。以常用的Intel x86平台，最后映射到cpu的 <code>cmpxchg</code> 来实现，这是一个原子指令。</li><li>系统底层进行CAS操作的时候，会判断当前系统是否是多核心，<strong>如果是就给 “ 总线加锁”</strong>，加锁之后，只有一个线程会对总线加锁成功，也就是说CAS的操作是平台级别的。</li></ul><h3 id="2-3-CAS带来的问题"><a href="#2-3-CAS带来的问题" class="headerlink" title="2.3 CAS带来的问题"></a>2.3 CAS带来的问题</h3><ul><li><p>循环时间长开销很大。</p></li><li><p><strong>只能保证一个变量的原子操作。</strong></p></li><li><p><strong>ABA 问题 ： 一句话总结，狸猫换太子</strong></p><ul><li><p>解决方案： <code>AtomicStampReference</code> （Pair对象）</p></li><li><pre><code class="java"><span class="comment">// 内部类：不但要提供数据引用，还要提供版本号    </span><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>{        <span class="keyword">final</span> T reference;        <span class="keyword">final</span> <span class="keyword">int</span> stamp;        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>{            <span class="keyword">this</span>.reference = reference;             <span class="keyword">this</span>.stamp = stamp;        }        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>{            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);        }    }    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair&lt;!--￼<span class="number">2</span>--&gt;</code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-18-CAS&quot;&gt;&lt;a href=&quot;#JUC-18-CAS&quot; class=&quot;headerlink&quot; title=&quot;JUC-18-CAS&quot;&gt;&lt;/a&gt;JUC-18-CAS&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CAS&lt;strong&gt;（Compare-and-Swap），即比较并替换&lt;/strong&gt;，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题，本文将深入的介绍CAS的原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[参考博客][&lt;a href=&quot;https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-CAS&quot;&gt;&lt;a href=&quot;#2-CAS&quot; class=&quot;headerlink&quot; title=&quot;2. CAS&quot;&gt;&lt;/a&gt;2. CAS&lt;/h2&gt;&lt;h3 id=&quot;2-1-一个例子&quot;&gt;&lt;a href=&quot;#2-1-一个例子&quot; class=&quot;headerlink&quot; title=&quot;2.1 一个例子&quot;&gt;&lt;/a&gt;2.1 一个例子&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.CountDownLatch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;VolatileTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; race = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; THREADS_COUNT = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; CountDownLatch countDownLatch = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CountDownLatch(THREADS_COUNT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;increase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        race++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread[] threads = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread[THREADS_COUNT];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; THREADS_COUNT; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            threads[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        increase();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    countDownLatch.countDown();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            threads[i].start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        countDownLatch.await();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(race);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;我们知道，运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;分析字节码&lt;/strong&gt;我们知道，这是因为volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示），在并发的情况下，putstatic指令可能把较小的race值同步回主内存之中，导致我们每次都无法获得想要的结果。那么，应该怎么解决这个问题了？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC-17-ConcurrentHashMap</title>
    <link href="http://zhuuu.work/2020/07/29/JUC/JUC-17-ConcurrentHashMap/"/>
    <id>http://zhuuu.work/2020/07/29/JUC/JUC-17-ConcurrentHashMap/</id>
    <published>2020-07-29T03:02:24.000Z</published>
    <updated>2020-07-29T06:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-17-ConcurrentHashMap"><a href="#JUC-17-ConcurrentHashMap" class="headerlink" title="JUC-17-ConcurrentHashMap"></a>JUC-17-ConcurrentHashMap</h1><p><a href="https://blog.csdn.net/weixin_44460333/article/details/86770169" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44460333/article/details/86770169</a></p><p><a href="https://www.jianshu.com/p/d0b37b927c48" target="_blank" rel="noopener">https://www.jianshu.com/p/d0b37b927c48</a></p><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>ConcurrentHashMap 是一个并发散列映射表，它允许完全并发的读取，并且支持给定数量的并发更新。</li><li>而HashTable和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC-17-ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#JUC-17-ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;JUC-17-ConcurrentHashMap&quot;&gt;&lt;/a&gt;JUC-17-Concurr
      
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>排序-03-快速排序</title>
    <link href="http://zhuuu.work/2020/07/27/Sort/%E6%8E%92%E5%BA%8F-03-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/07/27/Sort/%E6%8E%92%E5%BA%8F-03-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-27T10:33:24.000Z</published>
    <updated>2020-09-03T02:51:53.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-03-快速排序"><a href="#排序-03-快速排序" class="headerlink" title="排序-03-快速排序"></a>排序-03-快速排序</h1><h2 id="1-思想"><a href="#1-思想" class="headerlink" title="1. 思想"></a>1. 思想</h2><ul><li><strong>快速排序,说白了就是给基准数据找其正确索引位置的过程.</strong></li></ul><p>举个栗子：</p><ul><li>如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105141936.png" alt="mark"></p><a id="more"></a><ul><li>首先从后半部分开始，<strong>如果扫描到的值大于基准数据就让high减1</strong>,<strong><em>如果发现有元素比该基准数据的值小(如上图中18&lt;=tmp)，就将high位置的值赋值给low位置</em></strong> ,结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105611384.png" alt="mark"></p><ul><li>然后开始从前往后扫描,<strong>如果扫描到的值小于基准数据就让low加1</strong>,<strong><em>如果发现有元素大于基准数据的值(如上图46=&gt;tmp)，就再将low位置的值赋值给high位置的值</em></strong>,指针移动并且数据交换后的结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105635565.png" alt="mark"></p><ul><li>然后再开始从后向前扫描,原理同上,发现上图<code>11&lt;=tmp</code>,则将high位置的值赋值给low位置的值,结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105749727.png" alt="mark"></p><ul><li><strong>这样一遍走下来,可以很清楚的知道,其实快速排序的本质就是把基准数大的都放在基准数的右边,把比基准数小的放在基准数的左边,这样就找到了该数据在数组中的正确位置.</strong></li><li><strong>以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。</strong></li></ul><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2. 结论"></a>2. 结论</h2><p>从上面的过程中可以看到:</p><p>  ①先从队尾开始向前扫描且当<code>low &lt; high</code>时,如果<code>a[high] &gt; tmp</code>则<code>high–</code>,但如果<code>a[high] &lt; tmp</code>,则将<code>high</code>的值赋值给<code>low</code>,即<code>arr[low] = a[high]</code>,同时要转换数组扫描的方式,即需要从队首开始向队尾进行扫描了<br>  ②同理,当从队首开始向队尾进行扫描时,如果<code>a[low] &lt; tmp</code>,则<code>low++</code>,但如果<code>a[low] &gt; tmp</code>了,则就需要将<code>low</code>位置的值赋值给<code>high</code>位置,即<code>arr[low] = arr[high]</code>,同时将数组扫描方式换为由队尾向队首进行扫描.</p><p>​    ③不断重复①和②,知道<code>low&gt;=high</code>时(其实是<code>low=high</code>),<code>low</code>或<code>high</code>的位置就是该基准数据在数组中的正确索引位置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">76</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">22</span> &#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"排序后:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 找寻基准数据的正确索引</span></span><br><span class="line">            <span class="keyword">int</span> index = getIndex(arr, low, high);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序</span></span><br><span class="line">            quickSort(arr, low, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基准数据</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 当队尾的元素大于等于基准数据时,向前挪动high指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果队尾元素小于tmp了,需要将其赋值给low</span></span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            <span class="comment">// 当队首元素小于等于tmp时,向前挪动low指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= tmp) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当队首元素大于tmp时,需要将其赋值给high</span></span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置</span></span><br><span class="line">        <span class="comment">// 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low]</span></span><br><span class="line">        arr[low] = tmp;</span><br><span class="line">        <span class="keyword">return</span> low; <span class="comment">// 返回tmp的正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-优化"><a href="#3-优化" class="headerlink" title="3. 优化"></a>3. 优化</h2><p>参考博客 ： <a href="https://blog.csdn.net/qq_19525389/article/details/81436838" target="_blank" rel="noopener">https://blog.csdn.net/qq_19525389/article/details/81436838</a></p><p><strong>1、快速排序的基本思想：</strong></p><ul><li>快速排序使用<strong>分治</strong>的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。</li><li>之后分别对这两部分记录继续进行排序，递归地以达到整个序列有序的目的。</li></ul><p><strong>2、快速排序的三个步骤：</strong></p><p>(1<strong>)选择基准</strong>：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</p><p>(2)<strong>分割操作</strong>：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p><p>(3)<strong>递归地</strong>对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><p><strong>优化一 ： 选择基准的方式</strong></p><ul><li><p>对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p></li><li><p>最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列</p></li></ul><p>我们介绍<strong>三种选择基准的方法</strong></p><ol><li>思想：取序列的第一个或最后一个元素作为基准</li></ol><p>基本的快速排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr[low];<span class="comment">//选择选取序列的第一个元素作为基准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：基本的快速排序选取第一个或最后一个元素作为基准。但不是一种好方法</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113020716.png" alt="mark"></p><p>测试数据分析：如果输入序列是随机的，处理时间可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为起泡排序，时间复杂度为Θ(n^2)。而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为枢纽元是非常糟糕的，为了避免这个情况，就引入了下面两个获取基准的方法。</p><p><strong>方法(2)：随机选取基准</strong></p><p>引入的原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴</p><p>思想：取待排序列中任意一个元素作为基准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/*随机选择枢轴的位置，区间在low和high之间*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivotRandom</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((unsigned)time(NULL));<span class="comment">//产生枢轴的位置</span></span><br><span class="line"><span class="keyword">int</span> pivotPos = rand()%(high - low) + low;</span><br><span class="line"> </span><br><span class="line">swap(arr[pivotPos],arr[low]);<span class="comment">//把枢轴位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数</span></span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113115935.png" alt="mark"></p><p><strong>方法三： 三数取中</strong></p><ul><li>引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取枢轴</li><li>具体思想：对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">举例：待排序序列为：8 1 4 9 6 3 5 2 7 0</span><br><span class="line"></span><br><span class="line">左边为：8，右边为0，中间为6.</span><br><span class="line"></span><br><span class="line">我们这里取三个数排序后，中间那个数作为枢轴，则枢轴为6</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivotMedianOfThree</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);<span class="comment">//计算数组中间的元素的下标</span></span><br><span class="line"><span class="comment">//使用三数取中法选择枢轴</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[high])<span class="comment">//目标: arr[mid] &lt;= arr[high]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[mid],arr[high]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; arr[high])<span class="comment">//目标: arr[low] &lt;= arr[high]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[low],arr[high]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[low]) <span class="comment">//目标: arr[low] &gt;= arr[mid]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[mid],arr[low]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此时，arr[mid] &lt;= arr[low] &lt;= arr[high]</span></span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line"><span class="comment">//low的位置上保存这三个位置中间的值</span></span><br><span class="line"><span class="comment">//分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113256817.png" alt="mark"></p><p><strong>优化二：当待排序序列长度分割到一定大小后，使用插入排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</span><br><span class="line"></span><br><span class="line">截止范围：待排序序列长度N &#x3D; 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。摘自《数据结构与算法分析》Mark Allen Weiness 著</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (high - low + <span class="number">1</span> &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">InsertSort(arr,low,high);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//else时，正常执行快排</span></span><br></pre></td></tr></table></figure><p>测试数据：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113505110.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试数据分析：针对随机数组，使用三数取中选择枢轴+插排，效率还是可以提高一点，</span><br><span class="line">但是针对已排序的数组，是没有任何用处的。因为待排序序列是已经有序的，那么每次划分只能使待排序序列减一。</span><br><span class="line">此时，插排是发挥不了作用的。所以这里看不到时间的减少。另外，三数取中选择枢轴+插排还是不能处理重复数组</span><br></pre></td></tr></table></figure><p><strong>优化三：在一次分割结束后，可以把key相等的元素聚集在一起，不用在对key相等的元素分割</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line"></span><br><span class="line">待排序序列 <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">三数取中选取枢轴：下标为<span class="number">4</span>的数<span class="number">6</span></span><br><span class="line"></span><br><span class="line">转换后，待分割序列：<span class="number">6</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">             枢轴key：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">本次划分后，未对与key元素相等处理的结果：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">下次的两个子序列为：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> 和 <span class="number">7</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">本次划分后，对与key元素相等处理的结果：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">下次的两个子序列为：<span class="number">1</span> <span class="number">4</span> 和 <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">经过对比，我们可以看出，在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少</span><br><span class="line"></span><br><span class="line">具体过程：在处理过程中，会有两个步骤</span><br><span class="line"></span><br><span class="line">第一步，在划分过程中，把与key相等元素放入数组的两端</span><br><span class="line"></span><br><span class="line">第二步，划分结束后，把与key相等的元素移到枢轴周围</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br><span class="line">待排序序列 <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">三数取中选取枢轴：下标为<span class="number">4</span>的数<span class="number">6</span></span><br><span class="line"></span><br><span class="line">转换后，待分割序列：<span class="number">6</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">             枢轴key：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">第一步，在划分过程中，把与key相等元素放入数组的两端 </span><br><span class="line"></span><br><span class="line">结果为：<span class="number">6</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span>(枢轴) <span class="number">7</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">此时，与<span class="number">6</span>相等的元素全放入在两端了</span><br><span class="line"></span><br><span class="line">第二步，划分结束后，把与key相等的元素移到枢轴周围</span><br><span class="line"></span><br><span class="line">结果为：<span class="number">1</span> <span class="number">4</span> <span class="number">66</span>(枢轴)  <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">此时，与<span class="number">6</span>相等的元素全移到枢轴周围了</span><br><span class="line"></span><br><span class="line">之后，在<span class="number">1</span> <span class="number">4</span> 和 <span class="number">7</span> <span class="number">8</span> <span class="number">7</span>两个子序列进行快排</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gather</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> boundKey, <span class="keyword">int</span> *left, <span class="keyword">int</span> *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> count = boundKey - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = boundKey - <span class="number">1</span>; i &gt;= low; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[boundKey])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr, i, count);</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*left = count;</span><br><span class="line">count = boundKey + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = boundKey + <span class="number">1</span>; i &lt;= high; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[boundKey])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr, i, count);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*right = count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：在数组中，如果有相等的元素，那么就可以减少不少冗余的划分。这点在重复数组中体现特别明显啊。</p><p>其实这里，插排的作用还是不怎么大的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-03-快速排序&quot;&gt;&lt;a href=&quot;#排序-03-快速排序&quot; class=&quot;headerlink&quot; title=&quot;排序-03-快速排序&quot;&gt;&lt;/a&gt;排序-03-快速排序&lt;/h1&gt;&lt;h2 id=&quot;1-思想&quot;&gt;&lt;a href=&quot;#1-思想&quot; class=&quot;headerlink&quot; title=&quot;1. 思想&quot;&gt;&lt;/a&gt;1. 思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速排序,说白了就是给基准数据找其正确索引位置的过程.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105141936.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="快速排序" scheme="http://zhuuu.work/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-03-传输层</title>
    <link href="http://zhuuu.work/2020/07/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-03-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/07/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-03-%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2020-07-27T04:02:24.000Z</published>
    <updated>2020-08-05T07:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-03-传输层"><a href="#计算机网络-03-传输层" class="headerlink" title="计算机网络-03-传输层"></a>计算机网络-03-传输层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>推荐博客：</strong> <a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p><h6 id="传输层和网络层的关系"><a href="#传输层和网络层的关系" class="headerlink" title="传输层和网络层的关系"></a>传输层和网络层的关系</h6><ul><li>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</li><li>传输层提供了进程中的逻辑通信，传输层向高层用户屏蔽了网络层的核心实现，使得应用进程看起来像是两个传输层实体之间一条端到端的逻辑通信信道。</li></ul><p>实际上，<strong>传输层和应用程序进程之间通过Socket（套接字）</strong>关联，这样通过Socket就可以区别同一主机上的不同应用进程，从而传输层提供服务变为可能；</p><p>实际上，每个套接字都有一个唯一的ID，被称为<strong>端口号</strong>；而在传输层接收到来自应用程序的分组并通过添加传输层首部而形成报文段的过程中，该端口号被写入；端口号大小在0-65535之间，其中0-1023属于周知端口号，它们为特定的Socket而拥有。</p><a id="more"></a><h2 id="1-UDP-和-TCP的特点"><a href="#1-UDP-和-TCP的特点" class="headerlink" title="1. UDP 和 TCP的特点"></a>1. UDP 和 TCP的特点</h2><ul><li><strong>用户数据报协议（UDP）</strong>（User Datagram Protocol）<ul><li>无连接的，尽最大努力交付</li><li>没有拥塞控制</li><li>面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）</li><li>支持一对一，一对多，多对一和多对多的交互通信。</li></ul></li><li><strong>传输控制协议 TCP</strong> （Transmission Control Protocol）<ul><li>面向连接的，提供可靠交付</li><li>有流量控制，拥塞避免，提供全双工通信</li><li>面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</li><li>每一条 TCP 连接只能是点对点的（一对一）。</li></ul></li></ul><h2 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h2><h3 id="2-1-UDP首部格式"><a href="#2-1-UDP首部格式" class="headerlink" title="2.1 UDP首部格式"></a>2.1 UDP首部格式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-102741716.png" alt="mark"></p><ul><li>首部字段只有8个字节，包括源端口，目的端口，长度，检验和。12字节的伪首部是为了计算检验和临时添加的</li></ul><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h2><h3 id="3-1-TCP-首部格式"><a href="#3-1-TCP-首部格式" class="headerlink" title="3.1 TCP 首部格式"></a>3.1 TCP 首部格式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-105028905.png" alt="mark"></p><ul><li><p><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong>：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认ACK :</strong> 当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步SYN</strong> : 在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止FIN :</strong> 用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p><strong>窗口</strong> ： 窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h3 id="3-2-TCP-的-三次握手（面试必问）"><a href="#3-2-TCP-的-三次握手（面试必问）" class="headerlink" title="3.2 TCP 的 三次握手（面试必问）"></a>3.2 TCP 的 三次握手（面试必问）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-110028209.png" alt="mark"></p><p>假设A是客户端，B是服务器端。</p><ul><li>首先B处于Listen(监听)状态，等待客户的连接请求。</li><li>A向B发送连接请求报文，SYN = 1 ，ACK = 0，选择一个初始的序号x</li><li>B收到连接请求报文，如果同意建立连接，则向A发送连接确认报文，SYN = 1，ACK = 1,确认号是 x + 1,同时也选择一个初始序号y</li><li>A收到B的连接确认报文后，还要向B发出确认，确认号为 y + 1,序号是 x +  1</li><li>B收到A的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><ul><li>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误的打开连接。</li><li><strong>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发送回的连接确认。</strong>客户端等待一个<strong>超时重传时间</strong>之后，就会重新请求连接。但是这个滞留的连接最后还是到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端就会忽略服务器之后发送的滞留连接请求的连接确认，不进行第三次握手，所以不会再次重复的打开连接。</li></ul><h3 id="3-3-TCP的四次挥手（面试必问）"><a href="#3-3-TCP的四次挥手（面试必问）" class="headerlink" title="3.3 TCP的四次挥手（面试必问）"></a>3.3 TCP的四次挥手（面试必问）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-111815380.png" alt="mark"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论ACK，因为ACK在连接建立之后都是1.</p><ul><li>A发送连接释放报文，FIN = 1</li><li>B 收到之后发出确认，此时TCP处于半关闭状态，B 能向A  发送数据但是 A 不能向 B 发送数据。</li><li>当B 不再不要连接的时候，发出连接释放报文， FIN = 1；</li><li>A 收到后发出确认，进入TIME-WAIT状态，等待2MSL (最大报文存活时间)后释放连接。</li><li>B 收到 A  的 确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><ul><li>客户端发送了FIN 连接释放报文之后，服务器收到了这个报文，就进入了CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。</li></ul><p><strong>TIME_WAIT</strong> </p><p>客户端接收到服务器段的FIN报文后进入此状态，此时并不是直接进入CLOSED状态，还需要等待一个<strong>时间计时器设置的时间2MSL</strong> 。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h3 id="3-4-TCP-的-可靠传输"><a href="#3-4-TCP-的-可靠传输" class="headerlink" title="3.4 TCP 的 可靠传输"></a>3.4 TCP 的 可靠传输</h3><ul><li><strong>TCP使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么 就重传这个报文段。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-133408214.png" alt="mark"></p><ul><li><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><ul><li>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</li></ul></li><li><p>超时时间 RTO 应该略大于 RTTs，<strong>TCP 使用的超时时间计算如下：</strong></p><ul><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-133514339.png" alt="mark"></li><li>其中 RTT<sub>d</sub> 为偏差的加权平均值。</li></ul></li></ul><h3 id="3-5-TCP-滑动窗口"><a href="#3-5-TCP-滑动窗口" class="headerlink" title="3.5 TCP 滑动窗口"></a>3.5 TCP 滑动窗口</h3><ul><li><p>窗口是缓存的一部分，用来暂时存放字节流。<strong>发送方和接收方各有一个窗口</strong>，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p></li><li><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。</p><ul><li>如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；</li><li>接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-134644530.png" alt="mark"></p><h3 id="3-6-TCP-流量控制"><a href="#3-6-TCP-流量控制" class="headerlink" title="3.6 TCP 流量控制"></a>3.6 TCP 流量控制</h3><ul><li>流量控制是为了控制发送方发送速率，保证接收方来得及接收</li><li>接收方发送的确认报文中的窗口字段可以用来控制发送方的窗口大小，从而影响发送方的发送速率。将窗口字段设置成0，则发送方不能发送数据。</li></ul><h3 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a>3.7 TCP 拥塞控制</h3><ul><li><strong>如果网络出现拥塞</strong>，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。</li><li>因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。</li><li><strong>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-135235298.png" alt="mark"></p><p>TCP 主要通过四种算法来进行拥塞控制：<strong>慢开始，拥塞避免，快重传，快恢复。</strong></p><ul><li>发送方需要维护一个叫做<strong>拥塞窗口（cwnd）的状态变量</strong>，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</li></ul><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><h4 id="3-7-1-慢开始和拥塞避免"><a href="#3-7-1-慢开始和拥塞避免" class="headerlink" title="3.7.1 慢开始和拥塞避免"></a>3.7.1 慢开始和拥塞避免</h4><ul><li><p>发送的最初执行<strong>慢开始，令 cwnd = 1，发送方只能发送 1 个报文段</strong>；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p></li><li><p>注意到慢开始<strong>每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快</strong>，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。<strong>设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</strong></p></li><li><p><strong>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</strong></p></li></ul><h4 id="3-7-2-快重传和快恢复"><a href="#3-7-2-快重传和快恢复" class="headerlink" title="3.7.2 快重传和快恢复"></a>3.7.2 快重传和快恢复</h4><ul><li><p><strong>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。</strong>例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p></li><li><p><strong>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传</strong>，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p></li><li><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。<strong>因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</strong></p></li><li><p><strong>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-140417321.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-03-传输层&quot;&gt;&lt;a href=&quot;#计算机网络-03-传输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-03-传输层&quot;&gt;&lt;/a&gt;计算机网络-03-传输层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;推荐博客：&lt;/strong&gt; &lt;a href=&quot;https://blog.csdn.net/qq_39326472/article/details/88089747&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_39326472/article/details/88089747&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;传输层和网络层的关系&quot;&gt;&lt;a href=&quot;#传输层和网络层的关系&quot; class=&quot;headerlink&quot; title=&quot;传输层和网络层的关系&quot;&gt;&lt;/a&gt;传输层和网络层的关系&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。&lt;/li&gt;
&lt;li&gt;传输层提供了进程中的逻辑通信，传输层向高层用户屏蔽了网络层的核心实现，使得应用进程看起来像是两个传输层实体之间一条端到端的逻辑通信信道。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，&lt;strong&gt;传输层和应用程序进程之间通过Socket（套接字）&lt;/strong&gt;关联，这样通过Socket就可以区别同一主机上的不同应用进程，从而传输层提供服务变为可能；&lt;/p&gt;
&lt;p&gt;实际上，每个套接字都有一个唯一的ID，被称为&lt;strong&gt;端口号&lt;/strong&gt;；而在传输层接收到来自应用程序的分组并通过添加传输层首部而形成报文段的过程中，该端口号被写入；端口号大小在0-65535之间，其中0-1023属于周知端口号，它们为特定的Socket而拥有。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-02-应用层</title>
    <link href="http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-02-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-02-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-07-26T04:02:24.000Z</published>
    <updated>2020-08-12T03:02:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-02-应用层"><a href="#计算机网络-02-应用层" class="headerlink" title="计算机网络-02-应用层"></a>计算机网络-02-应用层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>一图胜千言</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172919828.png" alt="mark"></p><a id="more"></a><h2 id="1-DNS-域名系统"><a href="#1-DNS-域名系统" class="headerlink" title="1. DNS : 域名系统"></a>1. DNS : 域名系统</h2><ul><li>DNS 是一个由分层DNS服务器组成的<strong>分布式数据库</strong>，使得主机可以查询主机名和ip相互转换的规则。</li><li><strong>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174020503.png" alt="mark"></p><ul><li>DNS 可以<strong>使用UDP或者TCP进行传输，使用的端口号都是53</strong>，大多数情况DNS使用UDP进行传输，这就要求域名解析器和域名服务器有自己处理超时和重传从而保证可靠性。</li></ul><h3 id="1-1-实现原理"><a href="#1-1-实现原理" class="headerlink" title="1.1 实现原理"></a>1.1 实现原理</h3><ul><li><p><strong>首先，DNS使用UDP作为传输协议，DNS使用53号端口</strong>。</p></li><li><p>当主机上的DNS客户端收到一个转换请求的时候，<strong>客户端将向网络发送一个DNS查询报文</strong>，然后客户端将收到一个包含相关信息的DNS回答报文，这个报文里有客户端想要的内容</p></li><li><p><strong>之后DNS服务器将IP地址返回给请求的提出者即可</strong></p></li><li><p>DNS查询有两种，一种是<strong>递归查询</strong>一种是<strong>迭代查询</strong>；实践中，查询通常满足这样的模式：<strong>从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的</strong>。</p></li><li><p><strong>DNS缓存</strong>原理十分简单，每当DNS服务器发出请求后收到回答时，就<strong>将回答的内容缓存在它自己的主机空间上</strong>。这样，如果有相同的请求到达时，就不需要再去发出请求，直接使用缓存即可；因为有了缓存，本地DNS就可以直接提供一些经常被访问的主机名所对应的IP地址，而不需要询问根DNS服务器了。</p></li></ul><h2 id="2-文件传送协议：FTP"><a href="#2-文件传送协议：FTP" class="headerlink" title="2. 文件传送协议：FTP"></a>2. 文件传送协议：FTP</h2><ul><li>FTP 使用 TCP 建立链接，他需要两个链接来传送一个文件<ul><li><strong>控制连接</strong>：<strong>服务器打开端口号21等待客户端连接</strong>，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并返回服务器的应答</li><li><strong>数据连接</strong>：<strong>用来传送一个数据文件</strong>。</li></ul></li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><ul><li>主动模式：<strong>服务器端主动</strong>建立数据连接，其中服务器的端口号是20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174711960.png" alt="mark"></p><ul><li>被动模式：客户端主动和<strong>服务器建立数据连接</strong>，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174747930.png" alt="mark"></p><p>注意：</p><ul><li><strong>主动模式要求客户端开放端口号给服务器，需要配置客户端的防火墙。</strong></li><li>被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</li></ul><h2 id="3-动态主机配置协议（DHCP）"><a href="#3-动态主机配置协议（DHCP）" class="headerlink" title="3. 动态主机配置协议（DHCP）"></a>3. 动态主机配置协议（DHCP）</h2><ul><li>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</li><li>DHCP 配置的内容<strong>不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</strong></li></ul><h3 id="3-1-DHCP工作工程"><a href="#3-1-DHCP工作工程" class="headerlink" title="3.1 DHCP工作工程"></a>3.1 DHCP工作工程</h3><ol><li><p>客户端发送Discover 报文，该报文的目的地址是 255.255.255.255:<strong>67</strong>,源地址是0.0.0.0：<strong>68</strong>.</p></li><li><p>放入UDP中，该报文被广播到同一个子网的所有主机上，如果客户端和DHCP服务器不在同一个子网，就需要使用中继代理。</p></li><li><p>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</p></li><li><p>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</p></li><li><p>DHCP服务器发送Ack 报文，表示该客户端此时可以使用提供给它的信息。</p></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-085949476.png" alt="mark"></p><h2 id="4-远程登录协议"><a href="#4-远程登录协议" class="headerlink" title="4. 远程登录协议"></a>4. 远程登录协议</h2><ul><li>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</li><li>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</li></ul><h2 id="5-电子邮件协议"><a href="#5-电子邮件协议" class="headerlink" title="5. 电子邮件协议"></a>5. 电子邮件协议</h2><ul><li>一个电子邮件由三部分组成：用户代理，邮件服务器和邮件协议。</li><li>邮件协议包含发送协议和读取协议：<ul><li>发送协议：SMTP</li><li>读取协议： POP3 和 IMAP</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-091118003.png" alt="mark"></p><h3 id="5-1-SMTP"><a href="#5-1-SMTP" class="headerlink" title="5.1 SMTP"></a>5.1 SMTP</h3><ul><li>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</li><li>端口号25</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-091207208.png" alt="mark"></p><h3 id="5-2-POP3"><a href="#5-2-POP3" class="headerlink" title="5.2 POP3"></a>5.2 POP3</h3><ul><li>端口号110</li><li>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</li></ul><h3 id="5-3-IMAP"><a href="#5-3-IMAP" class="headerlink" title="5.3 IMAP"></a>5.3 IMAP</h3><ul><li>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</li><li>端口号143</li></ul><h2 id="6-常用端口号"><a href="#6-常用端口号" class="headerlink" title="6. 常用端口号"></a>6. 常用端口号</h2><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">端口号</th><th align="center">传输层协议</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">域名解析</td><td align="center">DNS</td><td align="center">53</td><td align="center">UDP/TCP</td><td align="center">长度超过 512 字节时使用 TCP</td></tr><tr><td align="center">动态主机配置协议</td><td align="center">DHCP</td><td align="center">67/68</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">简单网络管理协议</td><td align="center">SNMP</td><td align="center">161/162</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">文件传送协议</td><td align="center">FTP</td><td align="center">20/21</td><td align="center">TCP</td><td align="center">控制连接 21，数据连接 20</td></tr><tr><td align="center">远程终端协议</td><td align="center">TELNET</td><td align="center">23</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传送协议</td><td align="center">HTTP</td><td align="center">80</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">简单邮件传送协议</td><td align="center">SMTP</td><td align="center">25</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">邮件读取协议</td><td align="center">POP3</td><td align="center">110</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">网际报文存取协议</td><td align="center">IMAP</td><td align="center">143</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传送协议+SSL</td><td align="center">HTTPS</td><td align="center">443</td><td align="center">TCP</td><td align="center"></td></tr></tbody></table><h2 id="7-Web-请求页面的过程"><a href="#7-Web-请求页面的过程" class="headerlink" title="7.  Web 请求页面的过程"></a>7.  Web 请求页面的过程</h2><h3 id="7-1-DHCP配置主机信息"><a href="#7-1-DHCP配置主机信息" class="headerlink" title="7.1 DHCP配置主机信息"></a>7.1 DHCP配置主机信息</h3><ul><li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li><li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li><li>该数据报则被放置在MAC 帧中，该帧的目的地址 <code>FF FF FF FF FF FF</code>,广播到与交换机连接的所有设备。</li><li>连接到交换机的<strong>DHCP的服务器</strong>收到广播帧之后，不断向上分解得到IP数据报，UDP报文段，DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址，DNS服务器的IP地址，默认路由网关的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段又被放入IP数据报中，最后放入MAC帧中。</li><li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地s址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li><li><strong>主机</strong>收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li></ul><h3 id="7-2-ARP-解析MAC地址"><a href="#7-2-ARP-解析MAC地址" class="headerlink" title="7.2 ARP 解析MAC地址"></a>7.2 ARP 解析MAC地址</h3><ul><li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li><li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li><li>该DNS查询报文被放入目的地址为DNS服务器的IP地址的IP数据报中。</li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li><li><strong>DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议。</strong></li><li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（<code>FF FF FF FF FF FF</code>）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li><li><strong>网关路由器收到该帧后，不断向上分解得到ARP报文，发现其中IP地址和其接口IP地址匹配，因此就发送一个ARP回答报文，包含了他的MAC地址，发送回主机。</strong></li></ul><h3 id="7-3-DNS解析域名"><a href="#7-3-DNS解析域名" class="headerlink" title="7.3 DNS解析域名"></a>7.3 DNS解析域名</h3><ul><li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p></li><li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p></li><li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p></li><li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p></li><li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p></li></ul><h3 id="7-4-HTTP请求页面"><a href="#7-4-HTTP请求页面" class="headerlink" title="7.4 HTTP请求页面"></a>7.4 HTTP请求页面</h3><ul><li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p></li><li><p>在<strong>生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接</strong>。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p></li><li><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p></li><li><p><strong>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</strong></p></li><li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p></li><li><p><strong>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</strong></p></li></ul><p><strong>参考博客：</strong><a href="https://blog.csdn.net/JAck_chen0309/article/details/105020259![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-110232883.png)" target="_blank" rel="noopener">https://blog.csdn.net/JAck_chen0309/article/details/105020259![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-110232883.png)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-02-应用层&quot;&gt;&lt;a href=&quot;#计算机网络-02-应用层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-02-应用层&quot;&gt;&lt;/a&gt;计算机网络-02-应用层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一图胜千言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172919828.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-01-概述</title>
    <link href="http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-07-26T03:02:24.000Z</published>
    <updated>2020-07-26T09:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-01-概述"><a href="#计算机网络-01-概述" class="headerlink" title="计算机网络-01-概述"></a>计算机网络-01-概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-164551248.jpg" alt="mark"></p><ul><li>本教程是秋招面试复习用计算机网络知识点(意味着书上的“废话” 不会在本系列学习笔记中出现)</li><li>配套教材《计算机网络-自顶向下的方法》</li></ul><a id="more"></a><h2 id="1-网络中的网络"><a href="#1-网络中的网络" class="headerlink" title="1. 网络中的网络"></a>1. 网络中的网络</h2><ul><li>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165259125.png" alt="mark"></p><h2 id="2-ISP"><a href="#2-ISP" class="headerlink" title="2. ISP"></a>2. ISP</h2><ul><li>互联网提供商ISP可以从互联网管理机构获取许多IP地址</li><li>同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165342332.png" alt="mark"></p><ul><li>目前互联网是一种多层次的ISP结构，ISP根据覆盖面积的大小分为<ul><li>第一层ISP</li><li>区域ISP</li><li>接入ISP</li></ul></li><li>互联网交换节点IXP 允许两个ISP直接相连而不用经过第三个ISP</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165517216.png" alt="mark"></p><h2 id="3-主机之间的通信方式"><a href="#3-主机之间的通信方式" class="headerlink" title="3. 主机之间的通信方式"></a>3. 主机之间的通信方式</h2><ul><li><strong>客户端-服务器（C/S）</strong>:客户是服务的请求方，服务器是服务的提供方。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165625304.png" alt="mark"></p><ul><li><strong>对等（P2P）</strong>:不区分客户和服务器。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165638288.png" alt="mark"></p><h2 id="4-电路交换和分组交换"><a href="#4-电路交换和分组交换" class="headerlink" title="4. 电路交换和分组交换"></a>4. 电路交换和分组交换</h2><h3 id="4-1-电路交换"><a href="#4-1-电路交换" class="headerlink" title="4.1 电路交换"></a>4.1 电路交换</h3><ul><li>电路交换用于电话通信系统，两个用户通信之前需要建立一条专用的物理链路，并且整个通信过程中始终占用该链路。</li><li>由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</li></ul><h3 id="4-2-分组交换"><a href="#4-2-分组交换" class="headerlink" title="4.2 分组交换"></a>4.2 分组交换</h3><ul><li>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一条传输线路上同时传输多个分组互相不回影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</li><li>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，<strong>分组交换也使用了存储转发过程。</strong></li></ul><h2 id="5-时延"><a href="#5-时延" class="headerlink" title="5. 时延"></a>5. 时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170041265.png" alt="mark"></p><h3 id="5-1-排队时延"><a href="#5-1-排队时延" class="headerlink" title="5.1 排队时延"></a>5.1 排队时延</h3><ul><li>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li></ul><h3 id="5-2-处理时延"><a href="#5-2-处理时延" class="headerlink" title="5.2 处理时延"></a>5.2 处理时延</h3><ul><li>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</li></ul><h3 id="5-3-传输时延"><a href="#5-3-传输时延" class="headerlink" title="5.3 传输时延"></a>5.3 传输时延</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170144654.png" alt="mark"></p><p>其中 l 表示数据帧的长度，v 表示传输速率。</p><h3 id="5-4-传播时延"><a href="#5-4-传播时延" class="headerlink" title="5.4 传播时延"></a>5.4 传播时延</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170258454.png" alt="mark"></p><p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p><h2 id="6-计算机网络体系结构（重点）"><a href="#6-计算机网络体系结构（重点）" class="headerlink" title="6. 计算机网络体系结构（重点）"></a>6. 计算机网络体系结构（重点）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170612601.png" alt="mark"></p><h3 id="6-1-五层协议（面试答这个）"><a href="#6-1-五层协议（面试答这个）" class="headerlink" title="6.1 五层协议（面试答这个）"></a>6.1 五层协议（面试答这个）</h3><ul><li><p><strong>应用层：</strong> 为了特定的<strong>应用程序</strong>提供数据传输服务（例如HTTP,DNS协议）。<strong>数据单位是报文</strong></p></li><li><p><strong>传输层：</strong> 为进程提供<strong>通用数据传输服务</strong>。用于应用层协议很多，定义通用传输协议就可以支持不断的增多应用层协议。运输层包括两种协议：</p><ul><li><strong>传输控制协议TCP:</strong>提供面向链接，可靠的数据传输服务，数据单位是报文段。（TCPt提供完整性服务）</li><li><strong>用户数据报协议UDP</strong> ： 提供无连接，尽最大努力的数据传输服务，数据单位是用户数据报。（UDP 主要提供及时性服务。）</li></ul></li><li><p><strong>网络层</strong>：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。<strong>网络层把传输层传递下来的报文段或者用户数据报封装成分组。</strong></p></li><li><p><strong>数据链路层</strong>：<strong>网络层针对的还是主机之间的数据传输服务</strong>。而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。<strong>数据链路层把网络层传下来的分组封装成帧。</strong></p></li><li><p><strong>物理层：</strong>考虑的是怎么样在传输媒体或者介质上传输数据比特流，而不是具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使得数据链路层感觉不到这些差异。</p></li></ul><h3 id="6-2-OSI"><a href="#6-2-OSI" class="headerlink" title="6.2 OSI"></a>6.2 OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><p><strong>表示层</strong>  ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p></li><li><p><strong>会话层</strong>  ：建立及管理会话。</p></li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="6-3-TCP-IP"><a href="#6-3-TCP-IP" class="headerlink" title="6.3 TCP / IP"></a>6.3 TCP / IP</h3><ul><li>它只有四层，相当于五层协议中的数据链路层和物理层合并为接口层</li><li>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172620266.png" alt="mark"></p><h2 id="7-数据在各层之间的传递过程"><a href="#7-数据在各层之间的传递过程" class="headerlink" title="7. 数据在各层之间的传递过程"></a>7. 数据在各层之间的传递过程</h2><ul><li><strong>在向下的过程中，需要添加下层协议所需要的首部或者尾部</strong></li><li><strong>在向上的过程中，需要不断拆开首部和尾部</strong></li></ul><p><strong>需要注意的是：</strong></p><ul><li><strong>路由器</strong>只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-01-概述&quot;&gt;&lt;a href=&quot;#计算机网络-01-概述&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-01-概述&quot;&gt;&lt;/a&gt;计算机网络-01-概述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-164551248.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本教程是秋招面试复习用计算机网络知识点(意味着书上的“废话” 不会在本系列学习笔记中出现)&lt;/li&gt;
&lt;li&gt;配套教材《计算机网络-自顶向下的方法》&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JUC-16-Future</title>
    <link href="http://zhuuu.work/2020/07/25/JUC/JUC-16-Future/"/>
    <id>http://zhuuu.work/2020/07/25/JUC/JUC-16-Future/</id>
    <published>2020-07-25T14:02:24.000Z</published>
    <updated>2020-07-25T09:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-16-Future"><a href="#JUC-16-Future" class="headerlink" title="JUC-16-Future"></a>JUC-16-Future</h1><h2 id="1-Future-接口"><a href="#1-Future-接口" class="headerlink" title="1. Future 接口"></a>1. Future 接口</h2><ul><li><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。</p></li><li><p>必要时通过get 方法获取执行结果，该方法会阻塞直到任务返回结果。</p></li><li><p><strong>当一个线程需要等待另外一个线程把某个任务执行完成后它才能继续执行，此时可以似乎用FutureTask</strong></p></li><li><p>Future类位于java.util.concurrent包下，它是一个接口：</p></li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> FutureTask </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Executor </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; The result type returned by this Future's &lt;tt&gt;get&lt;/tt&gt; method </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Attempts to cancel execution of this task.  This attempt will </span></span><br><span class="line"><span class="comment">     * fail if the task has already completed, has already been cancelled, </span></span><br><span class="line"><span class="comment">     * or could not be cancelled for some other reason. If successful, </span></span><br><span class="line"><span class="comment">     * and this task has not started when &lt;tt&gt;cancel&lt;/tt&gt; is called, </span></span><br><span class="line"><span class="comment">     * this task should never run.  If the task has already started, </span></span><br><span class="line"><span class="comment">     * then the &lt;tt&gt;mayInterruptIfRunning&lt;/tt&gt; parameter determines </span></span><br><span class="line"><span class="comment">     * whether the thread executing this task should be interrupted in </span></span><br><span class="line"><span class="comment">     * an attempt to stop the task.     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this task was cancelled before it completed </span></span><br><span class="line"><span class="comment">     * normally. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this task completed. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Waits if necessary for the computation to complete, and then </span></span><br><span class="line"><span class="comment">     * retrieves its result. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Waits if necessary for at most the given time for the computation </span></span><br><span class="line"><span class="comment">     * to complete, and then retrieves its result, if available. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p><ul><li><strong>cancel（</strong>）<ul><li>用来取消任务，如果取消成功返回true,取消失败返回false.</li><li>参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li></ul></li><li><strong>isCancelled（）</strong><ul><li>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li></ul></li><li><strong>isDone（）</strong><ul><li>方法表示任务是否已经完成，若任务完成，则返回true；</li></ul></li><li><strong>get()</strong><ul><li>用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回。</li></ul></li><li><strong>get(long timeout, TimeUnit unit)</strong><ul><li>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul></li></ul><p><strong>总结：</strong></p><ul><li>Future 提供以下三种功能<ul><li>判断任务是否完成。</li><li>能够中断任务。</li><li>能够获取任务执行的结果。</li></ul></li><li>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</li></ul><h2 id="2-FutureTask-类"><a href="#2-FutureTask-类" class="headerlink" title="2. FutureTask 类"></a>2. FutureTask 类</h2><p><strong>概述</strong></p><ul><li><strong>FutureTask 类的实现基于 AQS</strong> ， <strong>JUC 中很多可阻塞的类都是基于AQS实现的。</strong></li><li><strong>AQS是一个同步框架，它提供通用机制来控制原子性管理同步状态，阻塞和唤醒线程，以及维护被阻塞线程的队列。</strong><ul><li><strong>JDK6 中被广泛使用</strong></li><li><strong>基于AQS的实现同步器包括 ： （ReetrantLock , Semaphore,CountDownLatch,ReetrantReadWriteLock,FutureTask）</strong></li></ul></li></ul><ul><li>首先是介绍下FutureTask类中的变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示当前task的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//表示当前task尚未执行</span></span><br><span class="line"><span class="comment">//场景：1、任务刚新建还未入队列</span></span><br><span class="line"><span class="comment">//     2、任务刚新建已入队列，还未被线程执行</span></span><br><span class="line"><span class="comment">//     3、任务刚新建已入队列，正在被线程执行run() 注意：当执行任务有结果后才会修改当前任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//表示当前task正在结束，但是还未完全结束的一种临界状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//表示当前task正常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//表示当前task执行过程中发生异常，内部封装的callable.run() 向上抛出了异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//表示当前task被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//表示当前task正在中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//表示当前task已中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//submit(runnable/callable)     runnable 使用装饰者模式装饰为 callable</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">//正常情况下：任务执行结束，outcome保存执行结果。 即callable的返回值</span></span><br><span class="line"><span class="comment">//异常情况下：callable向上抛出异常信息，outcome保存异常信息</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"><span class="comment">//当前任务被执行时，保存执行当前任务的当前线程的对象引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">//因为会有很多线程去get当前任务的结果。所以，这里使用 链表 这种数据结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    <span class="comment">//thread变量 保存线程对象引用</span></span><br><span class="line">    <span class="comment">//next变量 保存当前节点的下一个节点</span></span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器（2个构造器）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">this</span>.callable = callable;  </span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);  </span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Runnable注入会被Executors.callable()函数转换为Callable类型，即FutureTask最终都是执行Callable类型的任务。</p><p>这里使用到了适配器模式：将Runnable 接口 的任务 转换成 Callable接口的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * A callable that runs given task and returns given result </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Runnable task;  </span><br><span class="line">    <span class="keyword">final</span> T result;  </span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.task = task;  </span><br><span class="line">        <span class="keyword">this</span>.result = result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        task.run();  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行一个task的步骤是：<ul><li>submit(runnable/callable) -&gt; 调用 sumbit()提交我们自定义的工作单元 </li><li>newTaskFor(runnable/callable) -&gt;  调用newTaskFor将runnable/callable 封装成FutureTask</li><li>execute(task) -&gt;  执行execute()将传入的task放到线程池中</li><li>threadpool  -&gt; 当线程池中有空闲线程，就会执行任务的run()。否则，就会进入任务队列等待被执行</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit(runnable/callable) -&gt; newTaskFor(runnable/callable) -&gt; execute(task) -&gt; threadpool</span></span><br><span class="line"><span class="comment">//当线程池中没有空闲线程来执行当前任务，则会先进入任务队列中，等待空闲线程调用；如果有就直接执行。</span></span><br><span class="line"><span class="comment">//任务执行入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//条件1：true -&gt; 当前任务的状态不是新建状态。(可能已经被执行或者取消)</span></span><br><span class="line">    <span class="comment">//条件2：true -&gt; cas失败，表示当前有其它线程抢占了这个任务</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前线程开始执行当前任务</span></span><br><span class="line">    <span class="comment">//前置条件：1、当前任务的状态是新建状态 2、当前线程抢占到当前任务的执行权</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//表示外部传入的自定义的业务程序。 是callable或者是用runnable装饰后的callable</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">//条件1：防止空指针异常</span></span><br><span class="line">        <span class="comment">//条件2：防止有外部线程将任务cancel了</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            <span class="comment">//要返回的结果</span></span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">//true -&gt; callable程序执行成功，未抛出异常</span></span><br><span class="line">            <span class="comment">//false -&gt; callable程序执行失败，抛出异常</span></span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">//说明当前任务正常结束</span></span><br><span class="line">                <span class="comment">//设置result给outcome</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//只会在当前任务被cancel时执行</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用cas把任务当前状态设置成完成中</span></span><br><span class="line">    <span class="comment">//执行失败的情况：外部线程在当前线程执行set之前把当前任务cancel(很小概率事件)</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//将callable</span></span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用cas把任务当前状态设置成完成中</span></span><br><span class="line">    <span class="comment">//执行失败的情况：外部线程在当前线程执行set之前把当前任务cancel(很小概率事件)</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">//将结果赋值给outcome后，将当前任务的状态直接修改为NORMAL(正常完成)状态</span></span><br><span class="line">        <span class="comment">//putOrderedInt(Object obj, long offset, int value) obj:包含要修改field的对象 offset:obj中整型field的偏移量 value:field将被设置的新值</span></span><br><span class="line">        <span class="comment">//设置obj对象中offset偏移地址对应的整型field的值为指定值。</span></span><br><span class="line">        <span class="comment">//这是一个有序或者有延迟的putIntVolatile方法，并且不保证值的改变被其他线程立即看到。</span></span><br><span class="line">        <span class="comment">//只有在field被 volatile 修饰并且期望被意外修改的时候使用才有用。</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">    <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            <span class="comment">//释放cpu资源</span></span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get () 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景：多个线程等待当前任务执行完成后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前任务状态</span></span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">//true -&gt; 任务状态可能为 未执行、正在执行、完成中</span></span><br><span class="line">    <span class="comment">//当任务状态为以上情况时，调用get()的外部线程会被阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">//返回线程当前状态</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//System.nanoTime() 返回的是纳秒，nanoTime返回的可能是任意时间，甚至可能是负数</span></span><br><span class="line">    <span class="comment">//timed true -&gt; 表示带超时时间，deadline = System.nanoTime()</span></span><br><span class="line">    <span class="comment">//      false -&gt; 表示不带超时时间，deadline = 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//引用当前线程封装成WaitNode对象</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//表示是否入队</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//ture -&gt; 说明当前线程是被其它线程中断而唤醒的</span></span><br><span class="line">        <span class="comment">//interrupted() 返回true后 会将Thread的中断标记重置为false</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//当前线程node出队</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="comment">//向get()抛出中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前线程被其它线程正常唤醒(使用了unpark(thread))的场景，继续执行自旋逻辑</span></span><br><span class="line">        <span class="comment">//获取当前任务最新状态</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//true -&gt; 表示当前任务已经有结果了</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="comment">//true -&gt; 说明已经为当前线程创建node节点，需要执行 node.thread = null (helpGC)</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//返回任务状态</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//true -&gt; 表示当前任务正在完成中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            <span class="comment">//将当前cpu的资源释放，进行下次抢占cpu资源</span></span><br><span class="line">            <span class="comment">//注意：yield()会释放CPU资源，但是是与其它线程一起重新抢占资源。当前线程可能还会获取到执行权，也有可能被其他线程获取到</span></span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//场景：第一次自旋</span></span><br><span class="line">        <span class="comment">//true -&gt; 当前线程还未创建WaitNode对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//为当前线程创建WaitNode对象，并把当前线程赋值到thread全局变量中</span></span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="comment">//场景：第二次自旋</span></span><br><span class="line">        <span class="comment">//true -&gt; 当前线程已经创建WaitNode对象，但是还未入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)&#123;</span><br><span class="line">            <span class="comment">//把当前线程node节点的next指针 指向到原队列的头结点</span></span><br><span class="line">            <span class="comment">//waiters 表示队列头指针</span></span><br><span class="line">            q.next = waiters;</span><br><span class="line">            <span class="comment">//用cas方式设置waiters指针指向当前线程的node节点(头插法)</span></span><br><span class="line">            <span class="comment">//true -&gt; 入队成功</span></span><br><span class="line">            <span class="comment">//false -&gt; 有其它线程抢先入队，进入下次自旋</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, waiters, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//场景：第三次自旋</span></span><br><span class="line">        <span class="comment">//判断是否有带入超时时间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;<span class="comment">//有超时时间的场景</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">//true -&gt; 表示等待超时了</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">//当前线程node出队</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="comment">//无论完成与否，直接返回当前状态</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程进入有时间限制的休眠状态，有其它线程将其 唤醒 或者 中断 或者 时间到了 就会重新激活</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//无超时时间的场景</span></span><br><span class="line">            <span class="comment">//park() 会将当前线程状态变为waitting(休眠)</span></span><br><span class="line">            <span class="comment">//当前线程进入休眠状态， 有其它线程将其 唤醒 或者 中断 就会重新激活</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//正常情况下：outcome保存的是callable运行出来的结果</span></span><br><span class="line">    <span class="comment">//非正常情况下：outcome保存的是callable运行时抛出的异常信息</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="comment">//true -&gt; 表示当前任务正常完成</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="comment">//直接返回callable运行结果</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="comment">//true -&gt; 表示当前任务被取消</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="comment">//抛出取消中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">//抛出自定义的callable程序执行时产生的异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 ： </p><ol><li>get任务执行结果的线程并不只有一个，而是有很多个在同一链表中的线程竞争获取。</li><li>当任务还未执行完毕，线程就会进行休眠，等待其它线程唤醒(可能是正常唤醒，也可能是任务中断)</li></ol><ul><li><strong>cancel()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mayInterruptIfRunning 设成false话，不允许在线程运行时中断，设成true的话就允许。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//state == NEW：true -&gt; 表示当前任务处于运行中 或者 处于线程池队列中</span></span><br><span class="line">        <span class="comment">//UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)</span></span><br><span class="line">        <span class="comment">//  true -&gt; 表示cas成功，将当前任务状态修改为 中断中 或者 取消</span></span><br><span class="line">        <span class="comment">//注意，这里的if取反，上述条件都为true才会执行下面的逻辑。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取执行当前task的线程</span></span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="comment">//可能会为null，因为可能当前task还在任务队列中排队</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//如果不为null，则给runner线程一个中断信号</span></span><br><span class="line">                        <span class="comment">//只是会给任务一个中断标志，能否中断要看task中是否有响应中断的程序</span></span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    <span class="comment">//执行完中断后将任务的状态改为已中断</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>最后要讲下finishCompletion()这个方法，看了上面的源码可以发现，有3个地方都执行了这个方法，分别是cancel()、set()、setException()。<br>其作用就是当任务执行有结果了(无论好坏)都会唤醒waiters链表中的 所有 线程继续执行自旋逻辑。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒所有waiters中的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">//将waiters头结点赋值给q</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">//用cas将头结点置为null，防止该任务被其它线程取消 且 help gc</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">                <span class="comment">//获取当前节点的thread对象</span></span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="comment">//true -&gt; thread对象存在防止空指针</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//清空当前节点引用的thread对象 help gc</span></span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//唤醒该线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前节点的下一个节点</span></span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="comment">//true -&gt; 已经处于队列末尾</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//退出自旋</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//清空当前节点的next指针指向的对象引用 help gc</span></span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                <span class="comment">//当前节点指针指向下一个节点</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所有waiters队列中的线程唤醒完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义扩展的操作</span></span><br><span class="line">    done();</span><br><span class="line">    <span class="comment">//释放资源 help gc</span></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-16-Future&quot;&gt;&lt;a href=&quot;#JUC-16-Future&quot; class=&quot;headerlink&quot; title=&quot;JUC-16-Future&quot;&gt;&lt;/a&gt;JUC-16-Future&lt;/h1&gt;&lt;h2 id=&quot;1-Future-接口&quot;&gt;&lt;a href=&quot;#1-Future-接口&quot; class=&quot;headerlink&quot; title=&quot;1. Future 接口&quot;&gt;&lt;/a&gt;1. Future 接口&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;必要时通过get 方法获取执行结果，该方法会阻塞直到任务返回结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;当一个线程需要等待另外一个线程把某个任务执行完成后它才能继续执行，此时可以似乎用FutureTask&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Future类位于java.util.concurrent包下，它是一个接口：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="异步计算" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-14-ThreadLocal</title>
    <link href="http://zhuuu.work/2020/07/22/jdk_SourceCode/JDK1.8-14-ThreadLocal/"/>
    <id>http://zhuuu.work/2020/07/22/jdk_SourceCode/JDK1.8-14-ThreadLocal/</id>
    <published>2020-07-22T05:33:53.000Z</published>
    <updated>2020-08-13T02:41:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8-14-ThreadLocal"><a href="#JDK1-8-14-ThreadLocal" class="headerlink" title="JDK1.8-14-ThreadLocal"></a>JDK1.8-14-ThreadLocal</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>参考博客： <a href="https://www.cnblogs.com/fsmly/p/11020641.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsmly/p/11020641.html</a></p><p><strong>总结几个字：线程自己的本地变量</strong></p><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>多线程访问同一个共享变量时候容易出现并发问题，特别是多个线程对同一个变量进行写入的时候，为了确保线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程的安全性。</li><li><strong>ThreadLocal 是除了加锁这种同步方式以外的一种保证一种规避多线程访问出现线程不安全的方法，当我们创建一个共享变量后，如果每个线程对其进行访问的时候访问都是线程自己的变量就不会存在线程不安全的问题。</strong></li><li>ThreadLocal 是 JDK包提供的，它提供<strong>线程的本地变量</strong>，如果创建一个ThreadLocal变量，那么访问这个变量的每一个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而避免了线程安全性问题。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/132845616.png" alt="mark"></p><!--more--><h2 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2.简单使用"></a>2.简单使用</h2><ul><li>在下面的例子中，在每个线程的内部都设置了本地变量的值，然后调用print 方法打印当前本地变量的值。</li><li>如果在打印之后调用本地变量的remove方法后会删除把本地内存中的变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">" :"</span> + localVar.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        localVar.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">                localVar.set(<span class="string">"localVar1"</span>);</span><br><span class="line">                <span class="comment">//调用打印方法</span></span><br><span class="line">                print(<span class="string">"thread1"</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">"after remove : "</span> + localVar.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">                localVar.set(<span class="string">"localVar2"</span>);</span><br><span class="line">                <span class="comment">//调用打印方法</span></span><br><span class="line">                print(<span class="string">"thread2"</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">"after remove : "</span> + localVar.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行后的结果：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/133208433.png" alt="mark"></p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><ul><li>下面是ThreadLocal的类图结构，从图中可知，<code>java.lang.Thread</code>中有两个变量<code>threadLocals</code> 和 <code>inheritableThreadLocals</code> 。两者都是<code>ThreadLocal</code>内部类 <code>ThreadLocalMap</code> 类型的变量。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/090201253.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/090208752.png" alt="mark"></p><ul><li>在默认情况下，每个线程中这两个变量都是<code>null</code>,之后我们通过原码后可以看到 <code>ThreadLocalMap</code> 实际上类似于一个 <code>HashMap</code>. 这两个变量只有当线程第一次调用ThreadLocal的 set和 get方法的时候才会创建它们。</li><li>需要注意的是：<strong>每个线程的本地变量</strong>不是存放在 new 出来的<code>TheadLocal</code> 实例中，而是存放在调用线程的<code>ThreadLocals</code> 变量中。（前面说过，这个变量在 <code>java.lang.Thread</code>类中）</li><li>也就是说，<code>ThreadLocal</code> 类型的本地变量实际是存放在具体的线程空间上，其本身相当于装在本地变量的工具壳，通过 set 方法将value 添加到 <code>threadlocals</code> 变量中，当调用线程的时候能够将它从 <code>threadLocals</code>变量中取出。</li><li>如果调用的线程一直不终止，那么这个本地变量将会一直存放在他的<code>threadLocals</code> 中，所以不使用本地变量的时候需要从它的<code>threadLocals</code> 取出变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment"> * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/134134649.png" alt="mark"></p><h3 id="3-1-set-方法"><a href="#3-1-set-方法" class="headerlink" title="3.1  set 方法"></a>3.1  set 方法</h3><ul><li>源码分析<strong>(重点是类似与Hashmap 的 ThreadlocalMap)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1) 获取当前线程（调用者线程）</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2) 以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//(3) 如果map不为null，就直接添加本地变量，key为当前线程的引用，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//(4) 如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，(2)处调用getMap方法<strong>获得当前线程对应的threadLocals变量</strong>(参照上面的图示和文字说明)，该方法代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals; <span class="comment">//获取线程自己的变量threadLocals，并绑定到当前调用线程的成员变量threadLocals上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果调用getMap 的返回值不为null,就直接将 value 设置到 threadLocals变量中<strong>（此时 key 是当前线程的引用，值是本地变量）</strong></li><li>如果调用 getMap 方法返回null 说明是第一次调用 set 方法(前面说到过,threadLocals默认值是 Null , 只有调用 set 方法的时候才会创建map),这个时候就需要调用 createMap方法来创建<code>ThreadLocalMap</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createMap 方法不仅创建了 <code>threadLocals</code>变量 ,通过是也将本地变量的值放到了 <code>threadLocals</code> 中.</li></ul><h3 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2 get 方法"></a>3.2 get 方法</h3><ul><li><p>在get 方法的实现中，首先获取当前调用者线程</p><ul><li>如果当前线程的<code>threadLocals</code> 不为 <code>null</code> ,就直接返回当前线程绑定的本地变量值，</li><li>否则执行 <code>setInitialValue</code>的方法初始化 <code>threadLocals</code> 变量。</li></ul></li><li><p>在 <code>setInitialValue</code> 方法中，类似于 <code>set</code> 方法的实现，都是判断当前线程的<code>threadLocals</code> 变量是否为null,是则添加本地变量（这个时候由于是初始化，所以添加的值是null）,否则创建的是<code>threadLocals变量</code>，同样添加的是null</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2)获取当前线程的threadLocals变量</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//(3)如果threadLocals变量不为null，就可以在map中查找到本地变量的值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(4)执行到此处，threadLocals为null，调用该更改初始化当前线程的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//protected T initialValue() &#123;return null;&#125;</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-remove-方法"><a href="#3-3-remove-方法" class="headerlink" title="3.3 remove 方法"></a>3.3 remove 方法</h3><ul><li>remove 方法判断该当前线程对应的threadLocals变量是否是null,不是 null 的话就直接删除当前线程中的threadLocals变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程绑定的threadLocals</span></span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="comment">//如果map不为null，就移除当前线程中指定ThreadLocal实例的本地变量</span></span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意  ： 这里可能有内存泄露问题</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/095307158.png" alt="mark"></p><ul><li>如上图所示，每个线程内部都有一个名为<code>threadLocals</code> 的成员变量，该变量的类型是<code>ThreadLocal.ThreadLocalMap</code>的类型（类似于一个HashMap） ,其中<strong>key是当前定义的<code>ThreadLocal</code> 变量 this的引用， value 是 使用 set 方法设置的值。</strong></li><li>每个线程的本地变量存放在自己的本地变量 <code>threadLocals</code>中，如果<strong>当前线程一直不消亡，那么这些本地变量会一直存在（所以会内存溢出），因此使用完毕需要remove 掉。</strong></li></ul><h2 id="4-ThreadLocal-不支持继承性"><a href="#4-ThreadLocal-不支持继承性" class="headerlink" title="4. ThreadLocal 不支持继承性"></a>4. ThreadLocal 不支持继承性</h2><ul><li>同一个<code>Threadlocal</code> 变量在父线程中被设置后，在子线程中是获取不到的</li><li>threadLocals 中为当前调用线程对应的本地变量，所以二者自然是不能共享的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)创建ThreadLocal变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在main线程中添加main线程的本地变量</span></span><br><span class="line">        threadLocal.set(<span class="string">"mainVal"</span>);</span><br><span class="line">        <span class="comment">//新创建一个子线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程中的本地变量值:"</span>+threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//输出main线程中的本地变量值</span></span><br><span class="line">        System.out.println(<span class="string">"mainx线程中的本地变量值:"</span>+threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-InheritableThreadLocal类"><a href="#5-InheritableThreadLocal类" class="headerlink" title="5. InheritableThreadLocal类"></a>5. InheritableThreadLocal类</h2><ul><li>在上面说到的ThreadLocal类是不能提供子线程访问父线程的本地变量的，而InheritableThreadLocal类则可以做到这个功能，下面是该类的源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从上面代码可以看出，InheritableThreadLocal类继承了ThreadLocal类，并重写了childValue、getMap、createMap三个方法。</li><li>其中createMap方法在被调用（当前线程调用set方法时得到的map为null的时候需要调用该方法）的时候，创建的是inheritableThreadLocal而不是threadLocals。同理，getMap方法在当前调用者线程调用get方法的时候返回的也不是threadLocals而是inheritableThreadLocal。</li></ul><p>下面我们看看重写的childValue方法在什么时候执行，怎样让子线程访问父线程的本地变量值。我们首先从Thread类开始说起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断名字的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">//(1)获取当前线程(父线程)</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="comment">//安全校验</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123; <span class="comment">//g:当前线程组</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g; <span class="comment">//设置为当前线程组</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();<span class="comment">//守护线程与否(同父线程)</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();<span class="comment">//优先级同父线程</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">//(2)如果父线程的inheritableThreadLocal不为null</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//（3）设置子线程中的inheritableThreadLocals为父线程的inheritableThreadLocals</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在init方法中，首先(1)处获取了当前线程(父线程)，然后（2）处判断当前父线程的inheritableThreadLocals是否为null，</li><li>然后调用createInheritedMap将父线程的inheritableThreadLocals作为构造函数参数创建了一个新的ThreadLocalMap变量，然后赋值给子线程。</li><li>下面是createInheritedMap方法和ThreadLocalMap的构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用重写的方法</span></span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在构造函数中将父线程的inheritableThreadLocals成员变量的值赋值到新的ThreadLocalMap对象中。</li><li>返回之后赋值给子线程的inheritableThreadLocals。</li><li>总之，InheritableThreadLocals类通过重写getMap和createMap两个方法将本地变量保存到了具体线程的inheritableThreadLocals变量中，当线程通过InheritableThreadLocals实例的set或者get方法设置变量的时候，就会创建当前线程的inheritableThreadLocals变量。</li><li>而父线程创建子线程的时候，ThreadLocalMap中的构造函数会将父线程的inheritableThreadLocals中的变量复制一份到子线程的inheritableThreadLocals变量中</li></ul><h2 id="6-从ThreadLocalMap-看-ThreadLocal-的内存泄露问题"><a href="#6-从ThreadLocalMap-看-ThreadLocal-的内存泄露问题" class="headerlink" title="6. 从ThreadLocalMap 看 ThreadLocal 的内存泄露问题"></a>6. 从ThreadLocalMap 看 ThreadLocal 的内存泄露问题</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><ul><li>首先我们看看<code>ThreadLocalMap</code>的类图，在前面的介绍中，我们知道ThreadLocal 是一个工具类，它为用户提供了 <code>set,get,remove</code> 接口操作实际存放本地变量的<code>threadLocals</code> （调用线程的成员变量）， 也知道<code>threadLocals</code>  是一个 <code>ThreadLocalMap</code> 类型的变量</li><li>下面我们来看看<code>ThreadLocalMap</code> 这个内部类，在此之前，我们先回忆以下<code>Java</code>中的四种引用类型，以及相关GC的工作机制</li></ul><p>①<strong>强引用</strong>：Java中默认的引用类型，一个对象如果具有强引用那么只要这种引用还存在就不会被GC。</p><p>②<strong>软引用</strong>：简言之，如果一个对象具有软引用，在JVM发生OOM之前（即内存充足够使用），是不会GC这个对象的；只有到JVM内存不足的时候才会GC掉这个对象。软引用和一个引用队列联合使用，如果软引用所引用的对象被回收之后，该引用就会加入到与之关联的引用队列中</p><p>③<strong>弱引用</strong>（这里讨论ThreadLocalMap中的Entry类的重点） ：如果一个对象只有弱引用，那么这个对象就会被垃圾回收器GC(弱引用的引用的对象只能到下一次之前，无论当前内存是否足够，弱引用所引用的对象都会被GC回收掉)。 弱引用也是和一个引用队列联合使用，如果弱引用的对象被垃圾回收掉，JVM会将这个引用加入到与之关联的弱引用队列中。若引用的对象可以通过弱引用的get方法得到，当引用对象被回收掉之后，在调用get方法就会返回null.</p><p>④<strong>虚引用</strong> : 虚引用是所有引用中最弱的一种引用，目的就是将关联虚引用对象在GC回收掉之后得到一个通知（不能通过get方法获得指引对象。）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/131415452.png" alt="mark"></p><h3 id="6-2-ThreadLocalMap的内部实现"><a href="#6-2-ThreadLocalMap的内部实现" class="headerlink" title="6.2 ThreadLocalMap的内部实现"></a>6.2 ThreadLocalMap的内部实现</h3><ul><li><code>ThreadLocalMap</code> 其实就是一个Entry 数组</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/132245248.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是继承自WeakReference的一个类，该类中实际存放的key是</span></span><br><span class="line"><span class="comment"> * 指向ThreadLocal的弱引用和与之对应的value值(该value值</span></span><br><span class="line"><span class="comment"> * 就是通过ThreadLocal的set方法传递过来的值)</span></span><br><span class="line"><span class="comment"> * 由于是弱引用，当get方法返回null的时候意味着坑能引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** value就是和ThreadLocal绑定的 */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：ThreadLocal的引用，被传递给WeakReference的构造方法</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//WeakReference构造方法(public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent); <span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reference构造方法</span></span><br><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);<span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从上面给的代码中可以看出，当前<code>threadLocal</code> 的引用k被传递给了<code>WeakReference</code>,所以ThreadLocalMap中的key为ThreadLocal的弱引用。</p></li><li><p>当一个线程调用<code>ThreadLocal</code> 的 set 方法设置变量的时候，当前线程<code>ThreadLocalMap</code> 中会存放一个记录，这个记录的key值就是<code>ThreadLocalMap</code> 的弱引用，<code>value</code>就是 set进去的值，这个值可以是任意的对象。</p></li><li><p>如果当前线程一直存在且没有调用<code>ThreadLocal</code>的remove方法，如果这个时候别的地方还有<code>ThreadLocal</code>的引用，那么当前线程的<code>ThreadLocalMap</code> 中会存在对<code>ThreadLocal</code>变量的引用和<code>value</code> 对象的引用，这个弱引用是不会被释放的，就会造成内存泄漏。</p></li><li><p>考虑这个<code>ThreadLocal</code>变量没有其他强依赖，如果当前线程还存在，由于<code>ThreadLocalMap</code> 中的key是弱引用，所以当前线程<code>ThreadLocalMap</code>里面的<code>ThreadLocal</code>变量的弱引用在gc时候就被回收，但是对应的value 还是存在这就可能导致内存泄漏(因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)。</p></li></ul><p><strong>总结：</strong></p><ul><li><code>ThreadLocalMap</code> 中的<strong>Entry数组</strong> 的 key 使用的是 <code>ThreadLocal</code>对象的弱引用，在没有其他地方对ThreadLoca依赖，ThreadLocalMap中的ThreadLocal对象就会被回收掉</li><li>但是对应的不会被回收，这个时候Map中就可能存在key为null但是value不为null的项</li><li>这需要实际的时候使用完毕及时调用remove方法避免内存泄漏。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8-14-ThreadLocal&quot;&gt;&lt;a href=&quot;#JDK1-8-14-ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8-14-ThreadLocal&quot;&gt;&lt;/a&gt;JDK1.8-14-ThreadLocal&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;参考博客： &lt;a href=&quot;https://www.cnblogs.com/fsmly/p/11020641.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/fsmly/p/11020641.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结几个字：线程自己的本地变量&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="面试必备" scheme="http://zhuuu.work/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>各种反转-合集</title>
    <link href="http://zhuuu.work/2020/07/20/LeetcodeExplore/%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/07/20/LeetcodeExplore/%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC-%E5%90%88%E9%9B%86/</id>
    <published>2020-07-20T07:52:53.000Z</published>
    <updated>2020-08-17T08:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种反转-合集"><a href="#各种反转-合集" class="headerlink" title="各种反转-合集"></a>各种反转-合集</h1><p>（本系列是针对Leetcode上常见的反转进行总结。）</p><a id="more"></a><h2 id="1-Leetcode-007-整数反转"><a href="#1-Leetcode-007-整数反转" class="headerlink" title="1. Leetcode 007 整数反转"></a>1. Leetcode 007 整数反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 反转后的结果</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 拿到每一个个位</span></span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 溢出处理</span></span><br><span class="line">        <span class="comment">// ans * 10 + pop &gt; Integer.MAXVAlUE</span></span><br><span class="line">        <span class="comment">// ans * 10 + pop &lt; Integer.MINVALUE</span></span><br><span class="line">        <span class="keyword">if</span> ((ans &gt; Integer.MAX_VALUE/<span class="number">10</span>) </span><br><span class="line">                || (ans == Integer.MAX_VALUE/<span class="number">10</span>) &amp;&amp; pop &gt; <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((ans &lt; Integer.MIN_VALUE/<span class="number">10</span>)</span><br><span class="line">                || (ans == Integer.MIN_VALUE/<span class="number">10</span>) &amp;&amp; pop &lt; -<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Leetcode-415-字符串相加"><a href="#2-Leetcode-415-字符串相加" class="headerlink" title="2. Leetcode   415. 字符串相加"></a>2. Leetcode   <a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 和num2 的长度都小于 5100</span><br><span class="line">num1 和num2 都只包含数字 0-9</span><br><span class="line">num1 和num2 都不包含任何前导零</span><br></pre></td></tr></table></figure><p><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 对溢出进行处理，超过就补一个0</span></span><br><span class="line">            <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 计算总和</span></span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            <span class="comment">// 计算进位</span></span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 拿个位结果</span></span><br><span class="line">            sb.append(tmp % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 继续向前遍历</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完如果有进位再加一个1</span></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)&#123;</span><br><span class="line">            sb.append(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将StringBuilder转为字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;各种反转-合集&quot;&gt;&lt;a href=&quot;#各种反转-合集&quot; class=&quot;headerlink&quot; title=&quot;各种反转-合集&quot;&gt;&lt;/a&gt;各种反转-合集&lt;/h1&gt;&lt;p&gt;（本系列是针对Leetcode上常见的反转进行总结。）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="反转" scheme="http://zhuuu.work/tags/%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>队列和栈-合集</title>
    <link href="http://zhuuu.work/2020/07/20/LeetcodeExplore/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/07/20/LeetcodeExplore/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88-%E5%90%88%E9%9B%86/</id>
    <published>2020-07-20T07:52:53.000Z</published>
    <updated>2020-08-09T13:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列和栈-合集"><a href="#队列和栈-合集" class="headerlink" title="队列和栈-合集"></a>队列和栈-合集</h1><p>（本系列是针对Leetcode上常见的队列和栈进行总结。）</p><a id="more"></a><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><ul><li><p>在数组中，我们可以通过<strong>索引</strong>随机访问元素。但是，在某些情况下，我们可以想要限制处理的顺序。</p></li><li><p>这两种不同的顺序就是 ， <code>先入先出</code> <code>先入后出</code> 。以及两个相应的线性数据结构，<strong>队列和栈</strong></p></li><li><p>在做到算法题的时候，<strong>队列一般用于BFS，而系统栈用于DFS</strong></p></li></ul><h2 id="1-1-队列（先入先出）"><a href="#1-1-队列（先入先出）" class="headerlink" title="1.1 队列（先入先出）"></a>1.1 队列（先入先出）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/134217670.png" alt="mark"></p><!--more--><ul><li>在FIFO 数据结构中，将首先处理添加到队列的第一个元素。</li><li>如上图所示，队列是典型的FIFO的数据结构。<strong>插入</strong>(insert) 操作也称为入队（enqueue），<strong>新元素始终被添加到队列的末尾</strong>。<strong>删除</strong>（delete） 操作也被称为出队(dequeue) 。 你<strong>只能移除第一个元素</strong>。</li><li><strong>总结：队尾入队，队首出队。</strong></li></ul><p><strong>出队：</strong><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/135940985.jpg" alt="mark"></p><p>*<em>入队 : *</em><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/140053661.png" alt="mark"></p><h3 id="1-1-1-数组实现队列"><a href="#1-1-1-数组实现队列" class="headerlink" title="1.1.1 数组实现队列"></a>1.1.1 数组实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实现队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 数组存放元素</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指向开始位置的指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> p_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        p_start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 出队相当于开始索引后移</span></span><br><span class="line">        p_start ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.get(p_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p_start &gt;= data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue q = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        q.enQueue(<span class="number">5</span>);</span><br><span class="line">        q.enQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/145353792.png" alt="mark"></p><ul><li>让我们考虑一种情况，即我们只能分配一个最大长度为 5 的数组。当我们只添加少于 5 个元素时，我们的解决方案很有效。 例如，如果我们只调用入队函数四次后还想要将元素 10 入队，那么我们可以成功。</li><li>但是我们不能接受更多的入队请求，这是合理的，因为现在队列已经满了。但是如果我们将一个元素出队呢？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/145423708.png" alt="mark"></p><h3 id="1-1-2-剑指-Offer-09-用两个栈实现队列"><a href="#1-1-2-剑指-Offer-09-用两个栈实现队列" class="headerlink" title="1.1.2 剑指 Offer 09. 用两个栈实现队列"></a>1.1.2 <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h3><p><strong>题目描述：</strong></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>遇到的问题</strong></p><ul><li><strong>栈无法实现队列的功能：</strong>栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈</li><li><strong>双栈可以实现列表的倒序</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设有含三个元素的栈 </span><br><span class="line">A &#x3D; [1,2,3] 和空栈 B &#x3D; []。</span><br><span class="line">若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A &#x3D; [] , B &#x3D; [3,2,1]，即 栈 B 元素实现栈 A 元素倒序 。</span><br></pre></td></tr></table></figure><ul><li><strong>利用栈B删除队首元素：倒序后，B执行出栈就相当于删除了A的栈底元素，即对应队首元素</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/141348516.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. B不为空，说明已经完成了倒叙，直接返回B栈顶元素即可</span></span><br><span class="line">        <span class="keyword">if</span> (!B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> B.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (A.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 2. 如果A为空,说明两个栈都为空</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 说明两个栈都存在元素</span></span><br><span class="line">            <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">                B.add(A.remove());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> B.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的解析：在我的Leetcode专题里面有，所以这里不再过度阐述。</strong></p><h3 id="1-1-3-622-设计循环队列"><a href="#1-1-3-622-设计循环队列" class="headerlink" title="1.1.3 622. 设计循环队列"></a>1.1.3 <a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></h3><ul><li>此前，我们提供了一种简单但低效的队列实现。（数组实现）</li><li>更有效的方法是使用循环队列，具体来说，我们可以使用固定大小的数组和两个指针来指示起始位置和结束位置。目的是重复使用被浪费的存储空间。</li></ul><p><strong>题目描述：</strong></p><ul><li><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p></li><li><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p></li><li><p>你的实现应该支持如下操作：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue(k): 构造器，设置队列长度为 k 。</span><br><span class="line">Front: 从队首获取元素。如果队列为空，返回 -1 。</span><br><span class="line">Rear: 获取队尾元素。如果队列为空，返回 -1 。</span><br><span class="line">enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</span><br><span class="line">deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</span><br><span class="line">isEmpty(): 检查循环队列是否为空。</span><br><span class="line">isFull(): 检查循环队列是否已满。</span><br></pre></td></tr></table></figure><p><strong>算法思路</strong></p><ul><li>这道题说“循环”的意思是要求我们在数组里实现。</li><li>在数组的操作中，我们参考“动态数组”的实现来完成。主要是为了让每一步操作的复杂度都降到最低。只不过我们自己实现动态扩容和缩容</li></ul><p>注意：</p><ol><li><p>定义循环变量 <code>front</code> 和 <code>rear</code> 。一直保持这个定义，到底是先赋值还是先移动指针就很容易想清楚了。</p><ul><li><code>front</code> 队列头部第一个有效的位置</li><li><code>rear</code>：指向队列尾部（即最后 1 个有效数据）的下一个位置，即下一个从队尾入队元素的位置。</li></ul></li><li><p><strong>为了避免“队列为空”和“队列为满”的判别条件冲突，我们有意浪费了一个位置。</strong></p><ul><li>浪费一个位置是指：循环数组中任何时刻一定至少有一个位置不存放元素。</li><li>判断队列为空的条件 <code>front == rear</code></li><li>判断队列为满的条件 <code>front == (rear + 1) % capacity</code> (可以这样理解，当 <code>rear</code> 循环到数组的前面，要从后面追上 <code>front</code>，还差一格的时候，判定队列为满。)</li></ul></li><li><p>因为有循环的出现，要<strong>特别注意处理数组下标可能越界的情况</strong>。指针后移的时候，索引 + 1，并且要注意取模。</p></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 浪费一个位置</span></span><br><span class="line">        capacity = k + <span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">        front = <span class="number">0</span>; <span class="comment">// 删除元素的时候，只索引 +1（注意取模）</span></span><br><span class="line">        rear  = <span class="number">0</span>; <span class="comment">// 插入元素的时候，先赋值，后索引 +1（注意取模）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先赋值，然后索引 + 1</span></span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先索引 + 1即可</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[(rear - <span class="number">1</span> + capacity) % capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经典设计</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % capacity == front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4-641-设计循环双端队列"><a href="#1-1-4-641-设计循环双端队列" class="headerlink" title="1.1.4 641. 设计循环双端队列"></a>1.1.4 <a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></h3><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span> </span>&#123;</span><br><span class="line">    <span class="comment">// front == rear 队列为空</span></span><br><span class="line">    <span class="comment">// (rear + 1) == front 队列为满</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularDeque</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        capacity = k + <span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertFront</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 索引 + 1 然后赋值</span></span><br><span class="line">        front = (front - <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        arr[front] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertLast</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// front 是在数组的开头，同时防止数组越界</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear = (rear - <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 rear 为0的时候防止数组越界</span></span><br><span class="line">        <span class="comment">// 因为真正的最后有效的元素是 rear - 1</span></span><br><span class="line">        <span class="keyword">return</span> arr[(rear - <span class="number">1</span> + capacity) % capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经典设计</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % capacity == front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-栈（后入先出）"><a href="#2-1-栈（后入先出）" class="headerlink" title="2.1 栈（后入先出）"></a>2.1 栈（后入先出）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200724-160713163.png" alt="mark"></p><ul><li>在 LIFO 数据结构中，将<code>首先处理添加到队列</code>中的<code>最新元素</code>。</li><li>与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 <code>push</code> 。与队列类似，总是<code>在堆栈的末尾添加一个新元素</code>。但是，删除操作，退栈 <code>pop</code> ，将始终<code>删除</code>队列中相对于它的<code>最后一个元素</code>。</li></ul><h3 id="2-1-1-栈的实现"><a href="#2-1-1-栈的实现" class="headerlink" title="2.1.1 栈的实现"></a>2.1.1 栈的实现</h3><ul><li>栈的实现比队列容易。<code>动态数组</code>足以实现堆栈结构。这里我们提供了一个简单的实现供你参考：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        list.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-155-最小栈"><a href="#2-1-2-155-最小栈" class="headerlink" title="2.1.2  155. 最小栈"></a>2.1.2  <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h3><p>题目描述：</p><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(x) ——   将元素 x 推入栈中。</span><br><span class="line">pop() ——     删除栈顶的元素。</span><br><span class="line">top() ——     获取栈顶元素。</span><br><span class="line">getMin() —— 检索栈中的最小元素。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MinStack"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"getMin"</span>,<span class="string">"pop"</span>,<span class="string">"top"</span>,<span class="string">"getMin"</span>]</span><br><span class="line">[[],[-<span class="number">2</span>],[<span class="number">0</span>],[-<span class="number">3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,-<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">0</span>,-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2</span>.</span><br></pre></td></tr></table></figure><p><strong>Solution：辅助栈和数据栈同步</strong></p><ul><li>特点：编写简单，不需要考虑一些边界情况（缺点：可能会存储一些多余的元素）</li><li>规则如下：<ul><li><strong>辅助栈为空的时候，必须放进来新的数字</strong></li><li>新来的数小于等于辅助栈栈顶元素的时候，才放入（<strong>这里“等于要考虑进去”，因为出栈的时候，相等的并且是最小值的元素要同步出栈</strong>），要不然就放入辅助栈栈顶自己</li><li><strong>出栈的时候，辅助栈的栈顶元素要等于数据栈栈顶的元素才出栈</strong></li></ul></li></ul><p><strong>总结：</strong></p><ul><li><strong>出栈的时候，最小值出栈才同步</strong></li><li><strong>入栈的时候，最小值入栈才同步</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data =   <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 思路1：数据栈和辅助栈在任何时候都要同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="keyword">if</span> (helper.isEmpty() || helper.peek() &gt;= x)&#123;</span><br><span class="line">            helper.add(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            helper.add(helper.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个栈都需要pop操作</span></span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty())&#123;</span><br><span class="line">            helper.pop();</span><br><span class="line">            data.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据栈的栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> data.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈元素为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小栈的栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!helper.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> helper.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈元素为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(1) 栈的操作</li><li><strong>空间复杂度</strong>：O(n) 需要一个辅助栈的空间</li></ul><h3 id="2-1-3-20-有效的括号"><a href="#2-1-3-20-有效的括号" class="headerlink" title="2.1.3 20. 有效的括号"></a>2.1.3 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h3><p><strong>题目描述</strong></p><p>给定一个只包括<code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code>的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br><strong>注意空字符串可被认为是有效字符串。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>算法思路</strong></p><ul><li>栈的先入后出的特点和括号排序一致，即遇到左括号入栈，遇到右括号时将对应的栈顶元素左括号出栈，则遍历完所有括号之后<code>stack</code> 仍然为空。</li><li>建立哈希表存储所有左右括号的对应关系，（key 左括号， value 右括号）。这样查询2个括号是否对应只要O(1) 的时间复杂度；<ul><li>建立栈<code>stack</code> ，遍历字符串s并按照算法流程就行判断</li></ul></li></ul><p><strong>算法流程</strong></p><ul><li>如果c 是左括号，则入栈push<ul><li>否则通过哈希表来判断对应关系，若<code>stack</code> 栈顶出栈的括号<code>stack.pop()</code> 与当前括号c不对应，则提前返回false</li></ul></li></ul><p><strong>提前返回false</strong></p><ul><li><strong>提前返回优点：</strong> 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。<ul><li><strong>栈 stack 为空</strong> ： 此时 stack.pop()会报错，因此使用一个取巧的办法，<strong>给stack 赋一个初值 ？</strong> ， <strong>并在哈希表中建立 ？ 和 ？ 的对应关系。</strong>此时当<code>stack</code> 为空且<code>c</code> 是右括号的时候，可以正常提前返回false.</li><li><strong>字符串s 以左括号结尾：</strong> 这种情况下，可以正常的遍历完字符串，但是最后的左括号遗留了下来，这时候要判断最后栈的长度是不是等于1，如果等于，说明多出来一个左括号，不是有效的括号组合。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195452276.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195501520.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195513439.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195521791.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195532859.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// map来预存括号以及辅助判断字符</span></span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'&#123;'</span>,<span class="string">'&#125;'</span>);</span><br><span class="line">        map.put(<span class="string">'['</span>,<span class="string">']'</span>);</span><br><span class="line">        map.put(<span class="string">'('</span>,<span class="string">')'</span>);</span><br><span class="line">        map.put(<span class="string">'?'</span>,<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有左括号直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span> &amp;&amp; !map.containsKey(s.charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈</span></span><br><span class="line">        LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，检查括号符不符合要求</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="comment">// 左括号放入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line">                list.add(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(list.removeLast()) != c)&#123;</span><br><span class="line">                <span class="comment">// 栈顶左括号和右括号是否匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断有没有遗留左括号</span></span><br><span class="line">        <span class="keyword">return</span> list.size() ==  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>复杂度分析</strong><ul><li>时间复杂度 O(N)：正确的括号组合需要遍历 1 遍 <code>s</code>；</li><li>空间复杂度 O(N)：哈希表和栈使用线性的空间大小。</li></ul></li></ul><h3 id="2-1-4-739-每日温度"><a href="#2-1-4-739-每日温度" class="headerlink" title="2.1.4  739. 每日温度"></a>2.1.4  <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h3><p><strong>题目描述：</strong></p><p><strong>本质</strong> ： 找到数组中第一个大于该元素数字的索引 ，并返回索引差值</p><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温 列表长度的范围是<code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在<code>[30, 100]</code>范围内的整数。</p><p><strong>解法思路：单调递减栈</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205146576.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205229904.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205245835.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205259273.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205320457.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205337913.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205344516.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 单调递减栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">                ret[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈为空的话</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)，</strong>其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</li><li><strong>空间复杂度：O(n)，</strong>其中 n是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</li></ul><h3 id="2-1-5-150-逆波兰表达式求值"><a href="#2-1-5-150-逆波兰表达式求值" class="headerlink" title="2.1.5 150. 逆波兰表达式求值"></a>2.1.5 <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h3><p><strong>题目描述</strong></p><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener"> 逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">逆波兰表达式：</span><br><span class="line"></span><br><span class="line">逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</span><br><span class="line"></span><br><span class="line">平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</span><br><span class="line">该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</span><br><span class="line">逆波兰表达式主要有以下两个优点：</span><br><span class="line"></span><br><span class="line">去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</span><br><span class="line">适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><p><strong>方法：单调栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 减少自动装箱拆箱的负担</span></span><br><span class="line">        Integer op1,op2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，进行运算</span></span><br><span class="line">        <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span> :</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 + op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 - op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 * op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 / op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(Integer.valueOf(s));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最后栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-队列和BFS"><a href="#2-队列和BFS" class="headerlink" title="2. 队列和BFS"></a>2. 队列和BFS</h1><h2 id="2-1-BFS"><a href="#2-1-BFS" class="headerlink" title="2.1 BFS"></a>2.1 BFS</h2><ul><li><p>广度优先搜索（BFS）是一个常见应用是从根节点到目标节点的最短路径。</p></li><li><p>在本文中，我们提供了一个示例来解释在 BFS 算法中是如何逐步应用队列的。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/162240980.gif" alt="mark"></p><p><strong>分析</strong></p><ol><li>节点的处理顺序是什么？</li></ol><ul><li>在第一轮中，我们处理根节点。</li><li>在第二轮中，我们处理第二层节点。</li><li>第三轮中，我们处理第三层节点。</li><li>。。。。</li></ul><ul><li>与树的<strong>层序遍历</strong>类似，<code>越是接近根结点的结点将越早地遍历</code>。</li></ul><ol start="2"><li>队列的入队和出队顺序是什么？</li></ol><ul><li>首先将根节点入队，逐个处理已经在队列中的节点，并将所有的邻居添加到队列中。值得注意的是，新添加的节点并不会立即遍历，而是在下一轮搜索中处理。</li><li>节点处理的顺序和添加到队列的顺序是完全相同的，即先进先出（FIFO）,这就是我们为什么使用队列的原因。</li></ul><h2 id="2-2-BFS两种模板"><a href="#2-2-BFS两种模板" class="headerlink" title="2.2 BFS两种模板"></a>2.2 BFS两种模板</h2><ul><li>之前，我们已经介绍了使用 BFS 的两个主要方案：<code>遍历</code>或<code>找出最短路径</code>。通常，这发生在树或图中。正如我们在章节描述中提到的，BFS 也可以用于更抽象的场景中。</li></ul><p><strong>模板一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一轮中，<strong>队列的节点是等待处理的节点</strong></li><li>在每个更外的一层<code>while</code> 循环之后，我们举例根节点更远一步。变量<code>step</code> 从根节点到我们正在访问的节点的距离。</li></ul><p><strong>模板二</strong></p><ul><li>有时候，确保我们永远不会访问同一个节点两次很重要。</li><li>否则的话，我们可能会陷入无限死循环，如果是这样，我们可以添加一个哈希set来解决这样的问题，下面是修改后的伪代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>队列q 就不用说了，BFS核心的数据结构；</strong></li><li><code>cur.adj()</code> 表示 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 的上下左右位置就是相邻的节点；</li><li><code>visited()</code> 节点的作用就是防止走回头路<ul><li><strong>大部分情况下，<code>visited</code> 数组或者说 哈希表 是必须的</strong></li><li><strong>但是像二叉树一般的结构，没有子节点到父节点的指针，不会走回头路就不需要<code>visited</code></strong></li></ul></li></ul><h2 id="2-3-BFS-题目1：-102-二叉树的层序遍历"><a href="#2-3-BFS-题目1：-102-二叉树的层序遍历" class="headerlink" title="2.3 BFS 题目1： 102. 二叉树的层序遍历"></a>2.3 BFS 题目1： <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>思路：BFS</strong></p><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="comment">// res 记录最后结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列（LinkedList实现）</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点放入队列</span></span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出队列首元素并删除</span></span><br><span class="line">                TreeNode curr = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 队首元素放到结果中</span></span><br><span class="line">                    subList.add(curr.val);</span><br><span class="line">                    <span class="comment">// 对子节点进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(curr.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(curr.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200809-163226648.gif" alt="mark"></p><ul><li>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</li></ul><p><strong>复杂度分析</strong></p><p>记树上所有节点的个数为 nn。</p><ul><li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li><li>空间复杂度：队列中元素的个数不超过 nn 个，故渐进空间复杂度为 O(n)。</li></ul><h2 id="2-4-BFS-题目2：111-二叉树的最小深度"><a href="#2-4-BFS-题目2：111-二叉树的最小深度" class="headerlink" title="2.4 BFS 题目2：111. 二叉树的最小深度"></a>2.4 BFS 题目2：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h2><p><strong>题目描述</strong></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>思路：BFS</strong></p><ul><li>首先来看看DFS和BFS的区别</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200728-150819598.gif" alt="mark"></p><ul><li><p>这个遍历顺序也是 BFS 能够用来解「层序遍历」、「最短路径」问题的根本原因。</p></li><li></li></ul><h2 id="2-5-BFS-题目3-：-279-完全平方数"><a href="#2-5-BFS-题目3-：-279-完全平方数" class="headerlink" title="2.5 BFS  题目3 ： 279-完全平方数"></a>2.5 BFS  题目3 ： 279-<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</span><br></pre></td></tr></table></figure><p><strong>解法：BFS（下面一图胜千言）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200809-170946859.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        queue.add(n);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            level++; <span class="comment">// 开始生成下一层</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                <span class="comment">//依次减 1, 4, 9... 生成下一层的节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= cur; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> next = cur - j * j;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">                        queue.offer(next);</span><br><span class="line">                        visited.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-栈和DFS"><a href="#3-栈和DFS" class="headerlink" title="3. 栈和DFS"></a>3. 栈和DFS</h1><ul><li><p>正如我们在本章的描述中提到的，在大多数情况下，我们在能使用 BFS 时也可以使用 DFS。但是有一个重要的区别：遍历顺序。</p></li><li><p>与 BFS 不同，更早访问的结点可能不是更靠近根结点的结点。因此，你在 DFS 中找到的第一条路径可能不是最短路径。</p></li><li><p>在本文中，我们将为你提供一个 DFS 的递归模板，并向你展示栈是如何帮助这个过程的。</p></li></ul><p><strong>模板</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Return true if there is a path from cur to target.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) &#123;</span><br><span class="line">    return true if cur is target;</span><br><span class="line">    for (next : each neighbor of cur) &#123;</span><br><span class="line">        if (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            return true if DFS(next, target, visited) &#x3D;&#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-94-二叉树的中序遍历"><a href="#3-1-94-二叉树的中序遍历" class="headerlink" title="3.1 94. 二叉树的中序遍历"></a>3.1 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h2><p>给定一根二叉树，返回它的中序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否是null</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 1. 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.left,res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 打印</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="comment">// 3. 右子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.right,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前序遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        DFS(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;DFS(root.left,res);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;DFS(root.right,res);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        DFS(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;DFS(root.left,res);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;DFS(root.right,res);&#125;</span><br><span class="line"></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-329-矩阵中的最长递增路径"><a href="#3-3-329-矩阵中的最长递增路径" class="headerlink" title="3.3 329. 矩阵中的最长递增路径"></a>3.3 <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;队列和栈-合集&quot;&gt;&lt;a href=&quot;#队列和栈-合集&quot; class=&quot;headerlink&quot; title=&quot;队列和栈-合集&quot;&gt;&lt;/a&gt;队列和栈-合集&lt;/h1&gt;&lt;p&gt;（本系列是针对Leetcode上常见的队列和栈进行总结。）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://zhuuu.work/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>汇编-07-内存</title>
    <link href="http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-07-%E5%86%85%E5%AD%98/"/>
    <id>http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-07-%E5%86%85%E5%AD%98/</id>
    <published>2020-07-17T03:47:41.000Z</published>
    <updated>2020-07-17T04:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-07-内存"><a href="#汇编-07-内存" class="headerlink" title="汇编-07-内存"></a>汇编-07-内存</h1><ul><li>寄存器很小，不够用，所以说，数据放到了内存中。</li><li>每个应用程序（进程）都有4GB的内存空间（空头支票）</li></ul><p>1 B = 8bit</p><p>1 KB = 1024B</p><p>1 MB = 1024KB</p><p>1 GB = 1024MB</p><h2 id="1-内存地址"><a href="#1-内存地址" class="headerlink" title="1. 内存地址"></a>1. 内存地址</h2><ul><li>给计算机中每个空间分配一个地址（名字） </li><li>32位 ： 寻址能力 ！ （4GB） </li><li></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-07-内存&quot;&gt;&lt;a href=&quot;#汇编-07-内存&quot; class=&quot;headerlink&quot; title=&quot;汇编-07-内存&quot;&gt;&lt;/a&gt;汇编-07-内存&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;寄存器很小，不够用，所以说，数据放到了内存中。&lt;/li&gt;
&lt;li&gt;每个应用程序（进程）都有4GB的内存空间（空头支票）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1 B = 8bit&lt;/p&gt;
&lt;p&gt;1 KB = 1024B&lt;/p&gt;
&lt;p&gt;1 MB = 1024KB&lt;/p&gt;
&lt;p&gt;1 GB = 1024MB&lt;/p&gt;
&lt;h2 id=&quot;1-内存地址&quot;&gt;&lt;a href=&quot;#1-内存地址&quot; class=&quot;headerlink&quot; title=&quot;1. 内存地址&quot;&gt;&lt;/a&gt;1. 内存地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给计算机中每个空间分配一个地址（名字） &lt;/li&gt;
&lt;li&gt;32位 ： 寻址能力 ！ （4GB） &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编-06-寄存器</title>
    <link href="http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-06-%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-06-%E5%AF%84%E5%AD%98%E5%99%A8/</id>
    <published>2020-07-17T03:40:41.000Z</published>
    <updated>2020-07-17T03:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-06-寄存器"><a href="#汇编-06-寄存器" class="headerlink" title="汇编-06-寄存器"></a>汇编-06-寄存器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>寄存器是CPU的组成部分，因为在CPU中，CPU对其读写速度是最快的，不需要IO传输</li><li>但是同时寄存器的数量是有限的，优先到几乎每个寄存器都有自己的名字，而且有些还有多个名字。</li></ul><p> IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类:</p><ul><li>通用寄存器</li><li>段寄存器</li><li>状态和控制寄存器</li><li>指令寄存器</li></ul><h2 id="1-32位通用寄存器"><a href="#1-32位通用寄存器" class="headerlink" title="1. 32位通用寄存器"></a>1. 32位通用寄存器</h2><ul><li>32位通用寄存器有八个<ul><li>eax : 累加和结果寄存器</li><li>ebx：数据指针寄存器</li><li>ecx：循环计数器</li><li>edx：i/o指针</li><li>esi：源地址寄存器</li><li>edi：目标地址寄存器</li><li>ebp：堆栈指针</li><li>esp：栈指针寄存器</li></ul></li></ul><a id="more"></a><p>[参考博客：][<a href="https://blog.csdn.net/lidonghat/article/details/70244288?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight]" target="_blank" rel="noopener">https://blog.csdn.net/lidonghat/article/details/70244288?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight]</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-06-寄存器&quot;&gt;&lt;a href=&quot;#汇编-06-寄存器&quot; class=&quot;headerlink&quot; title=&quot;汇编-06-寄存器&quot;&gt;&lt;/a&gt;汇编-06-寄存器&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;寄存器是CPU的组成部分，因为在CPU中，CPU对其读写速度是最快的，不需要IO传输&lt;/li&gt;
&lt;li&gt;但是同时寄存器的数量是有限的，优先到几乎每个寄存器都有自己的名字，而且有些还有多个名字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;li&gt;段寄存器&lt;/li&gt;
&lt;li&gt;状态和控制寄存器&lt;/li&gt;
&lt;li&gt;指令寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-32位通用寄存器&quot;&gt;&lt;a href=&quot;#1-32位通用寄存器&quot; class=&quot;headerlink&quot; title=&quot;1. 32位通用寄存器&quot;&gt;&lt;/a&gt;1. 32位通用寄存器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;32位通用寄存器有八个&lt;ul&gt;
&lt;li&gt;eax : 累加和结果寄存器&lt;/li&gt;
&lt;li&gt;ebx：数据指针寄存器&lt;/li&gt;
&lt;li&gt;ecx：循环计数器&lt;/li&gt;
&lt;li&gt;edx：i/o指针&lt;/li&gt;
&lt;li&gt;esi：源地址寄存器&lt;/li&gt;
&lt;li&gt;edi：目标地址寄存器&lt;/li&gt;
&lt;li&gt;ebp：堆栈指针&lt;/li&gt;
&lt;li&gt;esp：栈指针寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>汇编-05-位运算</title>
    <link href="http://zhuuu.work/2020/07/16/assembly/%E6%B1%87%E7%BC%96-05-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://zhuuu.work/2020/07/16/assembly/%E6%B1%87%E7%BC%96-05-%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2020-07-16T07:40:41.000Z</published>
    <updated>2020-07-17T02:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-05-位运算"><a href="#汇编-05-位运算" class="headerlink" title="汇编-05-位运算"></a>汇编-05-位运算</h1><p>参考博客链接：<a href="https://www.cnblogs.com/findbetterme/p/10787118.html" target="_blank" rel="noopener">https://www.cnblogs.com/findbetterme/p/10787118.html</a></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量的减少运行的开销，优化算法。</li><li>举个例子，翻转的操作比较常见，比如初始值是1，操作一次变成0，再操作一次变成1。 可能的做法是使用三木运算符，判断原始值是1还是0，如果是1，设置位0。否则设置位0，但是使用位运算，不用判断原始值，直接改变值就可以。<code>1^num //num</code> 为原始值。</li><li>当然，一句代码可能对性能没有什么影响，到那时在高并发，大数据量的情况下可以节省很多开销。</li><li>以下是整理的关于java位运算的部分内容，如有错误，还请指出，以共同进步，先行致谢。</li></ul><h2 id="1-位运算符"><a href="#1-位运算符" class="headerlink" title="1. 位运算符"></a>1. 位运算符</h2><h3 id="1-1-java支持的位运算符"><a href="#1-1-java支持的位运算符" class="headerlink" title="1.1 java支持的位运算符"></a>1.1 java支持的位运算符</h3><ul><li>&amp; ： 按位与</li><li>|  ：按位或</li><li>~  ： 按位非</li><li>^   :   按位异或</li><li>&lt;&lt; :  左位移运算符</li><li><code>&gt;&gt;</code> : 右位移运算符</li><li><code>&gt;&gt;&gt;</code> 无符号右移运算符</li><li><strong>注意：任何语言都没有无符号左移运算符</strong></li></ul><ul><li>位运算符中：除 ~ 以外，其余均为二元运算符。<strong>操作数只能是整型和字符型数据。</strong></li></ul><p>Java使用补码来表示二进制数，在补码表示中，最高位是符号位，正数的符号位为0，负数为1。</p><ul><li>补码的规定如下：<strong>对于正数来说</strong>，最高位是0，其余各位代表数值本身的二进制表示，如 <code>+ 42 的 补码  是  0010 1010</code></li><li><strong>补码对于负数来说，</strong>最高位是 1 ，把其余的位按位取反变成反码，然后对整个数+1，就是该数字的补码 ， <strong>如<code>-1 的补码是 1111 1111</code> （在java中 -1 的 补码 是 <code>1111 1111 1111 1111</code> ,因为java中的int是32位的）</strong></li></ul><h3 id="1-2-按位与（-amp-）"><a href="#1-2-按位与（-amp-）" class="headerlink" title="1.2 按位与（&amp;）"></a>1.2 按位与（&amp;）</h3><p>按位与的运算规则</p><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>&amp;</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p><strong>总结</strong></p><ul><li>两个数同时位1的时候，结果为1</li><li>其余全为0（只要有一个操作数为0，结果就为0）</li></ul><p><strong>举例：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084818815.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084849124.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084853301.png" alt="mark"></p><h3 id="1-3-按位或（-）"><a href="#1-3-按位或（-）" class="headerlink" title="1.3 按位或（|）"></a>1.3 按位或（|）</h3><p>按位或的运算规则</p><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位或</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p><strong>总结</strong></p><ul><li>只有两个操作数对应位同时为0，结果才是0</li><li>其余全是1（只要有一个1，那么结果就是1）</li></ul><h3 id="1-4-按位非（-）"><a href="#1-4-按位非（-）" class="headerlink" title="1.4 按位非（~）"></a>1.4 按位非（~）</h3><table><thead><tr><th>操作数</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>按位或</td><td>1</td><td>0</td></tr></tbody></table><p>在求负数的源码中使用过。</p><h3 id="1-5-按位异或（-）"><a href="#1-5-按位异或（-）" class="headerlink" title="1.5 按位异或（^）"></a>1.5 按位异或（^）</h3><ul><li>按位异或的运算规则</li></ul><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位异或</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>不一样就是1，一样就是0</li></ul><h3 id="1-6-左位移（-lt-lt-）"><a href="#1-6-左位移（-lt-lt-）" class="headerlink" title="1.6 左位移（&lt;&lt;）"></a>1.6 左位移（&lt;&lt;）</h3><ul><li>算数左移（<code>&lt;&lt;</code>） : 符号位不变，<strong>低位补0.</strong>  </li><li>如 <code>2 &lt;&lt; 2</code> 的结果是8.</li></ul><p><strong>举例：<code>2 &lt;&lt; 2</code> 的结果是8.</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/092343752.png" alt="mark"></p><p><strong>总结：</strong></p><ul><li>当移动的位数超过数字本身位数的时候，那么不就全部需要补0的操作吗？</li><li>实际上不是的，<strong>java不可能做这么浪费资源的事情。</strong>在真正执行位移前，其对要移动的位数做了一些预处理，如32处理为0，-1处理为31</li></ul><h3 id="1-7-右位移（-gt-gt-）"><a href="#1-7-右位移（-gt-gt-）" class="headerlink" title="1.7 右位移（&gt;&gt;）"></a>1.7 右位移（&gt;&gt;）</h3><ul><li>低位溢出，符号位不变，<strong>并用符号位补溢出的高位。</strong></li><li>如 <code>-6 &gt;&gt; 2</code> 结果是 <code>-2</code> (相当于除3)</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/093302064.png" alt="mark"></p><h3 id="1-8-无符号右移（-gt-gt-gt-）"><a href="#1-8-无符号右移（-gt-gt-gt-）" class="headerlink" title="1.8 无符号右移（&gt;&gt;&gt;）"></a>1.8 无符号右移（&gt;&gt;&gt;）</h3><ul><li><strong>低位溢出，高位补0</strong></li><li><strong>注意，无符号右移(&gt;&gt;&gt;) 中的符号位（最高位）也跟着在变。</strong></li><li>无符号的意思是将符号位当作数字位来看待。</li><li>如 <code>-1 &gt;&gt;&gt; 1</code> 的结果是<code>2141483647</code></li></ul><p>这个数字应该比较熟悉，看两个输出语句就知道是什么了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(-<span class="number">1</span>&gt;&gt;&gt;<span class="number">1</span>));</span><br><span class="line">System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">1111111111111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111111111111</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/101857332.png" alt="mark"></p><p>除了使用-1&gt;&gt;&gt;1能得到Integer.MAX_VALUE，以下的也能得到同样的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;maxInt</span><br><span class="line">System.out.println(~(1 &lt;&lt; 31));</span><br><span class="line">System.out.println((1 &lt;&lt; -1) -1);</span><br><span class="line">System.out.println(~(1 &lt;&lt; -1));</span><br></pre></td></tr></table></figure><p>使用位运算往往能很巧妙的实现某些算法完成一些复杂的功能。</p><h2 id="2-常见使用"><a href="#2-常见使用" class="headerlink" title="2. 常见使用"></a>2. 常见使用</h2><h3 id="2-1-m-2-n"><a href="#2-1-m-2-n" class="headerlink" title="2.1 m*2 ^n"></a>2.1 m*2 ^n</h3><ul><li><p>可以使用 m &lt;&lt; n 求得结果：</p><ul><li>如 <code>System.*out*.println(&quot;2^3=&quot; + (1&lt;&lt;3));//2^3=8</code></li><li><code>System.*out*.println(&quot;3*2^3=&quot; + (3&lt;&lt;3));//3*2^3=24</code></li></ul></li><li><p>计算结果是不是很正确呢？ <strong>如果非要说 <code>2 &lt;&lt; -1</code> 为什么不等于0.5？ 前面说过，位运算的操作数只能是整型和字符型</strong>。再求int所能表示的最小值的时候，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># minInt</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li>可以发现左移31位和-1位所得的结果是一样的。同理，左移30位和左移-2所得的结果也是一样的。移动一个负数为，是不是等于右移该负数位的绝对值呢？输出一下发现结果不是的。</li><li><strong>java中 Int 所能表示的最大值是31位，加上符号位共32位。在这里有如下的位移法则：</strong><ul><li><strong>法则1： 任何数左移（右移）32的倍数位等于该数本身</strong></li><li><strong>法则2：在位移运算 m &lt;&lt; n 的计算中，若n 是正数，则实际移动的位数是 n % 32；若 n是负数，则实际移动的位数是 （32 + n % 32） ，右移同理</strong></li><li>左移是乘以2的幂，右移是除以2的幂。</li></ul></li></ul><h3 id="2-2-判断一个数的奇偶性"><a href="#2-2-判断一个数的奇偶性" class="headerlink" title="2.2 判断一个数的奇偶性"></a>2.2 判断一个数的奇偶性</h3><p><code>n &amp; 1 == 1? 奇数：偶数</code> </p><ul><li><strong>为什么与1能判断奇偶？</strong></li><li><strong>所谓的二进制就是满2进1，那么好了，偶数的最低位肯定是0（恰好满2，对不对？）</strong></li><li><strong>同理，奇数的最低为肯定是1，<code>对于int类型的1，前31位都是0，无论是1&amp;0 还是 0 &amp; 0结果都是0</code></strong></li><li><strong>那么有区别的肯定就是最低为上的 1 了，若 n 的二进制最低位为是1（奇数），反则就是结果就是0（偶数）</strong></li></ul><h3 id="2-3-不使用临时变量交换两个数字"><a href="#2-3-不使用临时变量交换两个数字" class="headerlink" title="2.3 不使用临时变量交换两个数字"></a>2.3 不使用临时变量交换两个数字</h3><p><strong>在int[]数组首尾互换中，是不看到过这样的代码：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-05-位运算&quot;&gt;&lt;a href=&quot;#汇编-05-位运算&quot; class=&quot;headerlink&quot; title=&quot;汇编-05-位运算&quot;&gt;&lt;/a&gt;汇编-05-位运算&lt;/h1&gt;&lt;p&gt;参考博客链接：&lt;a href=&quot;https://www.cnblogs.com/findbetterme/p/10787118.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/findbetterme/p/10787118.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-088-合并两个有序数组</title>
    <link href="http://zhuuu.work/2020/07/15/Leetcode/Leetcode-088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2020/07/15/Leetcode/Leetcode-088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-15T08:52:53.000Z</published>
    <updated>2020-07-17T07:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-088-合并两个有序数组"><a href="#Leecode-088-合并两个有序数组" class="headerlink" title="Leecode-088-合并两个有序数组"></a>Leecode-088-<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2*，请你将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p><p>说明:</p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</li><li><strong>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一：从头到后双指针"><a href="#方法一：从头到后双指针" class="headerlink" title="方法一：从头到后双指针"></a><strong>方法一：从头到后双指针</strong></h2><ul><li><p>跟合并两个链表很类似，这里也用两个指针指向数组的1的开头，数组2的开头</p></li><li><p>跟链表合并不同的是，如果往数组中插入一个元素，为了保证整体的顺序性，需要挪动前后的元素，所以我们<strong>要再创建一个数组来保存指针指向的元素。</strong></p></li><li><p>之后比较两个数组中的元素<code>nums1[i]</code>和<code>nums2[j]</code>，将其放到新数组中。</p></li><li><p>这种两两合并的好处是可以免掉排序了，比较完之后再放到新数组中，元素都是有序的了。</p></li><li><p>但题目要求是在数组1的基础上进行修改，而不是返回一个新数组，所以我们还得把排序好的新数组内容，再重新赋给数组1。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/152420791.jpg" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代新开的数组</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; m || k &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 两个边界条件 j = m  和 k = n</span></span><br><span class="line">            <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">                <span class="comment">// nums1走完了</span></span><br><span class="line">                arr[i++] = nums2[k++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (k == n)&#123;</span><br><span class="line">                <span class="comment">// nums2走完了</span></span><br><span class="line">                arr[i++] = nums1[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[j] &lt;= nums2[k])&#123;</span><br><span class="line">                arr[i++] = nums1[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i++] = nums2[k++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再把数组重新赋值给nums1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arr.length; l++) &#123;</span><br><span class="line">            nums1[l] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(m + n) 遍历两个数组需要的时间</li><li>空间复杂度： O(m + n) 新开了一个数组大小</li></ul><h2 id="方法二：从后向前迭代数组（空间优化）"><a href="#方法二：从后向前迭代数组（空间优化）" class="headerlink" title="方法二：从后向前迭代数组（空间优化）"></a>方法二：从后向前迭代数组（空间优化）</h2><ul><li><p>虽然方法一已经很ok了，<strong>但是仔细想想，nums1后面那些个0我们是不是没有用呢？</strong></p></li><li><p>另外题目中也说明了，数组1的空间是足够的，它可以完全容纳下数组1的m个元素和数组2的n个元素。</p></li><li><p>这两个条件拼在一起，我们就有了新的比较方式，即：反着比较。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/152800269.jpg" alt="mark"></p><p><strong>思路：</strong></p><ul><li>反向比较<code>nums1[m - 1] 和 nums2[n - 1]</code></li><li>注意:这样我们就不需要额外的空间了，数组1后面空着的我们都可以直接用</li><li><strong>关键：把两个数组后面最大的数放到数组1的最后一位</strong></li><li>依次类推直到两个数组的元素全部比较完。<br>最后数组1就是有序的，这种比较方式不需要再占用额外的空间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于修改元素的指针</span></span><br><span class="line">        <span class="keyword">int</span> k = m + n -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意边界条件， i &lt; 0以及 j &lt; 0,这表示一个数组已经使用完了</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 反向比较的话，拷贝的是较大的元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(m + n) 遍历两个数组需要的时间</li><li><strong>空间复杂度</strong>： O(1) </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-088-合并两个有序数组&quot;&gt;&lt;a href=&quot;#Leecode-088-合并两个有序数组&quot; class=&quot;headerlink&quot; title=&quot;Leecode-088-合并两个有序数组&quot;&gt;&lt;/a&gt;Leecode-088-&lt;a href=&quot;https://leetcode-cn.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并两个有序数组&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两个有序整数数组 &lt;em&gt;nums1&lt;/em&gt; 和 &lt;em&gt;nums2*，请你将 *nums2&lt;/em&gt; 合并到 &lt;em&gt;nums1&lt;/em&gt; 中&lt;em&gt;，&lt;/em&gt;使 &lt;em&gt;nums1&lt;/em&gt; 成为一个有序数组。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums1 &amp;#x3D; [1,2,3,0,0,0], m &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums2 &amp;#x3D; [2,5,6],       n &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2,2,3,5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-120-三角形最小路径和</title>
    <link href="http://zhuuu.work/2020/07/15/Leetcode/Leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/07/15/Leetcode/Leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2020-07-15T05:45:53.000Z</published>
    <updated>2020-07-15T08:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-120-三角形最小路径和"><a href="#Leetcode-120-三角形最小路径和" class="headerlink" title="Leetcode-120-三角形最小路径和"></a>Leetcode-120-三角形最小路径和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定三角形，每次智能移动到下一行的相邻节点，求从顶点到底边的最小路径和。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[2],</span><br><span class="line">[3,4],</span><br><span class="line">[6,5,7],</span><br><span class="line">[4,1,8,3]</span><br><span class="line">]</span><br><span class="line">相邻结点：与(i, j) 点相邻的结点为 (i + 1, j) 和 (i + 1, j + 1)。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h2><p><strong>分析</strong>： 若定义 <em>f(i, j)</em> 为 <em>(i, j)</em> 点到底边的最小路径和，则易知递归求解式为:</p><p><code>f(i,j) = min(f(i + 1,j) + f(i + 1,j + 1)) + trangle[i][j]</code></p><p>由此，我们将任一点到底边的最小路径和，转化成了与该点相邻两点到底边的最小路径和中的较小值，再加上该点本身的值。这样本题的 <strong>递归解法（解法一）</strong> 就完成了。</p><p><strong>代码实现</strong></p><p>解法一：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  dfs(triangle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == triangle.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dfs(triangle, i + <span class="number">1</span>, j), dfs(triangle, i + <span class="number">1</span>, j + <span class="number">1</span>)) + triangle.get(i).get(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力搜索会大量重复计算，导致超时，因此会在解法二中结合记忆化数组进行优化。</p><p>解法二：递归+记忆化</p><p>在解法一的基础上，定义了二维数组进行记忆化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一： 记忆化搜索 + 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Integer[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> Integer[triangle.size()][triangle.size()];</span><br><span class="line">        <span class="keyword">return</span> dfs(triangle,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == triangle.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归保存</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存每一个memo[i][j]</span></span><br><span class="line">        <span class="keyword">return</span> memo[i][j] = Math.min(dfs(triangle,i + <span class="number">1</span>,j),dfs(triangle,i + <span class="number">1</span>,j + <span class="number">1</span>)) + triangle.get(i).get(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。 </li><li>空间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。</li></ul><p><strong>解法三：动态规划</strong></p><ul><li>定义二维 dp 数组，将解法二中「自顶向下的G递归」改为「自底向上的递推」。</li></ul><ol><li>状态定义</li></ol><p><code>dp[i][j] 表示从点(i,j) 到 底边的最小路径和</code></p><ol start="2"><li>状态转移</li></ol><p><code>dp[i][j]</code>  = <code>min(dp[i + 1][j],dp[i + 1,j + 1]) + triangle[i][j]</code></p><ol start="3"><li>初始化</li></ol><p><code>dp[i][j] = 0</code></p><ol start="4"><li>代码实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示从点 (i, j) 到底边的最小路径和。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从三角形的最后一行开始递推。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。 空间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。</p><p><strong>空间优化的动态规划</strong></p><ul><li>在上述代码中，我们定义了一个N行N列的dp数组（N是三角形的行数）。</li><li>但是在实际计算中我们发现，计算<code>dp[i][j]</code> 时候，只用到了下一行的<code>dp[i + 1][j] 和 dp[i + 1][j + 1]</code>.</li><li>因此dp数组不需要定义N行，只要定义一行就可以了，所以我们稍微修改一下上述代码，将 i 所在的维度去掉（如下），就可以将 O(N^2) 的空间复杂度优化成O(N)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 状态定义</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示从点 (i, j) 到底边的最小路径和。</span></span><br><span class="line"><span class="comment">//        int[][] dp = new int[n + 1][n + 1];</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 状态转移</span></span><br><span class="line">        <span class="comment">// 从最后一行向上递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i ; j++) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。 </li><li>空间复杂度：<em>O(N)<em>，</em>N</em> 为三角形的行数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-120-三角形最小路径和&quot;&gt;&lt;a href=&quot;#Leetcode-120-三角形最小路径和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-120-三角形最小路径和&quot;&gt;&lt;/a&gt;Leetcode-120-三角形最小路径和&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定三角形，每次智能移动到下一行的相邻节点，求从顶点到底边的最小路径和。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[3,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[6,5,7],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,1,8,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;相邻结点：与(i, j) 点相邻的结点为 (i + 1, j) 和 (i + 1, j + 1)。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>汇编-04-数据格式</title>
    <link href="http://zhuuu.work/2020/07/14/assembly/%E6%B1%87%E7%BC%96-04-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/07/14/assembly/%E6%B1%87%E7%BC%96-04-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</id>
    <published>2020-07-14T11:40:41.000Z</published>
    <updated>2020-08-12T01:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-04-数据格式"><a href="#汇编-04-数据格式" class="headerlink" title="汇编-04-数据格式"></a>汇编-04-数据格式</h1><h2 id="1-数据宽度"><a href="#1-数据宽度" class="headerlink" title="1. 数据宽度"></a>1. 数据宽度</h2><ul><li>bit ： 1位</li><li>Byte ： 8 位</li><li>Word  ： 16 位</li><li>DWord : 32 位</li></ul><p><strong>java需要定义数据的类型</strong></p><ul><li>位： 0    1 （1位）</li><li>字节：0 - 0xFF （8位）</li><li>字 : 0 - 0xFFFF  （16位）</li><li>双字：0 - 0xFFFF FFFF （32位）</li></ul><h2 id="2-有符号数和无符号数"><a href="#2-有符号数和无符号数" class="headerlink" title="2. 有符号数和无符号数"></a>2. 有符号数和无符号数</h2><p><strong>本质是为了数据的正负号</strong></p><ul><li><p><strong>无符号数</strong></p><ul><li><p>举个例子</p><p><code>1 0 0 1   1 0 1 0</code></p><ul><li><p>十六进制    0x9A</p></li><li><p>十进制   154</p></li></ul></li></ul></li></ul><ul><li><p><strong>有符号数（最高位1：负数  最高位0：负数）</strong></p><ul><li><p>最高位是符号位</p></li><li><p>举个例子</p><p><code>1 0 0 1  1 0 1 0</code></p><ul><li>十六进制：？？？</li><li>十进制：？？？</li><li>这里？？？是为了引出<strong>（源码，反码和补码的概念）</strong></li></ul></li></ul></li></ul><h2 id="3-原码，反码，补码"><a href="#3-原码，反码，补码" class="headerlink" title="3. 原码，反码，补码"></a>3. 原码，反码，补码</h2><ul><li>编码规则<ul><li><strong>有符号的编码规则</strong></li><li><strong>原码</strong>：最高位是符号位，其他位就是自己的绝对值</li><li><strong>反码</strong>：<ul><li>正数：反码和原码一样的</li><li><strong>负数：符号位一定是1，其他位对原码取反。</strong></li></ul></li><li><strong>补码</strong>：<ul><li>正数：反码和补码相同</li><li><strong>负数：符号位一定是1，其他位对原码取反后 + 1（也就是对反码加1）</strong></li></ul></li></ul></li></ul><a id="more"></a><p><strong>测试：这都是二进制的规则</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">8位举例</span><br><span class="line"></span><br><span class="line">1. 如果是正数，都是一样的</span><br><span class="line">写出 1 的原码，反码，补码</span><br><span class="line">原码：0000 0001</span><br><span class="line">反码：0000 0001</span><br><span class="line">补码：0000 0001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 如果是负数 -1</span><br><span class="line">写出 -1 的原码，反码，补码</span><br><span class="line">原码：1000 0001</span><br><span class="line">反码：1111 1110</span><br><span class="line">补码：1111 1111</span><br><span class="line"></span><br><span class="line">3. 再来一个例子 -7</span><br><span class="line">写出 -7 的原码，反码，补码</span><br><span class="line">原码：1000 0111</span><br><span class="line">反码：1111 1000</span><br><span class="line">补码：1111 1001</span><br><span class="line"></span><br><span class="line">4. ff（有符号）</span><br><span class="line">原码 ： 1111 1111</span><br><span class="line">反码 ： 1000 0000</span><br><span class="line">补码 ： 1000 0001</span><br></pre></td></tr></table></figure><p><strong>这些知识都是为了后面的位运算。</strong></p><h2 id="4-为什么要使用原码-反码和补码"><a href="#4-为什么要使用原码-反码和补码" class="headerlink" title="4. 为什么要使用原码, 反码和补码"></a>4. 为什么要使用原码, 反码和补码</h2><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 &#x3D; [00000001]补</span><br></pre></td></tr></table></figure><p>所以不需要过多解释. 但是对于负数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-<span class="number">1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反 = [<span class="number">11111111</span>]补</span><br></pre></td></tr></table></figure><p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p><p>对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p><ol><li><strong>如果使用原码进行计算</strong></li></ol><p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算十进制表达式 1 - 1&#x3D; 0</span><br><span class="line">1 - 1 &#x3D; 1 + (-1) &#x3D; [00000001]原 + [10000001]原 &#x3D; [10000010]原 &#x3D; -2</span><br></pre></td></tr></table></figure><p><strong>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</strong></p><ol start="2"><li><strong>使用反码的话</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算十进制的表达式: 1-1&#x3D;0</span><br><span class="line"> 1 - 1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原 + [1000 0001]原&#x3D; [0000 0001]反 + [1111 1110]反 &#x3D; [1111 1111]反 &#x3D; [1000 0000]原 &#x3D; -0</span><br></pre></td></tr></table></figure><p><strong>发现如果使用反码进行计算，结果的真值部分是正确的。而唯一的问题其实就出现在”0” 这个特殊的数值上，虽然人们理解的<code>+0 和 -0</code> 是一样的，但是0带有符号是没有意义的，而且会出现[0000 0000]原和[1000 0000]原两个编码表示0.</strong></p><ol start="3"><li><strong>于是补码的出现解决了0的符号和两个编码的问题</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原 + [1000 0001]原 &#x3D; [0000 0001]补 + [1111 1111]补 &#x3D; [0000 0000]补&#x3D;[0000 0000]原</span><br></pre></td></tr></table></figure><p>这样的话 <code>+ 0和 -0</code>的问题就不存在了，而且可以使用[1000 0000] 表示 -128</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1) + (-127) &#x3D; [1000 0001]原 + [1111 1111]原 &#x3D; [1111 1111]补 + [1000 0001]补 &#x3D; [1000 0000]补</span><br></pre></td></tr></table></figure><ul><li><p><strong>-1 - 127的结果应该是-128 ， 在用补码运算的结果中, [1000 0000]补 就是-128.</strong></p></li><li><p><strong>但是注意因为实际上是使用以前的 - 0 来表示 -128 ，所以 -128 没有原码和反码的表示。（对 -128的补码表示[1000 0000]补  算出来的原码[0000 0000]原，这是不正确的）</strong></p></li><li><p><strong>使用补码的话，不仅仅修复了 0 的符号存在的两个编码的表示，而且还能多表示一个最低数字，这就是为什么8位二进制，使用原码或者反码的表示范围是[-127,127]。但是使用补码表示的范围就是[-128,127]</strong></p></li><li><p><strong>因为计算机使用补码，所以对于编程中常用的<code>32位int类型</code>，可以表示的范围的范围是<code>[-2^31,2^31-1]</code> 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</strong></p></li></ul><h2 id="5-原码，反码，补码再深入"><a href="#5-原码，反码，补码再深入" class="headerlink" title="5. 原码，反码，补码再深入"></a>5. 原码，反码，补码再深入</h2><ul><li>计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?</li><li>将钟表想象成一个1位的12进制数，如果当前时间是6点，我希望时间设置为4点，需要怎么做？<ul><li><ol><li>往回拨2个小时 6 -2 = 4</li><li>往前拨10个小时 （6+10）mod 12 = 4</li><li>往前拨10 + 12 = 12 个小时 (6+22) % 12 = 4</li></ol></li><li>2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4.</li><li>所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!</li><li>现在问题的焦点是如何用一个正数，来替代一个负数，上面的例子我们能感觉出来一些端倪, 发现一些规律. 但是数学是严谨的. 不能靠感觉.</li></ul></li></ul><ul><li><p><strong>首先介绍一个数学中的概念：同余</strong></p><ul><li>两个正数a,b 若它们整除m所得的余数相等，则称 a, b 对于模m同余</li><li>记作  <code>a ≡ b (mod m)</code></li><li>读作 a 与 b 关于模 m 同余。</li></ul><p>举例说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 mod 12 &#x3D; 4</span><br><span class="line"></span><br><span class="line">16 mod 12 &#x3D; 4</span><br><span class="line"></span><br><span class="line">28 mod 12 &#x3D; 4</span><br></pre></td></tr></table></figure><p>所以4, 16, 28关于模 12 同余.</p></li></ul><ul><li><p><strong>负数取模</strong></p><ul><li><p>正数进行mod运算是很简单的. 但是负数呢?</p></li><li><p><strong>下面是关于mod运算的数学定义：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200716/195329829.jpg" alt="mark"></p><ul><li><p><code>x mod y = x - yL x/y J</code>(上面是截图, “取下界”符号找不到如何输入(word中粘贴过来后乱码). 下面是使用”L”和”J”替换上图的”取下界”符号:)</p></li><li><p>x mod y等于 x 减去 y 乘上 x与y的商的下界.</p></li><li><p>以 -3 mod 2 举例:</p><blockquote><p>-3 mod 2</p><p>= -3 - 2xL -3/2 J</p><p>= -3 - 2xL-1.5J</p><p>= -3 - 2x(-2)</p><p>= -3 + 4 = 1</p></blockquote></li><li><blockquote><p>(-2) mod 12 = 12-2=10</p><p>(-4) mod 12 = 12-4 = 8</p><p>(-5) mod 12 = 12 - 5 = 7</p></blockquote></li></ul></li></ul></li></ul><ul><li><p><strong>再回到时钟问题</strong></p><ul><li><blockquote><p>回拨2小时 = 前拨10小时</p><p>回拨4小时 = 前拨8小时</p><p>回拨5小时= 前拨7小时</p></blockquote></li><li><p>注意, 这里发现的规律!</p><p>结合上面学到的同余的概念.实际上:</p></li><li><blockquote><p>(-2 ) mod 12 = 10</p><p>10 mod 12 = 10</p><p>所以说 -2 和 10 是同余的</p></blockquote></li><li><blockquote><p>同时， -4 和 8 也是同余的</p><p>（-4 ）mod 12 = 8</p><p>8    mod 12  = 8</p></blockquote></li></ul></li></ul><ul><li><p>要实现用正数替代负数, 只需要运用同余数的两个定理:</p><ul><li><p>反身性:这个定理是很显而易见的.</p><blockquote><p>a ≡ a (mod m)</p></blockquote></li><li><p>线性运算定理</p><blockquote><p>如果a ≡ b (mod m)，c ≡ d (mod m) 那么:</p><p>(1)a ± c ≡ b ± d (mod m)</p><p>(2)a * c ≡ b * d (mod m)</p><p>如果想看这个定理的证明, 请看:<a href="http://baike.baidu.com/view/79282.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/79282.htm</a></p></blockquote></li><li><blockquote><p>所以说：</p><p>7 ≡ 7 (mod 12)</p><p>(-2) ≡ 10 (mod 12)</p><p>7 -2 ≡ 7 + 10 (mod 12)</p></blockquote></li><li><p><strong>现在我们为一个负数，找到了它的正数的同余数，但是并不是 <code>7 -2 = 7 + 10</code> ，而是 <code>7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等.</code></strong></p></li></ul></li></ul><ul><li>接下来回到二进制的问题上, 看一下: 2-1=1的问题.<ul><li><code>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反</code></li><li>先走到这一步， <code>-1 的反码表示 是 1111 1110</code> ,如果这里将<code>[1111 1110]</code>认为是原码,那么<code>[1111 1110]</code> = <code>-126</code> ，这里将符号位除去，即认为是 126</li><li>发现如下规律<ul><li><code>(-1) mod 127 =126</code></li><li><code>126 mod 127 = 126</code></li></ul></li><li>即有如下表达式<ul><li><code>(-1) ≡ 126 (mod 127)</code></li><li><code>2 - 1 ≡ 2 + 126(mod 127)</code></li><li><strong>2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1</strong></li></ul></li></ul></li></ul><ul><li><p><strong>所以说一个数的反码，实际上是这个书对于一个数模的同余数，而这个模并不是我们的二进制，而是所能表达的最大值。</strong></p></li><li><p>这就和钟表是一样的了，转了一个圈之后，总能在可表达范围内找打一个正确的数值。</p></li><li><p>而 <code>2 + 126</code> 很明显先当与钟表过了一轮，而符号位是参与计算的，正好和溢出的最高位形成正确的结果</p></li><li><p><strong>既然反码可以将减法变成加法。那么现在计算机使用的补码呢？为什么在反码的基础上加1 ，还能得到正确的结果？</strong></p><ul><li><blockquote><p>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补</p><p>如果将 [1111 1111] 当作原码，去除符号位，则 [0111 1111] = 127</p><p>其实 在反码的基础上 + 1 就相当于增加了模的值</p><p>(-1) mod 128 = 127</p><p>127 mod 128 = 127</p><p>2-1 ≡ 2+127 (mod 128)</p></blockquote></li></ul></li><li><p>此时，表盘相当于每128个刻度转一轮，所以用补码表示的结果最大值和最小值[-128, 128].</p></li><li><p>但是由于0的特殊情况，没有办法表达128，所以补码的范围是[-128,127]</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-04-数据格式&quot;&gt;&lt;a href=&quot;#汇编-04-数据格式&quot; class=&quot;headerlink&quot; title=&quot;汇编-04-数据格式&quot;&gt;&lt;/a&gt;汇编-04-数据格式&lt;/h1&gt;&lt;h2 id=&quot;1-数据宽度&quot;&gt;&lt;a href=&quot;#1-数据宽度&quot; class=&quot;headerlink&quot; title=&quot;1. 数据宽度&quot;&gt;&lt;/a&gt;1. 数据宽度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;bit ： 1位&lt;/li&gt;
&lt;li&gt;Byte ： 8 位&lt;/li&gt;
&lt;li&gt;Word  ： 16 位&lt;/li&gt;
&lt;li&gt;DWord : 32 位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;java需要定义数据的类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位： 0    1 （1位）&lt;/li&gt;
&lt;li&gt;字节：0 - 0xFF （8位）&lt;/li&gt;
&lt;li&gt;字 : 0 - 0xFFFF  （16位）&lt;/li&gt;
&lt;li&gt;双字：0 - 0xFFFF FFFF （32位）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-有符号数和无符号数&quot;&gt;&lt;a href=&quot;#2-有符号数和无符号数&quot; class=&quot;headerlink&quot; title=&quot;2. 有符号数和无符号数&quot;&gt;&lt;/a&gt;2. 有符号数和无符号数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本质是为了数据的正负号&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;无符号数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;举个例子&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 0 0 1   1 0 1 0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;十六进制    0x9A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;十进制   154&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;有符号数（最高位1：负数  最高位0：负数）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最高位是符号位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举个例子&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 0 0 1  1 0 1 0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十六进制：？？？&lt;/li&gt;
&lt;li&gt;十进制：？？？&lt;/li&gt;
&lt;li&gt;这里？？？是为了引出&lt;strong&gt;（源码，反码和补码的概念）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-原码，反码，补码&quot;&gt;&lt;a href=&quot;#3-原码，反码，补码&quot; class=&quot;headerlink&quot; title=&quot;3. 原码，反码，补码&quot;&gt;&lt;/a&gt;3. 原码，反码，补码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编码规则&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有符号的编码规则&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原码&lt;/strong&gt;：最高位是符号位，其他位就是自己的绝对值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反码&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;正数：反码和原码一样的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负数：符号位一定是1，其他位对原码取反。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;补码&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;正数：反码和补码相同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负数：符号位一定是1，其他位对原码取反后 + 1（也就是对反码加1）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>汇编-03-二进制和十六进制</title>
    <link href="http://zhuuu.work/2020/07/14/assembly/%E6%B1%87%E7%BC%96-03-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/07/14/assembly/%E6%B1%87%E7%BC%96-03-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/</id>
    <published>2020-07-14T11:40:41.000Z</published>
    <updated>2020-07-14T13:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-03-二进制和十六进制"><a href="#汇编-03-二进制和十六进制" class="headerlink" title="汇编-03-二进制和十六进制"></a>汇编-03-二进制和十六进制</h1><p>[参考博客链接:进制转换][<a href="https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]" target="_blank" rel="noopener">https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]</a></p><h2 id="1-二进制和十六进制联系"><a href="#1-二进制和十六进制联系" class="headerlink" title="1. 二进制和十六进制联系"></a>1. 二进制和十六进制联系</h2><p>举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0 - 1111</span><br><span class="line">二进制</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">1000 十六进制</span><br><span class="line">1001  a</span><br><span class="line">1010  b</span><br><span class="line">1100  c </span><br><span class="line">1101  d </span><br><span class="line">1111  e</span><br></pre></td></tr></table></figure><h2 id="2-计算机基础进制转换（二进制、八进制、十进制、十六进制）"><a href="#2-计算机基础进制转换（二进制、八进制、十进制、十六进制）" class="headerlink" title="2. 计算机基础进制转换（二进制、八进制、十进制、十六进制）"></a>2. 计算机基础进制转换（二进制、八进制、十进制、十六进制）</h2><h3 id="2-1-十进制转R进制"><a href="#2-1-十进制转R进制" class="headerlink" title="2.1 十进制转R进制"></a>2.1 十进制转R进制</h3><h4 id="2-1-1-十进制转2进制"><a href="#2-1-1-十进制转2进制" class="headerlink" title="2.1.1 十进制转2进制"></a>2.1.1 十进制转2进制</h4><p><strong>例题：</strong> 135D = <strong>__</strong> B</p><p>十进制整数转换成二进制采用“除2倒取余”，十进制小数转换成二进制小数采用“乘2取整”。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205252067.png" alt="mark"></p><p>​                                图1.十进制整数转二进制</p><a id="more"></a><p><strong>解析：</strong>如下图所示，将135除以2，得余数，直到不能整除，然后再将余数从下至上倒取。得到结果：1000 0111B.</p><p><strong>十进制小数转二进制</strong></p><p>十进制小数转换成二进制小数采用 <strong>“乘2取整，顺序排列”</strong> 法。</p><p>用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。</p><p><strong>例题：</strong> 0.68D = <strong>__</strong> B（精确到小数点后5位）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205616022.png" alt="mark"></p><h4 id="2-2-十进制转8进制"><a href="#2-2-十进制转8进制" class="headerlink" title="2.2 十进制转8进制"></a>2.2 十进制转8进制</h4><p>思路和十进制转二进制一样，参考如下例题：</p><p><strong>例题：</strong> 10.68D = <strong>__</strong> Q（精确到小数点后3位）</p><p><strong>解析：</strong>如下图所示，整数部分除以8取余数，直到无法整除。小数部分0.68乘以8，取整，然后再将小数乘以8，取整，直到达到题目要求精度。得到结果：12.534Q.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205652243.png" alt="mark"></p><h4 id="2-3-十进制转十六进制"><a href="#2-3-十进制转十六进制" class="headerlink" title="2.3 十进制转十六进制"></a>2.3 十进制转十六进制</h4><p>思路和十进制转二进制一样，参考如下例题：</p><p><strong>例题：</strong> 25.68D = <strong>__</strong> H（精确到小数点后3位）</p><p><strong>解析：</strong>如下图所示，整数部分除以16取余数，直到无法整除。小数部分0.68乘以16，取整，然后再将小数乘以16，取整，直到达到题目要求精度。得到结果：19.ae1H.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205836688.png" alt="mark"></p><h3 id="3-R进制转十进制"><a href="#3-R进制转十进制" class="headerlink" title="3. R进制转十进制"></a>3. R进制转十进制</h3><h4 id="3-1-二进制转十进制"><a href="#3-1-二进制转十进制" class="headerlink" title="3.1 二进制转十进制"></a>3.1 二进制转十进制</h4><p><strong>例题：</strong> 1001 0110B = <strong>__</strong> D</p><p><strong>解析：</strong>如下图所示。得到结果：150D.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210001556.png" alt="mark"></p><h4 id="3-2-八进制转十进制"><a href="#3-2-八进制转十进制" class="headerlink" title="3.2 八进制转十进制"></a>3.2 八进制转十进制</h4><p>八进制转十进制的方法和二进制转十进制一样。</p><p><strong>例题：</strong> 26Q = <strong>__</strong> D</p><p><strong>解析：</strong>如下图所示。得到结果：22D.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210039039.png" alt="mark"></p><h4 id="3-3-十六进制转十进制"><a href="#3-3-十六进制转十进制" class="headerlink" title="3.3 十六进制转十进制"></a>3.3 十六进制转十进制</h4><p><strong>例题：</strong> 23daH = <strong>__</strong> D</p><p><strong>解析：</strong>如下图所示。得到结果：9178D.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210113899.png" alt="mark"></p><h2 id="4-二进制转八进制"><a href="#4-二进制转八进制" class="headerlink" title="4. 二进制转八进制"></a>4. 二进制转八进制</h2><p>二进制转八进制的方法是：<strong>取三合一法</strong>，即从二进制的小数点为分界点，向左或者向右每三位取成一位。</p><p><strong>例题：</strong> 1010 0100B = ____Q</p><p><strong>解析：</strong>计算过程如下图所示。得到结果：244Q.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210324217.png" alt="mark"></p><h2 id="5-二进制转十六进制"><a href="#5-二进制转十六进制" class="headerlink" title="5. 二进制转十六进制"></a>5. 二进制转十六进制</h2><p>二进制转十六进制的方法是：<strong>取四合一法</strong>，即从二进制的小数点为分界点，向左或者向右每四位取成一位。</p><p><strong>例题：</strong> 1010 0100B = ____H</p><p><strong>解析：</strong>计算过程如下图所示。得到结果：a4H.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210449390.png" alt="mark"></p><h2 id="6-助记"><a href="#6-助记" class="headerlink" title="6. 助记"></a>6. 助记</h2><p>下面的表格是8位二进制所对应的十进制数值，对进制转换以及类似题目的理解非常有用：</p><table><thead><tr><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>B</th></tr></thead><tbody><tr><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>D</td></tr></tbody></table><p>注：B：二进制<br>        D：十进制</p><p><strong>例题：</strong> 135D = <strong>__</strong> B</p><p><strong>解析：</strong>有了上面二进制对应十进制数值的表格，我们就可以将题目给的十进制135拆分为：128+7，再从表格中找到对应的数值，拼凑即可得到答案。</p><p>135D = 128D + 7D = 1000 0000 + 0000 0111 = 1000 0111B</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-03-二进制和十六进制&quot;&gt;&lt;a href=&quot;#汇编-03-二进制和十六进制&quot; class=&quot;headerlink&quot; title=&quot;汇编-03-二进制和十六进制&quot;&gt;&lt;/a&gt;汇编-03-二进制和十六进制&lt;/h1&gt;&lt;p&gt;[参考博客链接:进制转换][&lt;a href=&quot;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-二进制和十六进制联系&quot;&gt;&lt;a href=&quot;#1-二进制和十六进制联系&quot; class=&quot;headerlink&quot; title=&quot;1. 二进制和十六进制联系&quot;&gt;&lt;/a&gt;1. 二进制和十六进制联系&lt;/h2&gt;&lt;p&gt;举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 - 1111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二进制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1000 十六进制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1001  a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1010  b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1100  c &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1101  d &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1111  e&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;2-计算机基础进制转换（二进制、八进制、十进制、十六进制）&quot;&gt;&lt;a href=&quot;#2-计算机基础进制转换（二进制、八进制、十进制、十六进制）&quot; class=&quot;headerlink&quot; title=&quot;2. 计算机基础进制转换（二进制、八进制、十进制、十六进制）&quot;&gt;&lt;/a&gt;2. 计算机基础进制转换（二进制、八进制、十进制、十六进制）&lt;/h2&gt;&lt;h3 id=&quot;2-1-十进制转R进制&quot;&gt;&lt;a href=&quot;#2-1-十进制转R进制&quot; class=&quot;headerlink&quot; title=&quot;2.1 十进制转R进制&quot;&gt;&lt;/a&gt;2.1 十进制转R进制&lt;/h3&gt;&lt;h4 id=&quot;2-1-1-十进制转2进制&quot;&gt;&lt;a href=&quot;#2-1-1-十进制转2进制&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 十进制转2进制&quot;&gt;&lt;/a&gt;2.1.1 十进制转2进制&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;例题：&lt;/strong&gt; 135D = &lt;strong&gt;__&lt;/strong&gt; B&lt;/p&gt;
&lt;p&gt;十进制整数转换成二进制采用“除2倒取余”，十进制小数转换成二进制小数采用“乘2取整”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205252067.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;​                                图1.十进制整数转二进制&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-面试题29-顺时针打印矩阵</title>
    <link href="http://zhuuu.work/2020/07/13/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://zhuuu.work/2020/07/13/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</id>
    <published>2020-07-13T07:52:53.000Z</published>
    <updated>2020-07-14T00:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-面试题29-顺时针打印矩阵"><a href="#Leetcode-面试题29-顺时针打印矩阵" class="headerlink" title="Leetcode-面试题29- 顺时针打印矩阵"></a>Leetcode-面试题29-<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener"> 顺时针打印矩阵</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><a id="more"></a><h2 id="方法：边界模拟"><a href="#方法：边界模拟" class="headerlink" title="方法：边界模拟"></a>方法：边界模拟</h2><blockquote><p>根据题目示例 matrix = [[1,2,3],[4,5,6],[7,8,9]] 的对应输出 [1,2,3,6,9,8,7,4,5] 可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。</p></blockquote><ul><li>在考虑设定矩阵的 “左 上 右 下” 四个边界，模拟矩阵的遍历顺序。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/082353859.png" alt="mark"></p><p><strong>算法思想</strong></p><ol><li>处理空值：当<code>matrix</code> 为空的时候，直接返回空列表[] 即可</li><li>初始化：矩阵的四个边界 <code>l r t b</code> 用于打印结果列表 <code>res</code></li><li>循环打印： “从左到右 从上到下 从右到左 从下到上” 四个方法循环，每个方向打印做以下三件事情（各个方法具体信息见下表）<ul><li>根据边界打印，将元素添加到res的尾部</li><li>边界向内收缩1（代表已被打印）</li><li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li></ul></li></ol><ol start="4"><li>返回值：返回<code>res</code> 即可</li></ol><table><thead><tr><th>打印方向</th><th>1. 根据边界打印</th><th>2. 边界向内收缩</th><th>3. 是否打印完毕</th></tr></thead><tbody><tr><td>从左向右</td><td>左边界<code>l</code> ，右边界 <code>r</code></td><td>上边界 t  加 1</td><td>是否 t &gt; b</td></tr><tr><td>从上到下</td><td>上边界<code>t</code> ,   下边界<code>b</code></td><td>右边界 r  减 1</td><td>是否 l &gt; r</td></tr><tr><td>从右到左</td><td>右边界<code>r</code> ,    左边界<code>l</code></td><td>下边界 b 减 1</td><td>是否 t &gt; b</td></tr><tr><td>从下到上</td><td>下边界<code>b</code> ,    上边界<code>t</code></td><td>左边界 l  加  1</td><td>是否 l &gt; r</td></tr></tbody></table><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083602650.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083658901.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083708848.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083717288.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083725658.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083732833.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顺时针方向</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = matrix.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// left to right</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r ; i++) &#123;</span><br><span class="line">                res[index] = matrix[t][i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ++t ：先给t加1，然后用t的新值</span></span><br><span class="line">            <span class="comment">// t++ : 先用t的原值，然后t加1；</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// top to bottom</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b ; i++) &#123;</span><br><span class="line">                res[index] = matrix[i][r];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// right to left</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l ; i--) &#123;</span><br><span class="line">                res[index] = matrix[b][i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// bottom to top</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t ; i--) &#123;</span><br><span class="line">                res[index] = matrix[i][l];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java 代码利用了 ++ 操作的便利性，详情可见 ++i 和 i++ 的区别 ；</span><br><span class="line"></span><br><span class="line">res[x++] 等价于先给 res[x] 赋值，再给 x 自增 <span class="number">1</span>；</span><br><span class="line">++t &gt; b 等价于先给 t 自增 <span class="number">1</span> ，再判断 t &gt; b 逻辑表达式</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度 O(MN)</strong> ： M, N分别为矩阵行数和列数。</li><li><strong>空间复杂度 O(1)</strong> ： 四个边界 l , r , t , b 使用常数大小的 额外 空间（ res 为必须使用的空间）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-面试题29-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#Leetcode-面试题29-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-面试题29- 顺时针打印矩阵&quot;&gt;&lt;/a&gt;Leetcode-面试题29-&lt;a href=&quot;https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 顺时针打印矩阵&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= matrix.length &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= matrix[i].length &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-面试题16.11-跳水板</title>
    <link href="http://zhuuu.work/2020/07/10/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9816.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/"/>
    <id>http://zhuuu.work/2020/07/10/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9816.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/</id>
    <published>2020-07-10T07:52:53.000Z</published>
    <updated>2020-07-10T06:49:49.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-面试题-16-11-跳水板"><a href="#Leetcode-面试题-16-11-跳水板" class="headerlink" title="Leetcode-面试题 16.11. 跳水板"></a>Leetcode-<a href="https://leetcode-cn.com/problems/diving-board-lcci/" target="_blank" rel="noopener">面试题 16.11. 跳水板</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p><p>返回的长度需要从小到大排列。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter = <span class="number">1</span></span><br><span class="line">longer = <span class="number">2</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">输出： &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt; shorter &lt;= longer</li><li>0 &lt;= k &lt;= 100000</li></ul><a id="more"></a><h2 id="方法：数学"><a href="#方法：数学" class="headerlink" title="方法：数学"></a>方法：数学</h2><ul><li><strong>首先考虑两种边界情况</strong><ul><li>如果K = 0 ,那么不能创建任何水板，因此返回空数组。</li><li>如果 shorter 和 longer相等，则建造的跳水板的长度是唯一的，都等于 shorter∗k，因此返回长度为 1 的数组，数组中的元素为 shorter*k。</li></ul></li></ul><ul><li><strong>然后考虑一般情况</strong>，即 <code>shorter &lt; longer</code> 且 <code>k &gt; 0</code> ，由于短木板和长木板一共使用 k 块 ，所以一共有<code>K + 1</code>中组合，也就是 <code>k + 1</code>种长度<ul><li><strong>先说结论，假设使用了 i 块 长木板，那么使用了短木板就是 (k - i )块。表达式如下</strong></li><li>对于<code>i</code> 属于<code>[0,k]</code>  <code>length[i] = shorter * (k - i) + longer * i</code></li><li><strong>为什么每种组合下建造的跳水板长度都是不一样的？</strong>证明如下：<ul><li>第一种情况，有i 块 长木板，那么长度是<code>shorter * (k - i) + longer * i</code></li><li>第二种情况，有 j 块长木板，那么长度是<code>shorter * (k - j) + longer * j</code></li><li>两式相减，得：</li><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200710/144501891.png" alt="mark"></li><li>其中(longer &gt; shorter ) 并且 （i &lt; j ），所以乘积小于0，所以任何两种组合下的跳水板长度都是不一样的，使用的长木板越多，跳水板的长度越大。</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200710/144933674.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200710/144946336.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 长木板和短木板长度相等</span></span><br><span class="line">        <span class="keyword">if</span> (shorter == longer)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;shorter * k&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一共有 k + 1种不同长度</span></span><br><span class="line">        <span class="comment">// 假设有i块长板子,短板子就是k - i块</span></span><br><span class="line">        <span class="keyword">int</span>[] lengths = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            lengths[i] = shorter*(k - i) + longer * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lengths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(k)，其中 k 是木板数量。短木板和长木板一共使用 k块，一共有k+1 种组合，对于每种组合都要计算跳水板的长度。</p></li><li><p>空间复杂度：O(1)。除了返回值以外，额外使用的空间复杂度为常数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-面试题-16-11-跳水板&quot;&gt;&lt;a href=&quot;#Leetcode-面试题-16-11-跳水板&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-面试题 16.11. 跳水板&quot;&gt;&lt;/a&gt;Leetcode-&lt;a href=&quot;https://leetcode-cn.com/problems/diving-board-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 16.11. 跳水板&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。&lt;/p&gt;
&lt;p&gt;返回的长度需要从小到大排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shorter = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;longer = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt; shorter &amp;lt;= longer&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= k &amp;lt;= 100000&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://zhuuu.work/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JUC-15-线程和进程总结</title>
    <link href="http://zhuuu.work/2020/07/05/JUC/JUC-15-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/07/05/JUC/JUC-15-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-07-05T14:02:24.000Z</published>
    <updated>2020-07-21T06:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-15-线程和进程总结"><a href="#JUC-15-线程和进程总结" class="headerlink" title="JUC-15-线程和进程总结"></a>JUC-15-线程和进程总结</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><p>根本区别：<strong>进程</strong>是<strong>操作系统资源分配</strong>的基本单位，而<strong>线程</strong>是<strong>任务调度和执行的基本单位</strong>。</p><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><ul><li>一个在内存中应用的程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200706/143558022.png" alt="mark"></p><a id="more"></a><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><ul><li>线程也叫做轻量级进程，在一个进程中可以创建多个线程。（进程中的一个执行单元，一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。）</li><li>与进程不同的是同类的<strong>多个线程共享进程的堆和方法区（JDK1.8之后是元空间）资源</strong>，每个线程有自己的<strong>程序计数器，虚拟机栈和本地方法栈</strong>。所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><h3 id="1-3-进程和线程区别总结"><a href="#1-3-进程和线程区别总结" class="headerlink" title="1.3 进程和线程区别总结"></a>1.3 进程和线程区别总结</h3><ul><li><strong>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</strong></li><li><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>内存分配</strong>：同一个进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</li><li><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li><li><strong>执行过程</strong>：每个独立的进程都有程序运行的入口，执行顺序和程序出口。但是线程不能单独执行，必须依存在应用程序之中，由引用程序提供多个线程的执行控制。</li></ul><h2 id="2-从-JVM-角度说进程和线程之间的关系（重要）"><a href="#2-从-JVM-角度说进程和线程之间的关系（重要）" class="headerlink" title="2. 从 JVM 角度说进程和线程之间的关系（重要）"></a>2. 从 JVM 角度说进程和线程之间的关系（重要）</h2><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200706/144649712.png" alt="mark"></p><p>从上图可以明显的看出：</p><ul><li><strong>一个进程中可以有多个线程</strong>，</li><li><strong>多个线程共享进程的堆和方法区</strong></li><li><strong>但是每个线程有自己独立的程序计数器，虚拟机栈和本地方法栈</strong></li></ul><h3 id="2-2-程序计数器为什么是私有的？"><a href="#2-2-程序计数器为什么是私有的？" class="headerlink" title="2.2 程序计数器为什么是私有的？"></a>2.2 程序计数器为什么是私有的？</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，<strong>从而实现代码的流程控制</strong>，如：顺序执行，选择，循环，异常处理。</li><li>在<strong>多线程的场景下，程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪里了。</li></ol><p>需要注意的是，如果运行的是native方法，那么程序计数器记录的是undefined地址，只有执行java代码才能知道下一条指令的地址。</p><p><strong>所以，程序计数器的私有主要是为了线程切换后能够恢复到正确的执行位置</strong></p><h3 id="2-3-虚拟机栈和本地方法栈为什么是私有的？"><a href="#2-3-虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="2.3 虚拟机栈和本地方法栈为什么是私有的？"></a>2.3 虚拟机栈和本地方法栈为什么是私有的？</h3><ul><li><strong>虚拟机栈</strong>： 每个java方法在执行的同时会创建一个栈<strong>帧用于存储局部变量表，操作数栈，常量池的引用，方法返回地址。</strong>从方法调用直至执行完成的过程，对应着一个栈帧在java虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈</strong>：和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p><strong>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</strong></p><h3 id="2-4-一句话了解堆和方法区"><a href="#2-4-一句话了解堆和方法区" class="headerlink" title="2.4 一句话了解堆和方法区"></a>2.4 一句话了解堆和方法区</h3><ul><li>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象(所有对象都在这里分配内存)，</li><li><strong>方法区</strong>主要存放<strong>已被加载的类信息</strong>，<strong>常量</strong>，<strong>静态变量</strong>（常量和静态变量统称为常量池），<strong>即时编译后的代码数据</strong></li></ul><h2 id="3-多线程和多进程的区别"><a href="#3-多线程和多进程的区别" class="headerlink" title="3. 多线程和多进程的区别"></a>3. 多线程和多进程的区别</h2><ul><li>多进程：操作系统中同时运行的多个程序</li><li>多线程：在同一个进程中同时运行的多个任务。</li></ul><p>举个例子，多线程下载软件，可以同时运行多个线程，但是通过程序运行的结果发现，每一次结果都不一致。 因为多线程存在一个特性：<strong>随机性</strong>。造成的原因：<strong>CPU在瞬间不断切换去处理各个线程而导致的，可以理解成多个线程在抢CPU资源。</strong></p><p><strong>多线程提高CPU使用率</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200706/145943289.jpg" alt="mark"></p><p>注意的是：</p><ul><li>多线程并不能提高运行速度，但是可以提高运行效率，因为让CPU的使用率更高</li><li>但是如果多线程有安全访问问题或者出现频繁的上下文切换的时候，运行的速率可能反而会降低。</li></ul><h2 id="4-Java中的多线程"><a href="#4-Java中的多线程" class="headerlink" title="4. Java中的多线程"></a>4. Java中的多线程</h2><ul><li>Java程序中的线程<ul><li><strong>main线程</strong></li><li><strong>GC(垃圾回收线程)（是一个守护线程）</strong></li></ul></li><li><strong>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，</strong>而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li><li><strong>Java支持多线程，当Java程序执行main方法的时候，就是在执行一个名字叫做main的线程，可以在main方法执行时，开启多个线程A,B,C，多个线程 main,A,B,C同时执行，相互抢夺CPU</strong></li><li><strong>Thread类是java.lang包下的一个常用类，每一个Thread类的对象，都代表一个处理某种状态的线程。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-15-线程和进程总结&quot;&gt;&lt;a href=&quot;#JUC-15-线程和进程总结&quot; class=&quot;headerlink&quot; title=&quot;JUC-15-线程和进程总结&quot;&gt;&lt;/a&gt;JUC-15-线程和进程总结&lt;/h1&gt;&lt;h2 id=&quot;1-进程和线程&quot;&gt;&lt;a href=&quot;#1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;1. 进程和线程&quot;&gt;&lt;/a&gt;1. 进程和线程&lt;/h2&gt;&lt;p&gt;根本区别：&lt;strong&gt;进程&lt;/strong&gt;是&lt;strong&gt;操作系统资源分配&lt;/strong&gt;的基本单位，而&lt;strong&gt;线程&lt;/strong&gt;是&lt;strong&gt;任务调度和执行的基本单位&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-1-进程&quot;&gt;&lt;a href=&quot;#1-1-进程&quot; class=&quot;headerlink&quot; title=&quot;1.1 进程&quot;&gt;&lt;/a&gt;1.1 进程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个在内存中应用的程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200706/143558022.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程和线程" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二分查找-合集总结</title>
    <link href="http://zhuuu.work/2020/07/02/LeetcodeExplore/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/07/02/LeetcodeExplore/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%90%88%E9%9B%86/</id>
    <published>2020-07-02T07:52:53.000Z</published>
    <updated>2020-07-22T07:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找-合集总结"><a href="#二分查找-合集总结" class="headerlink" title="二分查找-合集总结"></a>二分查找-合集总结</h1><p>（本系列是针对Leetcode上常见的二分查找题目进行总结。）</p><p><strong>总体思想：把待搜索的目标值留在最后判断，在循环体内不断地把不符合题目要求的子区间排除掉，在退出循环以后，因为只剩下 1 个数没有看到，它要么是目标元素，要么不是目标元素，单独判断即可。</strong></p><p>用这种思路写二分<strong>不容易出错，需要考虑的细节最少</strong>。</p><ul><li>这种思路也非常符合“二分”这个名字，就是把【待搜索的区间】分为【有目标元素的区间】和【不包含目标元素的区间】，排除掉【不包含目标元素的区间】，剩下的就是有【目标元素的区间】。</li></ul><ul><li>初学写二分查找的问题是：跳步厉害，写下 left = mid 或者 right = mid - 1 等代码的时候，一定要搞清楚是什么意思，必要的时候写上注释，帮助自己思考和以后复查代码。</li></ul><ul><li>算法问题建议更多地理解思想，思考为什么这样写，而不建议背代码，背模板。即使要用代码和模板，例如并查集、线段树这种，也应该先把它们保存到自己的 github 代码仓库里，要用的时候去复制粘贴。</li></ul><p><strong>PS：分类是liweiwei老哥总结好的，在他的分类下，下文将以自己的思想将题目串通总结起来。</strong></p><p><strong>二分总结链接</strong>：<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/</a></p><h1 id="1-题目分类"><a href="#1-题目分类" class="headerlink" title="1. 题目分类"></a>1. 题目分类</h1><p><strong>「力扣」上的二分查找问题主要有这三类题型。</strong></p><p><strong>一、在数组中查找符合条件的元素的索引</strong></p><p>一般而言这个数组是有序的，也可能是半有序的，但不大可能是无序的。</p><table><thead><tr><th><strong>题目</strong></th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></td><td>二分查找的模板问题，使用本题解介绍的方法就要注意，需要“后处理”。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></td><td>查找边界问题，<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/" target="_blank" rel="noopener">题解（有视频讲解）</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></td><td>二分查找的思路需要理解，代码很像第 35 题，<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">275. H指数 II</a></td><td><a href="https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></td><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">852. 山脉数组的峰顶索引（简单）</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素（中等）</a></td><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">题解</a>，这个问题二分的写法需要做复杂的分类讨论，可以放在以后做。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a></td><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/" target="_blank" rel="noopener">官方题解（有视频讲解）</a>，<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><p><strong>二、在一个有上下界的区间里搜索一个整数</strong></p><table><thead><tr><th><strong>题目</strong></th><th><strong>提示与题解</strong></th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. 平方根</a></td><td>在一个整数范围里查找一个整数，也是二分查找法的应用场景，<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">题解</a>。在一个整数范围里查找一个整数。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><p><strong>三. 判别条件是一个函数</strong></p><table><thead><tr><th><strong>题目</strong></th><th><strong>提示与题解</strong></th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></td><td>经典问题，判别函数的写法很有技巧，<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a></td><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></td><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><a id="more"></a><h1 id="2-分类1：在数组中查找符合条件的元素的索引"><a href="#2-分类1：在数组中查找符合条件的元素的索引" class="headerlink" title="2. 分类1：在数组中查找符合条件的元素的索引"></a>2. 分类1：在数组中查找符合条件的元素的索引</h1><h2 id="题目1：704-二分查找"><a href="#题目1：704-二分查找" class="headerlink" title="题目1：704. 二分查找"></a>题目1：<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></h2><p><strong>1. 题目描述：</strong></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><p><strong>2.算法思路</strong></p><ul><li>经典的二分查找法（暂时不在这里详细叙述，各位有算法基础的大佬应该闭着眼睛都能写）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log<em>N</em>) &lt; O(N) </li><li>空间复杂度：O(1)</li></ul><p>上述的做法实际上是将<strong>待搜索的区间分为了三个区间</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/164445962.png" alt="mark"></p><p><strong>这种写法的弊端是：返回的边界问题（读者可以想一想弊端具体发生的情况）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/164615121.png" alt="mark"></p><p><strong>接下来提供另外一种：二分查找的思想（排除法）</strong></p><ul><li><strong>mid被分到左边区间</strong></li><li><strong>mid被分到右边区间</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/164822418.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/165100657.png" alt="mark"></p><p><strong>死循环可能产生的原因：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/165635068.png" alt="mark"></p><h2 id="题目2：35-搜索插入位置"><a href="#题目2：35-搜索插入位置" class="headerlink" title="题目2：35. 搜索插入位置"></a>题目2：<a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &lt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 什么时候不是解</span></span><br><span class="line">            <span class="comment">// 如果严格小于不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是[mid + 1,right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 相反的区间[left,mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(logN)，这里 N 是数组的长度，每一次都将问题的规模缩减为原来的一半，因此时间复杂度是对数级别的；</li><li>空间复杂度：O(1)。</li></ul><h2 id="题目3：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#题目3：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="题目3：34. 在排序数组中查找元素的第一个和最后一个位置"></a>题目3：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>题目描述：</p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: [-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>算法思想</strong></p><ul><li><code>nums[mid] &lt; target</code> 一定不是开始位置的解</li><li><code>nums[mid] &gt; target</code> 一定不是结束位置的解 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始位置</span></span><br><span class="line">        <span class="keyword">int</span> firstPosition = findFirstPosition(nums,target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果开始位置都没找到这个元素</span></span><br><span class="line">        <span class="keyword">if</span> (firstPosition == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束位置</span></span><br><span class="line">        <span class="keyword">int</span> lastPosition = findLastPosition(nums,target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstPosition,lastPosition&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 下取整</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 什么时候不是解</span></span><br><span class="line">            <span class="comment">// 严格小于不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮 搜索区间[mid + 1,right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nums[mid] &gt;= target</span></span><br><span class="line">                <span class="comment">// 搜索区间是[left,mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对查找的数进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这时候如果向下取整会有死循环的产生</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 上取整</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 大于一定不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是[left,mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是[mid,right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><strong>时间复杂度</strong>：O(log N)，这里 N 是数组的长度，两个子问题都是二分查找，因此时间复杂度为对数级别。</li><li><strong>空间复杂度</strong>：O(1)，只使用了常数个数的辅助变量、指针。</li></ul><h2 id="题目4：33-搜索旋转排序数组"><a href="#题目4：33-搜索旋转排序数组" class="headerlink" title="题目4：33. 搜索旋转排序数组"></a>题目4：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h2><p><strong>题目描述</strong></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>算法思路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法</span></span><br><span class="line"><span class="comment">// 讨论中间元素和有边界的关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="comment">// 使用上取整的中间数，必须在上面的 mid 表达式的括号里 + 1</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                    <span class="comment">// 下一轮搜索区间是[mid,right]</span></span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 只要上面对了，这个区间是上面区间的反面区间，下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt;= nums[right]</span></span><br><span class="line">                <span class="comment">// [left, mid] 有序，但是为了和上一个 if 有同样的收缩行为，</span></span><br><span class="line">                <span class="comment">// 故意强行认为[left, mid - 1]有序</span></span><br><span class="line">                <span class="comment">// 当区间只剩下2个元素的时候 int mid = (left + right + 1) &gt;&gt;&gt; 1 ;一定会取到右边</span></span><br><span class="line">                <span class="comment">// 此时mid - 1不会越界</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid - <span class="number">1</span>])&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 下一轮搜索区间是[mid,right]</span></span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有可能不存在目标元素，因此还需要做一次判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目-5-：-153-寻找旋转排序数组中的最小值"><a href="#题目-5-：-153-寻找旋转排序数组中的最小值" class="headerlink" title="题目 5 ： 153. 寻找旋转排序数组中的最小值"></a>题目 5 ： <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><ul><li>旋转排序数组，几乎都是有序的数组，也可以通过比较特定位置的元素判断达到”减治“的效果（逐渐缩小区间）</li><li>很自然地，我们会看<strong>中间数（</strong>位于待搜索区间中间位置的元素，由于不是有序数组，因此不能称之为<strong>中位数</strong>）。</li></ul><p>这时候有两个思路：</p><ul><li>思路一：看看搜索区间<strong>左边界</strong>和 ”<strong>中间数</strong>“（注意这里不是中位数），是不是可以缩小搜索区间的范围；</li><li>思路 2：看看当前搜索区间的<strong>右边界</strong>和“<strong>中间数</strong>”（注意这里不是中位数），是不是可以缩小搜索区间的范围；</li></ul><p>要想清楚这个问题，我们不妨举几个例子。</p><p><strong>针对思路1：</strong></p><p>例 1：<code>[1, 2, 3, 4, 5]</code></p><p>例 2：<code>[2, 3, 4, 5, 1]</code></p><ul><li>这两个例子中 ”中间数“都比左边界大，但是旋转排序数组的最小值一个在中间数的左边，一个在中间数的右边，因此思路1是不可行的。</li></ul><p><strong>针对思路2</strong></p><p>例 3：<code>[7, 8, 9, 10, 11, 12, 1, 2, 3]</code></p><p>例 4：<code>[7, 8, 1, 2, 3]</code></p><ul><li>中间数 11 比 3 大，因此中间数左边的数字都不可能是旋转排序数组的最小值，因此下一轮搜索的区间是 [mid + 1,right]</li><li>再看例4 ， 中间数到右边界是递增的， 1 比 3 小，那么中间数右边的数一定不是旋转排序数组的最小值，因此可以把中间数右边的数字排除，但是中间数有可能是整个数组的最小值，就如本例子，因此下一轮搜索区间是[left,mid] ,于是右边界 <code>right = mid</code></li></ul><p>从例 3 和例 4 可以看出，<strong>不论中间数比右边界大，还是中间数比右边界小，我们都可以排除掉将近一半的元素，把原始问题转换成一个规模更小的子问题，这正是“减而治之”思想的体现</strong>，<strong>因此思路 2 可行。</strong></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组为空，无最小元素"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nums[mid] &lt; nums[right](不存在重复的数字)</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一定存在最小元素，因此无需再做判断</span></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O（1）</li></ul><h2 id="题目6-：-154-寻找旋转排序数组中的最小值-II"><a href="#题目6-：-154-寻找旋转排序数组中的最小值-II" class="headerlink" title="题目6 ： 154. 寻找旋转排序数组中的最小值 II"></a>题目6 ： <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h2><p><strong>题目描述</strong></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟153题相比</span></span><br><span class="line"><span class="comment">// 数组中可能存在重复的元素。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组为空，无最小元素"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                <span class="comment">// 说明左侧是升序序列</span></span><br><span class="line">                <span class="comment">// 下一轮搜索区间[mid,right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间[left,mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nums[mid] == nums[right]</span></span><br><span class="line">                <span class="comment">// 例 5：[0, 1, 1, 1, 1, 1, 1]</span></span><br><span class="line">                <span class="comment">// 例 6：[1, 1, 1, 1, 0, 1, 1]</span></span><br><span class="line">                <span class="comment">// 目标值可能在中间数的左边，也有可能在中间数的右边</span></span><br><span class="line">                <span class="comment">// 此时看到了右边界，就把右边界排除掉就好了</span></span><br><span class="line">                <span class="comment">// 正是因为右边界和中间数相等，你去掉了右边界，中间数还在，就让中间数在后面的循环中再起效果</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(logn) ,这里不太确定，因为right– 的操作。</li><li>空间复杂度：O（1）</li></ul><h2 id="题目7-：-H指数-II"><a href="#题目7-：-H指数-II" class="headerlink" title="题目7 ： H指数 II"></a>题目7 ： <a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">H指数 II</a></h2><p><strong>题目描述</strong></p><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: citations = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 给定数组表示研究者总共有 <span class="number">5</span> 篇论文，每篇论文相应的被引用了 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span> 次。</span><br><span class="line">     由于研究者有 <span class="number">3</span> 篇论文每篇至少被引用了 <span class="number">3</span> 次，其余两篇论文每篇被引用不多于 <span class="number">3</span> 次，所以她的 h 指数是 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p>说明:</p><p>如果 h 有多有种可能的值 ，h 指数是其中最大的那个。</p><p>进阶：</p><p>这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。<br>你可以优化你的算法到<strong>对数时间复杂度吗？</strong></p><p><strong>方法：二分查找</strong></p><p>题目中说到：</p><blockquote><p>本题中的 citations 数组是保证有序的。</p></blockquote><p>并且还暗示</p><blockquote><p>你可以优化你的算法到对数时间复杂度吗？</p></blockquote><ul><li><p>因此，可以使用二分查找，二分查找这种非对即错的问题，个人觉得根据示例分析是一种不错的方法。</p><ul><li>就根据示例<code>citations = [0, 1, 3, 5, 6]</code>。</li><li>中位数是3，<code>citations[2]</code> 恰好也等于 3，这个 3 正好是边界，不太好分析 ，我把中位数改成了 2。</li><li>即： <code>citiations = [0,1,2,5,6]</code> 此时根据题目的意思，<strong>此时索引位2的那篇论文不能计入 h 指数（因为，如果算进去，则有3篇论文，但是这篇最小引用的文章才被引用两次）</strong></li></ul></li><li><p>因此，分析出 <code>h</code> 指数和以下两个指标有关：</p><ul><li><strong>某个索引 i 的  citiations 的取值</strong></li><li><strong>某个索引 i 到 citiations 末尾的长度，即区间<code>[i, len - 1]</code> 的长度，即 <code>len - 1 -i + 1 = len - i</code>。</strong></li></ul></li><li><p>如果<code>nums[i] &lt; len - i</code> 索引 <code>i</code> 必须后移一位，因此候选区间是<code>[i + 1,len - 1]</code> </p><ul><li>所以二分查找的下一轮区间是<code>left = i + 1</code> </li></ul></li><li><p>如果 <code>nums[i] &gt; len - i</code>的反面一定就是 <code>right = mid</code> ,看到 <code>left = i + 1</code>,可以知道分支排除了中位数，所以不会有死循环。</p></li><li><p>最后，返回的是区间的长度，区间长度是 <code>len - i</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="comment">// 思路：看nums[mid] 和 区间[mid,len - 1] 的长度</span></span><br><span class="line"><span class="comment">// 即 len - 1 - mid + 1 = len - mid</span></span><br><span class="line"><span class="comment">// [0, 1, 2, 5, 6] 为例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = citations.length;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || citations[len - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前的h指数比长度小就去掉这个值</span></span><br><span class="line">            <span class="keyword">if</span> (citations[mid] &lt; len - mid)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// citations[mid] &gt;= len - mid</span></span><br><span class="line">                <span class="comment">// 比长度大是满足的，应该让mid 往左走尝试看有没有更小的mid值</span></span><br><span class="line">                <span class="comment">// 可以满足mid 对应值大于等于从[mid,len - 1]的长度</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logN) N是数组的长度</li><li>空间复杂度：O(1)</li></ul><h2 id="题目8-：-H-指数"><a href="#题目8-：-H-指数" class="headerlink" title="题目8 ：  H 指数"></a>题目8 ： <a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener"> H 指数</a></h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数 不超过 h 次。）</p><p>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：citations &#x3D; [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure><p><strong>提示：本题和上述的区别是不是升序的数组</strong></p><p><strong>算法思路</strong></p><ol><li><strong>和上题一样，二分查找前加一个排序即可</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = citations.length;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || citations[len - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = citations.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比后面的长度小就去掉这个值</span></span><br><span class="line">            <span class="comment">// 区间长度[mid,len - 1]</span></span><br><span class="line">            <span class="comment">// len - 1 - mid + 1</span></span><br><span class="line">            <span class="keyword">if</span> (citations[mid] &lt; len - mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 比后面的长度大，满足条件，下一轮搜索区间[left,right]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回的是这个区间的长度(h指数)</span></span><br><span class="line">        <span class="keyword">return</span> len - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(nlogn)</li><li><strong>空间复杂度</strong>： O（1）</li></ul><h2 id="题目9-：-山脉数组中查找目标值-（困难）"><a href="#题目9-：-山脉数组中查找目标值-（困难）" class="headerlink" title="题目9 ： 山脉数组中查找目标值 （困难）"></a>题目9 ： <a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">山脉数组中查找目标值</a> （困难）</h2><p><strong>题目描述</strong></p><p>（这是一个 交互式问题 ）</p><p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p><p>如果不存在这样的下标 index，就请返回 -1。</p><p>你将 不能直接访问该山脉数组，<strong>必须通过 MountainArray 接口来获取数据</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）</span><br><span class="line">MountainArray.length() - 会返回该数组的长度</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案</strong>。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “答案”：<a href="https://leetcode-cn.com/playground/RKhe3ave，请注意这" target="_blank" rel="noopener">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> 不是一个正确答案。</p><p><strong>方法：三次二分查找</strong></p><ul><li>理解什么是山脉数组，山脉数组可以分为两部分，一部分是<strong>前有序数组</strong>，一部分是<strong>后有序数组</strong></li><li>“前有序数组” 是升序数组，后有序数组是降序数组。</li><li>题目还告诉我们 “对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案” ，就在疯狂暗示你使用时间复杂度低的算法，对于有序数组当然使用 “二分查找法” 。</li></ul><p><strong>算法思路</strong></p><ul><li>求解这道题分为三部分<ul><li>第一步：先找到<code>mountaintop</code> 所在的索引</li><li>第二步：在前有序数组中找target所在的索引，如果找到了就返回，没有找到执行步骤3</li><li>第三步：如果步骤2 找不到，就在后有序降序数组中找<code>target</code> 所在的索引</li></ul></li></ul><ul><li>写出来的 3 个辅助方法的分支逻辑出奇地一样，在取中位数的时候，都取左中位数，才不会发生死循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is MountainArray's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MountainArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MountainArrayImpl</span> <span class="keyword">implements</span> <span class="title">MountainArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MountainArrayImpl</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">this</span>.arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特别注意：3 个辅助方法的分支出奇地一样，因此选中位数均选左中位数，才不会发生死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = mountainArr.length();</span><br><span class="line">        <span class="comment">// 步骤 1：先找到山顶元素所在的索引</span></span><br><span class="line">        <span class="keyword">int</span> mountaintop = findMountaintop(mountainArr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 步骤 2：在前有序且升序数组中找 target 所在的索引</span></span><br><span class="line">        <span class="keyword">int</span> res = findFromSortedArr(mountainArr, <span class="number">0</span>, mountaintop, target);</span><br><span class="line">        <span class="keyword">if</span> (res != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 步骤 3：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引</span></span><br><span class="line">        <span class="keyword">return</span> findFromInversedArr(mountainArr, mountaintop + <span class="number">1</span>, size - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMountaintop</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回山顶元素</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 取左中位数，因为进入循环，数组一定至少有 2 个元素</span></span><br><span class="line">            <span class="comment">// 因此，左中位数一定有右边元素，数组下标不会发生越界</span></span><br><span class="line">            <span class="keyword">if</span> (mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果当前的数比右边的数小，它一定不是山顶</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据题意，山顶元素一定存在，因此退出 while 循环的时候，不用再单独作判断</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFromSortedArr</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在前有序且升序数组中找 target 所在的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.get(mid) &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为不确定区间收缩成 1个数以后，这个数是不是要找的数，因此单独做一次判断</span></span><br><span class="line">        <span class="keyword">if</span> (mountainArr.get(l) == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFromInversedArr</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在后有序且降序数组中找 target 所在的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 与 findFromSortedArr 方法不同的地方仅仅在于由原来的小于号改成大于好</span></span><br><span class="line">            <span class="keyword">if</span> (mountainArr.get(mid) &gt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为不确定区间收缩成 1个数以后，这个数是不是要找的数，因此单独做一次判断</span></span><br><span class="line">        <span class="keyword">if</span> (mountainArr.get(l) == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">3</span>;</span><br><span class="line">        MountainArray mountainArray = <span class="keyword">new</span> MountainArrayImpl(arr);</span><br><span class="line"></span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> res = solution.findInMountainArray(target, mountainArray);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度（OlogN）二分查找法的时间复杂度是对数级别的，这里使用了 3 次二分查找法，是常数倍数，因此可以忽略这个常数系数。</li><li>空间复杂度：O(1) 里使用的额外的辅助空间仅仅是 <code>mountaintop</code>、中位数索引 <code>mid</code> 等，是常数级别，因此空间复杂度为 O(1)。</li></ul><h1 id="3-分类2：在一个有范围的区间内找到一个整数"><a href="#3-分类2：在一个有范围的区间内找到一个整数" class="headerlink" title="3. 分类2：在一个有范围的区间内找到一个整数"></a>3. 分类2：在一个有范围的区间内找到一个整数</h1><h2 id="题目1-：-69：x-的平方根"><a href="#题目1-：-69：x-的平方根" class="headerlink" title="题目1 ： 69：x 的平方根"></a>题目1 ： <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69：x 的平方根</a></h2><p><strong>题目描述</strong></p><ul><li>实现 <code>int sqrt(int x)</code> 函数。</li><li>计算并返回 x 的平方根，其中 x 是非负整数。</li><li>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><p><strong>算法思路:二分查找</strong></p><ul><li><strong>二分查找法要找到左右边界</strong></li><li>一个数的平方根肯定不会超过它自己，还有比较细节的划分，那就是一个数的平方根不会超过它的一半。（比如8的平方根，一半是4，4的平方是16，大于8）</li><li><strong>因此我们要计算一下，这个右边界是多少</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/174153415.png" alt="mark"></p><p>意思就是：如果一个数的一般平方大于自己，那么这个数的取值范围。解以上不等式得 <code>a &gt;= 4 或者 a &lt; 0</code></p><ul><li>于是右边界的值就是4，因为边界值要大于0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对0的特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要把搜索的区间设置成长整型</span></span><br><span class="line">        <span class="comment">// 注意：针对特殊测试用例，例如 2147395599</span></span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> right = x/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> square = mid * mid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排除大于不是解</span></span><br><span class="line">            <span class="keyword">if</span> (square &gt; x)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意返回的是整型</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(logN),二分查找的时间复杂度是对数级别的</li><li><strong>空间复杂度</strong>：O(1) 使用了常数个数的辅助空间用于存储</li></ul><h2 id="题目2：-287-寻找重复数"><a href="#题目2：-287-寻找重复数" class="headerlink" title="题目2：  287. 寻找重复数"></a>题目2：  <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h2><p><strong>题目描述</strong></p><ul><li>给定一个包含 <code>n + 1</code>个整数的数组 <code>nums</code>，其数字都在 <code>1 到 n 之间</code>（包括 1 和 n），可知至少存在一个重复的整数。假设<strong>只有一个重复的整数</strong>，找出这个重复的数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><strong>不能更改原数组（假设数组是只读的）。</strong></li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n^2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul><p><strong>Solution：二分法</strong></p><ul><li><p><strong>如果测试数据不在这个范围里，二分法失效</strong>。</p></li><li><p><strong>二分法的常见作用：可以用来确定一个有范围的整数</strong></p></li></ul><ul><li>预备知识：</li></ul><p><strong>抽屉原理</strong>：假设要把10个苹果放进9个柜子，那么一定有一个柜子放了不止一个。</p><p>容易想到的方法有：</p><ul><li>使用哈希表判重，这违反了限制 2；</li><li>将原始数组排序，排序以后，重复的数相邻，即找到了重复数，这违反了限制 1；</li><li>使用类似「力扣」第 41 题：缺失的第一个正数 （原地哈希）的思路，当两个数发现要放在同一个地方的时候，就发现了这个重的元素，这违反了限制 1；</li><li>既然要定位数，这个数恰好是一个整数，可以在「整数的有效范围内」做二分查找，但是比较烦的一点是得反复看整个数组好几次，本题解就介绍通过二分法定位一个有范围的整数；</li><li>还可以使用「快慢指针」来完成，不过这种做法太有技巧性了，不是通用的做法，可以查看官方题解。</li></ul><p><strong>思路：</strong></p><ul><li><p>二分法的思路是先猜一个数（有效范围 <code>[left, right]</code>里的中间数 <code>mid</code>）</p></li><li><p>然后统计原始数组中<strong>小于等于</strong>这个中间数的元素的个数 count , 如果count <strong>严格大于</strong> mid ，注意我加了着重号的部分「小于等于」、「严格大于」）。</p></li><li><p>根据抽屉原理，重复的元素就在区间 <code>[left, mid]</code> 里；</p></li></ul><p><strong>举个例子：</strong></p><ul><li>以<code>[2,4,5,2,3,1,6,7]</code> 为例，一共 8 个数，<code>n + 1 = 8</code>  那么 n = 7 并且根据题目的意思，每个数都在[1,7]之间</li><li>例如：区间[1,7]的中位数是4<ul><li>之后遍历整个数组，统计小于等于4的整数的个数，如果不存在重复元素，最后就是4个。</li><li>等于4的时候区间[1,4]内也可能有重复的元素，比如 [1,2,2,4] 。</li><li>但是,如果整个数组里小于等于4的正数的个数严格大于4 的时候，根据抽屉原理，一定说明重复的数字在[1,4]之间。</li></ul></li></ul><p><strong>Solution : 算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//在 Java 里可以这么用，</span></span><br><span class="line">            <span class="comment">// 当 left + right 溢出的时候，无符号右移保证结果依然正确</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次更新 count 会被重置为0</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计原始数组中小于等于这个中间数元素的个数count</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid)&#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据抽屉原理，count如果严格大于mid个</span></span><br><span class="line">            <span class="comment">// 此时重复元素一定在[1,mid]之间</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid)&#123;</span><br><span class="line">                <span class="comment">// 重复元素位于[left,mid]之间</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重复元素位于[mid + 1, right] 之间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left = right 的时候推出循环，结果就是重复的数字</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(nlogn)</strong> - 二分法的时间复杂度是O(logn) ,并且在二分法内部执行了一次 for 循环 ，时间复杂度是O(n), 所以总的复杂度是O(nlogn)。</li><li><strong>空间复杂度O(1)</strong> : 使用了一个count变量</li></ul><h2 id="题目3-：-374-猜数字大小"><a href="#题目3-：-374-猜数字大小" class="headerlink" title="题目3 ： 374. 猜数字大小"></a>题目3 ： <a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></h2><p><strong>题目描述</strong></p><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 : 我的数字比较小</span><br><span class="line"> 1 : 我的数字比较大</span><br><span class="line"> 0 : 恭喜！你猜对了！</span><br></pre></td></tr></table></figure><p><strong>示例 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10, pick &#x3D; 6</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>算法思想：</strong></p><ol><li><strong>首先得先把guessnum接口先写出来</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuessGame</span></span>&#123;</span><br><span class="line">    <span class="comment">// 比如我猜的数字是6</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guess</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 你和我猜的一样</span></span><br><span class="line">        <span class="keyword">if</span> (num == NUM)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num &lt; NUM)&#123;</span><br><span class="line">            <span class="comment">// 你猜的比我猜的小</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 你猜的比我猜的大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>接下来的思路就很显然了</strong><ul><li>排除猜错的区间 <code>guessNum = -1</code> 的情况，那么下一轮搜索区间是<code>[left,mid - 1]</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> guessNum = guess(mid);</span><br><span class="line">            <span class="keyword">if</span> (guessNum == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 中位数比猜的数大</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一定会猜对</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(logn)</strong></li><li><strong>空间复杂度： O(1)</strong> </li></ul><h2 id="题目4-：-1300-转变数组后最接近目标值的数组和"><a href="#题目4-：-1300-转变数组后最接近目标值的数组和" class="headerlink" title="题目4 ： 1300. 转变数组后最接近目标值的数组和"></a>题目4 ： <a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></h2><p><strong>题目描述</strong></p><p>给你一个整数数组 <code>arr</code> 和一个目标值 <code>target</code> ，请你返回一个<code>整数 value</code> ，<strong>使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。</strong></p><p>如果有多种使得和最接近 <code>target</code> 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 <code>arr</code> 中的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [4,9,3], target &#x3D; 10</span><br><span class="line">输出：3</span><br><span class="line">解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [2,3,5], target &#x3D; 10</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [60864,25176,27249,21296,20204], target &#x3D; 56803</span><br><span class="line">输出：11361</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^4</code></li><li><code>1 &lt;= arr[i], target &lt;= 10^5</code></li></ul><p><strong>方法：二分查找</strong></p><p><strong>思路：</strong></p><ul><li>使用二分法确定一个正数<code>threshold</code>,使得这个<code>threshold</code>下，转变后的数组的和最接近目标值<code>target</code><ul><li>转变的规则是严格大于<code>threshold</code>元素变成<code>threshold</code>，那么也就意味着<code>threshold</code>越大，数组的和越大（注意这里是单调的，也有可能<code>threshold</code>扩大之后，和可能不变，也就是<strong>大于等于的关系</strong>）</li></ul></li></ul><ul><li>正是因为题目说 <code>value</code> 是整数，并且「答案不一定是 <code>arr</code> 中的数字」，因此依然可以使用二分查找法确定这个整数值。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200719/144801332.png" alt="mark"></p><ul><li><strong>做题的时候，发现最难写的其实是判断的条件，因为「怎么衡量接近」，度量这个「最接近」的量不好选。因此需要考虑别的方案；</strong></li></ul><ul><li><strong>这里问题就是：选定了一个value求和之后，</strong><ul><li>如果恰恰好等于 <code>target</code> ，那就万事大吉</li><li>不过更可能出现的情况是， value 取小了，接近程度变大</li><li>而value 取大了之后，接近程度变小了</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200719/145036767.png" alt="mark"></p><ul><li><strong>解决方案</strong><ul><li><strong>先用二分法确定value的可能的值</strong></li><li><strong>然后把value的上下边界都拿出来进行一次比较</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>  right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取最大的数置为right</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            right = Math.max(num,right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = calculateSum(arr,mid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算第一个使得转变后数组的和大于等于target的阈值</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断到底返回的是哪个阈值</span></span><br><span class="line">        <span class="comment">// 比较阈值线分别在left - 1 和 left的时候与target的接近程度</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = calculateSum(arr,left - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum2 = calculateSum(arr,left);</span><br><span class="line">        <span class="comment">// 判断接近程度</span></span><br><span class="line">        <span class="keyword">if</span> (target - sum1 &lt;= sum2 - target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left -  <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 计算数组中threshold以下数字的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            sum += Math.min(num,threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.findBestValue(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(NlogN)，这里 N 是输入数组的长度，二分的时间复杂度是 O(logN)，每一次 calculateSum 的时间复杂度是 O(N)；</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h2 id="题目5-：-1283-使结果不超过阈值的最小除数"><a href="#题目5-：-1283-使结果不超过阈值的最小除数" class="headerlink" title="题目5 ： 1283. 使结果不超过阈值的最小除数"></a>题目5 ： <a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/" target="_blank" rel="noopener">1283. 使结果不超过阈值的最小除数</a></h2><p><strong>题目描述</strong></p><ul><li>给你一个整数数组 <code>nums</code> 和一个正整数 <code>threshold</code>，选择一个正整数作为除数，然后将数组里的每个数都除以它，并对除法结果求和。</li><li>请你找出能够使得上述结果小于等于阈值 <code>threshold</code> 的除数<strong>最小</strong>的那个</li><li>每个数除以除数之后都会向上取整，比方说 7/3 = 3 ， 10/2 = 5 。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,5,9], threshold = 6</span><br><span class="line">输出：5</span><br><span class="line">解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。</span><br><span class="line">如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,3,5,7,11], threshold = 11</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [19], threshold = 5</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>方法思路</strong></p><ol><li>找出小于等于阈值 <code>threshold</code> 中<strong>最小</strong>的那个，明显可以使用二分查找</li><li>于是可以思考除数最大可以是多少，最小是多少<ul><li><strong>最大是数组中最大的那个数</strong>，因为除数如果再大，整除以后每个数都得 1（上取整的缘故）；</li><li><strong>最小可以是 1。</strong></li></ul></li></ol><ol start="3"><li>写 if  分支的时候，根据题目的意思选<ul><li>选择一个正整数作为除数，然后将数组重的每个数都除以它，并对除法结果求和</li></ul></li><li><strong>这时候开始思考二分查找的关键  ： 排除什么时候不是解</strong><ul><li>因此 ： 和<strong>严格</strong>大于 阈值<code>threshold</code> 的整数，一定不是解。根据减而治之的思想， 定位这个除数。</li></ul></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDivisor</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先找数组中的最大值，用最大值作为除数，除完以后和最小</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            maxVal = Math.max(maxVal, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：最小值是 1，因为 threshold 可以很大</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = maxVal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (calculateSum(nums, mid) &gt; threshold) &#123;</span><br><span class="line">                <span class="comment">// sum 大于阈值一定不是解，说明除数选得太小了</span></span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">                <span class="comment">// （把下一轮搜索区间写出来，边界选择就不会错）</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 边界是 left = mid + 1 ，中间数不用上取整</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divisor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组中各个元素与 divisor 相除的结果（向上取整）之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num / divisor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：不能整除的时候，需要向上取整</span></span><br><span class="line">            <span class="keyword">if</span> (num % divisor != <span class="number">0</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<img src="file:///C:/Users/Zhuuu/AppData/Local/Temp/leetcode/editor/cn/doc/p__O_N_log_max_nums___.png" alt="ONlogmaxnums "> ，这里 <em>N</em> 是数组的长度，每一次二分都执行了边界判断函数，都得遍历一遍数组；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><h2 id="题目6-：-875-爱吃香蕉的珂珂"><a href="#题目6-：-875-爱吃香蕉的珂珂" class="headerlink" title="题目6 ： 875. 爱吃香蕉的珂珂"></a>题目6 ： <a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></h2><p><strong>题目描述</strong></p><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂<strong>喜欢慢慢吃</strong>，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <strong>H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</strong></p><p><strong>思路</strong></p><ul><li>最小速度是1，最大速度是数组重的最大值。</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到速度的最大值</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">            maxVal = Math.max(maxVal,pile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 速度的最小值</span></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 速度的最大值</span></span><br><span class="line">        <span class="keyword">int</span> right = maxVal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排除：吃的太慢的情况</span></span><br><span class="line">            <span class="keyword">if</span> (calculateSum(piles,mid) &gt; H)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间[mid + 1,right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span>[] piles,<span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">            <span class="comment">// 除不尽向上取整</span></span><br><span class="line">            sum += pile / speed;</span><br><span class="line">            <span class="keyword">if</span>(pile % speed != <span class="number">0</span>)&#123;</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<img src="file:///C:/Users/Zhuuu/AppData/Local/Temp/leetcode/editor/cn/doc/p__O_N_log_max_nums___.png" alt="ONlogmaxnums "> ，这里 <em>N</em> 是数组的长度，每一次二分都执行了边界判断函数，都得遍历一遍数组；</li><li>空间复杂度：<em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分查找-合集总结&quot;&gt;&lt;a href=&quot;#二分查找-合集总结&quot; class=&quot;headerlink&quot; title=&quot;二分查找-合集总结&quot;&gt;&lt;/a&gt;二分查找-合集总结&lt;/h1&gt;&lt;p&gt;（本系列是针对Leetcode上常见的二分查找题目进行总结。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总体思想：把待搜索的目标值留在最后判断，在循环体内不断地把不符合题目要求的子区间排除掉，在退出循环以后，因为只剩下 1 个数没有看到，它要么是目标元素，要么不是目标元素，单独判断即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用这种思路写二分&lt;strong&gt;不容易出错，需要考虑的细节最少&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种思路也非常符合“二分”这个名字，就是把【待搜索的区间】分为【有目标元素的区间】和【不包含目标元素的区间】，排除掉【不包含目标元素的区间】，剩下的就是有【目标元素的区间】。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;初学写二分查找的问题是：跳步厉害，写下 left = mid 或者 right = mid - 1 等代码的时候，一定要搞清楚是什么意思，必要的时候写上注释，帮助自己思考和以后复查代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;算法问题建议更多地理解思想，思考为什么这样写，而不建议背代码，背模板。即使要用代码和模板，例如并查集、线段树这种，也应该先把它们保存到自己的 github 代码仓库里，要用的时候去复制粘贴。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：分类是liweiwei老哥总结好的，在他的分类下，下文将以自己的思想将题目串通总结起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分总结链接&lt;/strong&gt;：&lt;a href=&quot;https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-题目分类&quot;&gt;&lt;a href=&quot;#1-题目分类&quot; class=&quot;headerlink&quot; title=&quot;1. 题目分类&quot;&gt;&lt;/a&gt;1. 题目分类&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;「力扣」上的二分查找问题主要有这三类题型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、在数组中查找符合条件的元素的索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般而言这个数组是有序的，也可能是半有序的，但不大可能是无序的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;提示与题解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-search/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;704. 二分查找&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;二分查找的模板问题，使用本题解介绍的方法就要注意，需要“后处理”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;查找边界问题，&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解（有视频讲解）&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;33. 搜索旋转排序数组&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;81. 搜索旋转排序数组 II&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;153. 寻找旋转排序数组中的最小值&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;154. 寻找旋转排序数组中的最小值 II&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;300. 最长上升子序列&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;二分查找的思路需要理解，代码很像第 35 题，&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/h-index-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;275. H指数 II&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-in-mountain-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1095. 山脉数组中查找目标值&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;852. 山脉数组的峰顶索引（简单）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-k-closest-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;658. 找到 K 个最接近的元素（中等）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;，这个问题二分的写法需要做复杂的分类讨论，可以放在以后做。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;4. 寻找两个有序数组的中位数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方题解（有视频讲解）&lt;/a&gt;，&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;二、在一个有上下界的区间里搜索一个整数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;提示与题解&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sqrtx/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;69. 平方根&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在一个整数范围里查找一个整数，也是二分查找法的应用场景，&lt;a href=&quot;https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;287. 寻找重复数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;。在一个整数范围里查找一个整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/guess-number-higher-or-lower/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;374. 猜数字大小&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1300. 转变数组后最接近目标值的数组和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;三. 判别条件是一个函数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;提示与题解&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/first-bad-version/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;278. 第一个错误的版本&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/split-array-largest-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;410. 分割数组的最大值&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;经典问题，判别函数的写法很有技巧，&lt;a href=&quot;https://leetcode-cn.com/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-k-closest-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;658. 找到 K 个最接近的元素&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/koko-eating-bananas/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;875. 爱吃香蕉的珂珂&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1300. 转变数组后最接近目标值的数组和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="算法总结" scheme="http://zhuuu.work/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="二分查找" scheme="http://zhuuu.work/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>笔试题-01-有限制的跳台阶</title>
    <link href="http://zhuuu.work/2020/07/01/Leetcode/%E7%AC%94%E8%AF%95%E9%A2%98-01-%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://zhuuu.work/2020/07/01/Leetcode/%E7%AC%94%E8%AF%95%E9%A2%98-01-%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2020-07-01T07:12:53.000Z</published>
    <updated>2020-09-06T14:59:55.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔试题-01-有限制的跳台阶"><a href="#笔试题-01-有限制的跳台阶" class="headerlink" title="笔试题-01-有限制的跳台阶"></a>笔试题-01-有限制的跳台阶</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目来源：字节2020.09.06笔试第一题</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200906/225708979.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200906/225735259.png" alt="mark"></p><a id="more"></a><h2 id="思想-dp"><a href="#思想-dp" class="headerlink" title="思想:dp"></a>思想:dp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>]+dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n][<span class="number">0</span>]+dp[n][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>状态定义</strong><ul><li><code>dp[i][0]</code> 表示跳一步到达台阶</li><li><code>dp[i][1]</code>表示跳两步到达台阶 </li></ul></li></ul><p><strong>复杂度分析</strong></p><ul><li>空间复杂度：O(N^2)  dp表的空间复杂度</li><li>时间复杂度：O(N^2)  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;笔试题-01-有限制的跳台阶&quot;&gt;&lt;a href=&quot;#笔试题-01-有限制的跳台阶&quot; class=&quot;headerlink&quot; title=&quot;笔试题-01-有限制的跳台阶&quot;&gt;&lt;/a&gt;笔试题-01-有限制的跳台阶&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目来源：字节2020.09.06笔试第一题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200906/225708979.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200906/225735259.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-046-全排列</title>
    <link href="http://zhuuu.work/2020/06/30/Leetcode/Leetcode-046-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://zhuuu.work/2020/06/30/Leetcode/Leetcode-046-%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2020-06-30T08:44:53.000Z</published>
    <updated>2020-07-03T09:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-046-全排列"><a href="#Leetcode-046-全排列" class="headerlink" title="Leetcode-046-全排列"></a>Leetcode-046-<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：回溯算法（DFS）"><a href="#方法：回溯算法（DFS）" class="headerlink" title="方法：回溯算法（DFS）"></a>方法：回溯算法（DFS）</h2><ul><li>“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧</li><li>同时回溯其实就是“深度优先遍历”特有的一种现象</li><li>“全排列”就是一个非常经典的“回溯”算法的应用。我们知道，<code>N</code> 个数字的全排列一共有 N!这么多个。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以数组 [1, 2, 3] 的全排列为例。</span><br><span class="line"></span><br><span class="line">我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；</span><br><span class="line">再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；</span><br><span class="line">最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。</span><br></pre></td></tr></table></figure><ul><li>我们只需要按顺序枚举每一位可能出现的情况，已经选择的数字在接下来要确定的数字中不能出现。按照这种策略选取就能够做到不重不漏，把可能的全排列都枚举出来。<ul><li>在枚举第一位的时候，有三种情况。</li><li>在枚举第二位的时候，前面已经出现过的数字就不能再选择了。</li><li>在枚举第三位的时候，前面两个出现过的数字已经不能再选择了。</li></ul></li></ul><p>我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；<br>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；<br>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。</p><p>使用编程的方法得到全排列，就是在这样的一个树形结构中进行编程，具体来说，就是<strong>执行一次深度优先遍历，从树的根结点到叶子结点形成的路径就是一个全排列</strong>。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/165513074.png" alt="mark"></p><ol><li>每一个节点表示了全排列问题求解不同的阶段，这些<strong>阶段</strong>通过变量的不同值体现。</li><li>这些变量不同的值，也叫做<strong>状态</strong></li><li>使用深度优先遍历，可以借助系统的栈空间，为我们保存所需要的状态变量，具体做法是：<ul><li>往下走一层，将新的变量追加在尾部，</li><li>而往回走的时候，需要撤销上一次的选择，也就是在尾部删除之前的操作</li></ul></li><li>这里我们需要用到<strong>两个变量数组</strong><ul><li>已经选取了哪些数字，用path数组来记录</li><li>一个布尔数组used,初始化的时候都为false,表示这些数字没有被选择，如果被选择值为true</li></ul></li></ol><p><strong>废话不多说：show me the code(第一种：有错误的版本 )</strong></p><p>（注意：这个代码是错误的，希望读者能自己运行一下测试用例自己发现原因，然后再阅读后面的内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 首先是特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(nums, len, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line">                <span class="comment">// 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的</span></span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);</span><br><span class="line">        System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在运行的时候输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[], [], [], [], [], []]</span><br></pre></td></tr></table></figure><p>错误的原因出现在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">    res.add(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>path</code> <strong>这个变量指向的变量在全局递归过程中只有一份存在，深度优先遍历完成之后，因为回到了根节点（撤销了之前的操作），因此path回到根节点以后就是空</strong>。</p><p><strong>在java中，传递的对象的内存地址，这些地址实际上是同一块内存区域，所以说我们要做一次深拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确的版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="comment">// 首先是特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组来保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，</span></span><br><span class="line">        <span class="comment">// 当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，</span></span><br><span class="line">        <span class="comment">// 这样在考虑下一个位置的时候，就能够以 O(1） 的时间复杂度判断这个数是否被选择过，</span></span><br><span class="line">        <span class="comment">// 这是一种“以空间换时间”的思想。</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path 这个变量所指向的对象在递归的过程中只有一份，</span></span><br><span class="line">        <span class="comment">// 深度优先遍历完成以后，因为回到了根结点（因为我们之前说了，从深层结点回到浅层结点的时候，需要撤销之前的选择），</span></span><br><span class="line">        <span class="comment">// 因此 path 这个变量回到根结点以后都为空。</span></span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums,len,<span class="number">0</span>,path,used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// depth 用来记录递归到了第几层</span></span><br><span class="line">        <span class="comment">// 用来结束递归，拿到当前的结果之后再撤销回上一层</span></span><br><span class="line">        <span class="keyword">if</span> (depth == len)&#123;</span><br><span class="line"><span class="comment">//            res.add(path);</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// else进行递归</span></span><br><span class="line">        <span class="comment">// 遍历所有nums中的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 是否这个数字之前已经用过</span></span><br><span class="line">            <span class="keyword">if</span> (!used[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不断往下一层走</span></span><br><span class="line">                dfs(nums, len, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line"></span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(N * N!)   N个节点，每个都要计算N！次</li><li>空间复杂度：O(N * N!)  N个节点，每个都要存储N！次</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-046-全排列&quot;&gt;&lt;a href=&quot;#Leetcode-046-全排列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-046-全排列&quot;&gt;&lt;/a&gt;Leetcode-046-&lt;a href=&quot;https://leetcode-cn.com/problems/permutations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全排列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个 &lt;strong&gt;没有重复&lt;/strong&gt; 数字的序列，返回其所有可能的全排列。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,3,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,1,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,3,1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,1,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="回溯算法" scheme="http://zhuuu.work/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-047-全排列II</title>
    <link href="http://zhuuu.work/2020/06/29/Leetcode/Leetcode-047-%E5%85%A8%E6%8E%92%E5%88%97II/"/>
    <id>http://zhuuu.work/2020/06/29/Leetcode/Leetcode-047-%E5%85%A8%E6%8E%92%E5%88%97II/</id>
    <published>2020-06-29T09:59:53.000Z</published>
    <updated>2020-07-03T10:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-047-全排列-II"><a href="#Leetcode-047-全排列-II" class="headerlink" title="Leetcode-047-全排列 II"></a>Leetcode-047-<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个<strong>可包含重复数字</strong>的序列，返回所有不重复的全排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：回溯-剪枝"><a href="#方法：回溯-剪枝" class="headerlink" title="方法：回溯+剪枝"></a>方法：回溯+剪枝</h2><ul><li><p>这一题是在「力扣」第 46 题： <a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">“全排列”</a> 的基础上增加了“序列中的元素可重复”这一条件，但要求返回的结果又不能有重复元素。</p></li><li><p><strong>思路：在一定会产生重复的地方进行剪枝</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/181206422.png" alt="mark"></p><ul><li><strong>剪枝的方法</strong><ul><li><strong>一个比较容易想到的方法就是在结果集里面去重，但是问题来了，这里的结果集里面是一个列表，对列表的去重可没有HashSet那么容易</strong></li><li>如果要比较两个列表是否一样，<strong>一个很显然的办法就是排序，而且是一开始就进行排序，去除重复的选项</strong>。 一旦发现这一支搜索下去可能搜索到重复的元素就停止搜索，这样结果集中不会包含重复元素。</li></ul></li></ul><ul><li><p>产生重复结点的地方，正是图中标注了“剪刀”，且被绿色框框住的地方。</p></li><li><p>大家也可以把第 2 个 <code>1</code> 加上 <code>&#39;</code> ，即 <code>[1, 1&#39;, 2]</code> 去想象这个搜索的过程。只要遇到起点一样，就有可能产生重复。</p><ul><li><strong>这里有一个特别细节的地方</strong></li><li><strong>在图中 ② 处，搜索的数也和上一次一样，但是上一次的 <code>1</code> 还在使用中；</strong></li><li><strong>在图中 ① 处，搜索的数也和上一次一样，但是上一次的 <code>1</code> 刚刚被撤销，正是因为刚被撤销，下面的搜索中还会使用到，因此会产生重复，剪掉的就应该是这样的分支</strong>。</li></ul></li></ul><p>代码实现：在第 46 题的基础上，要加上这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想：在一定会产生重复结果集的地方剪枝</span></span><br><span class="line"><span class="comment">// 一个比较容易想到的办法是在结果集中去重。</span></span><br><span class="line"><span class="comment">// 但是问题又来了，这些结果集的元素是一个又一个列表，对列表去重不像用哈希表对基本元素去重那样容易。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在搜索之前就要对元素进行排序：排序是剪枝的前提</span></span><br><span class="line">        <span class="comment">// 一旦发现这一支搜索下去可能会遇到重复的元素就停止搜索</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局唯一的辅助结果集</span></span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(nums,<span class="number">0</span>,used,temp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> depth, <span class="keyword">boolean</span>[] used, ArrayList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for循环进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 如果当前数已经使用过</span></span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 剪枝条件 ： i &gt; 0 是为了保证 nums[i - 1] 有意义</span></span><br><span class="line">            <span class="comment">// 写！user[i] 是因为nums[i-1]在回溯的时候刚刚被撤销的选择的情况</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 做出选择</span></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. backtrack</span></span><br><span class="line">            backtrack(nums,depth + <span class="number">1</span>,used,temp,res);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 撤销选择</span></span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：（理由同第 46 题，重复元素越多，剪枝越多。但是计算复杂度的时候需要<strong>考虑最差情况</strong>。）</p><ul><li>时间复杂度： O(N*N!)</li><li>空间复杂度： O(N*N!)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-047-全排列-II&quot;&gt;&lt;a href=&quot;#Leetcode-047-全排列-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-047-全排列 II&quot;&gt;&lt;/a&gt;Leetcode-047-&lt;a href=&quot;https://leetcode-cn.com/problems/permutations-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全排列 II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个&lt;strong&gt;可包含重复数字&lt;/strong&gt;的序列，返回所有不重复的全排列。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,1,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="回溯算法" scheme="http://zhuuu.work/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>汇编-02-进制</title>
    <link href="http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-02-%E8%BF%9B%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-02-%E8%BF%9B%E5%88%B6/</id>
    <published>2020-06-28T11:40:41.000Z</published>
    <updated>2020-07-14T12:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-02-进制"><a href="#汇编-02-进制" class="headerlink" title="汇编-02-进制"></a>汇编-02-进制</h1><p>[参考博客链接:进制转换][<a href="https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]" target="_blank" rel="noopener">https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]</a></p><a id="more"></a><h2 id="1-为什么要使用进制数字？"><a href="#1-为什么要使用进制数字？" class="headerlink" title="1. 为什么要使用进制数字？"></a>1. 为什么要使用进制数字？</h2><p>如果我们直接操作二进制的话 , 面对这么长的数进行思考或操作，没有人会喜欢。</p><p>C，C++ 语言 没有提供在代码直接写二进制数的方法。<br>用16进制或8进制可以解决这个问题。<br><strong>因为，进制越大，数的表达长度也就越短。</strong></p><p><strong>之所以 使用 16或8进制，而不其它的，诸如9或20进制 .</strong></p><p><strong>是因为2、8、16，分别是2的1次方、3次方、4次方。这一点使得三种进制之间可以非常直接地互相转换 ;</strong></p><p>8进制或16进制 既 缩短了二进制数，还能 保持了二进制数的表达特点。转换还方便 .</p><h2 id="2-进制的介绍"><a href="#2-进制的介绍" class="headerlink" title="2. 进制的介绍"></a>2. 进制的介绍</h2><blockquote><p>进制 : 是计算机中数据的一种表示方法。 N进制的数可以用0~(N-1) 的数表示, 超过9的用字母A-F 表示 .</p></blockquote><ul><li>10进制</li></ul><blockquote><p>先说 我们最 熟悉的 10进制 , 就是 用 0~9 的数表示 , 逢 10 进 1 .</p></blockquote><ul><li>16进制</li></ul><blockquote><p>如果是 16 进制 , 它就是 由 0-9，A-F组成， 与10进制的对应关系是：0-9 对应 0-9；A-F对应10-15；<br>字母不区分大小写。</p></blockquote><ul><li>2进制 和 8进制</li></ul><blockquote><p>2进制 由 0-1组成</p><p>8进制 由 0-7组成</p></blockquote><p>再看几个特别的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写出各个进制1-20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一进制 </span></span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三进制</span></span><br><span class="line">0 1 2</span><br><span class="line">101112</span><br><span class="line">202122</span><br><span class="line">100101102</span><br><span class="line">110111112</span><br><span class="line">120121122</span><br><span class="line">1000 .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 七进制</span></span><br><span class="line">0123456</span><br><span class="line">10111213141516</span><br><span class="line">20212223242526</span><br><span class="line">30313233343536</span><br></pre></td></tr></table></figure><p><strong>现在有个问题，用进制问题解释1 + 1 = 3？</strong></p><ul><li>如果你想清楚了，进制你就没问题了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 十进制</span><br><span class="line">0 1 2 3 4 5 6 7 8 9        10  11 12</span><br><span class="line">0 2 4 6 8 9 a c d f    20  22 24</span><br></pre></td></tr></table></figure><h2 id="3-进制的计算"><a href="#3-进制的计算" class="headerlink" title="3. 进制的计算"></a>3. 进制的计算</h2><ul><li>八进制为例子</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 八进制计算下面结果</span></span><br><span class="line"></span><br><span class="line">2 + 3 = 5</span><br><span class="line">2 * 3 = 6</span><br><span class="line">4 + 5 = 11</span><br><span class="line">4 * 5 = 24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算的本质就是查数</span></span><br><span class="line">0 1 2 3 4 5 6 7 </span><br><span class="line">10 11 12 13 14 15 16 17</span><br><span class="line">20 21 22 23 24 25 26 27</span><br><span class="line"></span><br><span class="line">八进制计算  (进位和计算)</span><br><span class="line">277 + 333 = </span><br><span class="line">276 * 54 = </span><br><span class="line">237 - 54 = </span><br><span class="line">234 / 4 =</span><br></pre></td></tr></table></figure><p>各种进制的乘法表：<a href="https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html</a></p><ul><li>下面以八进制为例子</li></ul><p><strong>八进制乘法表</strong></p><table><thead><tr><th>1*1 = 1</th><th>1*2 = 2</th><th>1*3 = 3</th><th>1*4 =4</th><th>1*5 =5</th><th>1*6 = 6</th><th>1*7 = 7</th></tr></thead><tbody><tr><td>2*2 = 2</td><td>2*3 = 6</td><td>2*4 = 10</td><td>2*5 = 12</td><td>2*6 = 14</td><td>2*7 = 16</td><td></td></tr><tr><td>3*3 = 11</td><td>3*4 = 14</td><td>3*5 = 17</td><td>3* 6 = 22</td><td>3*7 = 25</td><td></td><td></td></tr><tr><td>4*4 = 20</td><td>4 * 5= 24</td><td>4*6 = 30</td><td>4*7 = 34</td><td></td><td></td><td></td></tr><tr><td>5*5 = 31</td><td>5*6 = 36</td><td>5*7 = 43</td><td></td><td></td><td></td><td></td></tr><tr><td>6*6 = 44</td><td>6*7 = 52</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7*7 = 61</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>八进制加法表</strong></p><table><thead><tr><th>1 + 1= 2</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1 + 2 = 3</td><td>2+ 2 = 4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1 + 3 = 4</td><td>2+ 3 = 5</td><td>3+ 3 = 6</td><td></td><td></td><td></td><td></td></tr><tr><td>1 + 4 = 5</td><td>2 + 4 = 6</td><td>3+4 = 7</td><td>4+ 4 = 10</td><td></td><td></td><td></td></tr><tr><td>1 + 5 = 6</td><td>2 + 5  = 7</td><td>3+ 5 = 104+</td><td>4+ 5 = 10</td><td>5 + 5 =12</td><td></td><td></td></tr><tr><td>1 + 6 = 7</td><td>2 + 6 = 10</td><td>3+ 6 =11</td><td>4+ 6 = 12</td><td>5+ 6 =13</td><td>6 + 6 =14</td><td></td></tr><tr><td>1 + 7 = 10</td><td>2 + 7 = 11</td><td>3+ 7 =12</td><td>4 + 7 = 13</td><td>5 + 7 =14</td><td>6+ 7 = 15</td><td>7 + 7 =16</td></tr></tbody></table><p><strong>结论：无论是什么进制，本身都有一套完美的体系</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-02-进制&quot;&gt;&lt;a href=&quot;#汇编-02-进制&quot; class=&quot;headerlink&quot; title=&quot;汇编-02-进制&quot;&gt;&lt;/a&gt;汇编-02-进制&lt;/h1&gt;&lt;p&gt;[参考博客链接:进制转换][&lt;a href=&quot;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-139-单词拆分</title>
    <link href="http://zhuuu.work/2020/06/28/Leetcode/Leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://zhuuu.work/2020/06/28/Leetcode/Leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2020-06-28T09:44:53.000Z</published>
    <updated>2020-06-30T06:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-139-单词拆分"><a href="#Leecode-139-单词拆分" class="headerlink" title="Leecode-139-单词拆分"></a>Leecode-139-<a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-139-单词拆分&quot;&gt;&lt;a href=&quot;#Leecode-139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;Leecode-139-单词拆分&quot;&gt;&lt;/a&gt;Leecode-139-&lt;a href=&quot;https://leetcode-cn.com/problems/word-break/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词拆分&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-316-去除重复的字母</title>
    <link href="http://zhuuu.work/2020/06/28/Leetcode/Leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E6%AF%8D/"/>
    <id>http://zhuuu.work/2020/06/28/Leetcode/Leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E6%AF%8D/</id>
    <published>2020-06-28T07:44:53.000Z</published>
    <updated>2020-06-29T09:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-316-去除重复字母"><a href="#Leetcode-316-去除重复字母" class="headerlink" title="Leetcode-316-去除重复字母"></a>Leetcode-316-<a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">去除重复字母</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个<strong>仅包含小写字母</strong>的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。</li><li><strong>保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;bcabc&quot;</span><br><span class="line">输出: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;cbacdcbc&quot;</span><br><span class="line">输出: &quot;acdb&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：栈-哨兵"><a href="#方法：栈-哨兵" class="headerlink" title="方法：栈+哨兵"></a>方法：栈+哨兵</h2><p>思路分析：</p><ul><li><strong>首先解释一下什么是字典序。</strong><ul><li>字典序是指从前到后比较两个字符串的大小</li><li>首先比较第一个字符，如果不同则第一个字符较小的字符串更小</li><li>如果相同则继续比较第二个字符…. 如果比到最后都一样的话，那么两个字符串相等</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">观察示例 1：bcabc。</span><br><span class="line"></span><br><span class="line">字符 a 在字符串中只出现一次，根据题目要求，字符 a 必须被选取；</span><br><span class="line">字符 b 出现了两次，显然选择 a后面的那个，因为字典序 ab 在 ba 前面。同理，有两个相同的字符 c ，我们选择后一个。因此，输出就是 abc。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">再观察示例 2：cbacdcbc。</span><br><span class="line"></span><br><span class="line">有 4 个字符：</span><br><span class="line">a、b、c、d。其中 a 和 d 只出现一次，必须被选取；</span><br><span class="line">b 出现 2 次，一个在 a 前面，一个在 a 后面，显然保留在 a 后面的；</span><br><span class="line">c 出现 4 次，我们把几种可能都列出来观察一下：</span><br><span class="line">情况 1：cadb</span><br><span class="line">情况 2：acdb（字典序最小）</span><br><span class="line">情况 3：adcb</span><br><span class="line">情况 4：adbc</span><br></pre></td></tr></table></figure><ul><li>下面我们就要思考，当遍历到字符串<strong>ASCII 值减少的时候</strong>，应该如何处理。（一种最理想的情况是：<code>abcd</code>，在遍历的时候，遇到的字符串的 <strong>ASCII 值逐渐增大</strong>。）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">还看示例 1：</span><br><span class="line">已经读到了 bc，已经是字典序最小的排列。</span><br><span class="line">即将读到的 a 比 c 的 ASCII 值小。如果 a 能排在 c 之前，就能得到一个比 ca 更小的字典序 ac。</span><br><span class="line">那么 a 能不能排在 c 之前，就看 a 的后面还会不会出现字符 c，显然会。同理，由于字符 b 在将来还会出现，构成的字典序更小，因此舍弃之前的字符 b。</span><br><span class="line">到此为止，应该想到我们需要借助栈帮助我们完成这题。</span><br></pre></td></tr></table></figure><ul><li>然后根据这个思路，我们再看一下示例 2：<code>cbacdcbc</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200629/143955298.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第 1 步：读到 c，入栈，此时栈中元素 [c]；</span><br><span class="line"></span><br><span class="line">第 2 步：读到 b，b 比之前 a 小，c 在以后还会出现，因此 c 出栈，b 入栈，此时栈中元素 [b]；</span><br><span class="line"></span><br><span class="line">第 3 步：读到 a，a 比之前 b 小，b 在以后还会出现，因此 b 出栈，a 入栈，此时栈中元素 [a]；</span><br><span class="line"></span><br><span class="line">第 4 步：读到 c，c 比之前 a 大，直接让 c 入栈，此时栈中元素 [a, c]；</span><br><span class="line"></span><br><span class="line">第 5 步：读到 d，d 比之前 d 大，直接让 d 入栈，此时栈中元素 [a, c, d]；</span><br><span class="line"></span><br><span class="line">第 6 步：读到 c，这里要注意：此时栈中已经有 c 了，此时栈中元素构成的字符顺序就是最小的字典序，不可能舍弃之前的 c，而用现在的读到的 c，因此这个 c 不需要，直接跳过；</span><br><span class="line"></span><br><span class="line">第 7 步：读到 b，b 比之前的 d 小，但是，后面不会再出现 d 了，因此 b 就应该放在这个位置，因此让 b 入栈，此时栈中元素 [a, c, d, b]；</span><br><span class="line"></span><br><span class="line">第 8 步：读到 c，同第 6 步，这个 c 我们不需要。</span><br></pre></td></tr></table></figure><ul><li><p>于是：我们可以设计如下算法：</p><ul><li>遍历字符串里的字符，<strong>如果读到的字符的 ASCII 值是升序</strong>，依次存到一个栈中；</li><li>如果读到的栈中已经存在，那么这个字符我们不需要。</li><li>如果<strong>读到的ASCII 值比栈顶元素严格小，看看栈顶后面的是否还会再出现</strong>，如果还会出现，则舍弃栈顶元素，而选择后面出现的那个元素，这样得到的字典序更小。</li></ul></li><li><p>因为需要判断读到的字符在栈中是否已经存在，因此可以使用哈希表，又因为题目说，字符只会出现小写字母，<strong>用一个布尔数组也是可以的，注意在出栈入栈的时候，需要同步更新一下这个布尔数组。</strong></p></li><li><p>又因为要<strong>判断栈顶元素在后面是否会被遍历到，因此我们需要首先遍历一次字符，存一下这个字符最后出现的位置，就能判断栈顶元素在后面是否会被遍历到</strong></p></li></ul><p><strong>未使用哨兵的版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助栈来帮助我们完成这道题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 不会有重复的情况</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于记录字符串中已经出现的字符</span></span><br><span class="line">        <span class="keyword">boolean</span>[] set = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个字符出现的最后一个位置</span></span><br><span class="line">        <span class="keyword">int</span>[] lastIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            lastIndex[s.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈：判断栈顶元素和入栈元素的ASCII大小</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curr = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (set[curr - <span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lastIndex[stack.peek() -'a'] &gt;= i 说明后面还会出现</span></span><br><span class="line">            <span class="comment">// stack.peek() &gt; curr说明当前入栈元素比栈顶小</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; curr &amp;&amp; lastIndex[stack.peek() -<span class="string">'a'</span>] &gt;= i)&#123;</span><br><span class="line">                <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">                set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入栈并记录</span></span><br><span class="line">            stack.push(curr);</span><br><span class="line">            set[curr - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈顶元素依次出栈并返回字符串形式</span></span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            buffer.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用哨兵原因</strong>：里面判断语句太长，每一次都要判断栈是否为空。这里使用一个哨兵的技巧，一开始就在栈里面放一个最小字符’a’ 。因为后面判断语句<code>stack.peek() &gt; currentChar</code> 这里是严格符号，因此这个 <code>a</code> 一定不会被弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; currentChar &amp;&amp; lastAppearIndex[stack.peek() - <span class="string">'a'</span>] &gt;= i) &#123;</span><br><span class="line">    <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">    set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用哨兵：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哨兵+栈</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个字符出现的最后一个位置</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] lastIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            lastIndex[charArray[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录字符是否已经出现在字符串中</span></span><br><span class="line">        <span class="keyword">boolean</span>[] set = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时 `a` 作为哨兵，这个 `a` 永远不会被弹出</span></span><br><span class="line">        <span class="comment">// 如此一来，在遍历的时候，就不用判断栈是否为空了</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.addLast(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符已经出现过了，跳出循环</span></span><br><span class="line">            <span class="keyword">char</span> currentChar = charArray[i];</span><br><span class="line">            <span class="keyword">if</span> (set[currentChar - <span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (stack.peekLast() &gt; currentChar &amp;&amp; lastIndex[stack.peekLast() - <span class="string">'a'</span>] &gt;= i)&#123;</span><br><span class="line">                <span class="comment">// 弹出并且将该字符改为未出现过</span></span><br><span class="line">                <span class="keyword">char</span> top = stack.removeLast();</span><br><span class="line">                set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说明ASCII是升序的，直接加入</span></span><br><span class="line">            stack.addLast(currentChar);</span><br><span class="line">            set[currentChar - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转为字符串返回结果</span></span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            buffer.insert(<span class="number">0</span>,stack.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-316-去除重复字母&quot;&gt;&lt;a href=&quot;#Leetcode-316-去除重复字母&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-316-去除重复字母&quot;&gt;&lt;/a&gt;Leetcode-316-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;去除重复字母&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个&lt;strong&gt;仅包含小写字母&lt;/strong&gt;的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;bcabc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;cbacdcbc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;acdb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>汇编-01-概述</title>
    <link href="http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-06-28T07:40:41.000Z</published>
    <updated>2020-06-28T14:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-01-概述"><a href="#汇编-01-概述" class="headerlink" title="汇编-01-概述"></a>汇编-01-概述</h1><ul><li><p>CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p></li><li><p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。</p></li><li><p><strong>编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</strong></p></li><li><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。</p></li><li><p>为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p></li></ul><p>一张程序猿的鄙视链：（哈哈哈 看看就好！！）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/220922706.png" alt="mark"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-01-概述&quot;&gt;&lt;a href=&quot;#汇编-01-概述&quot; class=&quot;headerlink&quot; title=&quot;汇编-01-概述&quot;&gt;&lt;/a&gt;汇编-01-概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一张程序猿的鄙视链：（哈哈哈 看看就好！！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/220922706.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-13-Scanner</title>
    <link href="http://zhuuu.work/2020/06/28/jdk_SourceCode/JDK1.8-13-Scanner/"/>
    <id>http://zhuuu.work/2020/06/28/jdk_SourceCode/JDK1.8-13-Scanner/</id>
    <published>2020-06-28T05:33:53.000Z</published>
    <updated>2020-06-28T13:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8使用-13-Scanner"><a href="#JDK1-8使用-13-Scanner" class="headerlink" title="JDK1.8使用-13-Scanner"></a>JDK1.8使用-13-Scanner</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>在笔试编程过程中，关于数据的读取如果迷迷糊糊，那后来的编程即使想法很对，实现很好，也是徒劳，于是在这里认真总结了Java Scanner 类的使用</p><a id="more"></a><h2 id="常用方法：next-和nextline"><a href="#常用方法：next-和nextline" class="headerlink" title="常用方法：next()和nextline()"></a>常用方法：next()和nextline()</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/201806538.png" alt="mark"></p><ul><li>上图的方法：只读取对应数据类型的数据，如果输入了非对应数据类型的数据就是报错。</li><li>比如：<code>nextlnt():只读取int值</code>，就是只能读取整数类型的数据，如果输入了非整型的数据（浮点型字符串等）就会报错。<br><code>nextFloat（）、nextDouble（）</code>这些也是以此类推，只能读取符合该类型的数据。</li><li><strong>next() :  只读取输入直到空格，它不能读取两个由空格或者符号隔开的单词。此外next() 在读取输入后将光标放入到同一行中</strong></li><li><strong>nextLine():读取输入，包括单词之间的空格和除回车意外的所有符号（即它会读到行尾）。读取输入后，nextLine()会将光标定位在下一行。</strong></li></ul><p><strong>废话不多说：show me the code</strong></p><ul><li><strong>源码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextInt(defaultRadix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scans the next token of the input as an &lt;tt&gt;int&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * if the next token cannot be translated into a valid int value as</span></span><br><span class="line"><span class="comment"> * described below. If the translation is successful, the scanner advances</span></span><br><span class="line"><span class="comment"> * past the input that matched.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If the next token matches the &lt;a</span></span><br><span class="line"><span class="comment"> * href="#Integer-regex"&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined</span></span><br><span class="line"><span class="comment"> * above then the token is converted into an &lt;tt&gt;int&lt;/tt&gt; value as if by</span></span><br><span class="line"><span class="comment"> * removing all locale specific prefixes, group separators, and locale</span></span><br><span class="line"><span class="comment"> * specific suffixes, then mapping non-ASCII digits into ASCII</span></span><br><span class="line"><span class="comment"> * digits via &#123;<span class="doctag">@link</span> Character#digit Character.digit&#125;, prepending a</span></span><br><span class="line"><span class="comment"> * negative sign (-) if the locale specific negative prefixes and suffixes</span></span><br><span class="line"><span class="comment"> * were present, and passing the resulting string to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#parseInt(String, int) Integer.parseInt&#125; with the</span></span><br><span class="line"><span class="comment"> * specified radix.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> radix the radix used to interpret the token as an int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the &lt;tt&gt;int&lt;/tt&gt; scanned from the input</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InputMismatchException</span></span><br><span class="line"><span class="comment"> *         if the next token does not match the &lt;i&gt;Integer&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *         regular expression, or is out of range</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if input is exhausted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this scanner is closed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check cached result</span></span><br><span class="line">    <span class="keyword">if</span> ((typeCache != <span class="keyword">null</span>) &amp;&amp; (typeCache <span class="keyword">instanceof</span> Integer)</span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.radix == radix) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = ((Integer)typeCache).intValue();</span><br><span class="line">        useTypeCache();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    setRadix(radix);</span><br><span class="line">    clearCaches();</span><br><span class="line">    <span class="comment">// Search for next int</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = next(integerPattern());</span><br><span class="line">        <span class="keyword">if</span> (matcher.group(SIMPLE_GROUP_INDEX) == <span class="keyword">null</span>)</span><br><span class="line">            s = processIntegerToken(s);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(s, radix);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">        position = matcher.start(); <span class="comment">// don't skip bad token</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException(nfe.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入一个字符串(中间能加空格或符号)"</span>);</span><br><span class="line">    String a = input.nextLine();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个字符串(中间不能加空格或符号)"</span>);</span><br><span class="line">    String b = input.next();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个整数"</span>);</span><br><span class="line">    <span class="keyword">int</span> c = input.nextInt(); <span class="comment">// 只能读取Int</span></span><br><span class="line">    System.out.println(<span class="string">"请输入一个double类型的小数"</span>);</span><br><span class="line">    <span class="keyword">double</span> d= input.nextFloat();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个float类型的小数"</span>);</span><br><span class="line">    <span class="keyword">float</span>  f = input.nextFloat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"按顺序输出abcdf的值："</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>运行输入：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">请输入一个字符串(中间能加空格或符号)</span><br><span class="line">我爱祖国！</span><br><span class="line">请输入一个字符串(中间不能加空格或符号)</span><br><span class="line">ILoveChina</span><br><span class="line">请输入一个整数</span><br><span class="line"><span class="number">520</span></span><br><span class="line">请输入一个<span class="keyword">double</span>类型的小数</span><br><span class="line"><span class="number">12.26e3</span></span><br><span class="line">请输入一个<span class="keyword">float</span>类型的小数</span><br><span class="line"><span class="number">3.1415926</span></span><br><span class="line">按顺序输出abcdf的值：</span><br><span class="line">我爱祖国！</span><br><span class="line">ILoveChina</span><br><span class="line"><span class="number">520</span></span><br><span class="line"><span class="number">12260.0</span></span><br><span class="line"><span class="number">3.1415925</span></span><br></pre></td></tr></table></figure><h2 id="常用用法：hasNext"><a href="#常用用法：hasNext" class="headerlink" title="常用用法：hasNext()"></a>常用用法：hasNext()</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/203935994.png" alt="mark"></p><ul><li><strong>源码：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasNextInt(defaultRadix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if the next token in this scanner's input can be</span></span><br><span class="line"><span class="comment"> * interpreted as an int value in the specified radix using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #nextInt&#125; method. The scanner does not advance past any input.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> radix the radix used to interpret the token as an int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if and only if this scanner's next token is a valid</span></span><br><span class="line"><span class="comment"> *         int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this scanner is closed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">(<span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    setRadix(radix);</span><br><span class="line">    <span class="keyword">boolean</span> result = hasNext(integerPattern());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123; <span class="comment">// Cache it</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String s = (matcher.group(SIMPLE_GROUP_INDEX) == <span class="keyword">null</span>) ?</span><br><span class="line">                processIntegerToken(hasNextResult) :</span><br><span class="line">                hasNextResult;</span><br><span class="line">            typeCache = Integer.parseInt(s, radix);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个boolean的值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试用例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过Scanner构造函数接收控制台输入的信息</span></span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入你的姓名"</span>);</span><br><span class="line">    <span class="comment">// 接收一个字符串，可以加出回车键意外所有的信息，包括空格和Tab</span></span><br><span class="line">    String name = scanner.nextLine();</span><br><span class="line">    System.out.println(<span class="string">"请输入你的ID"</span>);</span><br><span class="line">    String ID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环判断hasNextLine()方法是否有输入（返回true或false）</span></span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">        <span class="comment">// 如果输入的是整型类型，当为整型类型执行循环</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextInt())&#123;</span><br><span class="line">            ID = scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"你输入的姓名为："</span>+name);</span><br><span class="line">            System.out.println(<span class="string">"你输入的ID为："</span>+ID);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入数字哦！"</span>);</span><br><span class="line">            ID = scanner.nextLine();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">请输入你的姓名</span><br><span class="line">朱酱酱</span><br><span class="line">请输入你的ID</span><br><span class="line">qq353446503</span><br><span class="line">请输入数字哦！</span><br><span class="line"><span class="number">353446503</span></span><br><span class="line">你输入的姓名为：朱酱酱</span><br><span class="line">你输入的ID为：<span class="number">353446503</span></span><br></pre></td></tr></table></figure><h2 id="Demo-键盘输入求平均数"><a href="#Demo-键盘输入求平均数" class="headerlink" title="Demo:键盘输入求平均数"></a>Demo:键盘输入求平均数</h2><ul><li>注意：如果要输入int 或者 float … 之类的数据，在Scanner中输入之前最好先使用<code>hasNextXxx()</code> 方法进行验证，再使用<code>nextXxx()</code>进行读取接收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNextDouble())&#123;</span><br><span class="line">        <span class="comment">// 接收dobule的值</span></span><br><span class="line">        <span class="keyword">double</span> x = scanner.nextDouble();</span><br><span class="line">        m = m + <span class="number">1</span>;</span><br><span class="line">        sum = sum + x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(m + <span class="string">"个数的和为"</span> + sum);</span><br><span class="line">    System.out.println(m + <span class="string">"个数的平均值是"</span> + (sum / m));</span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试用例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入数字：</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="number">30.0</span></span><br><span class="line"><span class="number">40.0</span></span><br><span class="line">end</span><br><span class="line"><span class="number">3</span>个数的和为<span class="number">90.0</span></span><br><span class="line"><span class="number">3</span>个数的平均值是<span class="number">30.0</span>s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8使用-13-Scanner&quot;&gt;&lt;a href=&quot;#JDK1-8使用-13-Scanner&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8使用-13-Scanner&quot;&gt;&lt;/a&gt;JDK1.8使用-13-Scanner&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;在笔试编程过程中，关于数据的读取如果迷迷糊糊，那后来的编程即使想法很对，实现很好，也是徒劳，于是在这里认真总结了Java Scanner 类的使用&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="面试必备" scheme="http://zhuuu.work/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>排序-02-桶排序</title>
    <link href="http://zhuuu.work/2020/06/27/Sort/%E6%8E%92%E5%BA%8F-02-%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/06/27/Sort/%E6%8E%92%E5%BA%8F-02-%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-06-27T10:32:24.000Z</published>
    <updated>2020-08-12T12:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-02-桶排序"><a href="#排序-02-桶排序" class="headerlink" title="排序-02-桶排序"></a>排序-02-桶排序</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175321622.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175306350.png" alt="mark"></p><h2 id="1-桶排序思想"><a href="#1-桶排序思想" class="headerlink" title="1. 桶排序思想"></a>1. 桶排序思想</h2><ul><li><strong>一句话总结：划分多个范围相同的区间，每个子区间进行自排序，最后合并</strong></li><li>桶排序是计数排序的扩展版本<ul><li>计数排序可以看成每个桶只存储相同的元素</li><li>而桶排序每个桶存储的是一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/173153414.png" alt="mark"></p><a id="more"></a><h2 id="2-Java实现代码"><a href="#2-Java实现代码" class="headerlink" title="2. Java实现代码"></a>2. Java实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最大值与最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算桶的数量</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个元素放入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">            bucketArr.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将桶中的元素赋值到原序列</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)&#123;</span><br><span class="line">                arr[index++] = bucketArr.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BucketSort.bucketSort(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">18</span>,<span class="number">11</span>,<span class="number">28</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">50</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li><strong>时间复杂度：O(N+K)</strong><ul><li>N 次循环，将每个元素装入对应的桶中</li><li>M 次循环，对每个桶中的数据进行排序（平均每个桶有 N/M 个元素）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175714244.png" alt="mark"></p><ul><li><strong>空间复杂度： O( N + M )</strong></li></ul><ul><li><strong>稳定性分析</strong><ul><li><strong>桶排序的稳定性取决于桶内排序使用的算法</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-02-桶排序&quot;&gt;&lt;a href=&quot;#排序-02-桶排序&quot; class=&quot;headerlink&quot; title=&quot;排序-02-桶排序&quot;&gt;&lt;/a&gt;排序-02-桶排序&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175321622.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175306350.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-桶排序思想&quot;&gt;&lt;a href=&quot;#1-桶排序思想&quot; class=&quot;headerlink&quot; title=&quot;1. 桶排序思想&quot;&gt;&lt;/a&gt;1. 桶排序思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一句话总结：划分多个范围相同的区间，每个子区间进行自排序，最后合并&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;桶排序是计数排序的扩展版本&lt;ul&gt;
&lt;li&gt;计数排序可以看成每个桶只存储相同的元素&lt;/li&gt;
&lt;li&gt;而桶排序每个桶存储的是一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/173153414.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-02-二叉查找树</title>
    <link href="http://zhuuu.work/2020/06/26/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/06/26/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2020-06-26T10:32:24.000Z</published>
    <updated>2020-06-28T08:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-02-二叉查找树"><a href="#数据结构-02-二叉查找树" class="headerlink" title="数据结构-02-二叉查找树"></a>数据结构-02-二叉查找树</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p>数据结构在线生成工具 ： <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><a id="more"></a><h2 id="1-二叉查找树简介"><a href="#1-二叉查找树简介" class="headerlink" title="1. 二叉查找树简介"></a>1. 二叉查找树简介</h2><ul><li><p><strong>二叉查找树(Binary Search Tree)，又被称为二叉搜索树。</strong></p></li><li><p>它是<strong>特殊的二叉树</strong></p><ul><li>对于二叉树，假设x为二叉树中的任意一个节点，x节点中包含关键字key,节点x的key值记位key[x] 。</li><li>如果 y 是 x 的左子树中的一个节点，则key[y] &lt;= key[x] ; </li><li>如果 y 是  x的右子树中的一个节点，则key[y] &gt;= key[x];</li></ul></li></ul><p>那么，这棵树就是二叉查找树。如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/151835002.png" alt="mark"></p><p><strong>性质：在二叉查找树中</strong></p><ul><li><strong>如果任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值</strong></li><li><strong>任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值</strong></li><li><strong>任意节点的左，右子树也分别为二叉查找树。（递归的思想）</strong></li><li>没有键值相等的节点（no duplicate nodes）。</li></ul><h2 id="2-二叉查找树的Java实现"><a href="#2-二叉查找树的Java实现" class="headerlink" title="2. 二叉查找树的Java实现"></a>2. 二叉查找树的Java实现</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T extends Comparable&lt;T&gt; 说明泛型T必须实现了Comparable接口</span></span><br><span class="line"><span class="comment">// &lt;T extends Comparable&lt;? super T&gt;&gt;　说明泛型T或者其父类必须实现了Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BSTNode&lt;T&gt; mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        BSTNode&lt;T&gt; left;      <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; right;     <span class="comment">// 右孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; parent;    <span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BSTNode</span><span class="params">(T key, BSTNode&lt;T&gt; parent, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>BSTree是二叉树，它保护了二叉树的根节点mRoot;</li><li>mRoot是BSTNode类型，而BSTNode是而二叉查找树的节点，它是BSTree的内部类。</li><li>BSTNode 包含了以下几个基本信息：<ul><li>(01) key – 它是关键字，是用来对二叉查找树的节点进行排序的。<br>(02) left – 它指向当前节点的左孩子。<br>(03) right – 它指向当前节点的右孩子。<br>(04) parent – 它指向当前节点的父结点。</li></ul></li></ul><h3 id="2-2-遍历"><a href="#2-2-遍历" class="headerlink" title="2.2 遍历"></a>2.2 遍历</h3><ul><li>这里讲解前序遍历、中序遍历、后序遍历3种方式。</li></ul><p><strong>前序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 访问根结点；<br>(02) 先序遍历左子树；<br>(03) 先序遍历右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">        preOrder(tree.left);</span><br><span class="line">        preOrder(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 中序遍历左子树；<br>(02) 访问根结点；<br>(03) 中序遍历右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrder(tree.left);</span><br><span class="line">        System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">        inOrder(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 后序遍历左子树；<br>(02) 后序遍历右子树；<br>(03) 访问根结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder(tree.left);</span><br><span class="line">        postOrder(tree.right);</span><br><span class="line">        System.out.print(tree.key+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看下面这颗树的各种遍历方式：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/155914685.png" alt="mark"></p><p>对于上面的二叉树而言，<br>(01) 前序遍历结果： 3 1 2 5 4 6<br>(02) 中序遍历结果： 1 2 3 4 5 6<br>(03) 后序遍历结果： 2 1 4 6 5 3</p><h3 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h3><ul><li>递归版本的查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> search(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> search(x.right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> search(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非递归实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            x = x.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            x = x.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iterativeSearch(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-02-二叉查找树&quot;&gt;&lt;a href=&quot;#数据结构-02-二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;数据结构-02-二叉查找树&quot;&gt;&lt;/a&gt;数据结构-02-二叉查找树&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据结构在线生成工具 ： &lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://zhuuu.work/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-HTTPS详解</title>
    <link href="http://zhuuu.work/2020/06/26/NetworkCoding/HTTP-HTTPS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/06/26/NetworkCoding/HTTP-HTTPS%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-06-26T03:32:24.000Z</published>
    <updated>2020-08-25T01:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-HTTPS详解"><a href="#HTTP-HTTPS详解" class="headerlink" title="HTTP-HTTPS详解"></a>HTTP-HTTPS详解</h1><h2 id="一：-基础概念"><a href="#一：-基础概念" class="headerlink" title="一： 基础概念"></a>一： 基础概念</h2><h3 id="1-1-URI"><a href="#1-1-URI" class="headerlink" title="1.1 URI"></a>1.1 URI</h3><ul><li>URI 包含 URL 和 URN。</li><li>我们通常所说的<strong>URL（统一资源定位符）是URI的子集</strong></li><li>URI还有一个自己URN , URN只命名资源但是不指定如何定位资源.</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120156077.png" alt="mark"></p><a id="more"></a><h3 id="1-2-请求报文"><a href="#1-2-请求报文" class="headerlink" title="1.2 请求报文"></a>1.2 请求报文</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120719185.png" alt="mark"></p><h3 id="1-3-响应报文"><a href="#1-3-响应报文" class="headerlink" title="1.3 响应报文"></a>1.3 响应报文</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120739566.png" alt="mark"></p><h2 id="二-HTTP-请求方法"><a href="#二-HTTP-请求方法" class="headerlink" title="二: HTTP 请求方法"></a>二: HTTP 请求方法</h2><p>客户端发送的   <strong>请求报文</strong>   第一行为请求行，包含了方法字段。</p><p><strong>举例:</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120845030.png" alt="mark"></p><h3 id="1-1-GET"><a href="#1-1-GET" class="headerlink" title="1.1 GET"></a>1.1 GET</h3><ul><li><strong>获取资源的请求</strong>(绝大部分的请求都是GET方法)</li></ul><h3 id="1-2-HEAD"><a href="#1-2-HEAD" class="headerlink" title="1.2 HEAD"></a>1.2 HEAD</h3><ul><li><strong>获取报文的首部,但是不返回报文实体主体部分</strong></li><li>主要用于确认URL的有效性以及资源更新的日期时间等.</li></ul><h3 id="1-3-POST"><a href="#1-3-POST" class="headerlink" title="1.3 POST"></a>1.3 POST</h3><ul><li><strong>传输实体主体</strong></li><li>POST用于传输表单数据,具体和GET的区别会在下文进行阐述</li></ul><h3 id="1-4-PUT"><a href="#1-4-PUT" class="headerlink" title="1.4 PUT"></a>1.4 PUT</h3><ul><li><strong>上传文件</strong></li><li>由于自身不带验证机制,任何人都可以上传文件,因此存在安全性问题,一般不使用这个方法.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-PATCH"><a href="#1-5-PATCH" class="headerlink" title="1.5 PATCH"></a>1.5 PATCH</h3><ul><li><strong>类似与PUT,但是PATCH用于资源的部分修改</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: "e0023aa4e"</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure><h3 id="1-6-DELTETE"><a href="#1-6-DELTETE" class="headerlink" title="1.6 DELTETE"></a>1.6 DELTETE</h3><ul><li><p>删除文件</p></li><li><p>与PUT功能相反,并且同样不携带验证机制.</p></li></ul><h3 id="1-7-OPTIONS"><a href="#1-7-OPTIONS" class="headerlink" title="1.7 OPTIONS"></a>1.7 OPTIONS</h3><ul><li>支持查询的方法</li><li>作用:查询指定的URL能够支持的方法(会返回 <code>Allow GET POST HEAD OPTIONS</code>) 这样的内容</li></ul><h3 id="1-8-Connect"><a href="#1-8-Connect" class="headerlink" title="1.8 Connect"></a>1.8 Connect</h3><ul><li>要求在与代理服务器通信时建立隧道</li><li>使用SSL(Secure Sockets Layer，安全套接层) 和 TLS (Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/122102520.png" alt="mark"></p><h3 id="1-9-TRACE"><a href="#1-9-TRACE" class="headerlink" title="1.9 TRACE"></a>1.9 TRACE</h3><ul><li>追踪路径</li><li>服务器会将通信路径返回给客户端(在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。)</li><li>通常不会使用TRACE,并且它容易受到XST攻击(Cross-Site Tracing ,跨站追踪)</li></ul><h2 id="三-HTTP-状态码"><a href="#三-HTTP-状态码" class="headerlink" title="三:  HTTP 状态码"></a>三:  HTTP 状态码</h2><ul><li>服务器返回的   <strong>响应报文</strong>   中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</li></ul><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息状态码)</td><td>接收的请求正现在处理</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求发生错误</td></tr></tbody></table><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/122512956.png" alt="mark"></p><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue</strong> : 表示到目前为止数据都很正常,客户端可以继续发送请求或者忽略这个响应.</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200  OK</strong></li><li><strong>204  No Content</strong>: 请求已经成功处理,但是返回的响应报文不包含实体的主体部分.一般在只需要从客户端向服务器发送信息,而不需要返回数据的时候使用.</li><li><strong>206  Partial Content</strong>: 表示客户端进行的范围请求,响应报文包含由Content-Range 指定范围的实体内容.</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><p><strong>301 Moved Permanently</strong> : 永久性重定向</p></li><li><p><strong>302 Found</strong>: 临时性重定向</p></li><li><p><strong>303 See Other</strong> : 和302 有着相同的功能,但是303明确要求客户端应该采用GET方法请求资源</p><ul><li>注：虽然 <strong>HTTP 协议规定</strong> 301、302 状态下<strong>重定向时不允许把 POST 方法改成 GET 方法</strong>，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li></ul></li><li><p><strong>304 Not Modified</strong> : 如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since,如果不满足以上条件,则服务器会返回304状态码.</p></li><li><p><strong>307 Temporary Redirect :</strong>  临时重定向,与302的含义类似,但是307要求浏览器不会把重定向请求的POST方法修改成GET 方法.</p></li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><strong>400  Bad Request :</strong>: 请求报文中存在语法错误</li><li><strong>401  Unauthorizd</strong> : 该状态码表示发送的请求去需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden :</strong> 请求被拒绝</li><li><strong>404  Not found</strong></li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong>  ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong>: 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h2 id="四-：-HTTP-首部"><a href="#四-：-HTTP-首部" class="headerlink" title="四 ： HTTP 首部"></a>四 ： HTTP 首部</h2><ul><li>有四种类型的首部字段<ul><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ul></li></ul><h3 id="4-1-通用首部字段"><a href="#4-1-通用首部字段" class="headerlink" title="4.1 通用首部字段"></a>4.1 通用首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="center">Date</td><td align="center">创建报文的日期时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Trailer</td><td align="center">报文末端的首部一览</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">升级为其他协议</td></tr><tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr><tr><td align="center">Warning</td><td align="center">错误通知</td></tr></tbody></table><h3 id="4-2-请求首部字段"><a href="#4-2-请求首部字段" class="headerlink" title="4.2 请求首部字段"></a>4.2 请求首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr><tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr><tr><td align="center">Authorization</td><td align="center">Web 认证信息</td></tr><tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr><tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">请求资源所在服务器</td></tr><tr><td align="center">If-Match</td><td align="center">比较实体标记（ETag）</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr><tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与 If-Match 相反）</td></tr><tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td align="center">If-Unmodified-Since</td><td align="center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr><tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr><tr><td align="center">Referer</td><td align="center">对请求中 URI 的原始获取方</td></tr><tr><td align="center">TE</td><td align="center">传输编码的优先级</td></tr><tr><td align="center">User-Agent</td><td align="center">HTTP 客户端程序的信息</td></tr></tbody></table><h3 id="4-3-响应首部字段"><a href="#4-3-响应首部字段" class="headerlink" title="4.3 响应首部字段"></a>4.3 响应首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr><tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr><tr><td align="center">ETag</td><td align="center">资源的匹配信息</td></tr><tr><td align="center">Location</td><td align="center">令客户端重定向至指定 URI</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr><tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr><tr><td align="center">Server</td><td align="center">HTTP 服务器的安装信息</td></tr><tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr></tbody></table><h3 id="4-4-实体首部字段"><a href="#4-4-实体首部字段" class="headerlink" title="4.4 实体首部字段"></a>4.4 实体首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源可支持的 HTTP 方法</td></tr><tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr><tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr><tr><td align="center">Content-Length</td><td align="center">实体主体的大小</td></tr><tr><td align="center">Content-Location</td><td align="center">替代对应资源的 URI</td></tr><tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr><tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr><tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">资源的最后修改日期时间</td></tr></tbody></table><h2 id="五：具体应用"><a href="#五：具体应用" class="headerlink" title="五：具体应用"></a>五：具体应用</h2><h3 id="5-1-连接管理"><a href="#5-1-连接管理" class="headerlink" title="5.1 连接管理"></a>5.1 连接管理</h3><h4 id="5-1-1-短链接和长连接"><a href="#5-1-1-短链接和长连接" class="headerlink" title="5.1.1 短链接和长连接"></a>5.1.1 <strong>短链接和长连接</strong></h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" width="800"/> </div><br><ul><li>当浏览器访问一个包含多张图片的html 的时候，除了请求访问的HTML资源，还会请求图片的资源。如果每进行一次HTTP通信就要新建一个TCP连接，那么开销会很大。<ul><li><strong>长连接只需要建立一次TCP链接就能就行多次HTTP通信。</strong><ul><li>从 HTTP/1.1 <strong>开始默认是长连接</strong>的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 <strong>之前默认是短连接</strong>的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul></li></ul></li></ul><h4 id="5-1-2-流水线"><a href="#5-1-2-流水线" class="headerlink" title="5.1.2 流水线"></a>5.1.2 流水线</h4><ul><li><p><strong>默认情况下，HTTP请求时按顺序发出的，下一个请求只有在当前请求收到响应后才会被发出</strong>。</p></li><li><p>由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p></li><li><p><strong>流水线时在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</strong></p></li></ul><h3 id="5-2-Cookie"><a href="#5-2-Cookie" class="headerlink" title="5.2 Cookie"></a>5.2 Cookie</h3><ul><li><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p></li><li><p><strong>Cookie 是服务器发送到用户浏览器并在本地保存的一小块数据，他会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。</strong></p></li><li><p>于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p></li><li><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，<strong>Cookie 渐渐被淘汰。</strong></p><ul><li><strong>新的浏览器API 已经允许开发者直接将数据存储到本地，如使用Web Storage API(本地存储和会话存储)或者 IndexedDB.</strong></li></ul></li></ul><ol><li><strong>Cookie的用途</strong></li></ol><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><ol start="2"><li><strong>创建过程</strong></li></ol><ul><li>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 <strong>Cookie 内容保存到浏览器中。</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><ul><li>客户端之后对同一个服务器发起请求的时候，会<strong>从浏览器中取出Cookie 信息并通过Cookie 请求首部字段发送给服务器。</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>分类</strong></li></ol><ul><li><strong>会话期 Cookie</strong>：<strong>浏览器关闭之后它会被自动删除</strong>，也就是说它仅在会话期内有效。</li><li><strong>持久性 Cookie</strong>：<strong>指定过期时间（Expires）或有效期（max-age）</strong>之后就成为了持久性的 Cookie。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>作用域</strong></li></ol><ul><li><p>Domain 标识指定了哪些主机可以接受 Cookie。</p><ul><li>如果不指定，默认为当前文档的主机（不包含子域名）。</li><li>如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</li></ul></li><li><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul></li></ul><ol start="5"><li><strong>javaScript</strong></li></ol><ul><li>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "yummy_cookie=choco";</span><br><span class="line">document.cookie = "tasty_cookie=strawberry";</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>HttpOnly</strong></li></ol><ul><li>标志为httpOnly 的 Cookie 不能被 javaScript 脚本调用，跨站脚本（XSS）常常使用JavaScript 的 <code>document.cookie</code> API来窃取用户的 Cookie 信息，因此 HTTPONLY 标志可以一定程序上避免XSS攻击。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>Secure</strong></li></ol><ul><li><strong>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。</strong></li><li>但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</li></ul><ol start="8"><li><strong>Session</strong></li></ol><ul><li><p>除了可以将用户信息通过 <strong>Cookie 存储在用户浏览器中</strong>，也可以利用 <strong>Session 存储在服务器端</strong>，存储在服务器端的信息更加安全。</p></li><li><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p></li></ul><p>使用Session维护用户登录状态过程如下：</p><ul><li>用户进行登录的时候，用户提交包含用户名和密码的表单，放入HTTP请求报文中。</li><li><strong>服务器验证用户名和密码</strong>，如果正确就把用户信息存储到Redis中，他在Redis中的key 叫做Session ID;</li><li><strong>服务器返回响应报文的Set - Cookie 首部字段包含了 Session ID</strong> , 客<strong>户端收到响应报文之后将Cookie 值存入浏览器中。</strong></li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，<strong>服务器收到之后提取出 Session ID</strong>，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><ol start="9"><li><strong>禁用Cookie</strong></li></ol><ul><li>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</li></ul><ol start="10"><li><strong>Cookie 和 Session 的选择</strong></li></ol><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 可以存储任何类型的数据，因此考虑数据复杂性首选Session.</li><li>Cookie 存在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果所有用户信息都存储在Session中，那么开销是十分大的，因此不建议将所有信息都存储在Session中。</li></ul><h3 id="5-3-缓存"><a href="#5-3-缓存" class="headerlink" title="5.3 缓存"></a>5.3 缓存</h3><p><strong>优点：</strong></p><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h4 id="5-3-1-实现方式"><a href="#5-3-1-实现方式" class="headerlink" title="5.3.1 实现方式"></a>5.3.1 实现方式</h4><ul><li>让代理服务器进行缓存</li><li>让客户端进行缓存</li></ul><h4 id="5-3-2-Cache-Control"><a href="#5-3-2-Cache-Control" class="headerlink" title="5.3.2 Cache-Control"></a>5.3.2 Cache-Control</h4><ul><li>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</li></ul><p>禁止使用缓存</p><ul><li>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p>强制确认缓存</p><ul><li>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>私有缓存和公共缓存</p><ul><li>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure><ul><li>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure><h4 id="5-3-3-缓存过期机制"><a href="#5-3-3-缓存过期机制" class="headerlink" title="5.3.3 缓存过期机制"></a>5.3.3 缓存过期机制</h4><ul><li><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><ul><li>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h4 id="5-3-4-缓存验证"><a href="#5-3-4-缓存验证" class="headerlink" title="5.3.4 缓存验证"></a>5.3.4 缓存验证</h4><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><h3 id="5-4-内容协商"><a href="#5-4-内容协商" class="headerlink" title="5.4 内容协商"></a>5.4 内容协商</h3><ul><li>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</li></ul><ol><li><strong>类型</strong></li></ol><p><strong>1.1 服务端驱动型</strong>  </p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><p><strong>1.2 代理驱动型</strong>  </p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p><ol start="2"><li><strong>Vary</strong></li></ol><ul><li>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</li><li>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</li></ul><h3 id="5-6-内容编码"><a href="#5-6-内容编码" class="headerlink" title="5.6 内容编码"></a>5.6 内容编码</h3><ul><li>内容编码将实体主体进行压缩，从而减少传输的数据量。</li><li>常用的内容编码有：gzip、compress、deflate、identity。</li><li>浏览器发送 <strong>Accept-Encoding 首部</strong>，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</li></ul><h3 id="5-7-范围请求"><a href="#5-7-范围请求" class="headerlink" title="5.7 范围请求"></a>5.7 范围请求</h3><ul><li>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</li></ul><ol><li><strong>Range</strong></li></ol><ul><li>在请求报文中添加 Range 首部字段指定请求的范围。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></table></figure><ul><li>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Accpet- Ranges</strong></li></ol><ul><li>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>响应状态码</strong></li></ol><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul><h3 id="5-8-分块传输编码"><a href="#5-8-分块传输编码" class="headerlink" title="5.8 分块传输编码"></a>5.8 分块传输编码</h3><ul><li>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</li></ul><h3 id="5-9-多部份对象集合"><a href="#5-9-多部份对象集合" class="headerlink" title="5.9 多部份对象集合"></a>5.9 多部份对象集合</h3><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="submit-name"</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="files"; filename="file1.txt"</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><h3 id="5-10-虚拟主机"><a href="#5-10-虚拟主机" class="headerlink" title="5.10 虚拟主机"></a>5.10 虚拟主机</h3><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h3 id="5-11-通信数据转发"><a href="#5-11-通信数据转发" class="headerlink" title="5.11 通信数据转发"></a>5.11 通信数据转发</h3><h4 id="5-11-1-代理"><a href="#5-11-1-代理" class="headerlink" title="5.11.1 代理"></a>5.11.1 代理</h4><ul><li><p>代理服务器接受客户端的请求，并转发给其他服务器(Nginx)</p></li><li><p>使用代理的主要目的是：</p><ul><li><strong>缓存</strong></li><li><strong>负载均衡</strong></li><li><strong>网络访问控制</strong></li><li><strong>访问日志记录</strong></li></ul></li><li><p>代理服务器分为<strong>正向代理</strong>和<strong>反向代理</strong>两种</p><ul><li>用户察觉得到正向代理的存在。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png" width=""/> </div><br>- 反向代理一般位于内部网络中，用户察觉不到<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png" width=""/> </div><br></li></ul><h4 id="5-11-2-网关"><a href="#5-11-2-网关" class="headerlink" title="5.11.2 网关"></a>5.11.2 网关</h4><ul><li>与代理服务器不同的是，<strong>网关服务器会将HTTP转换成其他协议进行通信，从而实现其他非HTTP请求</strong> （RPC）</li></ul><h4 id="5-11-3-隧道"><a href="#5-11-3-隧道" class="headerlink" title="5.11.3 隧道"></a>5.11.3 隧道</h4><ul><li>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</li></ul><h2 id="六-HTTPS"><a href="#六-HTTPS" class="headerlink" title="六. HTTPS"></a>六. HTTPS</h2><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的<strong>身份有可能遭遇伪装；</strong></li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p><strong>HTTPS 并不是新的协议，而是让HTTP 先和 SSL(Secure Sockets Layer )通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信。</strong></p><p><strong>通过SSL ,HTTPS具有了加密（防窃听），认证（防伪装）和 完整性保护（防篡改）</strong></p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg" width="700"/> </div><br><h3 id="6-1-加密"><a href="#6-1-加密" class="headerlink" title="6.1 加密"></a>6.1 加密</h3><h4 id="6-1-1-对称密钥加密"><a href="#6-1-1-对称密钥加密" class="headerlink" title="6.1.1 对称密钥加密"></a>6.1.1 对称密钥加密</h4><ul><li>对称密钥加密（Symmetric-Key Encryption），加密和解密使用的是同一个密钥。<ul><li>优点：运算速度快。</li><li>缺点：无法安全的将密钥传输给通信方。</li></ul></li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600"/> </div><br><h4 id="6-1-2-非对称加密"><a href="#6-1-2-非对称加密" class="headerlink" title="6.1.2 非对称加密"></a>6.1.2 非对称加密</h4><ul><li>非对称加密，又叫做公开密钥加密（Public-Key Encryption）,加密和解密使用不同的密钥</li></ul><ul><li>公开密钥所有人都可以获得，通信发送发获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥进行解密。</li><li>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方无法使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</li></ul><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600"/> </div><br><h3 id="6-2-HTTPS采用的加密方式"><a href="#6-2-HTTPS采用的加密方式" class="headerlink" title="6.2 HTTPS采用的加密方式"></a>6.2 HTTPS采用的加密方式</h3><ul><li>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方</li><li>而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key  传输给通信方。</li></ul><p>HTTPS采用了混合加密的方式，正式利用了上面提到的方案：：</p><ul><li>使用非对称加密的方式，传输对称密钥加密所需要的 Secret Key ，从而保证安全性</li><li>获取到Secret Key 之后，在使用对称密钥方法进行通信，从而保证效率</li></ul><p>（下图中的 Session Key 就是 Secret Key）</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png" width="600"/> </div><br><h3 id="6-3-认证"><a href="#6-3-认证" class="headerlink" title="6.3 认证"></a>6.3 认证</h3><ul><li><p>通过使用 <strong>证书</strong> 来对通信放进行认证</p></li><li><p>数字证书认证机构（<strong>CA</strong>,Certificate Authority）是<strong>客户端和服务器双方都信赖的第三方机构</strong>。</p></li><li><p>服务器的运营人员向<strong>CA提出公开密钥的申请，CA再判明提出申请的身份之后，会对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将公开密钥证书后绑定在一起。</p></li><li><p><strong>进行HTTPS通信的时候，服务器会把证书发送给客户端。客户端取得其公开密钥之后，先使用数字签名进行验证，如果通过，才能开始通信。</strong></p></li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png" width=""/> </div><br><h3 id="6-4-完整性保护"><a href="#6-4-完整性保护" class="headerlink" title="6.4 完整性保护"></a>6.4 完整性保护</h3><ul><li>SSL 提供报文摘要功能来对完整性进行保护。</li><li>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</li><li><strong>HTTPS 的报文摘要功能</strong>之所以安全，是因为它结合了<strong>加密和认证这两个操作</strong>。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</li></ul><p><strong>HTTPS的缺点：</strong></p><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2 id="七-：-HTTP-2-0"><a href="#七-：-HTTP-2-0" class="headerlink" title="七 ： HTTP/2.0"></a>七 ： HTTP/2.0</h2><p>参考博客 ： <a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">https://www.zhihu.com/question/34074946</a></p><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><p><strong>1.0 短连接：请求完了即关闭</strong></p><p><strong>1.1 长连接：设置了<code>keep- alive time</code> 来保证TCP连接不关闭</strong></p><p><strong>2.0 多路复用</strong>：<strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。</strong></p><ul><li>目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。</li></ul><h4 id="7-1-二进制分帧层"><a href="#7-1-二进制分帧层" class="headerlink" title="7.1 二进制分帧层"></a>7.1 二进制分帧层</h4><ul><li>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png" width="400"/> </div><br><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png" width="600"/> </div><br><h4 id="7-2-服务端推送"><a href="#7-2-服务端推送" class="headerlink" title="7.2 服务端推送"></a>7.2 服务端推送</h4><ul><li>HTTP 2.0 在客户端请求一个资源的时候，会把相关的资源一起发送给客户端，这样客户端就不用再次发起请求。</li><li>例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" width="800"/> </div><br><h4 id="7-3-首部压缩"><a href="#7-3-首部压缩" class="headerlink" title="7.3 首部压缩"></a>7.3 首部压缩</h4><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png" width="600"/> </div><br><h2 id="八：-HTTP-1-1新特性"><a href="#八：-HTTP-1-1新特性" class="headerlink" title="八： HTTP/1.1新特性"></a>八： HTTP/1.1新特性</h2><ul><li>默认是长连接</li><li>支持流水线</li><li>同时可以打开多个TCP连接</li><li>支持虚拟主机</li><li>新增状态码100</li><li>支持分块传输编码</li><li>新增缓存处理指令  max - age</li></ul><h2 id="九：-GET-和-POST-比较"><a href="#九：-GET-和-POST-比较" class="headerlink" title="九： GET 和 POST 比较"></a>九： GET 和 POST 比较</h2><ol><li><strong>作用上的比较</strong></li></ol><ul><li>get用于请求获取资源</li><li>POST传递传递要给表单，这个表单可以是数据的主体</li></ul><ol start="2"><li><strong>参数</strong></li></ol><ul><li>GET 和 POST 的请求都能使用额外的参数，但是 <strong>GET 的参数是以查询字符串出现在 URL 中，</strong></li><li>而 <strong>POST 的参数存储在实体主体</strong>中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些<strong>抓包工具（Fiddler）查看</strong>。</li></ul><ol start="3"><li><strong>字符集</strong></li></ol><ul><li>因为 URL 只支持 <strong>ASCII 码</strong>，因此 <strong>GET 的参数中如果存在中文等字符就需要先进行编码</strong></li><li>POST支持 UTF-8</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</span><br><span class="line"></span><br><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>安全</strong></li></ol><ul><li>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</li><li>POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</li></ul><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><ol start="5"><li><strong>幂等性</strong></li></ol><ul><li>幂等的HTTP请求，<strong>同样的请求被执行一次或者执行多次的效果是一样的，因此服务器的状态也是一样的。</strong>换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</li><li>所有的安全方法也都是幂等的。</li><li>所以说：GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。<ul><li>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</li><li>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</li><li>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</li></ul></li></ul><ol start="6"><li><strong>可缓存</strong></li></ol><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><ol start="7"><li><strong>XMLHttpRequest</strong></li></ol><ul><li>为了阐述POST和 GET的另一个区别，需要先了解一个类 <strong>XMLHttpRequest(ajax)</strong>- </li><li>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。<strong>XMLHttpRequest 在 AJAX 中被大量使用。</strong></li></ul><p><strong>在使用XMLHttpRequest 的POST方法的时候 ， 浏览器会先发送Header 再发送 Data。</strong></p><p><strong>而Get方法会把Header和 Data一起发送。</strong></p><h2 id="十：-HTTP无状态无链接"><a href="#十：-HTTP无状态无链接" class="headerlink" title="十： HTTP无状态无链接"></a>十： HTTP无状态无链接</h2><p><strong>正文：http协议无状态中的【状态】到底指的是什么？！</strong></p><p>先来看这句话的另外两个概念：（标准的http协议是<strong>无状态的，无连接</strong>的）</p><ol><li>标准的http协议指的是不包括<code>cookies, session，application</code>的http协议，他们都不属于标准协议，虽然各种网络应用提供商，实现语言、web容器等，都默认支持它</li><li><strong>无连接指的是什么</strong><ol><li>每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的</li><li><strong>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接</strong></li></ol></li></ol><p><strong>对于【无状态】</strong>，我看到很多隔着一层磨砂玻璃一样的模糊说法（官方或者教程里的说法），看着非常难受（但其实算是对的）（后来我发现我为什么觉得它看着难受了，因为他们引入了很多新的，而且明显是一个可能用在很多地方的广义名词，这些词最大的作用就是，混淆概念，下面我标注了）</p><ol><li>协议对于事务处理<strong>没有记忆能力</strong>【事物处理】【记忆能力】</li><li>对同一个url请求没有上下文关系【上下文关系】</li><li><strong>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的</strong>，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器【状态】</li></ol><p>这几点给了我下一步思考的方向：</p><ol><li>【服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 】这里的客户端的状态是不是确切地指服务器没有保存客户的信息呢？但显然不是啊</li><li>【HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品】我对此质疑为什么无状态就不能实现购物车呢？服务器就不能存储东西了么？</li><li>【 每次的请求都是独立的，&lt;它的执行情况和结果&gt;与&lt;前面的请求&gt;和&lt;之后的请求&gt;是无直接关系的】我觉得这个说法比较靠谱，但是所谓的不同请求间的没有关系，是指的请求内容没有关系，还是只是指请求本身没有关系？<ol><li>请求内容没有关系只可能是服务器上不存有用户数据才可能啊，但是显然是存有的啊</li><li>请求本身没有关系，这又有什么意义呢，每一次的请求有什么价值？</li></ol></li></ol><p>根据这个方向我做了一个模拟访问实验：假如没有cookie没有session，只有http的时候，那当一个注册用户访问这个购物网站的时候，会发生这些事情：</p><ol><li>前提情况：<ol><li>服务器肯定为每个注册用户建立了数据表，记录用户的数据</li><li>http是无连接的</li></ol></li><li>第一步需要登录<ol><li>用户通过http把用户的用户名和密码发送给服务器，服务器把他们跟自己存有的用户资料对比，如果一致，则返回信息登录成功</li></ol></li><li>然后用户点击某一商品页<ol><li>这个动作相当于输入一个商品页的网址</li><li>假如商品页比较机密不对外公开，需要是用户才能访问</li><li>而虽然http能传送用户名和密码，而且刚才也输入了，还验证成功了，但是因为服务器既不会记得你登录的状态，你的客户端也不会存储你刚才输入的用户名和密码</li><li>所以因为这一次访问因为无法确定你的身份，只能访问失败<ol><li>这时候如果要解决这个问题，而且没有cookie没有session，那就只能你在访问网址的同时继续带上你的用户名和密码（继续输入咯）其实就像我现在的APP一样</li></ol></li></ol></li><li>假设上一步的问题解决了，就是每次访问的时候都会手动输入用户名和密码，然后现在的情况是：你已经选了几件商品在你的购物车中，你想再添加一件商品，于是你点击某个商品旁边的加号<ol><li>这个动作也相当于输入一个网址，网址的内容是发送一个请求，往你的购物车中加入这个商品</li><li>系统首先用你传来的用户名和密码验证你的身份，然后访问你的数据库，在其中的购物车属性下加一条数据，就是这个商品的数据</li><li>操作结束后，返回操作成功，并结束访问</li></ol></li><li>OK，实验结束，看似没有cookie没有session也能凑合解决问题，其实两个操作都有很大的问题<ol><li>你每访问一次需要权限的内容都需要在客户端输入用户名和密码，这一项的繁琐就不必赘述了</li><li>你的每一次操作都要与系统底层的数据库进行交互<ol><li>多次少量的访问存在非常大的性能浪费。非常容易就能想到肯定是一次大量的操作更加有效率，于是就想到了缓存区</li></ol></li><li>你的非重要琐碎数据也被写进数据库中，跟你的主要数据放在一起<ol><li>一次次添加和删除购物车其实只是跟你这次浏览，或者叫这次会话有关，是临时的数据，跟用户的主要信息无关，它们没什么价值，纯粹的冗余数据（不排除现在有的公司觉得这种数据也有非常大的价值可以让它们巧妙的利用），用什么存放这些临时的数据，我们也很容易想到缓存区</li></ol></li></ol></li></ol><p>经过这个模拟访问实验，结合前面的思考方向，我们知道了三点：</p><ol><li>服务器上肯定存有用户的数据，你提交的增删改查它也能够处理，所以这句话中【服务器中没有保存客户端的状态】的状态并不是指用户的数据，我们的猜测不对</li><li>我们的质疑对了，无状态能实现购物车，可以通过服务器上存有的用户数据来实现</li><li>但是，使用上面这种方式实现购物车，存在三个比较大的问题。由此，我们不禁会想，这三个问题的解决是不是跟我们不确切了解的【状态】一词有关？于是，接下来我们来通过解决这三个问题来把【状态】的意义探寻下去</li></ol><p>由上所述，我们可以在http的基础上增加一些机制来解决上面出现的三个问题</p><ol><li>在用户端增加一个记录本是非常有必要的，正好官方加入的cookie机制跟这个一样，它的用处也确实是上面讨论的那样，一般就是用来标识访问者的身份</li><li>在服务器增加一个缓存区能同时解决后两个问题<ol><li>有了这个缓存区作为一个数据缓冲，就不用一次次地访问数据库，浪费大量计算机资源，而是在最后统一归入数据库</li><li>有了这个缓存区，你就不用把临时的数据放到数据库中了，只需要在你们交流告一段落之后，再把数据整理，把有用的数据归入数据库</li></ol></li><li>这里就自然引申出了一个重要的概念：会话，它作为一个缓冲存储区被从数据库中分离出来，理由并不生硬，它有其独特的重要且不可替代的作用。这个东西恰好跟官方加入的session机制一样<ol><li>另外说一个非常具有迷惑性的容易让人对session的主要作用产生偏离的理解：认为session存在的价值就是给访问者分配一个sessionID代替用户名和密码，</li><li>为什么非常具有迷惑性，因为session确实做了这件事，而且也起到了很大的作用，所以它是对的，但是只对一半，而且没有涉及问题的本质，这种情况是最危险的（看似很有说服力，把你说服了，所以你很难有动力继续找下去，但是真实情况跟它有偏差，但是偏差不大，所以又很难把你说服回来，只有隐隐的不对劲，这个时候你离真实最近，也离真实最远）</li><li>那就顺便说说它为什么是对的，也就是用session做的另一件有用的事：<ol><li>给每个session一个ID，一方面用来方便自己查询，另一方面把这个ID给用户，用户下一次访问的时候就可以不用用户名和密码，而是直接使用这个ID来表明自己的身份</li><li>首先，这个ID安全吗？这个ID比直接传用户名和密码安全吗？<ol><li>你很容易会想到，本来用户名和密码的组合还特地设置地比较复杂，你这换一组数字就代替了，是不是太不安全了？</li><li>我们知道http协议本身是完全不加密的，如果使用用户名和密码，第一次访问是放在http头中，后边自动保存了密码就会放在cookie中，这些都完全没有加密，它的安全性基本为0，就是裸奔了，只要被窃取，那就丢失了</li><li>所以，就这个意义来讲，sessionID的安全性跟使用用户名和密码没什么区别</li><li>但是其实，虽然http本身不能加密，但是有些软件什么的，能在应用层面手动给你加密，比如QQ就会使用户名密码加临时验证码联合哈希，sessionID加一个时间戳简单加密也是非常常用的方法</li><li>而且因为sessionID本身有有效期，即使丢了，也可能很快失效，造成的损失可能没那么大，而用户名跟密码丢了，那就大了</li><li>所以总结就是：<ol><li>不严格加密的sessionID和用户名和密码一样，都不太安全</li><li>但是相比较来说，sessionID要安全一些</li><li>而使用https是完全安全的</li></ol></li></ol></li><li>然后，使用sessionID有哪些好处<ol><li>方便直接根据ID查询用户对应的session</li><li>加密的时候计算量小</li><li>安全性不会降低，甚至还更高一些</li></ol></li></ol></li></ol></li></ol><p>OK，通过独立地解决纯http机制会产生的问题，我们探讨了cookie和session机制的本质。而且想到：【使用http协议，服务器中不会保存客户端的状态】所产生的问题通过增加cookie和session机制解决了，是不是就意味着这个【状态】跟cookie和session的关系非常紧密？所以这个无状态指的是【没有对 本次会话 设置一个缓存区，记录这次会话的状态，缓存区包括服务器端和用户端】但好像还是没有点破关键（主要是觉得跟前面那些官方对状态的说法不太吻合，甚至没有对应关系）</p><p>忽然我想到一个问题：一个有状态的http是什么样的？</p><ol><li><p>很难直接想象有状态的http是什么样，因为http这种机制是天然无状态的</p></li><li><p>那就类比一下吧，另一个天然有状态的机制叫TCP</p><ol><li>如果有状态的意思是它的每次请求是有联系的，那么有状态的TCP的样子是：假如一份数据分了三份TCP包发送，那这个包上面会标明这是第几个包，会标明这个包跟那几个包是有联系的，有什么联系</li></ol></li><li><p>但好像这个有状态的TCP跟我们想要的有状态的HTTP没有关系，因为即使每次http请求之间互相有联系，它也不能解决上面提到的http无状态的问题</p></li><li><p>诶，等等，好像能类比：</p><ol><li><p>假如每个http连接都有一个签名，于是第一次登陆成功之后，服务器就知道了这个签名是允许登陆的，于是之后所有同样签名的http连接都能登陆，这里利用了同一个用户发出的http连接之间的同主人关系，这里解决了一个保持登录状态的问题</p></li><li><p>同样，来尝试利用这个【每次http请求之间互相有联系】来解决上面碰到的那个问题【每一次操作都要与系统底层的数据库进行交互】，但想了半天确实无法进行下去</p></li><li><p>不过我灵机一动，从另一个角度来想，好像解决了这个问题：</p><ol><li><p>只有【每次http请求之间互相有联系】这个条件，无法解决【每一次操作都要与系统底层的数据库进行交互】</p></li><li><p>因为很明显，要解决【每一次操作都要与系统底层的数据库进行交互】就必须在服务器端开辟一块缓存区</p></li><li><p>不过如果你思考一下如何实现【每次http请求之间互相有联系】，你就会发现，它也需要在服务器端开辟一块缓存区</p></li><li><p>所以【在服务器端开辟一块缓存区】才是真正的条件，也就是说，它确实等价于【有状态】</p></li><li><p>而且我也找到了这个【在服务器端开辟一块缓存区】的条件跟前面那些官方对状态的说法对应的点，那就是：</p><ol><li>通过在服务器端开辟一块缓存区，存储、记忆、共享一些临时数据，你就可以：<ol><li>协议对于事务处理有记忆能力【事物处理】【记忆能力】</li><li>对同一个url请求有上下文关系【上下文关系】</li><li>每次的请求都是不独立的，它的执行情况和结果与前面的请求和之后的请求是直接关系的【不独立】【直接关系】</li><li>服务器中保存客户端的状态【状态】</li></ol></li></ol></li><li><p>所以，这个状态，加上前面说的客户端也有cookie，就是指，</p><p>客户端和服务器在临时会话中产生的数据</p><p>！而前面也说道了，使用缓存区保存临时会话中的数据是多么重要</p><ol><li>所以状态不仅包括不同URL访问之间的关系，还有对其他URL访问的数据记录，还有一些其他的东西，所以更确切地说，状态应该是【实现了这些东西所凭借的后面的缓存空间】中的客户的临时数据</li><li>cookie和session应该是完全实现了有状态这个功能</li></ol></li></ol></li></ol></li></ol><p><strong>一种常见的对状态的误解：</strong></p><ol><li>有人在解释HTTP的无状态时，把它跟有连接对立，说是两种方式，也就是如果想不无状态，就必须有连接，但其实不然</li><li>有连接和无连接以及之后的Keep-Alive都是指TCP连接</li><li>有状态和无状态可以指TCP也可以指HTTP</li><li>TCP一直有状态，HTTP一直无状态，但是应用为了有状态，就给HTTP加了cookie和session机制，让使用http的应用也能有状态，但http还是无状态</li><li>开始TCP是有连接，后来TCP无连接，再后来也就是现在TCP是Keep-Alive，有点像有连接</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-HTTPS详解&quot;&gt;&lt;a href=&quot;#HTTP-HTTPS详解&quot; class=&quot;headerlink&quot; title=&quot;HTTP-HTTPS详解&quot;&gt;&lt;/a&gt;HTTP-HTTPS详解&lt;/h1&gt;&lt;h2 id=&quot;一：-基础概念&quot;&gt;&lt;a href=&quot;#一：-基础概念&quot; class=&quot;headerlink&quot; title=&quot;一： 基础概念&quot;&gt;&lt;/a&gt;一： 基础概念&lt;/h2&gt;&lt;h3 id=&quot;1-1-URI&quot;&gt;&lt;a href=&quot;#1-1-URI&quot; class=&quot;headerlink&quot; title=&quot;1.1 URI&quot;&gt;&lt;/a&gt;1.1 URI&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;URI 包含 URL 和 URN。&lt;/li&gt;
&lt;li&gt;我们通常所说的&lt;strong&gt;URL（统一资源定位符）是URI的子集&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;URI还有一个自己URN , URN只命名资源但是不指定如何定位资源.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120156077.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络编程" scheme="http://zhuuu.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://zhuuu.work/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://zhuuu.work/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Spring-11-设计模式</title>
    <link href="http://zhuuu.work/2020/06/25/Spring/Spring-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/06/25/Spring/Spring-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-25T07:32:24.000Z</published>
    <updated>2020-08-24T09:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-11-设计模式"><a href="#Spring-11-设计模式" class="headerlink" title="Spring-11-设计模式"></a>Spring-11-设计模式</h2><p>参考博客 ： <a href="https://blog.csdn.net/qq_34337272/article/details/90487768" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/90487768</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-11-设计模式&quot;&gt;&lt;a href=&quot;#Spring-11-设计模式&quot; class=&quot;headerlink&quot; title=&quot;Spring-11-设计模式&quot;&gt;&lt;/a&gt;Spring-11-设计模式&lt;/h2&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https:
      
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-015-三数之和</title>
    <link href="http://zhuuu.work/2020/06/24/Leetcode/Leetcode-015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/06/24/Leetcode/Leetcode-015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-24T11:52:53.000Z</published>
    <updated>2020-06-27T04:35:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-015-三数之和"><a href="#Leecode-015-三数之和" class="headerlink" title="Leecode-015-三数之和"></a>Leecode-015-<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></h1><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路</strong></p><ul><li>首先对排序后的数组进行遍历，固定一个nums[i] 。</li><li>其次使用一个指针L指向 <code>i + 1</code> 的位置，一个指针R指向 <code>nums.length - 1</code>的位置，同时计算<code>nums[i] + nums[L] + nums[R]</code>,计算这三个数的和是否等于0</li><li>细节条件一定要注意<ul><li>如果<code>nums[i] &gt; 0</code> ，那么这三个数的和比不可能等于0</li><li>如果<code>nums[i] == nums[i -1]</code> ,则说明该数字重复，会导致结果的重复，所以应该跳过</li><li>当sum == 0的时候，如果<code>nums[L] == nums[L+1]</code>,则会导致结果的重复，应该跳过，(L++)</li><li>当sum == 0的时候，如果<code>nums[R] == nums[R - 1]</code>,则会导致结果的重复，应该跳过，(R–)</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li><strong>首先进行排序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100358932.png" alt="mark"></p><ol start="2"><li><strong>第一轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100418544.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100451353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100458185.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100504327.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100511291.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100527129.png" alt="mark"></p><ol start="3"><li><strong>第二轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100538257.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100548763.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100554929.png" alt="mark"></p><ol start="4"><li><strong>第三轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100609939.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100615721.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：ans记录结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历数组中的每一个数字，固定nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于0,，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：对 i 进行去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化双指针</span></span><br><span class="line">            <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 指针遍历</span></span><br><span class="line">            <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  如果三数之和等于0</span></span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 记录结果</span></span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>]) L++; <span class="comment">// 注意：去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>]) R--; <span class="comment">// 注意：去重</span></span><br><span class="line">                    <span class="comment">// 指针移动来产生新的结果</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O（n^2） 排序O(nlogn) + 循环O（n^2） = O(n^2)</li><li>空间复杂度：O(1)  没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-015-三数之和&quot;&gt;&lt;a href=&quot;#Leecode-015-三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-015-三数之和&quot;&gt;&lt;/a&gt;Leecode-015-&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;三数之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;p&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定数组 nums &amp;#x3D; [-1, 0, 1, 2, -1, -4]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;满足要求的三元组集合为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, -1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leecode-016-最接近的三数之和</title>
    <link href="http://zhuuu.work/2020/06/24/Leetcode/Leetcode-016-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/06/24/Leetcode/Leetcode-016-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-24T07:52:53.000Z</published>
    <updated>2020-06-25T01:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-016-最接近的三数之和"><a href="#Leecode-016-最接近的三数之和" class="headerlink" title="Leecode-016-最接近的三数之和"></a>Leecode-016-<a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091530419.png" alt="mark"></p><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><ul><li>本题目和Leetcode-015合在一起是三数之和的系列题目</li><li><a href="https://leetcode-cn.com/problems/3sum/（Leetcode-015）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/（Leetcode-015）</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。</li><li>找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。</li><li>假定每组输入只存在唯一答案。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">3 &lt;&#x3D; nums.length &lt;&#x3D; 10^3</span><br><span class="line">-10^3 &lt;&#x3D; nums[i] &lt;&#x3D; 10^3</span><br><span class="line">-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路：</strong></p><ul><li>本题目因为要计算三个数，如果暴力枚举的话时间复杂度会来到O（n^3） ，需要降低时间的复杂度才行</li><li>首先对数组进行排序，时间复杂度O(nlogn)</li><li>在数组 nums 中，进行遍历，每次遍历固定一个nums[i]</li><li>其次使用两个指针，一个L指针指向<code>i + 1</code> 处，一个R指针指向 <code>nums.length-1</code> 处，也就是结尾处。</li><li>计算sum的值 ，sum = nums[i] + nums[L] + nums[R]</li><li>最后判断sum 和 target的关系，因为数组有序，<ul><li>如果sum &gt; target, <code>R --</code></li><li>如果sum &lt; target , <code>L++</code></li><li>如果 sum == target ,距离为0直接返回结果</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li>排序</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091321683.png" alt="mark"></p><ol start="2"><li>初始化</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091334756.png" alt="mark"></p><ol start="3"><li>for循环</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091411150.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091423709.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091437310.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091444470.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091452814.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091505156.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091511678.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091521010.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化</span></span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 循环固定nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (L &lt; R)&#123;</span><br><span class="line">                <span class="comment">// 三数之和</span></span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次更新结果</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(target - sum) &lt; Math.abs(target - ans))&#123;</span><br><span class="line">                    ans = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断sum 和 target之间的关系</span></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target)&#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ：O（n^2）  排序O(nlogn) + 遍历O(n^2) = O(n^2)</li><li>空间复杂度： O(1) 没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-016-最接近的三数之和&quot;&gt;&lt;a href=&quot;#Leecode-016-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-016-最接近的三数之和&quot;&gt;&lt;/a&gt;Leecode-016-&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-closest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最接近的三数之和&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091530419.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本题目和Leetcode-015合在一起是三数之和的系列题目&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/（Leetcode-015）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/3sum/（Leetcode-015）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个包括 &lt;em&gt;n&lt;/em&gt; 个整数的数组 &lt;code&gt;nums&lt;/code&gt; 和 一个目标值 &lt;code&gt;target&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;找出 &lt;code&gt;nums&lt;/code&gt; 中的三个整数，使得它们的和与 &lt;code&gt;target&lt;/code&gt; 最接近。返回这三个数的和。&lt;/li&gt;
&lt;li&gt;假定每组输入只存在唯一答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1,2,1,-4], target &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：与 target 最接近的和是 2 (-1 + 2 + 1 &amp;#x3D; 2) 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 10^3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10^3 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 10^3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10^4 &amp;lt;&amp;#x3D; target &amp;lt;&amp;#x3D; 10^4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-350-两个数组的交集II</title>
    <link href="http://zhuuu.work/2020/06/23/Leetcode/Leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>http://zhuuu.work/2020/06/23/Leetcode/Leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</id>
    <published>2020-06-23T03:22:53.000Z</published>
    <updated>2020-06-25T07:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-350-两个数组的交集-II"><a href="#Leetcode-350-两个数组的交集-II" class="headerlink" title="Leetcode-350-两个数组的交集 II"></a>Leetcode-350-<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>进阶:</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><a id="more"></a><h2 id="方法一：排序-双指针"><a href="#方法一：排序-双指针" class="headerlink" title="方法一：排序+双指针"></a>方法一：排序+双指针</h2><p><strong>算法分析：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/143433760.jpg" alt="mark"></p><ul><li><p>首先对两个数组<code>nums1</code> 和 <code>nums2</code>进行排序</p></li><li><p>初始化指针<code>i,j</code> 用于指向两个数组</p><ul><li>指针<code>i</code> 指向 <code>nums1</code>,指针<code>j</code> 指向<code>nums2</code></li><li>如果<code>nums1[i] &lt; nums2[j]</code>  则 <code>i++</code></li><li>如果<code>nums1[i] &gt; nums2[j]</code>  则 <code>j++</code></li><li>如果<code>nums1[i] == nums2[j]</code>  则将元素拷贝到<code>nums1[k]</code>,且同时<code>i++ , j ++ , k++</code></li></ul></li><li><p><strong>初始化指针<code>k</code> 用于记录是否应该修改元素（作用是为了不使用额外的空间）</strong></p></li><li><p><strong>最后返回<code>nums1</code>的前k个元素就好</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对两个数组进行排序</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 指向nums1</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 指向nums2</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">// 用于记录nums1 和 nums2 中重复元素的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。</span></span><br><span class="line">        <span class="comment">// 注意这里包括下标from，不包括上标to。</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(nums1,<span class="number">0</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：</strong><code>O(nlogn+mlogm)</code>其中 n，m分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。</li><li><strong>空间复杂度</strong>：O（1） 没有使用额外的空间。</li></ul><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><ul><li>相对于上一题我们使用set去重，本题不要求去重，那么使用哈希表也很合适</li><li>如果 <code>nums1</code> 元素个数大于 <code>nums2</code>，则交换数组元素。</li><li>对于 <code>nums1</code> 的每个元素，添加到 <code>HashMap m</code> 中，如果元素已经存在则增加对应的计数。(这里用了一个getOrDefault方法，作用同map用if-else存放元素)</li><li>遍历数组<code>nums2</code><ul><li>检查元素在map中是否存在，如果存在且个数大于0<ul><li>将元素拷贝到<code>nums1[k]</code>, k++</li><li>减少map中对应元素的个数</li></ul></li></ul></li></ul><ul><li>最后返回<code>nums1</code>的前k个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 首先决定用长度小的数组进行操作（检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。）</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用map存放元素</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">            map.put(n, map.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 对应nums2去减少元素，（避免再开一个map浪费空间）</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果有这个Key存在的话</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums2[i]))&#123;</span><br><span class="line">                <span class="comment">// 获取这个key对应的value，</span></span><br><span class="line">                <span class="comment">// 如果对应的value &gt; 0,并将这个value值 - 1</span></span><br><span class="line">                <span class="keyword">int</span> count = map.get(nums2[i]);</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    map.put(nums2[i],count - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 同时把当前元素的值赋值给nums1[k] ，这样减少了内存的浪费</span></span><br><span class="line">                    nums1[k] = nums2[i];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(nums1,<span class="number">0</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>时间复杂度</strong>：<strong>O( n + m )</strong> 其中 n<em>，m</em> 分别代表了数组的大小。</p></li><li><p><strong>空间复杂度</strong>：<strong>O(min(m,n))</strong> 创建了两个数组中最小大小的map映射。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-350-两个数组的交集-II&quot;&gt;&lt;a href=&quot;#Leetcode-350-两个数组的交集-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-350-两个数组的交集 II&quot;&gt;&lt;/a&gt;Leetcode-350-&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个数组的交集 II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums1 &amp;#x3D; [1,2,2,1], nums2 &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums1 &amp;#x3D; [4,9,5], nums2 &amp;#x3D; [9,4,9,8,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [4,9]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。&lt;/li&gt;
&lt;li&gt;我们可以不考虑输出结果的顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果给定的数组已经排好序呢？你将如何优化你的算法？&lt;/li&gt;
&lt;li&gt;如果 nums1 的大小比 nums2 小很多，哪种方法更优？&lt;/li&gt;
&lt;li&gt;如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-242-有效的字母异位词</title>
    <link href="http://zhuuu.work/2020/06/15/Leetcode/Leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>http://zhuuu.work/2020/06/15/Leetcode/Leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</id>
    <published>2020-06-15T07:22:53.000Z</published>
    <updated>2020-06-17T09:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-242-有效的字母异位词"><a href="#Leecode-242-有效的字母异位词" class="headerlink" title="Leecode-242-有效的字母异位词"></a>Leecode-242-<a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p><p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><a id="more"></a><h2 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h2><p>思路： </p><ul><li>通过将s字符串转换成char数组</li><li>对每个字符进行排序。</li><li>因此，如果T是S的异位词，对两个字符串进行排序将产生两个相同的字符串。</li><li>此外，如果s和t的长度不同，t不可能是s的异位词，这样我们可以提前返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O（n）</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1,str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度分析<ul><li>时间复杂度：O(nlogn) ，排序的成本是O(nlogn) ，比较字符串的成本是O(n),所以总体的时间复杂度是O(nlogn)</li><li>空间复杂度：O(n) ,<code>toCharArray()</code> 制作了一个字符串的拷贝，所以它花费 O(n)额外的空间</li></ul></li></ul><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>思路：</p><ul><li>为了检查t是否是s的重新排列，我们只需要计算两个字符串中对应字母出现的次数是否相同即可</li><li>因为S和T都只包含26个小写字母，所以哈希表大小26个字母就够了</li><li>这里需要两个计数器来进行比较吗？<ul><li>答：不需要，只需要一个计数器表即可。用一个计数器表计算s字母的频率，用t减少计数器表中每个字母的计数器，然后检查计数器是否回到了0。</li></ul></li></ul><ul><li>这里直接用数组代替hash，减少哈希碰撞带来的复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="comment">// 为了检查t是否是s的重新排列，我们可以计算连个字符串中每个字母的出现次数并比较</span></span><br><span class="line"><span class="comment">// 因为s和t都只包含A-Z的字母，所以一个简单的26位计数器就够了</span></span><br><span class="line"><span class="comment">// 我们需要连个计数器表进行比较吗？</span></span><br><span class="line"><span class="comment">// 答：是不需要的，因为我们可以用一个计数器表计算s字母的频率，用t减少计数器表中每个字母的计数器，最后检查计数器是否回到0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            counter[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            counter[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count : counter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)     遍历两个字符串的开销</li><li>空间复杂度： O(1)     26个字母对计算机来说不是什么事情。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-242-有效的字母异位词&quot;&gt;&lt;a href=&quot;#Leecode-242-有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;Leecode-242-有效的字母异位词&quot;&gt;&lt;/a&gt;Leecode-242-&lt;a href=&quot;https://leetcode-cn.com/problems/valid-anagram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有效的字母异位词&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个字符串 &lt;em&gt;s&lt;/em&gt; 和 &lt;em&gt;t&lt;/em&gt; ，编写一个函数来判断 &lt;em&gt;t&lt;/em&gt; 是否是 &lt;em&gt;s&lt;/em&gt; 的字母异位词。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;anagram&amp;quot;, t &amp;#x3D; &amp;quot;nagaram&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;rat&amp;quot;, t &amp;#x3D; &amp;quot;car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;你可以假设字符串只包含小写字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;br&gt;如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-原码,补码,反码</title>
    <link href="http://zhuuu.work/2020/06/13/JavaInterview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%A0%81,%E8%A1%A5%E7%A0%81,%E5%8F%8D%E7%A0%81/"/>
    <id>http://zhuuu.work/2020/06/13/JavaInterview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%A0%81,%E8%A1%A5%E7%A0%81,%E5%8F%8D%E7%A0%81/</id>
    <published>2020-06-13T07:38:38.000Z</published>
    <updated>2020-06-13T07:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机基础-原码-补码-反码"><a href="#计算机基础-原码-补码-反码" class="headerlink" title="计算机基础-原码,补码,反码"></a>计算机基础-原码,补码,反码</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机基础-原码-补码-反码&quot;&gt;&lt;a href=&quot;#计算机基础-原码-补码-反码&quot; class=&quot;headerlink&quot; title=&quot;计算机基础-原码,补码,反码&quot;&gt;&lt;/a&gt;计算机基础-原码,补码,反码&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="计算机基础" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-349-两个数组的交集</title>
    <link href="http://zhuuu.work/2020/06/13/Leetcode/Leetcode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/06/13/Leetcode/Leetcode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-06-13T06:22:53.000Z</published>
    <updated>2020-07-13T11:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-349-两个数组的交集"><a href="#Leecode-349-两个数组的交集" class="headerlink" title="Leecode-349-两个数组的交集"></a>Leecode-349-<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">两个数组的交集</a></h1><h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h2 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：两个set"><a href="#方法：两个set" class="headerlink" title="方法：两个set"></a>方法：两个set</h2><ul><li>将两个数组都转换成集合</li><li>然后迭代较小的集合，检查其中每个元素是否在较大的集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将两个数组都转化为集合</span></span><br><span class="line"><span class="comment">// 然后迭代较小的集合</span></span><br><span class="line"><span class="comment">// 检查其中每个元素是否同样存在较大的集合中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把nums1数组存到对应的set1中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把nums2数组存到对应的set2中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            set2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从较小的set检查和较大数组的交集</span></span><br><span class="line">        <span class="keyword">if</span> (set1.size() &lt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(set1,set2);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(set2,set1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] helper(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;</span><br><span class="line">        <span class="comment">// 创建一个和较小set一样的数组记为result</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">        <span class="comment">// 交集含有的个数</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历较小Set</span></span><br><span class="line">        <span class="comment">// 查找较大set中是否存在较小set的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Integer num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.contains(num))&#123;</span><br><span class="line">                result[idx] = num;</span><br><span class="line">                idx++; <span class="comment">// 这里idx++完之后会比原数组长度多1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个idx长度的交集</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(result,idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度： O（m + n）</strong> 其中 <code>n</code> 和 <code>m</code> 是数组的长度。<ul><li>将<code>num1</code> 转换成集合要 O(n )的时间</li><li>类似地，将 <code>nums2</code> 转换为集合需要 <em>O</em>(<em>m</em>) 的时间</li><li>而在平均情况下，集合的 <code>in/contains</code> 操作只需要 O(1) 的时间。</li></ul></li></ul><ul><li><strong>空间复杂度：O<em>(</em>m<em>+</em>n)</strong>，最坏的情况是数组中的所有元素都不同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-349-两个数组的交集&quot;&gt;&lt;a href=&quot;#Leecode-349-两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;Leecode-349-两个数组的交集&quot;&gt;&lt;/a&gt;Leecode-349-&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个数组的交集&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：哈希表&quot;&gt;&lt;a href=&quot;#思路：哈希表&quot; class=&quot;headerlink&quot; title=&quot;思路：哈希表&quot;&gt;&lt;/a&gt;思路：哈希表&lt;/h2&gt;&lt;h2 id=&quot;题目表述&quot;&gt;&lt;a href=&quot;#题目表述&quot; class=&quot;headerlink&quot; title=&quot;题目表述&quot;&gt;&lt;/a&gt;题目表述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [1,2,2,1], nums2 &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [4,9,5], nums2 &amp;#x3D; [9,4,9,8,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[9,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>��Դ��Ŀ-02-SSM����</title>
    <link href="http://zhuuu.work/2020/06/13/Project/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-02-SSM%E6%95%B4%E5%90%88/"/>
    <id>http://zhuuu.work/2020/06/13/Project/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-02-SSM%E6%95%B4%E5%90%88/</id>
    <published>2020-06-13T03:02:24.000Z</published>
    <updated>2020-06-13T12:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="��Դ��L-02-SSM����"><a href="#��Դ��L-02-SSM����" class="headerlink" title="��Դ��Ŀ-02-SSM����"></a>��Դ��Ŀ-02-SSM����</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;��Դ��L-02-SSM����&quot;&gt;&lt;a href=&quot;#��Դ��L-02-SSM����&quot; class=&quot;headerlink&quot; title=&quot;��Դ��Ŀ-02-SSM����&quot;&gt;&lt;/a&gt;��Դ��Ŀ-02-SSM����&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="��Դ��Ŀ" scheme="http://zhuuu.work/tags/%EF%BF%BD%EF%BF%BD%D4%B4%EF%BF%BD%EF%BF%BDL/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-秒杀问题</title>
    <link href="http://zhuuu.work/2020/06/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/06/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-12T09:44:38.000Z</published>
    <updated>2020-09-10T01:49:04.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-秒杀问题"><a href="#Java-基础-秒杀问题" class="headerlink" title="Java-基础-秒杀问题"></a>Java-基础-秒杀问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>秒杀或抢购活动一般会经过【预约】【抢订单】【支付】这3个大环节，而其中【抢订单】这个环节是最考验业务提供方的抗压能力的。</p><p>抢订单环节一般会带来2个问题：</p><p>　　<strong>1、高并发</strong></p><p>　　比较火热的秒杀在线人数都是10w起的，如此之高的在线人数对于网站架构从前到后都是一种考验。</p><p>　　<strong>2、超卖</strong></p><p>　　任何商品都会有数量上限，如何避免成功下订单买到商品的人数不超过商品数量的上限，这是每个抢购活动都要面临的难题。</p><a id="more"></a><h2 id="1-前端解决方案"><a href="#1-前端解决方案" class="headerlink" title="1. 前端解决方案"></a>1. 前端解决方案</h2><p>面对高并发的抢购活动，前端常用的三板斧是<strong>【扩容】【静态化】【限流】</strong></p><p>　　<strong>A：扩容</strong></p><p>　　加机器，这是最简单的方法，通过增加前端池的整体承载量来抗峰值。</p><p>　　<strong>B：静态化</strong></p><p>　　将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过CDN来抗峰值。</p><p>　　<strong>C：限流</strong></p><p>　　一般都会采用IP级别的限流，即针对某一个IP，限制单位时间内发起请求数量。</p><p>　　或者活动入口的时候增加游戏或者问题环节进行消峰操作。</p><p>　　<strong>D：有损服务</strong></p><p>　　最后一招，在接近前端池承载能力的水位上限的时候，随机拒绝部分请求来保护活动整体的可用性。</p><h2 id="2-后端解决方案"><a href="#2-后端解决方案" class="headerlink" title="2. 后端解决方案"></a>2. 后端解决方案</h2><ul><li>那么后端的数据库在高并发和超卖下会遇到什么问题呢？主要会有如下3个问题：（<strong>主要讨论写的问题，读的问题通过增加cache可以很容易的解决）</strong><ul><li><strong>首先MySQL自身对于高并发的处理性能</strong>就会出现问题，一般来说，MySQL的处理性能会随着并发thread上升而上升，但是到了一定的并发度之后会出现明显的拐点，之后一路下降，最终甚至会比单thread的性能还要差。</li><li>其次，超卖的根结在于减库存操作是一个<strong>事务操作</strong>，需要先select，然后insert，最后update -1。最后这个-1操作是不能出现负数的，<strong>但是当多用户在有库存的情况下并发操作，出现负数这是无法避免的。</strong></li><li>最后，当减库存和高并发碰到一起的时候，由于操作的库存数目在同一行，就会出现<strong>争抢InnoDB行锁的问题，导致出现互相等待甚至死锁，</strong>从而大大降低MySQL的处理性能，最终导致前端页面出现超时异常。</li></ul></li></ul><p>针对上述问题，如何解决呢？ 我们先看眼<strong>淘宝的高大上解决方案</strong>：</p><p>　　<strong>I：  关闭死锁检测，提高并发处理性能。</strong></p><p>　　II： 修改源代码，将排队提到进入引擎层前，降低引擎层面的并发度。</p><p>　　<strong>III：组提交，降低server和引擎的交互次数，降低IO消耗。</strong></p><p>不过结合我们的实际，改源码这种高大上的解决方案显然有那么一点不切实际。于是小伙伴们需要讨论出一种适合我们实际情况的解决方案。以下就是我们讨论的解决方案：</p><ul><li>首先设定一个前提，为了防止超卖现象，所有减库存操作都需要进行一次减后检查，保证减完不能等于负数。（由于MySQL事务的特性，这种方法只能降低超卖的数量，但是不可能完全避免超卖）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="built_in">number</span> <span class="keyword">set</span> x=x<span class="number">-1</span> <span class="keyword">where</span> (x <span class="number">-1</span> ) &gt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>解决方案1：</strong></p><ul><li>将存库从MySQL前移到Redis中，所有的写操作放到内存中，由于Redis中不存在锁故不会出现互相等待，并且由于Redis的写性能和读性能都远高于MySQL，这就解决了高并发下的性能问题。<strong>然后通过队列等异步手段，将变化的数据异步写入到DB中。</strong><ul><li>优点：解决性能问题</li><li>缺点：没有解决超卖问题，同时由于异步写入DB，存在某一时刻DB和Redis中数据不一致的风险。</li></ul></li></ul><p><strong>解决方案2：</strong></p><ul><li><strong>引入队列，然后将所有写DB操作在单队列中排队，完全串行处理。当达到库存阀值的时候就不在消费队列，并关闭购买功能。这就解决了超卖问题。</strong><ul><li>（缓存里面设置阀值可以起到请求过滤的功能，有效的解决内存爆满问题。比如，设置阀值为100，每次请求先判断阀值是否大于0，大于0说明请求有效，存入Redis队列，阀值减1，小于等于0说明请求无效，直接返回结果（即产品售罄）。</li><li>一般来说，这个阀值的设置要比库存数稍微大点，这样就可以解决用户抢到产品而不付钱的情况。</li></ul></li><li><ul><li>优点：解决超卖问题，略微提升性能。</li><li>缺点：性能受限于队列处理机处理性能和DB的写入性能中最短的那个，另外多商品同时抢购的时候需要准备多条队列。</li></ul></li></ul><p><strong>解决方案3：</strong></p><ul><li><strong>将写操作前移到MC中</strong>，同时利用MC的轻量级的锁机制CAS来实现减库存操作。<ul><li>优点：读写在内存中，操作性能快，引入轻量级锁之后可以保证同一时刻只有一个写入成功，解决减库存问题。</li><li>缺点：没有实测，基于CAS的特性不知道高并发下是否会出现大量更新失败？不过加锁之后肯定对并发性能会有影响。</li></ul></li></ul><p><strong>解决方案4：</strong></p><ul><li><strong>将提交操作变成两段式，先申请后确认。</strong>然后利用Redis的原子自增操作（相比较MySQL的自增来说没有空洞），同时利用Redis的事务特性来发号，保证拿到小于等于库存阀值的号的人都可以成功提交订单。然后数据异步更新到DB中。<ul><li>优点：解决超卖问题，库存读写都在内存中，故同时解决性能问题。</li><li>缺点：由于异步写入DB，可能存在数据不一致。另可能存在少买，也就是如果拿到号的人不真正下订单，可能库存减为0，但是订单数并没有达到库存阀值。</li></ul></li></ul><p><strong>同时</strong></p><ul><li>为了防刷、防止同一个用户同一秒里面把购物车里的商品进行多次结算，防止前端代码出问题触发两次，我们可以使用<strong>分布式锁</strong>来解决。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>1、前端三板斧【扩容】【限流】【静态化】</p><p>2、后端两条路【内存】+【排队】</p><p><strong>参考博客：</strong> <a href="https://www.cnblogs.com/billyxp/p/3701124.html" target="_blank" rel="noopener">https://www.cnblogs.com/billyxp/p/3701124.html</a></p><p>​                    <a href="https://www.cnblogs.com/yaopengfei/p/12418229.html" target="_blank" rel="noopener">https://www.cnblogs.com/yaopengfei/p/12418229.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-秒杀问题&quot;&gt;&lt;a href=&quot;#Java-基础-秒杀问题&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-秒杀问题&quot;&gt;&lt;/a&gt;Java-基础-秒杀问题&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;秒杀或抢购活动一般会经过【预约】【抢订单】【支付】这3个大环节，而其中【抢订单】这个环节是最考验业务提供方的抗压能力的。&lt;/p&gt;
&lt;p&gt;抢订单环节一般会带来2个问题：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、高并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　比较火热的秒杀在线人数都是10w起的，如此之高的在线人数对于网站架构从前到后都是一种考验。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、超卖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　任何商品都会有数量上限，如何避免成功下订单买到商品的人数不超过商品数量的上限，这是每个抢购活动都要面临的难题。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="秒杀" scheme="http://zhuuu.work/tags/%E7%A7%92%E6%9D%80/"/>
    
      <category term="超卖" scheme="http://zhuuu.work/tags/%E8%B6%85%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-448-找到所有数组中消失的数字</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2020-06-12T08:44:53.000Z</published>
    <updated>2020-08-09T09:33:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-448-找到所有数组中消失的数字"><a href="#Leecode-448-找到所有数组中消失的数字" class="headerlink" title="Leecode-448-找到所有数组中消失的数字"></a>Leecode-448-<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h1><h2 id="思路：自哈希"><a href="#思路：自哈希" class="headerlink" title="思路：自哈希"></a>思路：自哈希</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p><strong>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</strong></p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：自哈希"><a href="#方法：自哈希" class="headerlink" title="方法：自哈希"></a>方法：自哈希</h2><ul><li><p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p><p>让数值 1 就放在索引位置 0 处；<br>让数值 2 就放在索引位置 1 处；<br>让数值 3 就放在索引位置 2 处；</p></li><li><p>再次遍历一遍数组，如果当前 <code>索引+1 != 当前值</code></p><ul><li>说明这个数不匹配，是消失的数，所以加入到结果集中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,i,nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历交换后的数组，查看消失的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基与异或的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边a b a</span></span><br><span class="line">        <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是数组的长度。<strong>(均摊复杂度)</strong></li><li>空间复杂度：O(1)，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;a href=&quot;#Leecode-448-找到所有数组中消失的数字&quot; class=&quot;headerlink&quot; title=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;/a&gt;Leecode-448-&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;找到所有数组中消失的数字&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希&quot;&gt;&lt;a href=&quot;#思路：自哈希&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希&quot;&gt;&lt;/a&gt;思路：自哈希&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-448-找到所有数组中消失的数字</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-06-12T08:44:53.000Z</published>
    <updated>2020-06-27T09:19:20.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-448-找到所有数组中消失的数字"><a href="#Leecode-448-找到所有数组中消失的数字" class="headerlink" title="Leecode-448-找到所有数组中消失的数字"></a>Leecode-448-<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h1><h2 id="思路：自哈希"><a href="#思路：自哈希" class="headerlink" title="思路：自哈希"></a>思路：自哈希</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p><strong>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</strong></p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：自哈希"><a href="#方法：自哈希" class="headerlink" title="方法：自哈希"></a>方法：自哈希</h2><ul><li><p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p><p>让数值 1 就放在索引位置 0 处；<br>让数值 2 就放在索引位置 1 处；<br>让数值 3 就放在索引位置 2 处；</p></li><li><p>再次遍历一遍数组，如果当前 <code>索引+1 != 当前值</code></p><ul><li>说明这个数不匹配，是消失的数，所以加入到结果集中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,i,nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历交换后的数组，查看消失的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基与异或的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边a b a</span></span><br><span class="line">        <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是数组的长度。<strong>(均摊复杂度)</strong></li><li>空间复杂度：O(1)，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;a href=&quot;#Leecode-448-找到所有数组中消失的数字&quot; class=&quot;headerlink&quot; title=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;/a&gt;Leecode-448-&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;找到所有数组中消失的数字&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希&quot;&gt;&lt;a href=&quot;#思路：自哈希&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希&quot;&gt;&lt;/a&gt;思路：自哈希&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-442-数组中重复的数据</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2020-06-12T07:46:53.000Z</published>
    <updated>2020-08-09T09:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-442-数组中重复的数据"><a href="#Leetcode-442-数组中重复的数据" class="headerlink" title="Leetcode-442-数组中重复的数据"></a>Leetcode-442-<a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">数组中重复的数据</a></h1><h2 id="思路：自哈希-抽屉原理"><a href="#思路：自哈希-抽屉原理" class="headerlink" title="思路：自哈希/抽屉原理"></a>思路：自哈希/抽屉原理</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</p><p>找到所有出现两次的元素。</p><p>你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：抽屉原理"><a href="#方法：抽屉原理" class="headerlink" title="方法：抽屉原理"></a>方法：抽屉原理</h2><ul><li><p><strong>思路分析：“桶排序”的思想是“抽屉原理”，</strong>即“一个萝卜一个坑”，8 个萝卜要放在 7 个坑里，则至少有 1 个坑里至少有 2 个萝卜。</p></li><li><p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p><p>让数值 1 就放在索引位置 0 处；<br>让数值 2 就放在索引位置 1 处；<br>让数值 3 就放在索引位置 2 处；</p></li><li><p><strong>一次遍历以后，那些“无处安放”的元素就是我们要查找的“出现两次的元素”</strong></p></li><li><p>为了不使用额外的空间，这里使用到的一个技巧是“基于异或运算交换两个变量的值”：交换两个整数，除了引入一个新的变量，写出一个“轮换”的赋值表达式以外，还有两种比较 tricky 的做法，下面给出结论。</p><ul><li>如果 <code>a ^ b = c</code> 那么 <code>a ^ c = b</code> 与 <code>b ^ c = a</code>同时成立</li></ul></li></ul><table><thead><tr><th>基于异或运算</th><th>基于加减法</th></tr></thead><tbody><tr><td><code>a = a ^ b</code> <code>b = a ^ b</code> <code>a = a ^ b</code></td><td><code>a = a + b</code> <code>b = a - b</code> <code>a = a - b</code></td></tr></tbody></table><ul><li>对于异或运算实现的交换方法，如果调用 <code>swap(nums, i, i)</code>，那么最终的结果会变为 <code>0</code>。</li><li>对于加减法实现的交换方法，有可能发生溢出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基与异或的交换方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左边a b a</span></span><br><span class="line">    <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">    nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">    nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数组自己做哈希：数值为i的数字映射到下标 i - 1的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 在指定范围内，如果数字并且没有放在正确的位置上，才交换</span></span><br><span class="line">            <span class="comment">// 例如：数值3应该放在索引2的位置上</span></span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,i,nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历交换后的数组，如果当前下标和数字不对应</span></span><br><span class="line">        <span class="comment">// 说明出现了重复的数字，加入到res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i)&#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基与异或的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边a b a</span></span><br><span class="line">        <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // 普通交换函数</span></span><br><span class="line"><span class="comment">//    private void swap(int[] nums, int i, int j) &#123;</span></span><br><span class="line"><span class="comment">//        int temp = nums[i];</span></span><br><span class="line"><span class="comment">//        nums[i] = nums[j];</span></span><br><span class="line"><span class="comment">//        nums[j] = temp;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是数组的长度。<strong>(均摊复杂度)</strong></li><li>空间复杂度：O(1)，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-442-数组中重复的数据&quot;&gt;&lt;a href=&quot;#Leetcode-442-数组中重复的数据&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-442-数组中重复的数据&quot;&gt;&lt;/a&gt;Leetcode-442-&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组中重复的数据&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希-抽屉原理&quot;&gt;&lt;a href=&quot;#思路：自哈希-抽屉原理&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希/抽屉原理&quot;&gt;&lt;/a&gt;思路：自哈希/抽屉原理&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。&lt;/p&gt;
&lt;p&gt;找到所有出现两次的元素。&lt;/p&gt;
&lt;p&gt;你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-0XX</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-264-%E4%B8%91%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-264-%E4%B8%91%E6%95%B0/</id>
    <published>2020-06-12T07:33:53.000Z</published>
    <updated>2020-06-17T10:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-264-丑数"><a href="#Leecode-264-丑数" class="headerlink" title="Leecode-264-丑数"></a>Leecode-264-<a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">丑数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 6</span><br><span class="line">输出: true</span><br><span class="line">解释: 6 &#x3D; 2 × 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 8</span><br><span class="line">输出: true</span><br><span class="line">解释: 8 &#x3D; 2 × 2 × 2</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 14</span><br><span class="line">输出: false </span><br><span class="line">解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li></ol><a id="more"></a><h3 id="方法一：除法"><a href="#方法一：除法" class="headerlink" title="方法一：除法"></a>方法一：除法</h3><ul><li>思路：不断除以2，3，5 ，最后结果是1，那么一定是丑数<ul><li>换句话来说：除尽所有的因子，那么最后一定等于1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度： O(1)</li><li>空间复杂度： O(1)</li></ul><h2 id="题目描述（丑数进阶）："><a href="#题目描述（丑数进阶）：" class="headerlink" title="题目描述（丑数进阶）："></a>题目描述（丑数进阶）：</h2><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><h3 id="方法一：三指针"><a href="#方法一：三指针" class="headerlink" title="方法一：三指针"></a>方法一：三指针</h3><p>思路：</p><ul><li><p>创建一个大小是 n+1 的数组，来存放n个丑数（第一个丑数是<code>numList[0] = 1</code>）</p></li><li><p>存入的每个丑数是2，3，5对应指针最小的那个丑数</p></li><li><p>三个指针分别指向2,3,5的因子</p><ul><li>如果含有2的因子，2的指针加1</li><li>如果含有3的因子，3的指针加1</li><li>如果含有5的因子，5的指针加1</li></ul></li><li><p>最后返回数组下标 <code>n - 1</code>对应的元素即可</p></li></ul><h3 id="方法二：最小堆"><a href="#方法二：最小堆" class="headerlink" title="方法二：最小堆"></a>方法二：最小堆</h3><p>思路：</p><ul><li><p>从堆中包含一个数字开始：1</p></li><li><p>去计算下一个丑数。将 1 从堆中弹出然后将三个数字添加到堆中：2，3，5</p></li><li><p>现在堆中最小的数字是 2。为了计算下一个丑数，要将 2 从堆中弹出然后添加三个数字：4，6，10</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181811361.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181826820.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181836970.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆：队列实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放丑数</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 用来对堆去重</span></span><br><span class="line">        HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 在每个步骤中，弹出堆中最小的丑数 k，并</span></span><br><span class="line">        <span class="comment">// 在堆中添加三个丑数：k×2, k×3，和 k×5</span></span><br><span class="line">        PriorityQueue&lt;Long&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时加入第一个丑数</span></span><br><span class="line">        pq.add(<span class="number">1L</span>);</span><br><span class="line">        set.add(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化丑数和因子</span></span><br><span class="line">        <span class="keyword">long</span> currUgly = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">long</span> newUgly  = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从堆中包含第一个数字开始</span></span><br><span class="line">        <span class="comment">// 重复该步骤计算所有丑数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 弹出堆中最小的丑数 k</span></span><br><span class="line">            currUgly = pq.poll();</span><br><span class="line">            <span class="comment">// 将这个丑数加入到数组存放</span></span><br><span class="line">            nums[i] = (<span class="keyword">int</span>)currUgly;</span><br><span class="line">            <span class="comment">// 添加三个新丑数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> prime : primes) &#123;</span><br><span class="line">                newUgly = currUgly * prime;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(newUgly))&#123;</span><br><span class="line">                    set.add(newUgly);</span><br><span class="line">                    pq.add(newUgly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n) 对每个丑数乘以因子的for循环操作。</li><li>空间复杂度：O(n) 数组的长度，Set的长度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-264-丑数&quot;&gt;&lt;a href=&quot;#Leecode-264-丑数&quot; class=&quot;headerlink&quot; title=&quot;Leecode-264-丑数&quot;&gt;&lt;/a&gt;Leecode-264-&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;丑数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个程序判断给定的数是否为丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 &lt;code&gt;2, 3, 5&lt;/code&gt; 的&lt;strong&gt;正整数&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 6 &amp;#x3D; 2 × 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 8 &amp;#x3D; 2 × 2 × 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 14 不是丑数，因为它包含了另外一个质因数 7。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 是丑数。&lt;/li&gt;
&lt;li&gt;输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="最小堆" scheme="http://zhuuu.work/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-283-移动0</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-283-%E7%A7%BB%E5%8A%A80/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-283-%E7%A7%BB%E5%8A%A80/</id>
    <published>2020-06-12T07:32:53.000Z</published>
    <updated>2020-06-14T09:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-283-移动零"><a href="#Leecode-283-移动零" class="headerlink" title="Leecode-283-移动零"></a>Leecode-283-<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><a id="more"></a><h2 id="方法一：两次遍历"><a href="#方法一：两次遍历" class="headerlink" title="方法一：两次遍历"></a>方法一：两次遍历</h2><ul><li>创建两个指针 i 和 j </li><li>第一次遍历指针 j 记录 当前有多少非0的元素，即遍历的时候每遇到一个非0的元素就将它向左边挪</li><li>第一次遍历完之后，j 指针就记录了最后一个非0元素的下标。</li><li>第二次遍历的时候，起始位置从 j 开始到结束，把所有剩下的元素都修改为0。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/172243741.gif" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次遍历，j指针记录非0的个数</span></span><br><span class="line">        <span class="comment">// 只要是非0的统统都赋给nums[j]</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次遍历把末尾的元素全部赋值为0</span></span><br><span class="line">        <span class="comment">// 非0元素统计完了，剩下的都是0了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j;i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度:O(1)</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul><h2 id="方法二：一次遍历"><a href="#方法二：一次遍历" class="headerlink" title="方法二：一次遍历"></a>方法二：一次遍历</h2><ul><li><strong>参考快速排序的思想</strong><ul><li>首先确定一个带分割的点 x ，</li><li>然后把所有小于等于x 的都放到 x的左边，把所有大于 x 的都放到 x的右边</li><li>这里的 x 根据题目 取 0 . (把所有小于等于0的都放在0的左边，所有大于0的都放在0的右边)</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/173058469.gif" alt="mark"></p><ul><li>这的中间点就是<code>0</code>本身，所以实现起来比快速排序简单很多，我们使用两个指针<code>i</code>和<code>j</code>，只要<code>nums[i]!=0</code>，我们就交换<code>nums[i]</code>和<code>nums[j]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针交换</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前元素不等于0.就把它交换到左边</span></span><br><span class="line">            <span class="comment">// 等于0就交换到右边</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-283-移动零&quot;&gt;&lt;a href=&quot;#Leecode-283-移动零&quot; class=&quot;headerlink&quot; title=&quot;Leecode-283-移动零&quot;&gt;&lt;/a&gt;Leecode-283-&lt;a href=&quot;https://leetcode-cn.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动零&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1,0,3,12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,3,12,0,0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在原数组上操作，不能拷贝额外的数组。&lt;/li&gt;
&lt;li&gt;尽量减少操作次数。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="快速排序" scheme="http://zhuuu.work/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-387-字符串中的第一个唯一字符</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</id>
    <published>2020-06-12T06:13:53.000Z</published>
    <updated>2020-06-14T09:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-387-字符串中的第一个唯一字符"><a href="#Leecode-387-字符串中的第一个唯一字符" class="headerlink" title="Leecode-387-字符串中的第一个唯一字符"></a>Leecode-387-<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">字符串中的第一个唯一字符</a></h1><h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;</span><br><span class="line">返回 0</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">返回 2</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路：哈希表-1"><a href="#思路：哈希表-1" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><ul><li>第一次遍历：遍历一遍字符串，把所有的字符串及对应的出现次数存入哈希表中。</li><li>第二次遍历：遍历一遍字符串，去哈希表中检查出现次数为1的字符在不在哈希表中，并且返回它的索引。</li></ul><p><strong>举例</strong></p><ol><li><strong>存入哈希表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/171457153.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/171519200.png" alt="mark"></p><ol start="2"><li>返回对应第一次出现次数为1的索引</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/171557448.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对应的字符存入hash表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                map.put(s.charAt(i),map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(s.charAt(i),<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串 去哈希表中查找对应元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(s.charAt(i)) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找不到返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(n)  遍历两次的时间复杂度 </li><li>空间复杂度：O(n)  哈希表的额外空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-387-字符串中的第一个唯一字符&quot;&gt;&lt;a href=&quot;#Leecode-387-字符串中的第一个唯一字符&quot; class=&quot;headerlink&quot; title=&quot;Leecode-387-字符串中的第一个唯一字符&quot;&gt;&lt;/a&gt;Leecode-387-&lt;a href=&quot;https://leetcode-cn.com/problems/first-unique-character-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字符串中的第一个唯一字符&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：哈希表&quot;&gt;&lt;a href=&quot;#思路：哈希表&quot; class=&quot;headerlink&quot; title=&quot;思路：哈希表&quot;&gt;&lt;/a&gt;思路：哈希表&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s &amp;#x3D; &amp;quot;leetcode&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s &amp;#x3D; &amp;quot;loveleetcode&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-面试题09-用两个栈实现队列</title>
    <link href="http://zhuuu.work/2020/06/11/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9809-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://zhuuu.work/2020/06/11/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9809-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-06-11T09:52:53.000Z</published>
    <updated>2020-07-20T06:41:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-剑指-Offer-09-用两个栈实现队列"><a href="#Leetcode-剑指-Offer-09-用两个栈实现队列" class="headerlink" title="Leetcode-剑指 Offer 09. 用两个栈实现队列"></a>Leetcode-<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>用两个栈实现一个队列。</p></li><li><p>队列的声明如下，请实现它的两个函数<code>appendTail</code>和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p></li></ul><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：两个栈实现队列"><a href="#方法：两个栈实现队列" class="headerlink" title="方法：两个栈实现队列"></a>方法：两个栈实现队列</h2><p><strong>遇到的问题</strong></p><ul><li><strong>栈无法实现队列的功能：</strong>栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈</li><li><strong>双栈可以实现列表的倒序</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设有含三个元素的栈 </span><br><span class="line">A &#x3D; [1,2,3] 和空栈 B &#x3D; []。</span><br><span class="line">若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A &#x3D; [] , B &#x3D; [3,2,1]，即 栈 B 元素实现栈 A 元素倒序 。</span><br></pre></td></tr></table></figure><ul><li><strong>利用栈B删除队首元素：倒序后，B执行出栈就相当于删除了A的栈底元素，即对应队首元素</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/141348516.png" alt="mark"></p><p><strong>算法：</strong></p><ul><li>题目只要求实现 <strong>加入队尾</strong><code>appendTail()</code> 和 <strong>删除队首</strong><code>deleteHead()</code> 两个函数的正常工作<ul><li><strong>因此我们可以设计栈A用于加入队尾的操作，栈B用于将元素倒序，从而实现删除队首的元素。</strong></li><li><strong>加入队尾<code>appendTail()</code> 将数字val加入到栈<code>A</code>即可</strong></li><li><strong>删除队首<code>deleteHead()</code> 有以下三种情况</strong><ul><li>栈B不为空：说明B中有已完成倒序的元素，因此直接返回B的栈顶元素</li><li>栈B为空，A也为空：说明两个栈都为空，没有元素存在，返回-1</li><li>栈B为空，A不为空：将栈A元素全部转移至栈B。实现元素的倒序，并返回栈B的栈顶元素</li></ul></li></ul></li></ul><p>举个例子:</p><ol><li><code>appendTail()</code></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142609731.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142654422.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142707058.png" alt="mark"></p><ol start="2"><li><code>deleteHead()</code></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142731670.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142740386.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142749930.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142758957.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142807413.png" alt="mark"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作，只需要在A栈最后添加元素即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 如果B不是空的，删除B的最后一个元素并返回</span></span><br><span class="line">        <span class="keyword">if</span> (!B.isEmpty()) <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        <span class="comment">// 2. 如果A空了，说明还没有入队，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 3. 如果A不是空的，B不断添加A的栈顶（相当于B是A的倒序）</span></span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            B.addLast(A.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除B的最后一个元素返回即可</span></span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)  <code>appendTail()</code> 函数为O(1) ,<code>deleteHead</code> 要完成N个元素的倒序</li><li>空间复杂度 : O(n) 。 最差情况下 栈A 栈B共要保存n个元素</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-剑指-Offer-09-用两个栈实现队列&quot;&gt;&lt;a href=&quot;#Leetcode-剑指-Offer-09-用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-剑指 Offer 09. 用两个栈实现队列&quot;&gt;&lt;/a&gt;Leetcode-&lt;a href=&quot;https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 09. 用两个栈实现队列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用两个栈实现一个队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队列的声明如下，请实现它的两个函数&lt;code&gt;appendTail&lt;/code&gt;和 &lt;code&gt;deleteHead&lt;/code&gt; ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;CQueue&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[3],[],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,3,-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;CQueue&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[],[5],[2],[],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,-1,null,null,5,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-190-颠倒的二进制位</title>
    <link href="http://zhuuu.work/2020/06/11/Leetcode/Leetcode-190-%E9%A2%A0%E5%80%92%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://zhuuu.work/2020/06/11/Leetcode/Leetcode-190-%E9%A2%A0%E5%80%92%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</id>
    <published>2020-06-11T07:32:53.000Z</published>
    <updated>2020-06-13T07:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-190-颠倒二进制位"><a href="#Leetcode-190-颠倒二进制位" class="headerlink" title="Leetcode-190-颠倒二进制位"></a>Leetcode-190-<a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">颠倒二进制位</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：10111111111111111111111111111111</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class="line">     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br></pre></td></tr></table></figure><h2 id="思路：逐位颠倒"><a href="#思路：逐位颠倒" class="headerlink" title="思路：逐位颠倒"></a>思路：逐位颠倒</h2><ul><li>在面试的时候逐位颠倒作为最直接的解决方案。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/153644249.png" alt="mark"></p><ul><li>对于十进制而言(反转)<ul><li>十进制：<code>ans = ans * 10 + n % 10; n = n / 10;</code></li><li>二进制：<code>ans = ans * 2 + n % 2; n = n / 2;</code></li></ul></li></ul><p><strong>但是：</strong></p><ul><li>这种写法会有整型溢出，Java的整数溢出后的二进制数会变成负数（补码的形式），Java中负数除以2会向0取整，参考：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a></li><li>所以综上所述，要使用位运算来避免溢出问题，同时循环32次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于十进制而言</span></span><br><span class="line"><span class="comment"> *  ans = ans * 10 + n % 10 ; n = n /10;</span></span><br><span class="line"><span class="comment"> * 对于二进制而言</span></span><br><span class="line"><span class="comment"> *  ans = ans * 2 + n % 2 ; n = n /2;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  * 对于二进制而言</span></span><br><span class="line">        <span class="comment">// *  ans = ans * 2 + n % 2 ; n = n /2;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ans = (ans &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/155935426.png" alt="mark"></p><p><strong>时间复杂度</strong>：O(logn)   这里32位所以是O(1) </p><p><strong>空间复杂度</strong>： O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-190-颠倒二进制位&quot;&gt;&lt;a href=&quot;#Leetcode-190-颠倒二进制位&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-190-颠倒二进制位&quot;&gt;&lt;/a&gt;Leetcode-190-&lt;a href=&quot;https:/
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="进制转换" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-168 &amp;&amp; 171-Excel表</title>
    <link href="http://zhuuu.work/2020/06/10/Leetcode/Leetcode-168&amp;&amp;171-Excel%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/06/10/Leetcode/Leetcode-168&amp;&amp;171-Excel%E8%A1%A8/</id>
    <published>2020-06-10T07:52:53.000Z</published>
    <updated>2020-06-11T07:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-168-amp-amp-171-Excel表"><a href="#Leetcode-168-amp-amp-171-Excel表" class="headerlink" title="Leetcode-168 &amp;&amp; 171-Excel表"></a>Leetcode-168 &amp;&amp; 171-Excel表</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>这两道题本质上就是进制转换，把10进制转换成26禁止表示。</p><p>关于进制转换：<a href="https://zhuanlan.zhihu.com/p/75006709" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75006709</a></p><h2 id="Leetcode-168-Excel表列名称"><a href="#Leetcode-168-Excel表列名称" class="headerlink" title="Leetcode 168 Excel表列名称"></a>Leetcode 168 <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">Excel表列名称</a></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;A&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 28</span><br><span class="line">输出: &quot;AB&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 701</span><br><span class="line">输出: &quot;ZY&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h3><p><strong>首先讨论一下10进制和16进制的转换</strong></p><ul><li>16 进制中，0 到 9 还是正常的数字，然后增加字母 A 表示 10，字母 B 表示 11… 以此类推，直到 F 表示 15，所以我们各个位的取值范围是 0 - 15 。</li><li>假如16进制的<code>A1F</code> 转换成16进制就是下边的式子</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/151121423.png" alt="mark"></p><ul><li>那么假如我们知道的是 <code>10</code> 进制的 <code>2591</code>，怎么转为 <code>16</code> 进制呢？<ul><li>我们把上边的等式一般化，设我们要求的每一位分别是 <code>x1,x2,x3...</code>，事先我们并不知道有多少位。</li><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/151303783.png" alt="mark"></li><li>我们可以同时在等式的两边模上<code>16</code>,等式就变成了</li><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/151458546.png" alt="mark"></li><li>这样我们就求出了<code>x1</code> ,接下来我们在等式的两边同时除以<code>16</code>。等式左边由于 <code>x1</code> 的范围是 <code>0 - 15</code>，所以在整数间运算不管 <code>x1</code> 是多少，<code>x1/16</code> 都等于 <code>0</code>，所以等式就变成了下边的样子</li><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/151621890.png" alt="mark"></li><li>接下来哦我们就可以重复上边的两个步骤，模16和除16，就可以依次算出<code>x2 , x3</code>了,直到除以16以后变成 0 就可以结束了。</li></ul></li><li>对于10 进制 转26 进制也是一样的道理，只不过我们每次都是模26和除26。 </li></ul><h3 id="3-题解"><a href="#3-题解" class="headerlink" title="3. 题解"></a>3. 题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出对应数字的序列号</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里参考leetcode171 ，因为正着计算加一 所以这里反着需要减一</span></span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 获得当前数字对应的字符 并加入到 StringBuffer中</span></span><br><span class="line">            sb.append((<span class="keyword">char</span>)(<span class="string">'A'</span> + (n % <span class="number">26</span>)));</span><br><span class="line">            <span class="comment">// 向下退一位</span></span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序输出字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述唯一不一样的地方是：</strong></p><ul><li><strong>对于Excel来说 ， x1,x2,x3的取值范围都是0-25。 所以在除以26之前，我们需要将对应的数减去1在进行模运算。</strong></li></ul><h2 id="Leetcode-171-Excel表列序号"><a href="#Leetcode-171-Excel表列序号" class="headerlink" title="Leetcode 171 Excel表列序号"></a>Leetcode 171 <a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">Excel表列序号</a></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p><p>例如，</p><pre><code>A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ...</code></pre><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A&quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;AB&quot;</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;ZY&quot;</span><br><span class="line">输出: 701</span><br></pre></td></tr></table></figure><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h3><ul><li><p>这里是26进制转换成10进制 （也就是需要乘上26）</p></li><li><p>以ZY为例，Z的值为26，Y的值为25，则结果为<code>26 * 26 + 25=701</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 算出当前i索引对应的字母值</span></span><br><span class="line">            <span class="keyword">int</span> num = s.charAt(i) - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 向前进一位</span></span><br><span class="line">            sum = sum * <span class="number">26</span> + num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>： O（n） 遍历一边字符串</li><li><strong>空间复杂度</strong>: O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-168-amp-amp-171-Excel表&quot;&gt;&lt;a href=&quot;#Leetcode-168-amp-amp-171-Excel表&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-168 &amp;amp;&amp;amp; 171-Excel表&quot;&gt;&lt;/a&gt;Leetcode-168 &amp;amp;&amp;amp; 171-Excel表&lt;/h1&gt;&lt;h2 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h2&gt;&lt;p&gt;这两道题本质上就是进制转换，把10进制转换成26禁止表示。&lt;/p&gt;
&lt;p&gt;关于进制转换：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/75006709&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/75006709&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-168-Excel表列名称&quot;&gt;&lt;a href=&quot;#Leetcode-168-Excel表列名称&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 168 Excel表列名称&quot;&gt;&lt;/a&gt;Leetcode 168 &lt;a href=&quot;https://leetcode-cn.com/problems/excel-sheet-column-title/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Excel表列名称&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h3&gt;&lt;p&gt;给定一个正整数，返回它在 Excel 表中相对应的列名称。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 -&amp;gt; A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 -&amp;gt; B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 -&amp;gt; C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26 -&amp;gt; Z&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27 -&amp;gt; AA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28 -&amp;gt; AB &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;A&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;AB&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 701&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;ZY&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="进制转换" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-191-位1的个数</title>
    <link href="http://zhuuu.work/2020/06/10/Leetcode/Leetcode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/06/10/Leetcode/Leetcode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2020-06-10T03:00:53.000Z</published>
    <updated>2020-06-10T03:06:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-191-Number-of-1-Bits"><a href="#Leetcode-191-Number-of-1-Bits" class="headerlink" title="Leetcode-191-Number of 1 Bits"></a>Leetcode-191-<a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">Number of 1 Bits</a></h1><h2 id="思路：位运算"><a href="#思路：位运算" class="headerlink" title="思路：位运算"></a>思路：位运算</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：-按位与1"><a href="#方法：-按位与1" class="headerlink" title="方法： 按位与1"></a>方法： 按位与1</h2><ul><li>这个方法比较直接。我们遍历数字的 32 位。如果某一位是 1 ，将计数器加一。</li><li><strong>重点：任何数字跟掩码1进行逻辑与运算，都可以让我们获得这个数字的最低位。当检查下一位时候，我们将掩码左移一位</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"><span class="comment"># 左移一位</span></span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查二进制每一位1的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化掩码是1</span></span><br><span class="line">        <span class="keyword">int</span> bitmask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; bitmask) != <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次掩码向左移动一位</span></span><br><span class="line">            bitmask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(1) 。 因为本题最大数字长度是32位，所以运行时间是O(1)的。</li><li>空间复杂度：O(1)  没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-191-Number-of-1-Bits&quot;&gt;&lt;a href=&quot;#Leetcode-191-Number-of-1-Bits&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-191-Number of 1 Bits&quot;&gt;&lt;/a&gt;Leetcode-191-&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-1-bits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Number of 1 Bits&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：位运算&quot;&gt;&lt;a href=&quot;#思路：位运算&quot; class=&quot;headerlink&quot; title=&quot;思路：位运算&quot;&gt;&lt;/a&gt;思路：位运算&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为&lt;a href=&quot;https://baike.baidu.com/item/汉明重量&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明重量&lt;/a&gt;）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：00000000000000000000000000001011&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &amp;#39;1&amp;#39;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：00000000000000000000000010000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &amp;#39;1&amp;#39;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：11111111111111111111111111111101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &amp;#39;1&amp;#39;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式-详细总结</title>
    <link href="http://zhuuu.work/2020/06/09/GoF23/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>http://zhuuu.work/2020/06/09/GoF23/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-09T11:02:24.000Z</published>
    <updated>2020-07-13T13:37:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="23种设计模式-详细总结"><a href="#23种设计模式-详细总结" class="headerlink" title="23种设计模式-详细总结"></a>23种设计模式-详细总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200610/221023280.png" alt="mark"></p><ul><li>设计模式是解决问题的方案，学习现有的设计模式可以做到经验的复用</li><li>拥有设计模式的词汇，在沟通是就能用到更少的词汇来讨论，并且不需要知道底层的细节</li></ul><p><strong>话在前头：</strong></p><ol><li>什么是好的设计模式？</li></ol><ul><li>提高复用</li><li>应对变化</li></ul><ol start="2"><li>在什么时候，什么地方使用设计模式？</li></ol><ul><li><p><strong>在需求频繁变化的变化点使用设计模式</strong></p></li><li><p><strong>Refactoring to Patterns(重构的方式一步一步到模式)</strong></p></li></ul><p>重构的关键方法：</p><ol><li>静态 -&gt; 动态</li><li>早绑定 -&gt; 晚绑定</li><li>继承 -&gt; 组合</li><li>编译时依赖 -&gt; 运行时依赖</li><li>紧耦合 -&gt; 松耦合</li></ol><a id="more"></a><h3 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1. 设计原则"></a>1. 设计原则</h3><h4 id="1-1-依赖倒置原则-DIP"><a href="#1-1-依赖倒置原则-DIP" class="headerlink" title="1.1 依赖倒置原则(DIP)"></a>1.1 依赖倒置原则(DIP)</h4><ul><li><p>Dependence Inversion Principle，缩写DIP</p></li><li><p>高层次的模块不依赖于低层次模块的实现细节</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>细节应该依赖抽象</li><li>抽象不应该依赖细节</li></ul></li></ul><p>是不是觉得和没说一个样，至少我是这么觉得的；继续往后看才明白，</p><ul><li>所谓高层模块就是调用端</li><li>低层模块就是具体的实现类</li><li><strong>依赖倒置原则在java中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系</strong><ul><li><strong>也就是通过接口或者抽象类产生依赖关系（调用关系）</strong></li><li><strong>也就是面向接口编程或者说面向抽象编程</strong></li></ul></li></ul><p>其实依赖倒置原则主要目的就是解耦</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/211520692.png" alt="mark"></p><p>可以使用这张图来表示，表达出来就是<code>ImageLoader</code>和<code>MemonyCache</code>等并没有直接关系，甚至<code>ImageLoader</code>只需要实现<code>ImageCache</code>类或继承其他已有的<code>ImageCache</code>子类完成相应的缓存功能，然后将具体的实现注入到<code>ImageLoader</code>即可实现缓存功能的替换。这也是依赖倒置原则的体现。</p><h4 id="1-2-开闭原则（OCP）"><a href="#1-2-开闭原则（OCP）" class="headerlink" title="1.2 开闭原则（OCP）"></a>1.2 开闭原则（OCP）</h4><ul><li><p>Open Close Principle，缩写OCP</p></li><li><p>定义：软件中得对象应该对于扩展是开放的，但是对于修改是封闭的。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/211520692.png" alt="mark"></p><p><strong>简单地说，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</strong></p><p>“应该尽量”4个字说明OCP原则并不是说绝对不可以修改原始类的，当代码需要需要重构的时候要及时重构，使代码恢复正常，而不是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。</p><h4 id="1-3-单一职责原则（SRP）"><a href="#1-3-单一职责原则（SRP）" class="headerlink" title="1.3 单一职责原则（SRP）"></a>1.3 单一职责原则（SRP）</h4><ul><li>单一职责原则，就一个类而言，应该只有一个引起它变化的原因。</li><li>简单说，<strong>一个类</strong>应该是一组<strong>高度相关的函数</strong>、数据的封装；也就是高内聚。</li><li>Single Responsibility Principle，缩写SRP</li></ul><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">//图片缓存</span></span><br><span class="line">    LruCache&lt;String,Bitmap&gt; mImageCache;</span><br><span class="line">    <span class="comment">//线程池，线程数量为CPU的数量</span></span><br><span class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProessors());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        initImageCache();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略...         </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//显示图片</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//下载图片</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出来 <code>ImageLoader</code> 类作用有初始化图片缓存、显示图片、下载图片，显然显示图片和下载图片两个方法与初始化图片缓存方法相比作用就显得有些不相关。(也就是不符合单一职责原则)。</p><p>按照逻辑进行拆分后得到<code>ImageLoader</code>和<code>ImageCache</code>两个类。</p><ul><li><code>ImageLoader</code>负责图片加载逻辑</li><li><code>ImageCache</code>负责处理图片缓存逻辑</li><li>这样职责就很清楚了，当与缓存相关的逻辑需要改变时，不需要修改<code>ImageLoader</code>类，而图片加载的逻辑需要修改时也不会影响到缓存处理逻辑。</li></ul><p>修改后代码如下所示：</p><ul><li>添加的<code>ImageCache</code>类用于处理图片缓存，具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图片LRU缓存</span></span><br><span class="line">    LruCache&lt;String, Bitmap&gt; mImageCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initImageCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        mImageCache.put(url, bitmap) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImageCache.get(url) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ImageLoader</code>代码修改如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 图片加载类 */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//图片缓存</span></span><br><span class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache() ;</span><br><span class="line">    <span class="comment">//线程池,线程数量为CPU的数量</span></span><br><span class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-里氏替换原则-LSP"><a href="#1-4-里氏替换原则-LSP" class="headerlink" title="1.4 里氏替换原则 (LSP)"></a>1.4 里氏替换原则 (LSP)</h4><ul><li>Liskov Substitution Principle</li><li>里氏替换原则，书上原话的定义简直看不得（解释的辣眼睛，完全看不懂），简单的来说就是所有引用基类的地方必须能透明的时候其子类的对现象。只要父类能出现的地方子类就能出现，而且替换成子类也不会产生任何的错误和异常。使用者可能根本就不需要知道是父类还是子类。</li><li>但是，反过来就不行了，有子类出现的地方，父类未必就能适应。其实就是：抽象。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/145239391.png" alt="mark"></p><ul><li>上图可以看出，<code>Window</code>依赖于<code>View</code>，而<code>Button</code>和<code>TextView</code>继承<code>View</code>。这里任何继承自<code>View</code>类的子类都可以设置给<code>show()</code>方法，也就是<strong>里氏替换原则</strong>。</li><li>通过里氏替换，就可以自定义各式各样的View，然后传递给Window，并且将View显示到屏幕上。</li></ul><p><strong>里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，继承的优缺点都相当明显</strong></p><p>优点：</p><ul><li>代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性</li><li>子类与父类基本相似，但又与父类有所区别</li><li>提高代码的可扩展性</li></ul><p>缺点：</p><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法</li><li>可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法</li></ul><p>事物总是具有两面性，如何权衡利与弊都是需要根据具体场景来做出选择并加以处理。</p><h4 id="1-5-接口隔离原则（ISP）"><a href="#1-5-接口隔离原则（ISP）" class="headerlink" title="1.5 接口隔离原则（ISP）"></a>1.5 接口隔离原则（ISP）</h4><ul><li><p>Interface Segregation Principle</p></li><li><p>接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口；目的就是解耦。</p></li><li><p>这个原则的做法和单一职责有点相似，就是说接口中的方法保持更高的相关性，尽量少，避免调不需要的方法。</p></li><li><p><strong>java中类尽量不使用public</strong></p></li></ul><h4 id="1-6-迪米特法则（LOP）"><a href="#1-6-迪米特法则（LOP）" class="headerlink" title="1.6 迪米特法则（LOP）"></a>1.6 迪米特法则（LOP）</h4><ul><li><p>Law of Principle</p></li><li><p>迪米特法则还有一个英文解释是：Only talk to your immedate friends，翻译过来就是：只与直接的朋友通信。（什么叫做直接的朋友，每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系类型有很多，例如：组合，聚合，依赖等）</p></li><li><p>迪米特原则也称为最少知识原则（Least Knowledge Principle），定义：一个对象应该对其他对象有最少的了解。通俗地讲，一个类要对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者（或依赖者）没关系，调用者（或依赖者）只需要知道他需要的方法即可，其他的不需要关心。</p></li><li><p>类与类之间的关系越密切，耦合度越大；当一个类发生改变时，对另一个类的影响也越大。</p></li></ul><h2 id="一-创建型"><a href="#一-创建型" class="headerlink" title="一 . 创建型"></a>一 . 创建型</h2><h3 id="1-原型模式（Prototype）"><a href="#1-原型模式（Prototype）" class="headerlink" title="1. 原型模式（Prototype）"></a>1. 原型模式（Prototype）</h3><ul><li><p>使用原型实例指定要创建对象的类型，通过<strong>复制这个原型来创建新对象。</strong></p></li><li><p>简单来说，其实就是当需要创建一个指定对象的时候，我们刚好有这样一个对象，但是又不能直接使用这个对象，那么我就会<strong>clone</strong> 一个一模一样的对象，基本上这就是原型模型</p></li><li><p><strong>关键字： clone</strong></p></li></ul><p>这些场景可能派的上用场</p><ul><li>当new一个对象时，非常繁琐复杂时，可以使用原型模式来进行复制一个对象。即使需求的变更，这些对象需要作出调整，我们依然拥有比较稳定一致的接口创建对象。</li><li>需要提供数据对象，同时有需要避免外部对数据对象进行修改。</li></ul><p><strong>简单的UML类图</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200610/221312940.webp" alt="mark"></p><p><strong>角色：</strong></p><ul><li><code>client</code> ： 使用者</li><li><code>Prototype</code> : 接口（抽象类），声明具备clone 能力，例如Java中的<code>Cloneable</code> 接口</li><li><code>ConcretePrototype</code>： 具体的原型类</li></ul><p><strong>关于浅拷贝和深拷贝：</strong></p><ul><li><strong>浅拷贝</strong>：一个对象通过赋值的形式直接传递的其实是对象在内存中的内存地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList&lt;String&gt; b = a;</span><br><span class="line"><span class="comment">//当修改a时，b的值同样会被修改</span></span><br></pre></td></tr></table></figure><p>以上的代码就是浅拷贝，从某种角度来说，<strong>这种浅拷贝的方式并不合适在原型模式中使用，更多情况下我们需要一个不会影响原始对象的一个新对象，也就需要使用到深拷贝</strong></p><ul><li><strong>深拷贝</strong>：一个不会影响原始对象的一个新对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList&lt;String&gt; b = a.clone();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">ArrayList&lt;String&gt; c = <span class="keyword">new</span> ArrayList(a);</span><br></pre></td></tr></table></figure><p>上面代码的</p><p><strong>第一种方式</strong>，是使用<code>Object</code> 类的<code>super.clone()</code>方法来使用实现拷贝的过程。</p><p><strong>第二种方式</strong>：使用a在创建了一个新的对象并且赋值给c ， 这样a和 c是两个值相同的两个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList的clone()方法代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：通过实现<code>Cloneable</code>接口的原型模式在调用<code>clone()</code> 方法构造实例并不一定比new操作速度快，只有new 对象操作复杂且耗时成本较高的时候，clone方法才有效率上的提升。</p><p><strong>简单实现</strong></p><ol><li>Prototype</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Prototype <span class="title">myclone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>ConcretePrototype</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype</span><span class="params">(String filed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Prototype <span class="title">myclone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototype(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ConcretePrototype&#123;"</span> +</span><br><span class="line">                <span class="string">"filed='"</span> + filed + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Client</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype(<span class="string">"abc"</span>);</span><br><span class="line">        Prototype clone = prototype.myclone();</span><br><span class="line">        System.out.println(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29" target="_blank" rel="noopener">java.lang.Object#clone()</a></li></ul><h3 id="2-生成器（Builder）"><a href="#2-生成器（Builder）" class="headerlink" title="2. 生成器（Builder）"></a>2. 生成器（Builder）</h3><ul><li>封装一个对象的构造过程，并允许按照步骤构造。</li><li>Builder 模式也就是<strong>建造者模式</strong>，先说定义，<strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</strong><ul><li>首先，将复杂对象的创建过程和部件分离出来，其实就是把创建过程和自身的部件解耦，使得构建过程和部件都可以自由扩展，两者之间的耦合度降到最低。</li><li>然后，再是相同的构建过程可以创建不同的表示，相同的组合也可以通过不同的部件创建出不同的对象。</li></ul></li></ul><p><strong>可能使用的场景</strong></p><ul><li>相同的方法，不同的执行顺序，产生不同的结果</li><li>多个部件（代码中就对应类的属性），都可以装配到同一个对象中，但是产生的结果又不相同的时候</li><li>初始化一个对象特别复杂，参数多且很多参数都有默认值的时候。</li></ul><p><strong>实现</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/114543747.webp" alt="mark"></p><ul><li>Product  : 抽象的产品类。</li><li>Builder : 抽象的Builder 类，规范产品的组件。</li><li>ConcreteBuilder  :  具体的Builder类，实现具体的组件过程。</li><li>Director : 统一组装的过程。</li></ul><ol><li>手机配置简化的抽象类，设置CPU、OS以、内存大小以及运存大小</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这是一个手机配置简化的抽象类，</span></span><br><span class="line"><span class="comment">// 设置CPU、OS以、内存大小以及运存大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String mCPU;</span><br><span class="line">    <span class="keyword">protected</span> String mOS;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mMemorySize;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mStorageSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setmCPU</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setmOS</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmMemorySize</span><span class="params">(<span class="keyword">int</span> mMemorySize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemorySize = mMemorySize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmStorageSize</span><span class="params">(<span class="keyword">int</span> mStorageSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mStorageSize = mStorageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Phone&#123;"</span> +</span><br><span class="line">                <span class="string">"mCPU='"</span> + mCPU + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", mOS='"</span> + mOS + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", mMemorySize="</span> + mMemorySize +</span><br><span class="line">                <span class="string">", mStorageSize="</span> + mStorageSize +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>具体的IPhoneX的类，由于CPU和系统是固定，而内存和运存运存可选。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体的IPhoneX的类，</span></span><br><span class="line"><span class="comment">// 由于CPU和系统是固定，而内存和运存运存可选。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhoneX</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPhoneX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCPU = <span class="string">"A11"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOS = <span class="string">"iOS 11"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>抽象的Builder类，作为主要隔离作用的类，<strong>Phone的API每一个方法都有对应的builder方法，并且都返回自身来实现链式API</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象的Builder类，作为主要隔离作用的类，</span></span><br><span class="line"><span class="comment">// Phone的API的每一个方法都有对应的build方法，并都返回自身来实现链式API。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置CPU</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">buildCPU</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设置系统</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">buildOS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设置运存大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">buildMemorySize</span><span class="params">(<span class="keyword">int</span> memorySize)</span></span>;</span><br><span class="line">    <span class="comment">//设置储存大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">buildStorageSize</span><span class="params">(<span class="keyword">int</span> storageSize)</span></span>;</span><br><span class="line">    <span class="comment">//创建一个Phone对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>IPhoneXBuilder</code>，具体的<code>Builder</code>类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPhoneXBuilder，具体的Builder类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhoneXBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IPhoneX mIPhoneX = <span class="keyword">new</span> IPhoneX();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">buildCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mIPhoneX.setmCPU();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mIPhoneX.setmOS();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">buildMemorySize</span><span class="params">(<span class="keyword">int</span> memorySize)</span> </span>&#123;</span><br><span class="line">        mIPhoneX.setmMemorySize(memorySize);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">buildStorageSize</span><span class="params">(<span class="keyword">int</span> storageSize)</span> </span>&#123;</span><br><span class="line">        mIPhoneX.setmStorageSize(storageSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意一定要返回一个具体的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mIPhoneX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Director：负责指挥phone的建造顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Director类，负责构造Phone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Builder mBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder Builder)</span> </span>&#123;</span><br><span class="line">        mBuilder = Builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">int</span> memorySize,<span class="keyword">int</span> StorageSize)</span></span>&#123;</span><br><span class="line">        mBuilder.buildCPU().</span><br><span class="line">                buildOS().</span><br><span class="line">                buildMemorySize(memorySize).</span><br><span class="line">                buildStorageSize(StorageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>客户端测试：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> IPhoneXBuilder();</span><br><span class="line"></span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line"></span><br><span class="line">        director.construct(<span class="number">6</span>,<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(builder.create().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再来一个JDK中简易的实现 (StringBuilder)</strong></p><ol><li><code>AbstractStringBuilder</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractStringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">            expandCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minimumCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">            newCapacity = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>StringBuilder</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Client:测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) (<span class="string">'a'</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());  <span class="comment">// abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中Builder模式的具体实现</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener">java.lang.StringBuilder</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener">java.nio.ByteBuffer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener">java.lang.StringBuffer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener">java.lang.Appendable</a></li><li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder" target="_blank" rel="noopener">Apache Camel builders</a></li></ul><h3 id="3-工厂模式（Factory）"><a href="#3-工厂模式（Factory）" class="headerlink" title="3. 工厂模式（Factory）"></a>3. 工厂模式（Factory）</h3><ul><li>顾名思义，工厂模式就是生产产品的！</li><li>工厂模式(Factory Pattern) 提供了一种<strong>创建对象的最佳方式，属于创建型模式。</strong></li><li>在工厂模式中，创建对象时不会对客户端暴露创建逻辑，并且是通过一个共同的接口来指定新创建的对象。<strong>（绕开了new）</strong></li></ul><p><strong>大致描述：</strong></p><ul><li>将上述思想对应到code中，工厂模式需要做的就是帮助我们构建对象，因为构建对象的过程可能比较复杂，我们无法掌握（例如：无法直接new 出来）。这是对工厂模式的一个大致描述，接下来可以从实现方式来说明。</li></ul><h4 id="3-1-简单工厂模式（Simple-Factory）"><a href="#3-1-简单工厂模式（Simple-Factory）" class="headerlink" title="3.1 简单工厂模式（Simple Factory）"></a>3.1 简单工厂模式（Simple Factory）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂模式的大致模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 商品B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 商品C</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductC</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先，简单工厂模式并没有被归纳到23中GOF设计模式中，其实可以理解为工厂模式的简单使用。</li><li><strong>一个工厂对象决定创建出哪一种类产品</strong>，而产品有不同的系列相互之间有些许差异。举个生产鞋的例子，先看UML图</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/092602806.webp" alt="mark"></p><p>大致可以分为三部分：工厂类，抽象产品类，具体的产品类</p><ul><li>Factory : 工厂类，生产shoe</li><li>Shoe : 抽象的产品类</li><li>SportShoe : 具体的产品，运动鞋</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 鞋的抽象类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shoe</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 运动鞋 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SportShoe</span> <span class="keyword">extends</span> <span class="title">Shoe</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 工厂类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是最简单的工厂，但是一个只生产运动鞋的工厂，老板想去赚更多的钱，要求添加生成<code>HighHeeledShoe</code>(高跟鞋)。我们需要对<code>ShoeFactory</code>的设计进行修改，如图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/092542993.webp" alt="mark"></p><p>改造后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在produceShoe()的函数中添加了type参数，</span></span><br><span class="line"><span class="comment">// 表示Shoe的不同类型，以此来生产不同的鞋子。我们开始改造ShoeFactory类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 高跟鞋 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighHeeledShoe</span> <span class="keyword">extends</span> <span class="title">Shoe</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 修改后的工厂类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"highHeeled"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HighHeeledShoe();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以根据给定的不同类型生产对应鞋子了。这里看到代码可能会有两个问题</p><ul><li>第一：每次添加一个品牌需要加一个case(虽然现实中是很正常的逻辑。但是在代码层面并不优雅)。同时，<strong>简单工厂模式违反了开闭原则，即对扩展开放，对修改关闭；因为增加了具体产品，就需要修改对应工厂类代码；</strong></li><li>第二：调用<code>produceShoe（）</code>的时候，我们还需要去创建一个Factory对象并进行控制管理<ul><li><strong>直接new出<code>Factory</code>的对象</strong>（如<code>return new SportShoe();</code>），我们就必须自己控制工厂类的构造和生成，同时我们也需要非常清楚工厂的构造函数（比如构造函数有多少个参数，输入参数时有什么条件等等），还需要知道工厂的内部细节，一旦工厂扩展或者改变了，就很可能不知道怎么调用了，对于调用者来说无疑会是噩梦。</li></ul></li></ul><p><strong>优化问题：</strong></p><ul><li>先优化第一个问题：从技术的层面我们不使用<code>swith case</code> 这种形式来实现不同类型的对象创建，我们<strong>使用反射就可以实现优化（编译期到运行期）</strong></li><li>对于第二个问题：最直接的解决方案就是我们直接调用生产鞋子的方法，直接告诉工厂再由工厂生产，这样我们就不需要创建工厂。（那就是给<code>produceShoe()</code>函数添加<code>static</code>关键字就可以解决问题了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 优化后的工厂类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类型生产鞋子</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shoe <span class="title">produceShoe</span><span class="params">(Class&lt;? extends Shoe&gt; cls)</span></span>&#123;</span><br><span class="line">        Shoe shoe = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            shoe = (Shoe) Class.forName(cls.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shoe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样一来问题就解决了</strong></p><ul><li>用静态方法则完全不用关心如何构造对象，我们需要关心工厂的构造细节，即使工厂内部发生变化也不需要关心</li><li>简单工厂模式主要适用于创建抽象子类的业务相同但具体实现不同的对象的情况。</li></ul><h4 id="3-2-工厂方法模式"><a href="#3-2-工厂方法模式" class="headerlink" title="3.2 工厂方法模式"></a>3.2 工厂方法模式</h4><ul><li>实际上，制造鞋子的厂商一定不会只有一家，肯定存在多家竞争的关系，所以有更多的制造不同鞋子的工厂，<code>produceShoe</code>函数就可以抽象出来，不同的<code>Factory</code>子类根据自己的需求去实现。</li><li>例如下图的<code>NikeFactory</code>和<code>DaphneFactory</code>类</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/112053054.webp" alt="mark"></p><ul><li>相对于简单工厂，<strong>工厂方法的区别就在于工厂类分类抽象工厂和具体的实现工厂类。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 抽象工厂类 */</span></span><br><span class="line">pulibc <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/** Nike工厂类 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class NikeFactory extends Factory </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"highHeeled"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HighHeeledShoe();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Daphne工厂类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaphneFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"highHeeled"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HighHeeledShoe();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候就很简单了，只需要调用对应的工厂，选择客户需要的类型就可以获得相应的产品了，这样不同的制造商就能分别生产不同的鞋子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Factory daphneFactory = <span class="keyword">new</span> DaphneFactory();</span><br><span class="line">daphneFactory.produceShoe(<span class="string">"highHeeled"</span>);</span><br><span class="line"></span><br><span class="line">Factory nikeFactory = <span class="keyword">new</span> NikeFactory();</span><br><span class="line">nikeFactory.produceShoe(<span class="string">"sport"</span>);</span><br></pre></td></tr></table></figure><p>在工厂的环节采用抽象类的形式实现，其实也可以将<code>produceShoe</code>抽象成<code>IProduceShoe</code>接口，当然，这也是我的个人理解。其实觉得抽象类或者接口使用其中一个就可以了，不必要同时使用；但也不是绝对的，这个需要根据具体的情况而定。</p><p><strong>对应JDK中：</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--" target="_blank" rel="noopener">java.util.Calendar</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-" target="_blank" rel="noopener">java.util.ResourceBundle</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--" target="_blank" rel="noopener">java.text.NumberFormat</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-" target="_blank" rel="noopener">java.nio.charset.Charset</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-" target="_blank" rel="noopener">java.net.URLStreamHandlerFactory</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-" target="_blank" rel="noopener">java.util.EnumSet</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--" target="_blank" rel="noopener">javax.xml.bind.JAXBContext</a></li></ul><p><strong>通用形式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = factoryMethod();</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-抽象工厂模式（Abstract-Factory）"><a href="#3-3-抽象工厂模式（Abstract-Factory）" class="headerlink" title="3.3 抽象工厂模式（Abstract Factory）"></a>3.3 抽象工厂模式（Abstract Factory）</h4><ul><li>生产鞋子的厂商不一定只会生产衣服<code>cloth</code>,我们需要为了工厂添加制造衣服的这条生产线。为了工厂添加生产衣服后的UML图如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/113418278.webp" alt="mark"></p><ul><li><p><strong>将<code>ShoeFactory</code>和<code>ClothFactory</code>抽象成接口（原因：Java无法多继承，所以使用Interface）</strong></p></li><li><p>需要对应的产品就要实现工厂对应的接口。</p></li><li><p>添加<code>NikeFactory</code>中的生产衣服的功能<code>produceCloth</code>,这样也就是实现<code>NikeFactory</code>可以生产多种产品。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NikeFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"highHeeled"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HighHeeledShoe();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cloth <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportCloth();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"skirt"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Skirt();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>当你需要创建一些对象家族时候，抽象工厂也是不错的选择，因为它可以一次性创建多个对象。</strong></p></li><li><p>抽象工厂十分强大灵活（至少比前两种都要好），可以用<strong>多个抽象子类完成复杂的需求</strong>，同时保证了外界接触不到任何类型的具体产品类型，某种意思上很符合开闭原则 。</p></li><li><p>当然，缺点也显而易见，模式比较庞大，从UML图就能看出来。</p></li></ul><h4 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h4><ul><li>简单工厂<strong>只能有一个工厂生产相同类型的产品</strong></li><li>工厂方法模式<strong>只能生产一系列的产品，可以同时有不同的工厂去实现。</strong></li><li>抽象工厂模式通过<strong>实现不同的抽象方法可以生产出多个系列的产品。</strong></li></ul><h3 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4. 单例模式"></a>4. 单例模式</h3><ul><li>单例模式是应用最广泛的模式之一，定义就是<strong>单例对象的类必须保证只有一个实例存在</strong></li><li>单例模式适用于创建一个对象需要消耗过多资源的情况，例如数据库等资源是需要考虑使用的。</li></ul><p>实现单例模式关键点如下：</p><ul><li><strong>构造函数私有化（不会让你有机会再创建一个对象）</strong></li><li><strong>通过一个静态方法或枚举（后面会有举例）返回单例类对象</strong></li><li>确保单例类的对象有且只有一个,尤其是多线程的环境下(难点)</li><li>确保单例类的对象在反序列化的时候不会重新构建对象</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200313101430.png" alt=""></p><h4 id="4-1-饿汉式-线程安全"><a href="#4-1-饿汉式-线程安全" class="headerlink" title="4.1 饿汉式-线程安全"></a>4.1 饿汉式-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明对象的时候就 已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共有静态方法，对外暴露获取的途径(Getter方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-懒汉式-线程不安全"><a href="#4-2-懒汉式-线程不安全" class="headerlink" title="4.2 懒汉式-线程不安全"></a>4.2 懒汉式-线程不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 懒汉式实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象的时候不进行初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter方法加锁保证线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进入是检查有没有被创建</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉式与饿汉式不同的地方是单例对象初始化的时机,实现了懒加载</li><li>同时<code>getInstance()</code>方法前添加了<code>synchronized</code>关键字,以此来确保多线程环境下单例模式的唯一性.(相对的,每次调用<code>getInstance()</code>方法都是会进行同步的,也是懒汉式最大的问题)</li></ul><h4 id="4-3-懒汉式-DCL-线程不安全"><a href="#4-3-懒汉式-DCL-线程不安全" class="headerlink" title="4.3 懒汉式(DCL)-线程不安全"></a>4.3 懒汉式(DCL)-线程不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. DCL</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象的时候不进行初始化</span></span><br><span class="line">    <span class="comment">// volatile作用：避免指令的重排，保证原子性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重检测锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">                     instance = <span class="keyword">new</span> Singleton();  <span class="comment">// 造成问题的关键</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回对象实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到<code>getInstance()</code>方法对instance进行了两次判空,</p><ul><li>第一次判断是为了判断不必要的同步</li><li>第二次是为了判断null的情况下创建实例</li></ul></li><li><p>同时<code>instance</code>对象前面还添加了 <code>volatile</code>关键字,如果不使用<code>volatile</code>是无法保证<code>instance</code>的原子性的</p><ul><li><code>instance = new Singleton();</code>这句代码不是一个原子性操作</li><li><strong>这句代码最终会被编译成多条汇编指令，大致做了3件事：</strong></li><li><ol><li><strong>给Singleton的实例分配内存空间</strong></li><li><strong>调用<code>Singleton()</code>的构造函数,初始化成员字段</strong></li><li><strong>指向分配的内存空间(此时<code>instance</code>不为null)**</strong></li></ol></li></ul></li><li><p>由于JMM允许指令重排来保证代码效率,所以上述第二点和第三点的顺序无法保证,也就是说执行顺序可能是1-2-3或者是1-3-2。</p><ul><li>如果是1-3-2, instance 在 3 步骤的时候就已经是非空了,所以2步骤没有执行,那么另外一个线程会取走一个还没初始化完毕的实例,导致DCL失效</li><li>在JDK1.5之后，调整了JVM，具体化了<code>volatile</code>关键字。然，<code>volatile</code>或多或少会影响到性能，考虑到正确性这点性能的牺牲还是值得的。</li></ul></li><li><p><strong>DCL模式能够在绝大多数场景下保证单例对象的唯一性，资源利用率高，只有第一次加载时反应稍慢，一般能够满足需求</strong></p></li></ul><h4 id="4-4-静态内部类"><a href="#4-4-静态内部类" class="headerlink" title="4.4 静态内部类"></a>4.4 静态内部类</h4><ul><li>懒汉式的改进</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4 . 静态内部类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">   <span class="comment">// 1. 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="comment">// final：保证线程中只有一个存在</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 只有调用的时候才会加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当第一次加载<code>Singleton</code>类时并不会初始化<code>instance</code>，只有在第一次调用<code>getInstance()</code>方法是回初始化。</p></li><li><p>第一次调用<code>getInstance()</code>方法导致虚拟机加载<code>SingletonHolder</code>类，这种方式嫩确保线程安全，也能确保单例对象的唯一性，</p></li><li><p>同时也延迟了单例对象的实例化，所以推荐使用这种实现方式。</p></li></ul><h4 id="4-5-枚举单例-线程安全"><a href="#4-5-枚举单例-线程安全" class="headerlink" title="4.5 枚举单例-线程安全"></a>4.5 枚举单例-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  5.枚举单例模式</span></span><br><span class="line"><span class="keyword">public</span> enmu SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 枚举单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE; <span class="comment">//纯天然单例模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.INSTANCE;</span><br><span class="line">        Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就是这么简单粗暴，其实最大优点在于关键点的第4点，即是反序列化也不会重新生成新的实例。</li></ul><h4 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h4><p>不管哪种形式实现单例模式，核心原理都是那四个关键点，具体选择哪种实现方式取决于项目本身以及具体的开发环境等等。</p><p>而对于客户端来说通常没有高并发的情况，推荐使用DCL模式或者是静态内部类的方式实现。</p><p>优点</p><ul><li>只存在一个实例，减少了内存开支，减少了系统的性能开销</li><li>避免对资源的多重占用</li><li>全局的访问点，优化和共享资源访问</li></ul><p>缺点</p><ul><li>没有接口，难扩展，只能修改代码</li><li>如果持有Context容易导致内存泄露（需要传递Context的话最好是Application Context）</li></ul><p><strong>JDK实现:</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="noopener">java.lang.Runtime#getRuntime()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--" target="_blank" rel="noopener">java.awt.Desktop#getDesktop()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--" target="_blank" rel="noopener">java.lang.System#getSecurityManager()</a></li></ul><h2 id="二-行为型"><a href="#二-行为型" class="headerlink" title="二. 行为型"></a>二. 行为型</h2><h4 id="1-模板方法模式（Template-Method）"><a href="#1-模板方法模式（Template-Method）" class="headerlink" title="1. 模板方法模式（Template Method）"></a>1. 模板方法模式（Template Method）</h4><ul><li>动机：对于一项任务，常常有<strong>稳定的整体操作结构</strong>，但各个子步骤却又很多改变的需求，或者需要子步骤的晚期实现（<strong>延迟到子类去实现</strong>）。</li><li>Template Method 使得子类可以复用一个算法的结构（Override 重写）该算法的某些特定步骤。</li><li>不要调用我，让我来调用你，实现晚绑定机制，这也就是控制反转的思想。</li><li>声明成 <code>protected</code> ,因为具体步骤在流程中才有意义。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/161657528.png" alt="mark"></p><ul><li><strong>AbstractClass : 稳定的骨架（里面有具体的方法和需要被重写的方法）</strong></li><li><strong>ContreteClass : 具体的重写方法</strong></li></ul><ul><li>具体实现（举例）</li></ul><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/162632540.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 骨架流程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourIncoup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourIncoup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入咖啡粉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒茶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">        coffee.prepareRecipe();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"========"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AbstractClass tea = <span class="keyword">new</span> Tea();</span><br><span class="line">        tea.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">倒水</span><br><span class="line">倒咖啡</span><br><span class="line">倒进杯子</span><br><span class="line">加入咖啡粉</span><br><span class="line">========</span><br><span class="line">倒水</span><br><span class="line">倒茶</span><br><span class="line">倒进杯子</span><br><span class="line">加入茶叶</span><br></pre></td></tr></table></figure><p><strong>JDK中实现：</strong></p><ul><li>java.util.Collections#sort()</li><li>java.io.InputStream#skip()</li><li>java.io.InputStream#read()</li><li>java.util.AbstractList#indexOf()</li></ul><h4 id="2-策略模式（Strategy）"><a href="#2-策略模式（Strategy）" class="headerlink" title="2. 策略模式（Strategy）"></a>2. 策略模式（Strategy）</h4><ul><li><p>定义：针对同一个算法的问题多种处理方式，仅仅是具体的行为有差别的时候</p></li><li><p>在工厂模式中，为了创建不同的产品使用了<code>switch case</code>（或<code>if else</code>）的形式的代码，这样违背了<strong>开闭原则：对扩展开放，对修改封闭</strong> 。</p></li><li><p>服务端的性能负担会随着条件判断的增加而增加，而本文的<strong>策略模式</strong>可以较好的解决这个问题</p></li></ul><p><strong>定义：定义了一系列的算法，把它们一个个封装起来，并且是他们可以相互替换。策略模式让算法独立于它的使用者之外，可以自由修改。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200623/091054383.webp" alt="mark"></p><p>来看看UML类图，图中主要有三个部分组成</p><ul><li>Context: 上下文环境，持有<code>Strategy</code> 引用</li><li>Strategy: 抽象的策略（接口或者抽象类）</li><li>ConcreteStrategy: 具体的实现策略，实现了具体的算法（<strong>一般是工厂模式的具体实现</strong>）</li></ul><p><strong>注意：</strong></p><p><strong><code>Strategy</code>是使用接口还是抽象类</strong></p><ul><li>取决于一系列的策略中是否有共同的属性或者方法，如果没有，使用接口更加灵活方便</li><li>反之，使用抽象类，抽象类中便可存放公共的属性以及方法。</li></ul><p><strong>原始待修改代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待修改的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetGo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MODE_AIRPLAN = <span class="string">"airPlan"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MODE_TRAVEL = <span class="string">"travel"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MODE_CAR = <span class="string">"car"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSpend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出行花费："</span> + needSpend(MODE_AIRPLAN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">(String model)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (model)&#123;</span><br><span class="line">            <span class="keyword">case</span> MODE_AIRPLAN:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1400</span>;</span><br><span class="line">            <span class="keyword">case</span> MODE_TRAVEL:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> MODE_CAR:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2400</span>;</span><br><span class="line">                <span class="comment">// 异常值</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LetGo letGo = <span class="keyword">new</span> LetGo();</span><br><span class="line">        letGo.printSpend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同前文所说的，当需要添加可选的出行方案时，我们不得不去修改<code>needSpend()</code>函数中的<code>switch case</code>来达到目的；然而这样并不利于后期的维护。接下来，试着使用策略模式来使实现这个简单的出行案例。</p><p><strong>策略模式实现：</strong></p><ul><li>既然，出现是可选的策略，我们可以先抽象除一个出行策略的的接口，包含<code>needSpend()</code>方法，返回出行花费的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着，实现各种出行方案的实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 飞机出行 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirPlanStrategy</span> <span class="keyword">implements</span> <span class="title">ITravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 火车出行 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainStrategy</span>  <span class="keyword">implements</span> <span class="title">ITravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 自驾出行 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarStrategy</span>  <span class="keyword">implements</span> <span class="title">ITravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们需要的策略就都已经完成了，就等着我们选一种方案，看看所需要的花费。</p><ul><li>我们创建一个类，和<strong><code>Strategy</code>组合</strong>使用来获取各种出行方的花费，并在<code>printSpend()</code>方法中打印出所需要的花费。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetGoII</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 组合的思想</span></span><br><span class="line">    ITravelStrategy iTravelStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LetGoII</span><span class="params">(ITravelStrategy iTravelStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iTravelStrategy = iTravelStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSpend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出行花费："</span> + iTravelStrategy.needSpend());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LetGoII letGoII = <span class="keyword">new</span> LetGoII(<span class="keyword">new</span> AirPlanStrategy());</span><br><span class="line">    letGoII.printSpend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码就可以完成自驾游花费的输出，使用了策略模式。</p><p>现在代码是不是比之前使用<code>switch case</code>实现的代码结构更加清晰、简洁</p><p>如果要实现更多的出行方式，只需要再实现<code>ITravelStrategy</code>接口,替换掉传入的<code>LetGo</code> 构造器的参数即可。</p><p><strong>总结：</strong></p><ul><li><strong>策略模式，其实可以简单地理解成，将过多的<code>switch case</code>中<code>case</code>的代码封装成一个个具有共性的对象，需要什么我们就直接使用什么；</strong></li><li><strong>对于这种共性的实现就利用<code>interface</code>或者是抽象类来实现。这从对代码的封装以及解耦的角度来理解，可能会更加容易理解。</strong></li></ul><p><strong>使用场景：</strong></p><ul><li>针对同一个算法的问题多种处理方式，仅仅是具体的行为有差别的时候</li><li>出现同一抽象类的多个子类，而有需要使用<code>switch case</code>或<code>if else</code>来选择具体子类时</li></ul><h4 id="3-观察者模式（Obersver）"><a href="#3-观察者模式（Obersver）" class="headerlink" title="3. 观察者模式（Obersver）"></a>3. 观察者模式（Obersver）</h4><ul><li>观察者模式是使用频率非常高的模式了，它定义了对象间一种一对多的关系，使得每当一个对象改变状态，则所有依赖它的对象都会收到通知，并且自动更新。</li><li>例如：Java中的监听器Listener用的就是观察者模式。</li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/094333516.png" alt="mark"></p><ul><li>Subject: 具有注册和移除观察者，并且通知观察者的功能，主体是通过某种数据结构（可能是列表）来维护一张观察者列表实现这些操作的。</li><li>观察者（Observer）的注册功能需要调用主体的registerObserver() 方法。</li></ul><p><strong>实现：</strong></p><ul><li>开发技术周报，每周会更新一些内容，但是不知道具体的更新时间，又想第一时间阅读更新内容。</li><li>难道要一直按住F5等它更新么？那估计F5烂了可能都没有更新。其实我们只需要简单的订阅一下就好，当有新的内容更新的时候，会发邮件到你订阅的邮箱中。</li></ul><p>上述例子中：</p><ul><li>订阅者就是观察者，技术周报就是被观察者</li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者：程序员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的更新内容为"</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者：主体（开发周报）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekly</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一对多的通知</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        observers.forEach(observer -&gt; observer.update(<span class="string">"数据更新了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中自带的观察者模式的类</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/103921192.png" alt="mark"></p><ul><li>在<code>java.util</code> 包中内置了<code>Observer</code> 和 <code>observable</code>类,同时<code>Observable</code>类实现了注册和反注册等方法，使用起来方便很多。可见观察者模式是非常重要的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;java.util.Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Observer</code>接口则是比较简单的代码，<code>update()</code>的参数中除了可以传递数据意外，还提供了被观察者的引用对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called whenever the observed object is changed. An</span></span><br><span class="line"><span class="comment">     * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's</span></span><br><span class="line"><span class="comment">     * observers notified of the change.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o     the observable object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                 method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中的实现：</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener">javax.servlet.http.HttpSessionBindingListener</a></li><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li></ul><h4 id="4-中介者模式（Mediator）"><a href="#4-中介者模式（Mediator）" class="headerlink" title="4 . 中介者模式（Mediator）"></a>4 . 中介者模式（Mediator）</h4><ul><li>中介者模式（Mediator Pattern） , 使用一个中介对象封装一系列对象交互，使得个对象之间没有明显的交互，并且能够独立的改变对象之间的交互（可能说的有点绕<strong>T_T</strong>）</li><li>看看下面这张<strong>UML类图</strong>，就能理解了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200701/091636157.webp" alt="mark"></p><ul><li>其实和门面模式（Facade）有异曲同工之处，Facade解决的是系统内外的耦合性问题，而Mediator解决的是系统内的对象间的耦合问题。</li></ul><p><strong>举个例子：</strong></p><ul><li>简单的说就是，中介者对象聚合了对象的交互，其他的对象都是通过中介者对象进行交互，没有直接的交互。</li><li>这个可以想象一下租房，中介手里有房东的房子，你找中介租房，中介就是你和房东之间的那个中介对象。（代理模式也是如此）</li></ul><blockquote><p>虽然跳过中介直接找房东更加便宜，但是相对的，中介起的作用也简化和房东扯皮的一些过程</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200701/092158293.webp" alt="mark"></p><ul><li>Meadiator:  抽象中介者，定义了同事对象到中介者对象的接口。</li><li>ConcreteMediator： 具体的中介者角色，继承抽象中介者，实现了父类定义的方法，负责具体的同事对象之间的交互</li><li>Colleague : 抽象同事类,定义了中介者对象接口,只于中介者交互.不与其他同事对象交互.</li><li>ConcreteColleagueA/B:具体的同事类,继承抽象的同事类,每个具体的同事类都知道本身小范围内的行为,不知道自己大范围内的目的.</li></ul><p>其实这样描述,有没有觉得想MVC模式里面的Controller(当然在Controller里面的代码可能不会像中介者这样降低View 之间的耦合),也是起到Model 和 View 聚合的一个作用,使得Model 和 View的耦合性降低.</p><p><strong>代码实现:</strong></p><ul><li>直接实现房客找中介联系房东的过程，首先是抽象中介者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(Person person,String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后是抽象的同事类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是创建两个具体的同事类了，也就是<code>HouseOwner</code>房东和<code>Tenant</code>租客</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseOwner</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseOwner</span><span class="params">(String name, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> 与中介者联系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.constact(<span class="keyword">this</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> 获取信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"房主:"</span> + name +<span class="string">",获得信息："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tenant</span><span class="params">(String name, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> 与中介者联系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.constact(<span class="keyword">this</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> 获取信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"租房者:"</span> + name +<span class="string">",获得信息："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就需要具体的中介者，将房东和租客聚合起来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorStructure</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先中介结构必须知道所有房主和租房者的信息</span></span><br><span class="line">    <span class="keyword">private</span> HouseOwner houseOwner;</span><br><span class="line">    <span class="keyword">private</span> Tenant tenant;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HouseOwner <span class="title">getHouseOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseOwner</span><span class="params">(HouseOwner houseOwner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseOwner = houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tenant <span class="title">getTenant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTenant</span><span class="params">(Tenant tenant)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tenant = tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(Person person, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person == houseOwner) &#123;</span><br><span class="line">            <span class="comment">//如果是房主，则租房者获得信息</span></span><br><span class="line">            tenant.getMessage(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反正则是房主获得信息</span></span><br><span class="line">            houseOwner.getMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个房主、一个租房者、一个中介机构</span></span><br><span class="line">        MediatorStructure mediator = <span class="keyword">new</span> MediatorStructure();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//房主和租房者只需要知道中介机构即可</span></span><br><span class="line">        HouseOwner houseOwner = <span class="keyword">new</span> HouseOwner(<span class="string">"包租婆"</span>, mediator);</span><br><span class="line">        Tenant tenant = <span class="keyword">new</span> Tenant(<span class="string">"酱爆"</span>, mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中介结构要知道房主和租房者</span></span><br><span class="line">        mediator.setHouseOwner(houseOwner);</span><br><span class="line">        mediator.setTenant(tenant);</span><br><span class="line"></span><br><span class="line">        tenant.constact(<span class="string">"怎么停水啦？"</span>);</span><br><span class="line">        houseOwner.constact(<span class="string">"你没交水费"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">房主:包租婆,获得信息：包租婆，怎么停水啦？</span><br><span class="line">租房者:酱爆,获得信息：打死你呀的！！</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>简化了对象之间的关系，将系统的哥哥对现象之间相互关联进行封装，将各个同事解耦</li><li>使得多对多的关系变成了一对多的关系，简化对象之间的直接交互</li></ul><p><strong>缺点：</strong></p><ul><li>由于中介者对象封装了系统中对象之间的交互，导致器变得非常复杂，随着同事类的增加，维护难度会逐渐增大</li><li>其实中介者模式的缺点和优点在<code>MVC</code>模式体现的都很明显，所有的交互逻辑在<code>Controller</code>中，但是交互复杂之后经常导致<code>Controller</code>对象过于臃肿，难以维护更加不要说扩展了</li></ul><p><strong>JDK:</strong></p><ul><li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html" target="_blank" rel="noopener">java.util.Timer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-" target="_blank" rel="noopener">java.util.concurrent.Executor#execute()</a></li><li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener">java.util.concurrent.ExecutorService</a></li><li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener">java.util.concurrent.ScheduledExecutorService</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-" target="_blank" rel="noopener">java.lang.reflect.Method#invoke()</a></li></ul><h4 id="5-状态模式（State）"><a href="#5-状态模式（State）" class="headerlink" title="5. 状态模式（State）"></a>5. 状态模式（State）</h4><ul><li>定义：类的内部状态改变的时候，可以改变它的行为<ul><li>可能描述的有点模糊，举个栗子（真就是举个栗子）</li></ul></li></ul><p>（Android系统在未root时，是无法卸载系统预装应用的；root成功，开启root权限之后，不仅可以卸载系统预装应用，还可以使用xposed，简直就是可以为所欲为啊！这就可以看出，Android系统在root的状态变更时，影响到了自身的某些行为，进而某些行为也相对应的发生了改变。）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/083558850.webp" alt="mark"></p><ul><li><p>从UML类图上来看，结构似乎和策略模式是一模一样的。</p></li><li><p>状态模式的关键点在于不同的状态下，对于同一行为有不同的响应，避免使用<code>if-else</code>或<code>switch-case</code>区分状态所带来的代码臃肿；在保持代码结构的清晰的同时还保证了扩展和维护性。</p></li></ul><p><strong>代码实现</strong></p><ul><li>平常使用的登陆或者注销状态，经常使用的收藏和关注的功能，然而没有登录会提示去登陆，功能是无法使用的。</li><li>实现收藏功能很容易出现以下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isLogin())&#123;</span><br><span class="line">        <span class="comment">//收藏</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//去登陆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果还需要添加关注功能的话，又需要再次判断是否登录，一旦需要判断登录的功能一多，这种coding方式就会成为噩梦。</strong></p><ul><li>接下来使用状态模式可以很好的避免这种情况，首先我们需要抽象出一个公共行为接口<code>UserState</code> ，其中包含<code>collect()</code>以及<code>follow()</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 收藏行为 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/** 关注行为 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对应<strong>登录</strong>和<strong>未登录</strong>两种状态会有两种不同的实现方式，如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginState</span> <span class="keyword">implements</span> <span class="title">UserState</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收藏成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关注成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogoutState</span> <span class="keyword">implements</span> <span class="title">UserState</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来，我们需要一个类来关联登录状态与外界，并为外界提供<code>collect()</code>函数和<code>follow()</code>函数对应的调用；并将<code>LoginState</code>和<code>LogoutState</code>结合起来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里主要是实现状态模式，</span></span><br><span class="line"><span class="comment">// 对于用户这个案例来说，结合单例模式可能会更好。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserState LOGIN = <span class="keyword">new</span> LoginState();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserState LOGOUT = <span class="keyword">new</span> LogoutState();</span><br><span class="line">    <span class="keyword">private</span> UserState mState = LOGOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 登录，供外部调用 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mState = LOGIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 退出登录，供外部调用 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mState = LOGOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 调用mState的coolect() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mState.collect(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 调用mState的follow() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mState.follow(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此方法判断不太严谨，请忽略 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState <span class="keyword">instanceof</span> LoginState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>这里的<code>UserContext</code> 提供给外部的<code>collect()</code> 和 <code>follow()</code> 方法的同时，还要提供<code>login()</code> 和 <code>logout（）</code>两个方法给外部调用来更改<code>UserContext</code> 的内部状态。</p></li><li><p>这里主要是实现状态模式，<strong>对于用户这个案例来说，通常会结合单例模式使用的更好</strong></p></li></ul><blockquote><p>从某种程度上来说，提供login()和logout()两个方法是为了防止外界篡改内部的行为，因为外部无法传入自己实现的UserState对象，也就无法修改UserContext对应状态的行为。</p><p>确实也看到有些文章，在设置状态时，状态是由外部传入的，这种写法觉得不太合适，所以这里单独说明。</p></blockquote><p><strong>扩展思考</strong></p><p>其实对于实际情况来说，用户的操作行为可能远远不止这两个方法，若还有需要状态判断登录状态的行为，我们可以继续在<code>UserState</code>接口中为新增的行为添加相应的方法；但是，我们也可以预见，<code>UserState</code>接口将会越来越庞大。</p><p>这种问题的话，也可以将每个行为独立成一个接口，进而让<code>UserState</code>继承各个行为接口，或者将<code>UserState</code>改成抽象类实现各个行为接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独立的收藏的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICollect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//独立的关注的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFollow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有行为接口的集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserState</span> <span class="keyword">extends</span> <span class="title">ICollect</span>,<span class="title">IFollow</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>总结：</strong><ul><li>状态模式的关键点在于不同的状态下，对于同一行为有不同的响应，避免使用<code>if-else</code>或<code>switch-case</code>区分状态所带来的代码臃肿；在保持代码结构的清晰的同时还保证了扩展和维护性。</li><li>随着状态的增加，系统类和对象的个数也会增加，使用不当会导致程序结构变得越来越庞大。</li></ul></li></ul><h4 id="6-备忘录模式（Memento）"><a href="#6-备忘录模式（Memento）" class="headerlink" title="6. 备忘录模式（Memento）"></a>6. 备忘录模式（Memento）</h4><ul><li>定义：在不破坏封闭的前提下，将对象的当前内部状态保存到对象之外，之后可以再次恢复到此对象。（典型的例子就是游戏存档和读档的这个行为）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/090135433.webp" alt="mark"></p><ul><li><strong>Originator:</strong> 发起者，负责创建一个备忘录，并且可以记录，恢复自身的内部状态。可以根据需要决定<code>Memeto</code>保存自身的那些内部状态。</li><li><strong>Memento:</strong>备忘录，用于存储<code>Originator</code>的状态，防止<code>Originator</code>以外的对象访问<code>Memento</code></li><li><strong>Caretaker</strong> : 备忘录管理者，负责存储备忘录，不能对备忘录的内容进行操作和访问，只能将备忘录传递给其他对象。</li></ul><p><strong>代码实现：</strong></p><ul><li>发起者通过创建一个新的备忘录对象来保存自己的内部状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看出其模式的封闭性，对于状态得存储只有Originator知道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的备忘录对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将发起者的状态恢复到备忘录的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>备忘录，将发起人对象传入的状态存储起来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>备忘录管理者，负责保存备忘录对象，但是从不修改（甚至不查看）备忘录对象的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Memento mMemento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">restoreMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeMemengto</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上这就是备忘录模式的结构了，可以看出其模式的封闭性，对于状态的存储只有<code>Originator</code> 知道。</p><p><strong>总结：</strong></p><ul><li>备忘录模式在不破坏封装性的条件下，通过备忘录对象存储另外一个对象的内部状态的快照，在将来合适的时候把这个对象还原到存储的状态。</li></ul><p><strong>优点：</strong></p><ul><li>给用户提供了一种可以恢复状态的机制，可以是用户能够方便的回到某个历史的状态</li><li>实现了信息的封装，是的用户不需要关心状态的保存细节</li></ul><p><strong>缺点</strong></p><ul><li><strong>现在很多序列化的技术已经比备忘录模式优秀很多</strong></li></ul><p><strong>JDK：</strong></p><ul><li>java.io.Serializable</li></ul><h4 id="7-迭代器模式（Iterator）"><a href="#7-迭代器模式（Iterator）" class="headerlink" title="7. 迭代器模式（Iterator）"></a>7. 迭代器模式（Iterator）</h4><ul><li><p>迭代器模式：行为型设计模式之一。</p></li><li><p>定义：提供一种方法顺序访问要给容器对象中的各个元素，而有不需要暴露该对象的内部数据存储的实现。<strong>（应用于数据结构）</strong></p></li><li><p>迭代器模式源于对数据集合的访问，1. 将遍历的方法封装到数据集合中，2. 或者不提供方法由用户自己遍历。</p><ul><li>以上两种方式都有弊端</li><li>封装在数据集合中，那数据集合似乎多了些功能，数据集合不仅要维护自身数据元素，还要对外提供遍历的结构方法，遍历状态下还不能对同一个数据集合进行多个遍历操作。</li><li>不提取公共的遍历方法，如果让使用者自己实现，又会让容器内部细节对外暴露。</li></ul></li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/090918549.webp" alt="mark"></p><ul><li>Iterator：迭代器接口，负责定义，访问和遍历元素的接口</li><li>ConcreteIterator：具体的迭代器，实现迭代器接口，并记录遍历的当前位置。</li><li>Aggregate: 容器接口，负责创建具体的迭代器角色的接口。</li><li>ConcreteAggregate：具体的容器类，具体迭代器和该容器相关联。</li></ul><p><strong>代码实现</strong></p><ol><li><strong>迭代器接口</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前位置元素并将位置移至下一位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否还有下一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true-有，false-没有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>具体的迭代器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="comment">// 用于移动的游标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasNext())&#123;</span><br><span class="line">            t = list.get(cursor++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>容器接口</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>具体的容器类</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>封装性好，对外部的使用者来说可以以相同的API来获取不同结构的数据集合中的数据元素，不需要关心遍历算法，简化了遍历方式</li><li>便于扩展遍历方式，例如：可以创建一个正序迭代器同时还有一个倒序迭代器</li></ul><p>看了<code>ArratList</code>代码中的<code>Iterator</code>主要的代码和上述是基本一致的，添加了更多的判断。而对于不同的数据结构<code>Map</code>、<code>Set</code>根据其不同的实现方式<code>Iterator</code>的实现方式也各不相同。</p><p>迭代器模式，在数据结构中有广泛的使用，由于现在很多语言的API都提供了高效数据集合API，所以我们很少有需要去运用此模式，有兴趣的可以学习数据结构或者阅读源码来深入了解迭代器模式的实现。</p><p><strong>JDK</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">java.util.Iterator</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener">java.util.Enumeration</a></li></ul><h4 id="8-职责链模式（Chain-of-Responsibility）"><a href="#8-职责链模式（Chain-of-Responsibility）" class="headerlink" title="8. 职责链模式（Chain of Responsibility）"></a>8. 职责链模式（<strong>Chain of Responsibility</strong>）</h4><ul><li><p><strong>责任链模式（Chain of Responsibility）</strong>，行为型设计模式之一。</p></li><li><p>什么是责任链呢？这个链很像<strong>数据结构</strong>中的<strong>单链表</strong>，链中的每个节点都有自己的职责，同时也持有下一个节点的引用。<strong>属于自己职责范围内的请求就自己处理，并完成请求的处理；而不属于的职责就传递给下一个节点。每个节点都是如此循环，直至请求被处理或者已经没有处理节点。</strong></p></li><li><p>这种设计模式为了避免<strong>请求的发送者和接收者的耦合关系</strong>，而责任链就是中间请求处理者（其中可能包括多个有可能处理请求的对象，并将这些对象连成一条链。这样也使得请求发送者无需关注处理细节和请求的传递。）</p></li></ul><p><strong>UML类图</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/111235950.webp" alt="mark"></p><ul><li>Client：请求发送者</li><li>Handler：抽象处理者，声明一个请求方法，并且保持一个对下一个处理节点Hanler的引用</li><li>ConcreteHandler： 具体的处理角色。对请求进行处理，如果不能处理就转发给下一个对象处理。</li></ul><blockquote><p>这是一个基本的结构描述，实际应用中会有进一步的封装。</p></blockquote><p><strong>代码实现：</strong></p><ul><li>以公司正常请假为例，1天以内的假需要客户端部门主管签字，3天以内（不包含3天）需要技术部门主管签字，3天及以上就需要找CEO签字。</li><li>最简单的就是使用<code>if-else</code>实现，但是结构并不是那么美观，试着用责任链模式来实现。</li><li>首先是假条的类，包含姓名、请假原因和请假时间,使用<code>final</code> 声明是为了便面外部修改属性而已。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 假条的对象 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveNote</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请假人</span></span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">// 请假理由</span></span><br><span class="line">    <span class="keyword">final</span> String reason;</span><br><span class="line">    <span class="comment">// 请假天数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> leaveDays;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeaveNote</span><span class="params">(String name, String reason, <span class="keyword">int</span> leaveDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">        <span class="keyword">this</span>.leaveDays = leaveDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeaveDays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leaveDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是比较重要的<code>Handler</code>类，代码比较简单，下一个<code>Handler</code>的对象引用，再就是<code>handle()</code>和<code>setNextHandler()</code>方法，不多解释了，和之前的UML图中的的结构是一样的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个对象的引用</span></span><br><span class="line">    <span class="keyword">public</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理什么东西</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">hand</span><span class="params">(LeaveNote note)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置下一个对象的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在我们需要实现客户端主管、技术主管和CEO三个<code>Handler</code>的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientLeader</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hand</span><span class="params">(LeaveNote note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (note.leaveDays &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"部门主管同意"</span> + note.name + <span class="string">"请假"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler.hand(note);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TechnologyLeader</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hand</span><span class="params">(LeaveNote note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (note.leaveDays &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"技术主管"</span> + note.name + <span class="string">"请假"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler.hand(note);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEO</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hand</span><span class="params">(LeaveNote note)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CEO同意"</span> + note.name + <span class="string">"请假"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就需要测试调用我们写好的代码了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 测试方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LeaveNote note = <span class="keyword">new</span> LeaveNote(<span class="string">"朱酱酱"</span>, <span class="string">"回家过年"</span>, <span class="number">3</span>);</span><br><span class="line">        requestLevel(note);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 具体的封装方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLevel</span><span class="params">(LeaveNote note)</span> </span>&#123;</span><br><span class="line">        ClientLeader leader = <span class="keyword">new</span> ClientLeader();</span><br><span class="line">        TechnologyLeader technologyLeader = <span class="keyword">new</span> TechnologyLeader();</span><br><span class="line">        CEO ceo = <span class="keyword">new</span> CEO();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表的形式</span></span><br><span class="line">        leader.setNextHandler(technologyLeader);</span><br><span class="line">        technologyLeader.setNextHandler(ceo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从头节点开始判断是否能够处理</span></span><br><span class="line">        leader.hand(note);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里完成了，比较简单地责任链模式就完成了。</p><p>其实对于链表，nextHandler还可以作为构造函数的参数传入，于是代码变成这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLeave</span><span class="params">(LeaveNote leaveNote)</span></span>&#123;</span><br><span class="line">    CEO ceo = <span class="keyword">new</span> CEO(<span class="keyword">null</span>);</span><br><span class="line">    TechnologyLeader technologyLeader = <span class="keyword">new</span> TechnologyLeader(ceo);</span><br><span class="line">    ClientLeader clientLeader = <span class="keyword">new</span> ClientLeader(technologyLeader);</span><br><span class="line"></span><br><span class="line">    clientLeader.hand(leaveNote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><strong>责任链的优点就在于请求者和接受者松散耦合，以及能动态组合职责。</strong></p><p>（例子中可以看出，请求者不知道接收者是谁，也不知道具体的处理过程，只需要发出请求就可以了。而对于每一个职责对象来说，也不关心请求者和其他职责对象，虽然由下一个职责对象的引用，但是还是只负责处理自己的职责部分就好了，其他部分交给其他职责对象去处理）</p><p>动态组合职责则是利用职责的拆分，可以灵活的组合形式责任链，从而可以灵活的分配职责对象，也可以灵活的实现职责对象。</p><p><strong>PS：其实刚开始学习责任链模式的时候，我在想：“这种设计模式并没有做到很好地解耦啊！每个Handler还需要持有下一个Handler对象的引用，这不是造成更高的耦合度了么！”。之后才看明白，责任链的解决的时发出请求的一方和接受请求的一方的耦合度的问题，而处理这一切的<code>Handler</code>就是解决方案，所以<code>Handler</code>之间的耦合基本算是内部的</strong></p><p><strong>JDK:</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29" target="_blank" rel="noopener">java.util.logging.Logger#log()</a></li><li><a href="https://commons.apache.org/proper/commons-chain/index.html" target="_blank" rel="noopener">Apache Commons Chain</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-" target="_blank" rel="noopener">javax.servlet.Filter#doFilter()</a></li></ul><h4 id="9-命令模式（Command-）"><a href="#9-命令模式（Command-）" class="headerlink" title="9. 命令模式（Command ）"></a>9. 命令模式（<strong>Command</strong> ）</h4><p>定义：将命令封装成对象，具有以下作用</p><ul><li>使用命令来参数化其他对象</li><li>将命令放入队列进行排序</li><li>将命令的操作记录到日志中</li><li>支持可撤销的操作</li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/115952847.webp" alt="mark"></p><ul><li>Client：客户端，也就是发出命令者。</li><li>Invoker:执行者，该类的职业就是调用命令对象执行具体的请求操作，相关的方法我们称为行动方法。</li><li>Command:命令，定义所有具体命令类的接口。</li><li>ConcreteCommand：具体命令，实现了<code>Command</code>接口，在<code>execute()</code>方法中调用<code>Receiver</code>相关的方法。</li><li>Receiver：接收者，负责执行具体的逻辑。</li></ul><blockquote><p>整体来看，命令模式比较繁琐，执行一个指令的过程被分解成了好几部分，相对的复杂度也提升了；但是命令模式结构还是很清晰的。</p></blockquote><p><strong>代码实现：</strong></p><p>​    记得有个段子：</p><p>如果有一个按钮，按下以后会忘记一切事情，你会怎样？<br>咦，这里有个按钮，按一下<br>咦，这里有个按钮，按一下<br>咦，这里有个按钮，按一下</p><p>。。。</p><p>其实这个按下这个按钮就是执行了一个命令，是一个让你忘记一切的命令（于是自己开始递归，最后还Stack Overflow了？）</p><ul><li>首先我们需要一个接收者<code>Receiver</code> ， 来实现我们所传递的命令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里接收者只执行这一个命令，</span></span><br><span class="line"><span class="comment">// 复杂的情况们可以继承Receiver来实现不同的接收者处理不同的命令。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//具体命令操作</span></span><br><span class="line">        System.out.println(<span class="string">"清除所有记忆"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里接收者只执行这一个命令，复杂的情况们可以继承<code>Receiver</code>来实现不同的接收者处理不同的命令。</p></blockquote><ul><li>再是一个命令的接口<code>Command</code>和一个具体的<code>Command</code>实现类<code>CleanMemoryCommand</code>，很简单，只有一个没有实现的<code>execute()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 命令接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 清除记忆命令 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanMemoryCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CleanMemoryCommand</span><span class="params">(Receiver receiver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样，命令和接收者都有了，我们只差一个供用户直接使用的<code>Invoker</code>了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actoin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用的代码就比较简单了，这代码可以封装成一个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        CleanMemoryCommand command = <span class="keyword">new</span> CleanMemoryCommand(receiver);</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(command);</span><br><span class="line">        invoker.actoin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>命令模式看似简单，细想来其实存在着几乎所有设计模式的通病，那就是大量衍生类的创建，这是一个不可避免的问题。</li><li>尽管如此，也给我们带来了许多好处，更弱的耦合性、更灵活的控制性以及更好的扩展性。但是最后还是那句话，用不用，还是根据实际情况而定。</li></ul><h4 id="10-访问者模式（Visitor）"><a href="#10-访问者模式（Visitor）" class="headerlink" title="10 .访问者模式（Visitor）"></a>10 .访问者模式（Visitor）</h4><ul><li><p>访问者模式是一种将数据操作和数据结构分离的设计模式，是23种设计模式中非常复杂的一种设计模式。</p></li><li><p><strong>定义：封装一些作用与某种数据结构中的各元素的操作（访问），可以在不改变这个数据的前提下定义作用于这些元素的新操作。</strong></p></li><li><p>顾名思义：某些不能改变的数据，对于不同的访问者有不同的操作（或者访问），为不同的访问者提供相对应的操作。例如：公司CEO就能看到公司所有的真实财报数据，而作为一个员工可能就只能知道同比去年的增长比例。</p></li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200711/090626735.webp" alt="mark"></p><ul><li><p><strong>Visitor</strong>：<strong>访问者抽象类</strong>（或者接口），它定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素；理论上，它的方法个数和元素个数是一样的。因此，<strong>访问者模式要求元素的类族要稳定，不能频繁的添加，移除元素。如果出现频繁修改Visitor接口的情况，说明可能并不适合使用访问者模式。</strong></p></li><li><p><strong>ConcreteVisitor</strong> ： 具体的访问者，需要实现每一个元素类访问时所产生的具体的行为 。</p></li><li><p><strong>Element</strong>： 元素接口（或者抽象类），它定义了一个接收访问者的方法（<code>accept</code>） 方法，意义在于对于每一个元素都要刻意被访问者访问。</p></li><li><p><strong>ElementA、ElementB：</strong> 具体的元素类，提供接收访问方法的具体实现。而这个具体实现，通常情况下是使用访问者提供的访问该元素类的方法。</p></li><li><p><strong>ObjectStructure：</strong> 定义当中所提到的对象结构，<strong>对象结构是一个抽象表述</strong>，它内部管理了元素集合，并且可以迭代这些元素供访问者访问。</p></li></ul><blockquote><p>PS：访问者模式违反了迪米特原则（对访问者公布元素细节）以及依赖倒置原则（依赖了具体类，没有依赖抽象），由此可见，此模式需要应用在特定的情况中。</p></blockquote><p><strong>案例实现</strong></p><p>这里就以公司为例，公司员工暂且分为开发人员和运营人员，而公司的CEO和CTO对于不同员工的KPI关注点不同，因此我们需要做出不同的处理，接着看看代码实现</p><ul><li><strong>员工基类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Element接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> kpi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Staff</span><span class="params">(String name, <span class="keyword">int</span> kpi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.kpi = kpi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受visitor的访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>具体员工类</strong></li></ul><p>具体的员工，根据各自不同的职责添加了不同的方法，开发人员的KPI和代码产量相关，于是添加了获取代码行数的方法，而运营人员的KPI和新增用户量相关，于是添加了获取新增用户数的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发人员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Developer</span><span class="params">(String name, <span class="keyword">int</span> kpi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, kpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCodeLines</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运维人员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Operator</span><span class="params">(String name, <span class="keyword">int</span> kpi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, kpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNewUserNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>访问者</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问者Visitor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问开发人员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Developer developer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问运营人员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Operator operator)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，直接从方法上就区分<code>Developer</code>和<code>Operator</code>，这里主要考虑到的是，如果使用基类<code>Staff</code>作为参数的话代码就会是这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Staff staff)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(staff <span class="keyword">instanceof</span> Developer)&#123;</span><br><span class="line">            Developer developer = (Developer)staff;</span><br><span class="line">            System.out.print(<span class="string">"开发"</span> + developer.name</span><br><span class="line">                    + <span class="string">",KPI:"</span> + developer.kpi + <span class="string">"，代码"</span> + developer.getCodeLines() + <span class="string">"行"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(staff <span class="keyword">instanceof</span> Operator)&#123;</span><br><span class="line">            Operator operator = (Operator) staff;</span><br><span class="line">            System.out.print(<span class="string">"运营"</span> + operator.name + <span class="string">",KPI:"</span> + operator.kpi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>visit()</code> 方法中，我们就需要判断参数类型和类型转换，这样代码就难以扩展和维护。</p><blockquote><p>这是访问者模式的一个优点，也是一个缺点，优点在于代码清晰，某种程度上代码的维护和扩张更好；而缺点也是一样，如果需要添加一类<code>Staff</code>，所有的<code>Visitor</code>都需要在实现一个新的<code>visit()</code>方法。</p></blockquote><ul><li><strong>具体的访问者</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CTO对于不同人员操作不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CTOVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Developer developer)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"开发"</span> + developer.name</span><br><span class="line">                + <span class="string">",KPI:"</span> + developer.kpi + <span class="string">"，代码"</span> + developer.getCodeLines() + <span class="string">"行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Operator operator)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"运营"</span> + operator.name + <span class="string">",KPI:"</span> + operator.kpi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CEO对于不同人员操作不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEOVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Developer developer)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"开发"</span> + developer.name + <span class="string">",KPI:"</span> + developer.kpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Operator operator)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"运营"</span> + operator.name</span><br><span class="line">                + <span class="string">",KPI:"</span> + operator.kpi + <span class="string">"新增用户："</span> + operator.getNewUserNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>对象结构</strong></li></ul><p>这里的对象结构，直接就设定成了公司，集合就是员工们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Staff&gt; staffList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Staff staff : staffList) &#123;</span><br><span class="line">            staff.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStaff</span><span class="params">(Staff staff)</span></span>&#123;</span><br><span class="line">        staffList.add(staff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>客户端代码：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Company company = <span class="keyword">new</span> Company();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        company.addStaff(<span class="keyword">new</span> Developer(<span class="string">"Bruce Wayne"</span>,<span class="number">10</span>));</span><br><span class="line">        company.addStaff(<span class="keyword">new</span> Developer(<span class="string">"ClarkKent"</span>,<span class="number">20</span>));</span><br><span class="line">        company.addStaff(<span class="keyword">new</span> Developer(<span class="string">"Barry Allen"</span>,<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        company.addStaff(<span class="keyword">new</span> Operator(<span class="string">"Diana Prince"</span>,<span class="number">40</span>));</span><br><span class="line">        company.addStaff(<span class="keyword">new</span> Operator(<span class="string">"Oliver Queen"</span>,<span class="number">50</span>));</span><br><span class="line">        company.addStaff(<span class="keyword">new</span> Operator(<span class="string">"Dinah Lance"</span>,<span class="number">60</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CEOVisitor ceo = <span class="keyword">new</span> CEOVisitor();</span><br><span class="line">        company.action(ceo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CTOVisitor cto = <span class="keyword">new</span> CTOVisitor();</span><br><span class="line">        company.action(cto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体输出如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CEO所看到的======</span><br><span class="line">开发Bruce Wayne,KPI:<span class="number">6</span></span><br><span class="line">开发ClarkKent,KPI:<span class="number">2</span></span><br><span class="line">开发Barry Allen,KPI:<span class="number">8</span></span><br><span class="line">运营Diana Prince,KPI:<span class="number">4</span>,新增用户：<span class="number">46642</span></span><br><span class="line">运营Oliver Queen,KPI:<span class="number">1</span>,新增用户：<span class="number">7687</span></span><br><span class="line">运营Dinah Lance,KPI:<span class="number">3</span>,新增用户：<span class="number">67382</span></span><br><span class="line"> </span><br><span class="line">CTO所看到的======</span><br><span class="line">开发Bruce Wayne,KPI:<span class="number">6</span>,代码<span class="number">8285</span>行</span><br><span class="line">开发ClarkKent,KPI:<span class="number">2</span>,代码<span class="number">8351</span>行</span><br><span class="line">开发Barry Allen,KPI:<span class="number">8</span>,代码<span class="number">658</span>行</span><br><span class="line">运营Diana Prince,KPI:<span class="number">4</span></span><br><span class="line">运营Oliver Queen,KPI:<span class="number">1</span></span><br><span class="line">运营Dinah Lance,KPI:<span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="10-1-分派"><a href="#10-1-分派" class="headerlink" title="10.1 分派"></a>10.1 分派</h5><ul><li>变量名<strong>被声明时的类型叫做变量的静态类型</strong>(Static Type)，静态变量类型又可以叫做明显类型(Apparent Type)；而变量所引起的对象的正式类型叫做变量的<strong>实际类型</strong>(Actual Type)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List静态类型，Arraylist动态类型</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><ul><li>在java代码中有一种很常见的写法，声明父类对象创建子类对象（比如上面 声明是 <code>List</code> 类型（也就是静态类型即明显类型）），创建的是<code>ArrayList</code> 的对象（实际类型）。</li><li><strong>这里需要提到一个词，分派（Dispatch</strong>） 。 当使用上述形式声明并创建对象，根据对象的类型对方法进行选择。这就是分派，而分配又可以分为<strong>静态分派（Static Dispatch）</strong> 和 <strong>动态分派（Dynamic Dispatch）</strong><ul><li><strong>静态分派：对应的就是编译时，根据静态类型信息发生的分派。方法重载就属于静态分派</strong></li><li><strong>动态分派：对应的就是运行时，动态的自动的换掉某个方法。方法的重写就属于动态分派。</strong></li></ul></li></ul><p><strong>静态分派</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法的重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">extends</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operator</span> <span class="keyword">extends</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行类，<code>execute()</code>方法有三个<strong>重载方法</strong>，方法的参数分别上面对应的三个类型<code>Staff</code>、<code>Developer</code>、<code>Operator</code>的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Staff staff)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Developer developer)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开发人员"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Operator operator)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运营人员"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码和结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行结果："</span>);</span><br><span class="line">       </span><br><span class="line">        Staff staff = <span class="keyword">new</span> Staff();</span><br><span class="line">        Staff staff1 = <span class="keyword">new</span> Developer();</span><br><span class="line">        Staff staff2 = <span class="keyword">new</span> Operator();</span><br><span class="line">        </span><br><span class="line">        Execute execute = <span class="keyword">new</span> Execute();</span><br><span class="line">        execute.execute(staff);</span><br><span class="line">        execute.execute(staff1);</span><br><span class="line">        execute.execute(staff2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">员工</span><br><span class="line">员工</span><br><span class="line">员工</span><br></pre></td></tr></table></figure><p><strong>静态分派总结：</strong></p><ul><li>可以推断出，传入三个对象，最后执行的方法都是参数类型是<code>Staff</code> 的方法，即使三个对象有不同的真实类型。</li><li><strong>方法重载中实际起作用的是他们的静态类型，也就是在编译期间就完成了分派，即静态分派</strong></li></ul><p><strong>动态分派</strong></p><p>三个类自带<code>execute()</code>方法，<code>Developer</code>和<code>Operator</code>继承<code>Staff</code>，并重写了<code>execute()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法的重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"员工"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开发人员"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运营人员"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码以及结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行结果："</span>);</span><br><span class="line">        Staff staff = <span class="keyword">new</span> Staff();</span><br><span class="line">        staff.execute();</span><br><span class="line">        </span><br><span class="line">        Staff staff1 = <span class="keyword">new</span> Developer();</span><br><span class="line">        staff1.execute();</span><br><span class="line">        </span><br><span class="line">        Staff staff2 = <span class="keyword">new</span> Operator();</span><br><span class="line">        staff2.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">员工</span><br><span class="line">开发人员</span><br><span class="line">运营人员</span><br></pre></td></tr></table></figure><p><strong>动态分派总结</strong></p><ul><li>测试的情况相同，三个对象，其静态方法都是<code>Staff</code> ，而实际类型分别是<code>Staff</code> , <code>Developer</code> 和 <code>Operator</code> 。可以看到重写<code>execute()</code> 方法都生效了，各自输出了对应的内容</li><li><strong>java编译器在编译期间不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</strong></li></ul><h5 id="10-2-单分派和多分派"><a href="#10-2-单分派和多分派" class="headerlink" title="10.2 单分派和多分派"></a>10.2 单分派和多分派</h5><ul><li>首先要了解一个<strong>宗量</strong>的概念。一个方法所属的对象叫做方法的接收者，方法的接收者和方法的参量统称为方法的宗量。而根据分派可以基于多少种宗量，可以将面向对l象分为<strong>单分派语言和多分派语言。</strong><ul><li><strong>单分派语言</strong>根据一个宗量的类型（真实类型）进行对方法的选择</li><li><strong>多分派语言</strong>根据多个宗量的类型对方法进行选择。</li></ul></li><li><strong>那Java属于什么类型呢？</strong><ul><li><code>Java</code> 中<strong>静态分派时</strong>决定方法的选择的宗量包括方法的接收者和方法参数的静态类型。所以是<strong>多分派。</strong></li><li>在<strong>动态分派</strong>时，方法的选择只会考虑方法的接收者和实际类型，所以是<strong>单分派</strong></li><li><strong>其实<code>Java</code>语言是支持静态多分派和动态单分派的语言。</strong></li></ul></li></ul><h5 id="10-3-双重分派"><a href="#10-3-双重分派" class="headerlink" title="10.3 双重分派"></a>10.3 双重分派</h5><p>那双重分派又是什么呢？分派和访问者模式又有什么关系呢？接下来就会解释这些问题</p><p><code>java</code> 支持静态多分派和动态但分派，并不支持动态多分派，于是就有了两次单分派组成的双重分派来代替动态多分派。而访问者模式恰好使用到了双重分派的技术。</p><p><strong>双重分派</strong>技术就是在选择一个方法的时候，不仅仅要根据方法的接收者的运行时区别，还要根据运行时的参数进行区别（达到二次分派的效果）</p><p>在访问者模式中，客户端将具体的对象传递给访问者，也就是<code>staff.accpet(vistior)</code> 方法的调用，完成第一次分派；然后具体的访问者作为参数传入到具体的对象方法中，也就是<code>visitor.visit(this)</code>,将<code>this</code> 作为参数传递进去完成第二次分派。</p><p>双重分派也就是意味着得到的执行操作决定请求的种类和接收者的类型。双重分派的核心就是<code>this</code> 对象。</p><blockquote><p>从访问者模式可以看出，双重分派就是在方法的委派前面加上了继承的重写，使得从某种角度上来说重载变成了动态的。</p></blockquote><p><strong>缺点：</strong></p><ul><li>对象结构变化很困难： 不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。</li><li>破坏封装： 访问者模式通常需要对象结构开放内部数据给访问者和<code>ObjectStructrue</code>，这破坏了对象的封装性。</li></ul><h4 id="11-解释器模式-Interpreter"><a href="#11-解释器模式-Interpreter" class="headerlink" title="11 解释器模式(Interpreter)"></a>11 解释器模式(<strong>Interpreter</strong>)</h4><ul><li><strong>解释器模式（Interpreter Pattern）</strong>，实际应用中较少用到的行为模式。主要作用就是提供解释语言的语法或表达式的能力，从作用上来说，注定实际开发过程中会使用的少，毕竟很少有人需要构建一套自己的语法来解析吧！但是，这并不表示解释器模式我们可以忽略掉。</li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200713/211053813.webp" alt="mark"></p><ul><li><strong>Context</strong>：上下文环境，包含解释器之外的全局信息</li><li><strong>Client</strong>：客户端，解析表达式，构建语法树，执行具体的解释操作等</li><li><strong>AbstractExpression</strong> ： 抽象的表达式，声明一个抽象的解释操作父类，并定义一个抽象的解释方案，其具体的实现在各个具体的子类解释其中完成。</li><li><strong>TerminalExpression</strong> ： 终结符表达式，实现文法中终结符有关的解释操作。文法中每一个终结符都有一个具体的中介表达式与之对应。</li><li><strong>NonterminalExpression</strong>：非终结表达式，实现文法中非终结符有关的解释操作。</li></ul><p>其中<code>AbstractExpression</code>的<code>interpret()</code>是抽象的解析方法，参数是上下文的环境，而<code>interpret()</code>方法的具体实现则由<code>TerminalExpression</code>和<code>NonterminalExpression</code>实现。</p><p><strong>具体实现：</strong></p><p>如下我们通过对算术表达式的解释来看一个解释器模式的实现, 如表达式<code>m+n+p</code>中,如果我们使用解释器模式对该表达式进行解释，那么<code>m</code>、<code>n</code>、<code>p</code>代表的三个字母可以看成是终结符号，而<code>+</code>代表的运算符则可以看成是非终结符号。</p><ul><li>先创建抽象的解释器，表示数学运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interptet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解释器中定义了<code>interptet()</code>方法，<code>ArithmeticExpression</code>有两个子类，分别是<code>NumExpression</code>和<code>OperatorExpression</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 对数字进行解释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumExpression</span> <span class="keyword">extends</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumExpression</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interptet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对运算符进行解释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorExpression</span> <span class="keyword">extends</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> ArithmeticExpression mArithmeticExpression1,mArithmeticExpression2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorExpression</span><span class="params">(ArithmeticExpression arithmeticExpression1,ArithmeticExpression arithmeticExpression2)</span> </span>&#123;</span><br><span class="line">        mArithmeticExpression1 = arithmeticExpression1;</span><br><span class="line">        mArithmeticExpression2 = arithmeticExpression2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基础的类已经完成了，如果需要处理加法运算还需要继承<code>OperatorExpression</code>并实现<code>interptet()</code>方法来实现加法运算器<code>AdditionExpression</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdditionExpression</span> <span class="keyword">extends</span> <span class="title">OperatorExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdditionExpression</span><span class="params">(ArithmeticExpression arithmeticExpression1,ArithmeticExpression arithmeticExpression2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arithmeticExpression1, arithmeticExpression2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interptet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mArithmeticExpression1.interptet() + mArithmeticExpression2.interptet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还差一个业务逻辑处理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个Stack栈，存储并操作所有相关的解释器</span></span><br><span class="line">    <span class="keyword">protected</span> Stack&lt;ArithmeticExpression&gt; mArithmeticExpressionStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明两个ArithmeticExpression类型的临时变量，存储运算符左右两边的数字解释器</span></span><br><span class="line">        ArithmeticExpression arithmeticExpression1, arithmeticExpression2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据空格分隔表达式字符串</span></span><br><span class="line">        String[] elements = expression.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环遍历表达式元素数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (elements[i].charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是加号</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    <span class="comment">//将栈中的解释器弹出作为运算符号左边的解释器</span></span><br><span class="line">                    arithmeticExpression1 = mArithmeticExpressionStack.pop();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//同时将运算符号数组下标下一个元素构造为一个数字解析器</span></span><br><span class="line">                    arithmeticExpression2 = <span class="keyword">new</span> NumExpression(Integer.valueOf(elements[++i]));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过上面两个数字解释器构造加法运算解释器</span></span><br><span class="line">                    mArithmeticExpressionStack.push(<span class="keyword">new</span> AdditionExpression(arithmeticExpression1, arithmeticExpression2));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//如果不是运算符，则是数字，直接构造数字解释器并压入栈</span></span><br><span class="line">                    mArithmeticExpressionStack.push(<span class="keyword">new</span> NumExpression(Integer.valueOf(elements[i])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mArithmeticExpressionStack.pop().interptet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，为了简化逻辑，在约定的表达式的每个元素之间必须使用空格隔开，如<code>123 + 32 + 666</code>这种形式的表达式，这样才能在<code>Calculator</code>中使用空格来拆分字符串。</p><ul><li>如果想引入减法运算，我们只需要定义一个减法解释器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubtractionExpreesion</span> <span class="keyword">extends</span> <span class="title">OperatorExpression</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubtractionExpreesion</span><span class="params">(ArithmeticExpression arithmeticExpression1,ArithmeticExpression arithmeticExpression2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arithmeticExpression1, arithmeticExpression2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interptet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mArithmeticExpression1.interptet() - mArithmeticExpression2.interptet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Calculator</code>的<code>switch</code>中添加如下代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">    arithmeticExpression1 = mArithmeticExpressionStack.pop();</span><br><span class="line">    arithmeticExpression2 = <span class="keyword">new</span> NumExpression(Integer.valueOf(elements[++i]));</span><br><span class="line">    </span><br><span class="line">    mArithmeticExpressionStack.push(<span class="keyword">new</span> SubtractionExpreesion(arithmeticExpression1, arithmeticExpression2));</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><blockquote><p>这里，我们能看出来解释器模式灵活性强，但是这是对于相对简单的语言；如果需要加入乘除取余等等，一并进行混合预算的话还需要考虑不同符号的运算优先级逻辑处理，所以在“简单的语言”中适用解释器模式。其实解释器模式的本质就是，将复杂的问题模块化，分离实现、解释执行。</p></blockquote><p><strong>JDK:</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">java.util.Pattern</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html" target="_blank" rel="noopener">java.text.Normalizer</a></li><li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html" target="_blank" rel="noopener">java.text.Format</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html" target="_blank" rel="noopener">javax.el.ELResolver</a></li></ul><h2 id="三：结构型"><a href="#三：结构型" class="headerlink" title="三：结构型"></a>三：结构型</h2><h4 id="1-装饰者模式（Decorator）"><a href="#1-装饰者模式（Decorator）" class="headerlink" title="1. 装饰者模式（Decorator）"></a>1. 装饰者模式（Decorator）</h4><ul><li>装饰者模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），以透明动态的方式来动态扩展对象的功能，也是<strong>继承关系中一种代替方案</strong>。</li><li><strong>装饰者模式与继承关系的目的都是要扩展对象的功能，但是装饰者模式可以提供比继承更多的灵活性。(减少代码的冗余)</strong></li><li><strong>通过不同具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/104532725.webp" alt="mark"></p><ul><li>Component: 抽象组件（可以是抽象类或者接口），被装饰的原始对象</li><li>ConcreteComponent：具体的实现类，被装饰的具体对象</li><li>Decorator ： 抽象的装饰者，职责就是为了装饰我们的组件对象，内部一定要有一个指向组件的对象引用。</li><li>ConcreteDecoratorA：装饰者具体实现类，只对抽象装饰者做出具体实现</li><li>ConcreteDecoratorB：同上</li></ul><p><strong>举个例子：</strong></p><ol><li>人定义为抽象类，有一个抽象方法<code>eat()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个<code>NormalPerson</code>类继承<code>Person</code>，对<code>eat()</code>方法有了具体实现；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalPerson</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义一个<code>PersonFood</code>类来表示装饰者的抽象类，保持了一个对<code>Person</code>的引用，可以方便调用具体被装饰的对象方法，这样就可以方便的对其进行扩展功能，并且不改变原类的层次结构。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFood</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonFood</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>接着就是具体的装饰类了，这两个类没有本质上的区别，都是为了扩展<code>PersonFood</code>类，不修改原有类的方法和结构</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFood</span> <span class="keyword">extends</span> <span class="title">PersonFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpensiveFood</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();</span><br><span class="line">        eatSteak();</span><br><span class="line">        drinkRedWine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatSteak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃牛排"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinkRedWine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喝拉菲"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheapFood</span> <span class="keyword">extends</span> <span class="title">PersonFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheapFood</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();</span><br><span class="line">        eatNoodles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatNoodles</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃面条"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client:测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> NormalPerson();</span><br><span class="line"></span><br><span class="line">        PersonFood cheapFood = <span class="keyword">new</span> CheapFood(person);</span><br><span class="line">        cheapFood.eat();</span><br><span class="line"></span><br><span class="line">        PersonFood expensiveFood = <span class="keyword">new</span> ExpensiveFood(person);</span><br><span class="line">        expensiveFood.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>装饰者模式与<strong>继承关系</strong>的目的都是要<strong>扩展对象的功能</strong>，但是装饰者模式可以提供比继承更多的灵活性。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的<strong>组合</strong>。</li></ul></li></ul><p><strong>与代理模式的区别：</strong></p><ul><li>其实装饰着模式和代理模式很想，但两个目的不尽相同</li><li>装饰者模式是以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，目的是为了减少类的冗余</li><li>代理模式是提供一个代理对象，并有代理对象来控制原来对象的引用。</li><li>总而言之：代理模式是为了对代理对象进行控制，但不做功能的扩展；装饰者模式为本装饰的对象进行功能的扩展。</li></ul><h4 id="2-桥模式（Bridge）"><a href="#2-桥模式（Bridge）" class="headerlink" title="2. 桥模式（Bridge）"></a>2. 桥模式（Bridge）</h4><ul><li><p>定义：将<strong>抽象部分（业务功能</strong>）与<strong>实现部分（平台实现）</strong>分离，使他们可以独立的变化。<strong>（主要是违背了单一职责原则）</strong></p></li><li><p>动机：由于某些类型的固有的实现逻辑，使得他们具有两个变化的维度，乃至多个变化的维度</p><ul><li>使用在对象间的<strong>组合关系</strong>，使得抽象和实现之间沿着各自的维度来变化。</li></ul></li></ul><p><strong>类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/091251315.png" alt="mark"></p><ul><li>Abstraction：定义抽象类的接口</li><li>Implementor：定义实现类接口</li></ul><p><strong>代码实现：</strong></p><ul><li>RemoteControl 表示遥控器，指代 Abstraction。</li><li>TV 表示电视，指代 Implementor。</li><li>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TV具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sony</span> <span class="keyword">extends</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony On"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony Off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony ChannelChange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">extends</span> <span class="title">TV</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ChangHong On"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ChangHong Off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ChangHong ChannelChange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遥控器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合tv</span></span><br><span class="line">    <span class="keyword">protected</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向tv的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteController</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体遥控器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteRemote1</span> <span class="keyword">extends</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向tv的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteRemote1</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1 on"</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1 off"</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1 tuneChannel"</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteRemote2</span> <span class="keyword">extends</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向TV的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteRemote2</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2 on"</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2 off"</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2 tuneChannel"</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组合的方式</span></span><br><span class="line">        ConcreteRemote1 remote1 = <span class="keyword">new</span> ConcreteRemote1(<span class="keyword">new</span> ChangHong());</span><br><span class="line">        remote1.on();</span><br><span class="line">        remote1.off();</span><br><span class="line">        remote1.tuneChannel();</span><br><span class="line">        System.out.println(remote1.tv);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组合的方式</span></span><br><span class="line">        ConcreteRemote2 remote2 = <span class="keyword">new</span> ConcreteRemote2(<span class="keyword">new</span> Sony());</span><br><span class="line">        remote2.on();</span><br><span class="line">        remote2.off();</span><br><span class="line">        remote2.tuneChannel();</span><br><span class="line">        System.out.println(remote2.tv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">ConcreteRemoteControl1 on</span><br><span class="line">ChangHong On</span><br><span class="line">ConcreteRemoteControl1 off</span><br><span class="line">ChangHong Off</span><br><span class="line">ConcreteRemoteControl1 tuneChannel</span><br><span class="line">ChangHong ChannelChange</span><br><span class="line">ChangHong@<span class="number">4554617</span>c</span><br><span class="line">=====================</span><br><span class="line">ConcreteRemoteControl2 on</span><br><span class="line">Sony On</span><br><span class="line">ConcreteRemoteControl2 off</span><br><span class="line">Sony Off</span><br><span class="line">ConcreteRemoteControl2 tuneChannel</span><br><span class="line">Sony ChannelChange</span><br><span class="line">Sony@<span class="number">74</span>a14482</span><br></pre></td></tr></table></figure><p><strong>JDK中实现</strong></p><ul><li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li><li>JDBC</li></ul><h4 id="3-享元模式（Flyweight）"><a href="#3-享元模式（Flyweight）" class="headerlink" title="3. 享元模式（Flyweight）"></a>3. 享元模式（Flyweight）</h4><ul><li><p><strong>享元模式</strong> ： 是对象池的一种实现，主要用于减少创建对象的数量，<strong>以减少内存占用和提供性能。</strong></p></li><li><p>定义：运用共享技术有效的支持大量细粒度的对象<strong>（要求对象是只读的）</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/111500446.webp" alt="mark"></p><ul><li>Flyweight:  享元模式的抽象类或者接口。</li><li>ConcreateFlyweight: 具体的享元对象。</li><li>FlyweightFactory：享元工厂，负责管理享元对象池和创建享元对象。</li></ul><p><strong>代码实现</strong></p><ul><li>场景：过年抢票，大家肯定都不陌生，各种刷票插件、软件什么的。在用户设置好出发和到达之后，每次查询请求都返回一系列的车票结果。<ul><li>当数千万的用户在不断请求查询结果时，如果每次查询结果都是重新创建返回的，可想而知，肯定会有大量的重复对象的创建、销毁，内存占用和GC的压力都会随之增大。</li><li>而享元模式就能很好的应对这种情况，车次是固定的，根据出发地和到达地查询出来的车次基本都是相同的</li></ul></li></ul><ol><li>创建一个Ticket接口，定义输出车票信息的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Ticket接口，定义输出车票信息的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicket</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>具体的实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTicket</span> <span class="keyword">implements</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出发地</span></span><br><span class="line">    <span class="keyword">private</span>  String from;</span><br><span class="line">    <span class="comment">//到达地</span></span><br><span class="line">    <span class="keyword">private</span>  String to;</span><br><span class="line">    <span class="comment">//铺位</span></span><br><span class="line">    <span class="keyword">private</span> String bunk;</span><br><span class="line">    <span class="comment">//价格</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicket</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        price = <span class="keyword">new</span> Random().nextInt(<span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">"查询 从 "</span>+from+<span class="string">" 到 "</span> + to + <span class="string">" 的 "</span> + bunk + <span class="string">" 车票，价格："</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>享元工厂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JUC MAP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Ticket&gt; ticketMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次获取车票对象时的创建，享元模式有效的减少了重复对象的创建。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ticket <span class="title">getTicket</span><span class="params">(String from,String to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String key = from + <span class="string">"-"</span> + to;</span><br><span class="line">        <span class="comment">// 享元模式的精髓，有就直接返回这个对象</span></span><br><span class="line">        <span class="keyword">if</span> (ticketMap.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> ticketMap.get(key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有就加入到对象池中，并且返回这个对象</span></span><br><span class="line">            TrainTicket ticket = <span class="keyword">new</span> TrainTicket(from, to);</span><br><span class="line">            ticketMap.put(key,ticket);</span><br><span class="line">            <span class="keyword">return</span> ticket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK:</strong></p><p>Java 利用缓存来加速大量小对象的访问时间。</p><ul><li>java.lang.Integer#valueOf(int)</li><li>java.lang.Boolean#valueOf(boolean)</li><li>java.lang.Byte#valueOf(byte)</li><li>java.lang.Character#valueOf(char)</li></ul><h4 id="4-外观模式（Facade）"><a href="#4-外观模式（Facade）" class="headerlink" title="4. 外观模式（Facade）"></a>4. 外观模式（Facade）</h4><ul><li>外观模式：封装系统的复杂结构，向外提供一个可以访问系统的接口，这个接口就是系统内外通信的统一的出入口。这样使得系统更加易于维护和使用<ul><li>在我们集成很多第三方SDK的时候就会发现，我们集成一次之后，想要升级SDK的版本的话，我们只需要替换jar或者修改依赖库的版本，当然你也可以一直使用最新的版本。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/113712188.webp" alt="mark"></p><ul><li>Client：客户端，直接使用<code>Facade</code>接口提供的方法</li><li>Facade：就是系统对外的同一对象，封装了各个子系统的交互简化了<code>Client</code>调用</li><li>SystemA、SystemB、SystemC：子系统接口</li><li>ConcreteSystemA、ConcreteSystemB、ConcreteSystemC：子系统的实现</li></ul><p>这里就可以看出，对Client来说只需要知道一个Facade一个就行，不需要知道Facade内部的具体复杂逻辑，降低用户的使用成本。<strong>（思想：高内聚，松耦合）</strong></p><p><strong>优点</strong></p><ul><li>对使用者隐藏内部的具体细节，降低使用者和子系统的耦合。</li><li>外观类对子系统的接口封装，使得系统更加容易使用</li></ul><p><strong>缺点</strong></p><ul><li>外观类接口会过于庞大</li><li>没有遵循开闭原则，业务变化时需要修改外观类</li></ul><p><strong>代码实现：没有特定代码结构</strong></p><ul><li>场景：生活中有很多这样的例子，我们经常使用的智能手机就是一个外观模式的例子，能够打电话、拍照等功能，而打电话和拍照又是独立的功能系统。</li></ul><ol><li>手机功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhomeImpl</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挂电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>拍照功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Camera</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnoyCamera</span> <span class="keyword">implements</span> <span class="title">Camera</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启相机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭相机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>组装手机</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PhomeImpl phome = <span class="keyword">new</span> PhomeImpl();</span><br><span class="line">    <span class="keyword">private</span> SnoyCamera camera = <span class="keyword">new</span> SnoyCamera();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        phome.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span></span>&#123;</span><br><span class="line">        camera.open();</span><br><span class="line">        camera.takePhoto();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-代理模式（Proxy）"><a href="#5-代理模式（Proxy）" class="headerlink" title="5. 代理模式（Proxy）"></a>5. 代理模式（Proxy）</h4><ul><li><strong>代理模式</strong>： 为其他对象提供一个代理，并由代理对象控制原有对象的引用。也称作委托模式</li><li>其实代理模式无论是在日常开发中还是设计模式汇总都随处可见，中介者模式的中介者对象也是<strong>代理模式</strong>的应用，其他的对象的交互都是交给终结者对象处理的。而在生活中就更多的类似代理模式的例子。例如：抢票插件，科学上网等等。</li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200629/091646377.webp" alt="mark"></p><ul><li>subject: 抽象主体类（也可以是接口），声明共同的功能</li><li>RealSubject: 真实的主体类，也就是<strong>被代理的类</strong>，负责执行具体的业务逻辑方法；客户类调用代理类间接调用其定义的方法。</li><li>ProxySubject:代理主体类，也就是<strong>代理类</strong>，持有一个被代理类的真实对象，在实现抽象主体类共同方法中调用<strong>被代理类</strong>的相对应的方法，起到代理的作用。</li><li>Client: 客户类，直接去访问代理</li></ul><h5 id="5-1-静态代理"><a href="#5-1-静态代理" class="headerlink" title="5.1 静态代理"></a>5.1 静态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**抽象主体*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**被代理主体*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"this is real subject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**代理主题*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="comment">// 真实主体</span></span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(RealSubject realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"proxy start"</span>);</span><br><span class="line">        realSubject.visit();</span><br><span class="line">        System.out.print(<span class="string">"proxy end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**客户类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        ProxySubject proxySubject = <span class="keyword">new</span> ProxySubject(realSubject);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        proxySubject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态代理的好处:</strong></p><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li><li>公共的业务由代理来完成 . 实现了业务的分工 ,</li><li>公共业务发生扩展时变得更加集中和方便 .</li></ul><p><strong>缺点：</strong></p><ul><li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li></ul><h5 id="5-2-动态代理"><a href="#5-2-动态代理" class="headerlink" title="5.2 动态代理"></a>5.2 动态代理</h5><ul><li>上一部分介绍的，其实就是<strong>静态代理，也就是在代码的编译阶段生成代理类来完成代理对象的一系列操作。</strong></li><li>而<strong>动态代理</strong>则是在运行时动态生成代理类对象。</li><li>代理对象的生成则是利用<code>JDK</code>中的<code>java.lang.reflect.Proxy</code> 类 ，使用<code>newProxyInstance</code> 方法则可以创建一个我们所需要代理的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要是newProxyInstance方法，动态生成代理类</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>newProxyInstance</code> 是一个<code>Proxy</code>的静态方法，并且接收三个参数</p><ul><li><code>ClassLoader loader</code> <strong>类加载器</strong></li><li><code>Class&lt;?&gt;[] interfaces</code> <strong>目标对象实现的接口类型</strong></li><li><code>InvocationHandler h</code> 处理事件的对象，<code>InvocationHandler</code> 是一个接口，执行目标对象的方法，会触发<code>InvocationHandler</code> 的<code>invoke</code></li></ul><p><strong>另外一个重要的类当然就是<code>InvocationHandler</code> 了，其中最重要的方法就是<code>invoke</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Object proxy</code>: 执行方法的代理对象</li><li><code>Method method</code> ：被执行的方法的对象</li><li><code>bject[] args</code> : 被执行方法的参数</li><li>返回值：代理对象调用方法所返回的值</li></ul><p>依然使用<code>Subject</code>作为例子，看看简单的代码实现（代码没有封装）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        <span class="keyword">final</span> RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Subject<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>&#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 第一个参数是要代理的对象</span></span><br><span class="line">                        <span class="comment">// 第二个参数是需要传入的参数</span></span><br><span class="line">                        <span class="keyword">return</span> method.invoke(realSubject,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        subject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从代码上来看，比之前静态代理要简单很多，没有那么多类和对象，但是<strong>相对的代码在性能上有牺牲</strong>，而且对于不太熟悉反射相关的知识的开发者并不是太友好。</li><li>通过反射类<code>Proxy</code> 和 <code>InvocationHandler</code> 回调接口实现JDK动态代理，要求被代理类必须实现一个接口，但事实上并不是所有的类都有接口，对于没有实现接口的类，便无法使用该方法实现动态代理。</li></ul><h5 id="5-3-其他代理分类"><a href="#5-3-其他代理分类" class="headerlink" title="5.3 其他代理分类"></a>5.3 其他代理分类</h5><p>静态代理和动态代理是代码方法来区分代理模式，也可以从使用范围来区分不同的代理实现</p><ul><li>远程代理（Remote Proxy）: 为某个对象在不同的内存地址空间提供局部代理。使得系统可以将<code>Server</code> 部分的实现隐藏，以便<code>Client</code>不必考虑<code>Server</code>的存在</li><li>虚拟代理（Virtual Proxy） : 使用一个代理对象表示一个十分耗资源的对象并在真正需要时候才创建</li><li>保护代理(Protection Proxy): 使用代理控制对原始对象的访问.该类型的代理常被用于原始对象有不同访问权限的情况.</li><li>智能引用(Smart Reference) : 在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数.</li></ul><p>这里要注意的是，静态和动态代理都可以应用于上述4种情形，两者是各自独立的变化。</p><p><strong>总结:</strong></p><p>代理模式使用非常广泛，基本在其他的设计模式中也能看到代理模式的影子，但是使用时针对性较强，而且模式本身并没有什么突出的优缺点，基本上可以放心使用</p><p><strong>通用的动态代理实现类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                <span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy ： 代理类</span></span><br><span class="line">    <span class="comment">// method : 代理类中要代理的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="comment">// 业务逻辑代码</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK:</strong></p><ul><li>java.lang.reflect.proxy</li><li>java.lang.reflect.InvocationHandler</li><li>Spring的 Aop</li></ul><h4 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6. 适配器模式（Adapter）"></a>6. 适配器模式（Adapter）</h4><p>定义：此模式的作用就是兼容原本接口不匹配的两个类，起到桥梁的作用。</p><h5 id="6-1-类的适配器模式"><a href="#6-1-类的适配器模式" class="headerlink" title="6.1 类的适配器模式"></a>6.1 类的适配器模式</h5><ul><li>类的适配器模式：采用继承实现</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200701/085746124.webp" alt="mark"></p><ul><li>Target：目标接口，也就是期望得到的接口</li><li>Adaptee：需要适配的接口</li><li>Adapter：适配器，负责把<code>Adaptee</code>转换成<code>Target</code>的类</li></ul><p>不说远了，就说<strong>手机充电头</strong>，其实就是一个电源适配器，生活用电的电压是220v，而手机充电的电压是5v，所以这时候就需要使用到电源适配器将220v的电压转换为5v（如果你是直接插在插板的USB接口上的话，当我没说）。</p><p>对应上面的UML图， 生活电压就是<code>Adaptee</code>，手机充电电压就是<code>Target</code>，不用多说，电源适配器自然就是<code>Adapter</code>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Volt5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adaptee类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volt220</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVlot220</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">extends</span> <span class="title">Volt220</span> <span class="keyword">implements</span> <span class="title">Volt5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VoltAdapter adapter = <span class="keyword">new</span> VoltAdapter();</span><br><span class="line">        System.out.println(<span class="string">"输出电压"</span> + adapter.getVolt5());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-2-对象适配器模式"><a href="#6-2-对象适配器模式" class="headerlink" title="6.2 对象适配器模式"></a>6.2 对象适配器模式</h5><ul><li>与类适配器不同的是，<strong>对象适配器模式不使用继承关联链接<code>Adaptee</code> 类，而是使用代理关系连接到<code>Adaptee</code>类</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200701/090602860.webp" alt="mark"></p><ul><li>这种实现方式直接将要被适配的对象传递到<code>Adapter</code> 中，使用组合的形式实现接口的兼容效果。</li><li>一般常用的适配器模式都是对象适配器模式</li><li>还有就是<code>Adaptee</code> 对象不会被暴露出来，因为没有继承被适配的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Volt5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Adaptee类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volt220</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVlot220</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">implements</span> <span class="title">Volt5</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合的形式</span></span><br><span class="line">    Volt220 volt220;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltAdapter</span><span class="params">(Volt220 volt220)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.volt220 = volt220;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt220</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> volt220.getVlot220();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VoltAdapter adapter = <span class="keyword">new</span> VoltAdapter(<span class="keyword">new</span> Volt220());</span><br><span class="line">        System.out.println(<span class="string">"输出电压"</span> + adapter.getVolt5());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK:</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29" target="_blank" rel="noopener">java.util.Arrays#asList()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-" target="_blank" rel="noopener">java.util.Collections#list()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-" target="_blank" rel="noopener">java.util.Collections#enumeration()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-" target="_blank" rel="noopener">javax.xml.bind.annotation.adapters.XMLAdapter</a></li></ul><h4 id="7-组合模式-Composite"><a href="#7-组合模式-Composite" class="headerlink" title="7. 组合模式(Composite)"></a>7. 组合模式(Composite)</h4><ul><li><strong>组合模式(Composite Pattern)</strong>，也称作部分整体模式(Part-Whole Pattern)</li><li><strong>定义：将一组相似的对象看作一个对象来处理，并根据一个树状结构来组合对象；对象都提供一个统一的方法去访问相应的对象来处理多个对象的同一性的问题</strong></li></ul><blockquote><p>组合模式属于结构设计模式之一，而其设计目的就是将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象的组合对象使用具有一致性；所以决定组合模式的设计基础就是树状结构。</p><p>组合模式所使用的情况也就是树状结构或者适用树状结构来解决问题的情况。</p></blockquote><p><strong>UML类图</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200704/084505772.webp" alt="mark"></p><ul><li>Component：抽象节点，为组合中的对象声明统一接口。</li><li>Composite：可以储存子节点的节点对象，并实现抽象节点的有关操作。</li><li>Leaf：叶子节点，没有子节点的对象了。</li><li>Client：组合节点对象，进行操作</li></ul><p>注意：</p><ul><li>这里所描述的是<strong>透明的组合模式</strong>，可以看到<code>Component</code>类中除了统一的操作方法<code>doSomthing()</code>方法以外，还有操作子节点的相关方法，<strong>而叶子节点<code>Leaf</code>类定义就是没有叶子节点的，显然这些操作子节点的方法就是多余的。</strong></li><li><strong>如果要让<code>leaf</code>类不继承这些方法，只能将<code>compoent</code> 类中的这些方法放到<code>composite</code>类中，然而这样的设计方式与依赖倒置原则相违背，所以这里没有采用这种组合模式（安全的组合模式）</strong></li></ul><p><strong>代码实现：</strong></p><ul><li>说到<strong>组合模式</strong>，最适合的就是文件系统的结构了，文件夹中就子文件夹和文件，子文件夹中可能又是如此，典型的树状结构。</li><li>抽象的目录类，有目录名，有输出目录名，并提供添加目录，删除目录和清除目录的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前目录名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出目录结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个文件或者文件夹</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Directory dir)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个文件或者文件夹</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeDir</span><span class="params">(Directory dir)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目录中的所有目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Directory&gt; <span class="title">getDirs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目录名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>文件夹类</strong>，申明一个集合存储自身的目录，并实现具体的操作方法，在<code>print()</code>方法中循环调用集合中目录的<code>print()</code>方法输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">Directory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前文件夹下的所有目录元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Directory&gt; directories = <span class="keyword">new</span> ArrayList&lt;Directory&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印文件目录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"["</span>);</span><br><span class="line">        Iterator&lt;Directory&gt; iterator = directories.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Directory directory = iterator.next();</span><br><span class="line">            directory.print();</span><br><span class="line">            <span class="keyword">if</span> (iterator.hasNext())&#123;</span><br><span class="line">                System.out.println(<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Directory dir)</span> </span>&#123;</span><br><span class="line">        directories.add(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeDir</span><span class="params">(Directory dir)</span> </span>&#123;</span><br><span class="line">        directories.remove(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        directories.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Directory&gt; <span class="title">getDirs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> directories;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>文件类</strong>：实现了<code>print()</code>方法，由于没有子目录，相关操作的方法都抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Directory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Directory dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"文件对象不支持该操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeDir</span><span class="params">(Directory dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"文件对象不支持该操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"文件对象不支持该操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Directory&gt; <span class="title">getDirs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"文件对象不支持该操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类：模拟输出C盘的结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Directory root = <span class="keyword">new</span> Folder(<span class="string">"C"</span>);</span><br><span class="line">        root.addDir(<span class="keyword">new</span> Folder(<span class="string">"windows"</span>));</span><br><span class="line">        Directory program = <span class="keyword">new</span> Folder(<span class="string">"Program File(x86)"</span>);</span><br><span class="line">        program.addDir(<span class="keyword">new</span> Folder(<span class="string">"Intellij"</span>));</span><br><span class="line">        program.addDir(<span class="keyword">new</span> File(<span class="string">"cache"</span>));</span><br><span class="line"></span><br><span class="line">        root.addDir(<span class="keyword">new</span> Folder(<span class="string">"windows"</span>));</span><br><span class="line">        root.addDir(<span class="keyword">new</span> File(<span class="string">"log.txt"</span>));</span><br><span class="line">        root.addDir(<span class="keyword">new</span> File(<span class="string">"null.txt"</span>));</span><br><span class="line"></span><br><span class="line">        root.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>组合模式和解释器模式有一定的类同，都涉及递归调用。</p><p>但是组合模式所提供的属性层次结构使得可以同等对象单个对象和多个对象。</p><p>不过是以牺牲单一原则换来的，而组合模式是通过继承来实现的，这样缺少了些扩展性。</p><p><strong>优点</strong></p><p>高层模块可以一致的使用一个组合结构或者其中单个对象，不必关心处理的单个对象还是整个组合结构，简化代码</p><p>对于枝干构件和叶子构件的新增很方便</p><p>通过枝干对象和叶子对象的递归组合，可以形成复杂的树形结构，同时保持简单的方式进行控制</p><p><strong>JDK:</strong></p><ul><li>javax.swing.JComponent#add(Component)</li><li>java.awt.Container#add(Component)</li><li>java.util.Map#putAll(Map)</li><li>java.util.List#addAll(Collection)</li><li>java.util.Set#addAll(Collection)</li></ul><p><strong>简书参考：</strong></p><p><strong>参考博客</strong>：<a href="https://www.jianshu.com/u/70bd9fefe61f" target="_blank" rel="noopener">https://www.jianshu.com/u/70bd9fefe61f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;23种设计模式-详细总结&quot;&gt;&lt;a href=&quot;#23种设计模式-详细总结&quot; class=&quot;headerlink&quot; title=&quot;23种设计模式-详细总结&quot;&gt;&lt;/a&gt;23种设计模式-详细总结&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200610/221023280.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计模式是解决问题的方案，学习现有的设计模式可以做到经验的复用&lt;/li&gt;
&lt;li&gt;拥有设计模式的词汇，在沟通是就能用到更少的词汇来讨论，并且不需要知道底层的细节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;话在前头：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是好的设计模式？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;提高复用&lt;/li&gt;
&lt;li&gt;应对变化&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在什么时候，什么地方使用设计模式？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在需求频繁变化的变化点使用设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Refactoring to Patterns(重构的方式一步一步到模式)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重构的关键方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态 -&amp;gt; 动态&lt;/li&gt;
&lt;li&gt;早绑定 -&amp;gt; 晚绑定&lt;/li&gt;
&lt;li&gt;继承 -&amp;gt; 组合&lt;/li&gt;
&lt;li&gt;编译时依赖 -&amp;gt; 运行时依赖&lt;/li&gt;
&lt;li&gt;紧耦合 -&amp;gt; 松耦合&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-189-旋转数组</title>
    <link href="http://zhuuu.work/2020/06/09/Leetcode/Leetcode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2020/06/09/Leetcode/Leetcode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2020-06-09T08:53:53.000Z</published>
    <updated>2020-06-09T09:21:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-189-Rotate-Array"><a href="#Leetcode-189-Rotate-Array" class="headerlink" title="Leetcode-189-Rotate Array"></a>Leetcode-189-<a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">Rotate Array</a></h1><h2 id="思路：遍历替换"><a href="#思路：遍历替换" class="headerlink" title="思路：遍历替换"></a>思路：遍历替换</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k &#x3D; 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一：暴力替换"><a href="#方法一：暴力替换" class="headerlink" title="方法一：暴力替换"></a>方法一：暴力替换</h2><p>最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外层循环：旋转k次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            previous = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 内层循环：每次和数组中最后一个元素交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n*k)   内层循环n个元素，外层循环遍历k次</li><li><strong>空间复杂度</strong>：O(1)</li></ul><h2 id="方法二：使用额外的数组"><a href="#方法二：使用额外的数组" class="headerlink" title="方法二：使用额外的数组"></a>方法二：使用额外的数组</h2><ul><li>思路：使用一个额外的数组把每个元素放到正确的位置上，也就是把i放到了 <code>i + k%数组长度</code>的位置。然后将数组重新拷贝到原数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新建一个数组，把对应位置存到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            a[(i+k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拷回到原数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n) 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。</li><li><strong>空间复杂度</strong>：O(n)。另一个数组需要原数组长度的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-189-Rotate-Array&quot;&gt;&lt;a href=&quot;#Leetcode-189-Rotate-Array&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-189-Rotate Array&quot;&gt;&lt;/a&gt;Leetcode-189-&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rotate Array&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：遍历替换&quot;&gt;&lt;a href=&quot;#思路：遍历替换&quot; class=&quot;headerlink&quot; title=&quot;思路：遍历替换&quot;&gt;&lt;/a&gt;思路：遍历替换&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;em&gt;k&lt;/em&gt; 个位置，其中 &lt;em&gt;k&lt;/em&gt; 是非负数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,4,5,6,7] 和 k &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [5,6,7,1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 1 步: [7,1,2,3,4,5,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 2 步: [6,7,1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 3 步: [5,6,7,1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [-1,-100,3,99] 和 k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [3,99,-1,-100]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 1 步: [99,-1,-100,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 2 步: [3,99,-1,-100]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-009-回文数反转</title>
    <link href="http://zhuuu.work/2020/06/09/Leetcode/Leetcode-009-%E5%9B%9E%E6%96%87%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://zhuuu.work/2020/06/09/Leetcode/Leetcode-009-%E5%9B%9E%E6%96%87%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2020-06-09T07:42:53.000Z</published>
    <updated>2020-06-13T08:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-009-回文数"><a href="#Leecode-009-回文数" class="headerlink" title="Leecode-009- 回文数"></a>Leecode-009- <a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">回文数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一：字符串双指针"><a href="#方法一：字符串双指针" class="headerlink" title="方法一：字符串双指针"></a>方法一：字符串双指针</h2><p><strong>思路：由于特点很合适，所以转换成字符串去判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int转换成string</span></span><br><span class="line">        String s = String.valueOf(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针判断</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 判断首尾是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                <span class="comment">// 相等的话判断下一位</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不相等直接退出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度： O(n) </li><li>空间复杂度：O(n) 使用了一个字符串数组实现</li></ul><h2 id="方法二-十进制反转"><a href="#方法二-十进制反转" class="headerlink" title="方法二: 十进制反转"></a>方法二: 十进制反转</h2><p><strong>思路: 把数字进行十进制倒转,再判断和原先是否相同</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/161720769.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存反转前的结果</span></span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每一位进行反转</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)  因为数字长度有限,int最大是32位,所以遍历32位就行.</li><li>空间复杂度：O(1)  使用常数的额外空间</li></ul><p>注意:这里有一个隐藏的问题细节</p><ul><li><p>如果我们输入的是最大32位整数2147483647，这个数字本身是没有问题，是一个合法的32位最大整数，用int存储也没问题，但是如果将这个数字反转的话，其大小超过了32位最大整数，也就是会溢出</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/161836795.png" alt="mark"></p></li><li><p>那么是否要改变类型位Long类型存储呢?</p><ul><li><strong>其实是不用的,因为32位整数中最大的回文数字是2147447421,这个数字是比最大32位整数要小的</strong></li><li>也就是说超过<code>2147447412</code>大小的数字也就不是回文数字了，虽然最后结果溢出了,但是返回的结果仍然是对的.</li></ul></li></ul><h2 id="方法三-反转一半的数字"><a href="#方法三-反转一半的数字" class="headerlink" title="方法三: 反转一半的数字"></a>方法三: 反转一半的数字</h2><p><strong>思路:我们不用反转整数的所有数字，只需要反转一半数字就可以了，这是利用了【回文】的对称性。。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/162055172.png" alt="mark"></p><ul><li>反转操作和方法二相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>不同的地方在于 while 的判断条件</strong><ul><li>我们可以注意到的是(如果反转后的数字 大于 反转后得到的数字,那么说明已经过半了)</li><li>上面的那个很好理解,你随便写一个数字看看就知道了</li></ul></li></ul><ul><li>最后要判断奇偶数的情况<ul><li>如果是偶数的话, 两者应该相等</li><li>如果是奇数的话,新得到的数字正好是原数字x的10倍.</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/162144789.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;&#x3D;ans || x&#x3D;&#x3D;(ans&#x2F;10)</span><br></pre></td></tr></table></figure><ul><li><p>还有要考虑的一点:</p><ul><li>对于<code>10</code>，<code>20</code>，<code>100</code>这样的数字，用上面的判断方式就有问题了</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/162255628.png" alt="mark"></p><ul><li>所以我们要对这些数字进行特殊处理(如果某个数字 % 10 等于 0 , 并且它不是0开头,那么直接返回false就可以了.)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这些数字特殊处理一下，</span></span><br><span class="line">        <span class="comment">// 如果某个数字%10等于0，并且它不是0开头，那么直接返回false就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x%<span class="number">10</span>==<span class="number">0</span> &amp;&amp; x!=<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果原数字大于新数字，不断求解得到新数字</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; ans)&#123;</span><br><span class="line">            ans = ans*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断奇数偶数的情况</span></span><br><span class="line">        <span class="keyword">return</span> x == ans || x==(ans/<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-009-回文数&quot;&gt;&lt;a href=&quot;#Leecode-009-回文数&quot; class=&quot;headerlink&quot; title=&quot;Leecode-009- 回文数&quot;&gt;&lt;/a&gt;Leecode-009- &lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;回文数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: -121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从右向左读, 为 01 。因此它不是一个回文数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-202-快乐数</title>
    <link href="http://zhuuu.work/2020/06/08/Leetcode/Leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/06/08/Leetcode/Leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</id>
    <published>2020-06-08T01:12:53.000Z</published>
    <updated>2020-06-09T03:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-202-Happy-Number"><a href="#Leetcode-202-Happy-Number" class="headerlink" title="Leetcode-202-Happy Number"></a>Leetcode-202-<a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">Happy Number</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/</a></p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们可以先举几个例子。我们从 7 开始。则下一个数字是 49（因为 7^2&#x3D;49 </span><br><span class="line">然后下一个数字是 97（因为 4^2+9^2&#x3D;97) </span><br><span class="line">）。</span><br><span class="line">我们可以不断重复该的过程，直到我们得到 1。因为我们得到了 1，我们知道 7 是一个快乐数，函数应该返回 true。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200609/100208586.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">再举一个例子，从116开始。</span><br><span class="line">通过反复平方和计算下一个数字，我们最终得到了58，</span><br><span class="line">在继续计算之后，我们又回到了58.由于我们回到了一个已经计算过的数字，可以知道有一个环，因此不可能达到1。</span><br><span class="line">所以对于116，函数应该返回false</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200609/100356018.png" alt="mark"></p><ul><li><strong>思考</strong></li></ul><p>根据我们的探索，我们猜测会有以下三种可能。</p><ol><li>最终会得到 1。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大。</li></ol><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 1 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><table><thead><tr><th>Digits</th><th align="center">Largest</th><th align="right">Next</th></tr></thead><tbody><tr><td>1</td><td align="center">9</td><td align="right">81</td></tr><tr><td>2</td><td align="center">99</td><td align="right">162</td></tr><tr><td>3</td><td align="center">999</td><td align="right">243</td></tr><tr><td>4</td><td align="center">9999</td><td align="right">324</td></tr><tr><td>13</td><td align="center">9999999999999</td><td align="right">1053</td></tr></tbody></table><ol><li>对于三位数的数字，他不可能大于243。</li></ol><p>（这意味着它要么被困在243以下的循环内，要么跌倒1。）</p><ol start="2"><li>对于4位或者以上的是数字，在每一步都会丢失一位，直到降到3位位置。所以我们知道，最坏的情况下，算法可能会在243以下的循环内或者回到1。但它不会无限期的进行下去，所以我们排除第三种选择。</li></ol><ul><li><strong>算法</strong><ul><li>给定一个数字n，判断他的下一个平方后数字是什么</li><li>按照一系列数字来判断我们是否进入了一个循环</li></ul></li></ul><p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p><p>第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。</p><ul><li>如果不在hashset中，把它加入到hashset中</li><li>如果在hashset中，说明我们进入了一个循环，返回false。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环条件： 回到了1表示快乐数字 并且 这个数字之前没有出现过</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            <span class="comment">// 加入到set中</span></span><br><span class="line">            set.add(n);</span><br><span class="line">            <span class="comment">// n的下一个平方数</span></span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算n 的平方数函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            total += d*d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：（这里参考官网）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算 getNext(n) 函数的时间复杂度。</span><br><span class="line"></span><br><span class="line">时间复杂度：O(243 \cdot 3 + \log n + \log\log n + \log\log\log n)...O(243⋅3+logn+loglogn+logloglogn)... &#x3D; O(logn)。</span><br><span class="line">查找给定数字的下一个值的成本为 O(logn)，因为我们正在处理数字中的每位数字，而数字中的位数由 \log nlogn 给定。</span><br><span class="line">要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</span><br><span class="line">我们在上面确定，一旦一个数字低于 243243，它就不可能回到 243243 以上。因此，我们就可以用 243243 以下最长循环的长度来代替 243243，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</span><br><span class="line">对于高于 243243 的 nn，我们需要考虑循环中每个数高于 243243 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 O(\log n) + O(\log \log n) + O(\log \log \log n)...O(logn)+O(loglogn)+O(logloglogn)...。幸运的是，O(\log n)O(logn) 是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于\log nlogn），所以我们可以忽略它们。</span><br><span class="line">空间复杂度：O(\log n)O(logn)。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。对于足够大的 nn，大部分空间将由 nn 本身占用。我们可以很容易地优化到 O(243 \cdot 3) &#x3D; O(1)O(243⋅3)&#x3D;O(1)，方法是只保存集合中小于 243243 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</span><br></pre></td></tr></table></figure><h2 id="方法二：快慢指针"><a href="#方法二：快慢指针" class="headerlink" title="方法二：快慢指针"></a>方法二：快慢指针</h2><ul><li><p>通过反复调用<code>getNext(n)</code> 得到的是一个<strong>隐式的链表</strong>。</p></li><li><p>隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。</p></li></ul><p><strong>如果这里意识到实际上有个链表，那么可以转换成链表是否有环的问题</strong></p><ul><li><p>因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的快的称为 “乌龟”，跑得快的称为 “兔子”。</p></li><li><p>不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200609/111050456.png" alt="mark"></p><p><strong>算法：</strong></p><ul><li>我们不是每次链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。</li><li>在每一步的算法中，慢速在链表中前进一个节点，快跑这前进两个节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-202-Happy-Number&quot;&gt;&lt;a href=&quot;#Leetcode-202-Happy-Number&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-202-Happy Number&quot;&gt;&lt;/a&gt;Leetcode-202-&lt;a href=&quot;https://leetcode-cn.com/problems/happy-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Happy Number&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;/p&gt;
&lt;p&gt;「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。&lt;/p&gt;
&lt;p&gt;如果 n 是快乐数就返回 True ；不是，则返回 False 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12 + 92 &amp;#x3D; 82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82 + 22 &amp;#x3D; 68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62 + 82 &amp;#x3D; 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12 + 02 + 02 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-108-将有序数组转换为二叉搜索树</title>
    <link href="http://zhuuu.work/2020/06/07/Leetcode/Leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/06/07/Leetcode/Leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-06-07T09:52:53.000Z</published>
    <updated>2020-07-03T00:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#Leecode-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="Leecode-108-Convert Sorted Array to Binary Search Tree"></a>Leecode-108-<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">Convert Sorted Array to Binary Search Tree</a></h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：DFS</strong></p><ul><li>深度优先遍历（DFS）<ul><li>这种方法以深度<code>depth</code> 为优先策略，从根节点开始一直遍历到某个叶子节点，回到根节点，再遍历另外一个分支。</li><li>根据根节点，左孩子和右孩子的访问顺序又可以把DFS细分为 前序遍历，中序遍历，后序遍历。</li></ul></li><li><strong>这里有很重要的一点：有序数组转换成二叉搜索树的结果不唯一</strong><ul><li><strong>众所周知，二叉搜索树的中序遍历是一个升序序列。</strong></li><li><strong>将有序数组作为输入，可以把该问题看作根据中序遍历创建二叉搜索树</strong></li><li>中序遍历不能唯一确定一棵二叉搜索树。</li><li>先序和后序遍历不能确定一颗唯一的二叉搜索树</li><li>中序+后序，后序+先序可以唯一确定一颗二叉搜索树</li><li>因此，“有序数组 -&gt; BST”有多种答案。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200608/172631566.png" alt="mark"></p><h2 id="方法一：中序遍历（始终选择中间左边元素作为根节点）"><a href="#方法一：中序遍历（始终选择中间左边元素作为根节点）" class="headerlink" title="方法一：中序遍历（始终选择中间左边元素作为根节点）"></a>方法一：中序遍历（始终选择中间左边元素作为根节点）</h2><ul><li>方法<code>helper(left,right,nums)</code> 使用数组nums 中索引从left到right创建BST<ul><li>如果 left &gt; right ，子树中不存在元素，返回空</li><li>找出中间元素 <code>p = (left + right) &gt;&gt;&gt;1;</code></li><li>创建根节点 <code>root = TreeNode(nums[p])</code></li><li>递归创建左子树 <code>root.left = helper(left,p-1,nums)</code></li><li>递归创建右子树 <code>root.right = helper(p + 1,right)</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,nums.length - <span class="number">1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right , <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 退出递归的条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到中间节点作为根节点 （左侧）</span></span><br><span class="line">        <span class="keyword">int</span> p = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inorder traversal: left -&gt; node -&gt; right</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[p]);</span><br><span class="line">        root.left  = helper(left, p -<span class="number">1</span>,nums);</span><br><span class="line">        root.right = helper(p + <span class="number">1</span>,right,nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N) 每个元素只访问一次</li><li>空间复杂度：O(N) 二叉搜索树空间O(<em>N</em>)，递归栈深度 O(log<em>N</em>)。</li></ul><h2 id="方法二：中序遍历：始终选择中间位置右边元素作为根节点"><a href="#方法二：中序遍历：始终选择中间位置右边元素作为根节点" class="headerlink" title="方法二：中序遍历：始终选择中间位置右边元素作为根节点"></a>方法二：中序遍历：始终选择中间位置右边元素作为根节点</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200608/173643871.png" alt="mark"></p><ul><li>道理同上一个解法，这里不再重述</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always choose right middle node as a root</span></span><br><span class="line">    <span class="keyword">int</span> p = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((left + right) % <span class="number">2</span> == <span class="number">1</span>) ++p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inorder traversal: left -&gt; node -&gt; right</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[p]);</span><br><span class="line">    root.left = helper(left, p - <span class="number">1</span>);</span><br><span class="line">    root.right = helper(p + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><p>时间复杂度：O(N)，每个元素只访问一次。</p></li><li><p>空间复杂度：O(N)，二叉搜索树空间O(N)，递归栈深度 O(logN)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-108-Convert-Sorted-Array-to-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#Leecode-108-Convert-Sorted-Array-to-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;Leecode-108-Convert Sorted Array to Binary Search Tree&quot;&gt;&lt;/a&gt;Leecode-108-&lt;a href=&quot;https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Convert Sorted Array to Binary Search Tree&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定有序数组: [-10,-3,0,5,9],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   -3   9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;   &amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -10  5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据库-面经</title>
    <link href="http://zhuuu.work/2020/06/05/JavaInterview/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E7%BB%8F/"/>
    <id>http://zhuuu.work/2020/06/05/JavaInterview/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-06-05T02:38:38.000Z</published>
    <updated>2020-08-14T03:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库-面经"><a href="#数据库-面经" class="headerlink" title="数据库-面经"></a>数据库-面经</h1><h2 id="1-索引的本质"><a href="#1-索引的本质" class="headerlink" title="1. 索引的本质"></a>1. 索引的本质</h2><ul><li>官方的话：索引是帮助MySQL高效获取数据的排好序的数据结构</li></ul><ul><li><p>索引的数据结构</p><ul><li>二叉查找树<strong>(不使用，缺点是因为会变成一颗斜树)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/110901758.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/110930860.png" alt="mark"></p></li></ul><ul><li>红黑树（特化二叉平衡树AVL）<ul><li>缺点：维护平衡二叉树的代价非常大，<strong>树的高度会很大</strong></li></ul></li><li>Hash表</li><li>B-Tree（）</li></ul><a id="more"></a><h2 id="2-B-树-和-B-树"><a href="#2-B-树-和-B-树" class="headerlink" title="2. B 树 和 B+树"></a>2. B 树 和 B+树</h2><h3 id="2-1-B-Tree"><a href="#2-1-B-Tree" class="headerlink" title="2.1 B-Tree"></a>2.1 B-Tree</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/114028488.png" alt="mark"></p><ul><li>所有的叶子节点在同一层</li><li>根节点至少有两个子女</li></ul><h3 id="2-2-B-Tree"><a href="#2-2-B-Tree" class="headerlink" title="2.2 B+Tree"></a>2.2 B+Tree</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/114050759.png" alt="mark"></p><ul><li><p>它是B树的变种</p></li><li><p><strong>非叶子节点没有指针，叶子节点由指针顺序相连</strong></p></li><li><p><strong>data元素放到了叶子节点去</strong></p></li><li><p>高度为3的B+ 树 根节点可以存放 16KB /( 8B + 6B) = 1170个索引</p><ul><li>对于叶子节点来说可以存放 1170 * 1170 * 16 = 2000万左右的数据</li></ul></li></ul><h2 id="3-B-树索引"><a href="#3-B-树索引" class="headerlink" title="3. B + 树索引"></a>3. B + 树索引</h2><ul><li><p>B+ 树索引的本质就是B+树在数据库中的实现</p></li><li><p><strong>B + 索引的特点就是高扇出性</strong>，<strong>树一般高度在 2 到 4层 ，这也就是说明了查找某一个键值记录最多需要2到4次的 IO</strong></p></li><li><p><strong>B + 索引 分为 聚集索引和非聚集索引</strong></p></li><li><p>因为有<strong>双向指针</strong>的原因，所以可以<strong>快速的进行范围查找</strong></p></li></ul><p><strong>对于MyISAM来说（frm,MYD,MYI）：</strong></p><ul><li>frm 表结构</li><li>MYD 存数据</li><li>MYI  存索引</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/120500810.png" alt="mark"></p><p><strong>对于Innodb来说(frm ibd)：</strong></p><ul><li>frm 表结构</li><li>ibd : 数据 + 索引</li><li>innodb 表必须有<strong>主键</strong>，并且推荐使用整型的自增主键</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/120742564.png" alt="mark"></p><h3 id="3-1-聚集索引"><a href="#3-1-聚集索引" class="headerlink" title="3.1 聚集索引"></a>3.1 聚集索引</h3><ul><li><strong>聚集索引就是按照每张表的主键构造一棵B + 树，同时叶子节点存放的就是整张表的行记录（也就是说聚集索引的叶子节点称为数据页）</strong></li></ul><h3 id="3-2-非聚集索引"><a href="#3-2-非聚集索引" class="headerlink" title="3.2 非聚集索引"></a>3.2 非聚集索引</h3><h2 id="4-哈希-索引"><a href="#4-哈希-索引" class="headerlink" title="4. 哈希 索引"></a>4. 哈希 索引</h2><ul><li>对于哈希索引，数据库一般采用<strong>除法散列</strong>的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h(k) &#x3D; k mod m</span><br><span class="line"></span><br><span class="line">解释： k个关键字映射到m个槽中</span><br></pre></td></tr></table></figure><ul><li><strong>只对等值查找(where)有效果，对范围查找没效果</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select XXX where id &#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="5-联合索引"><a href="#5-联合索引" class="headerlink" title="5. 联合索引"></a>5. 联合索引</h2><ul><li>联合索引是指多表上多个列进行索引</li><li>从本质上来说，不同的是联合索引的键值的数量不是1，而是大于等于2.</li></ul><h3 id="5-1-最左前缀原则"><a href="#5-1-最左前缀原则" class="headerlink" title="5.1 最左前缀原则"></a>5.1 最左前缀原则</h3><ol><li>创建表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line">c INT,</span><br><span class="line">d INT,</span><br><span class="line">KEY index_abc(a,b,c)</span><br><span class="line">)ENGINE&#x3D;INNODB DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure><ol start="2"><li>插入 10000 条数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS proc_initData;</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE proc_initData()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">WHILE i&lt;&#x3D;10000 DO</span><br><span class="line">    INSERT INTO test(a,b,c,d) VALUES(i,i,i,i);</span><br><span class="line">    SET i &#x3D; i+1;</span><br><span class="line">END WHILE;</span><br><span class="line">END $</span><br><span class="line">CALL proc_initData();</span><br></pre></td></tr></table></figure><p>这样就建立好了联合索引（a，b，c）</p><ol start="3"><li><strong>接下来我们来验证最左前缀原则</strong></li></ol><ul><li><p>关于explain 指令详解可以查看：[Explain指令][<a href="https://www.cnblogs.com/gomysql/p/3720123.html]" target="_blank" rel="noopener">https://www.cnblogs.com/gomysql/p/3720123.html]</a></p></li><li><p>接下来几个查询都是<strong>满足最左前缀原则的</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># a为主键，</span><br><span class="line">explain select * from test where a&lt;10 ;</span><br><span class="line"></span><br><span class="line">explain select * from test where a&lt;10 and b &lt;10;</span><br><span class="line"></span><br><span class="line">explain select * from test where a&lt;10 and b &lt;10 and c&lt;10;</span><br></pre></td></tr></table></figure><ul><li>能不能将 a，b出现顺序换一下，a，b，c出现顺序换一下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这样也是满足最左前缀原则的</span><br><span class="line"># 原因是：即使a不是在where的最左方，但mysql优化器会判断纠正这条sql以设么样执行效率最高，最后才生成最后的计划</span><br><span class="line">explain select * from test where b&lt;10 and a &lt;10;</span><br><span class="line"></span><br><span class="line">explain select * from test where b&lt;10 and a &lt;10 and c&lt;10;</span><br></pre></td></tr></table></figure><p><strong>以上都是用到了联合索引的。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200606/104420926.png" alt="mark"></p><ul><li><strong>重点</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 不会用到索引</span><br><span class="line">explain select * from test where b&lt;10 and c &lt;10;</span><br><span class="line"># 会用到索引</span><br><span class="line">explain select * from test where a&lt;10 and c &lt;10;</span><br><span class="line"></span><br><span class="line"># 为什么 b&lt;10 and c &lt;10,没有用到索引？而 a&lt;10 and c &lt;10用到了？</span><br><span class="line"></span><br><span class="line"># 原因：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树会按照从左到右的原则来建立搜索树，</span><br><span class="line"># 比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name 相同再比较sex和age,最后得到检索的数据</span><br><span class="line"># 但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</span><br><span class="line"># 比如当(张三,F)这样的数据来检索时，B+树可以用name来制定搜索方向，即使下一个字段age缺失，也可以把名字等于张三的数据都找到了，然后在匹配到F的数据，这就是复杂索引的最左匹配原则</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200606/104828872.png" alt="mark"></p><h2 id="6-Mysql事务"><a href="#6-Mysql事务" class="headerlink" title="6. Mysql事务"></a>6. Mysql事务</h2><ul><li><strong>事务的定义：事务会把数据会把数据库从一种一致的状态转换到另外一种一致的状态，在数据提交的工作时候，可以保证要么所有的修改都已经保存好了，要么所有的修改都不保存（要么成功，要么失败）</strong></li><li><strong>对于Innodb而言，其默认的事务隔离级别是READ REPEATABLE,完全遵循和符合事务的ACID的特性</strong></li></ul><ul><li>将一组SQL放在同一个批次去执行</li><li>如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行</li><li>MySQL事务处理只支持InnoDB和BDB数据表类型</li></ul><h3 id="6-1-事务的ACID原则"><a href="#6-1-事务的ACID原则" class="headerlink" title="6.1 事务的ACID原则"></a>6.1 事务的ACID原则</h3><ol><li><strong>原子性（Atomicity）</strong></li></ol><p>参考博客（<a href="https://blog.csdn.net/dengjili/article/details/82468576）" target="_blank" rel="noopener">https://blog.csdn.net/dengjili/article/details/82468576）</a></p><p><strong>核心：要么都成功，要么都失败</strong></p><ul><li>事务中任何一个SQL语句执行失败，已经成功执行的SQL语句也必须要撤销，数据库状态应该退回到执行事务前的状态。</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200225113920.png" alt=""></p><p>这个过程包含两个步骤</p><p>A： 800 - 200 = 600<br> B:   200 + 200 = 400</p><ol start="2"><li><strong>一致性：  (Consistency)</strong></li></ol><p><strong>核心：事务前后的一致性要保持一致</strong></p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200225113942.png" alt=""></p><p>操作前A：800，B：200<br>操作后A：600，B：400</p><p>一致性表示事务完成后，符合逻辑运算</p><ol start="3"><li><strong>隔离性（Isolaiton）</strong></li></ol><p><strong>核心：事务的隔离性是多个用户并发访问数据库的时候，数据库为每一个用户开启的事务，不能被其他用户访问，事务之间需要相互隔离。（通常使用锁来实现）</strong></p><ul><li>事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即事务提交前对其他事务都不可见，通常这使用锁来实现。</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200225114142.png" alt=""></p><ol start="4"><li><strong>持久性（Durability）</strong></li></ol><p><strong>核心：事务一旦提交则不可逆，被持久化到数据库中</strong></p><p>操作前A：800，B：200<br>操作后A：600，B：400</p><ul><li>如果在操作前（事务还没提交）服务器宕机或者断电，那么重启数据库之后，数据状态应该为 A：800 B:  200</li><li>如果在操作后（事务已经提交）服务器宕机或者断电，那么重启数据库之后，数据状态应该为 A:   600 B : 400</li></ul><h3 id="6-2-并发操作带来的隔离性的问题"><a href="#6-2-并发操作带来的隔离性的问题" class="headerlink" title="6.2 并发操作带来的隔离性的问题"></a>6.2 并发操作带来的隔离性的问题</h3><ul><li><strong>并发操作带来的隔离性的问题：本质上是锁带来的问题</strong></li></ul><p><strong>写的还可以的参考博客</strong>：<a href="https://www.cnblogs.com/shan-kylin/p/9543294.html" target="_blank" rel="noopener">https://www.cnblogs.com/shan-kylin/p/9543294.html</a></p><ol><li><strong>脏读：一个事务读取了另一个事务未提交的数据</strong></li></ol><p>首先分清楚脏页和脏数据的完全不同的概念</p><ul><li><strong>脏页</strong>： 缓冲池中已经修改的页，但还没有刷新到磁盘中，即数据库中的页和磁盘中的页数据是不一样的。</li><li><strong>脏数据：</strong>事务对缓冲池中行记录的修改，并且还没有提交</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200814-103338999.png" alt="mark"></p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200225114310.png" alt=""></p><ol start="2"><li><strong>不可重复读：</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200814-103849043.png" alt="mark"></p><ul><li>在一个事务中多次读取同一个数据集合，在这个事务还没有结束的时候，另外一个事务也访问该同一个数据集合，并做了一些DML操作。因此在第一个事务中两次读取数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能不一样，这种情况叫做不可重复读。</li><li><strong>与脏读的区别是，不可重复读读到的是已提交的数据，脏读读到的是未提交的数据。</strong></li></ul><p>不可重复读（Non-repeatable Reads）：一个事务对同一行数据重复读取两次，但是却得到了不同的结果。</p><p><strong>解决方法——引入隔离级别更高事务隔离：可重复读</strong></p><p>包括以下情况：</p><ul><li><strong>虚读</strong>：事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读取该数据时得到与前一次不同的值。</li><li><strong>幻读</strong>：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据。这是因为在两次查询过程中有另外一个事务插入数据造成的。</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200225114329.png" alt=""></p><ol start="3"><li><strong>丢失更新</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200814-100411279.png" alt="mark"></p><p>很明显的看出，旺财对A添加的20块不翼而飞了，这就是<strong>“数据丢失”，</strong>对事务不加任何锁（不存在事务隔离），就会导致这种问题。</p><ul><li><strong>简单的来说就是一个事务的更新操作会被另外一个事务的更新操作所覆盖。</strong></li><li><strong>要解决这个问题需要让事务的操作变成串行化，而不是并行操作。（Select … for update : 读的时候加一把排他锁）</strong></li></ul><p>逻辑意义的丢失更新出现的场景：</p><ol><li>事务T1 查询一行数据，放入本地内存，并显示给User1</li><li>事务T2 查询同一行数据，放入本地内存，并显示给User2</li><li>User1修改数据，更新数据库并提交</li><li>User2修改数据，更新数据库并提交</li></ol><h3 id="6-3-事务的隔离级别"><a href="#6-3-事务的隔离级别" class="headerlink" title="6.3 事务的隔离级别"></a>6.3 事务的隔离级别</h3><p>为了避免上面出现的几种情况，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。</p><ul><li><strong>读未提交（Read Uncommitted）</strong> ： <strong>只处理更新丢失</strong>。如果一个事务已经开始写数据，则不允许其他事务进行写操作，但允许其他事务读数据。可通过“排他写锁”实现。（ <strong>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。）</strong></li><li>简单一句话：操作：写数据的时候添加一个X锁（排他锁），也就是在写数据的时候不允许其他事务进行写操作，但是读不受限制，读不加锁。（这样就可以解决了多个人一起写数据而导致了“数据丢失”的问题，但是会引发新的问题——脏读。）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200814-100613256.png" alt="mark"></p><ul><li><strong>读已提交（Read Committed）</strong>：<strong>处理更新丢失，脏读</strong>。读取数据的事务允许其他事务继续访问修改数据，但是未提交的写事务会禁止其他事务访问修改。可通过“瞬间共享读锁”和“排他写锁”实现。<strong>（它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。）</strong></li></ul><p>操作：写数据的时候加上X锁（排他锁），读数据的时候添加S锁（共享锁），而且有约定：<strong>如果一个数据加了X锁就没法加S锁；同理如果加了S锁就没法加X锁，但是一个数据可以同时存在多个S锁（因为只是读数据），并且规定S锁读取数据，一旦读取完成就立刻释放S锁（不管后续是否还有很多其他的操作，只要是读取了S锁的数据后，就立刻释放S锁）。</strong></p><p>这样就解决了脏读的问题，但是又有新的问题出现——不可重复读。</p><p>解决方法——引入隔离级别更高事务隔离：可重复读</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200814-103749910.png" alt="mark"></p><ul><li><strong>可重复读（Repeatable Read）:</strong> <strong>处理更新丢失，脏读和不可重复读。</strong>读取数据的事务会禁止写事务，但允许读事务，写事务则禁止任何其他事务。可通过“共享读锁”和“排他写锁”实现。（Mysql在REPEATABLE READ 事务隔离的级别下，使用next-key-lock算法，来避免幻读的产生。）（Mysql 默认的隔离级别，它保证同一个事务在多个实例并发读取的时候，会看到同样的数据行。）</li></ul><p><strong>操作：对S锁进行修改，之前的S锁是：读取了数据之后就立刻释放S锁，现在修改是：在读取数据的时候加上S锁，但是要直到事务准备提交了才释放该S锁，X锁还是一致。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200814-104055542.png" alt="mark"></p><p><strong>这样就解决了不可重复读的问题了，但是又有新的问题出现——幻读。</strong></p><p>例如：</p><p>有一次旺财对一个“学生表”进行操作，选取了年龄是18岁的所有行， 用X锁锁住， 并且做了修改。</p><p>改完以后旺财再次选择所有年龄是18岁的行， 想做一个确认， 没想到有一行竟然没有修改！</p><p>这是怎么回事？ 出了幻觉吗？</p><p>原来就在旺财查询并修改的的时候， 小强也对学生表进行操作， 他插入了一个新的行，其中的年龄也是18岁！ 虽然两个人的修改都没有问题， 互不影响， 但从最终效果看， 还是出了事。</p><p>（<strong>码农翻身注： 正是小强的操作， 让旺财出现了“幻读”）</strong></p><p>解决幻读的方式——串行化</p><ul><li><strong>序列化（Serializable）</strong> ： <strong>提供严格的事务隔离级别</strong>。要求失去序列化执行，事务只能一个一个的执行，不能并发的执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。（<strong>主要用于Innodb的分布式事务</strong>）（最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读的问题，简而言之，就是在每个读的数据行上加上共享锁。）</li></ul><p><strong>事务只能一件一件的进行，不能并发进行。</strong></p><p><strong>注意：</strong></p><ul><li><strong><em>隔离级别越高，越能保证数据的完整性和统一性，但是对并发性能的影响也越大。</em></strong></li><li><strong><em>对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读，而且具有较好的并发性能。</em></strong></li><li><strong><em>尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</em></strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库-面经&quot;&gt;&lt;a href=&quot;#数据库-面经&quot; class=&quot;headerlink&quot; title=&quot;数据库-面经&quot;&gt;&lt;/a&gt;数据库-面经&lt;/h1&gt;&lt;h2 id=&quot;1-索引的本质&quot;&gt;&lt;a href=&quot;#1-索引的本质&quot; class=&quot;headerlink&quot; title=&quot;1. 索引的本质&quot;&gt;&lt;/a&gt;1. 索引的本质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;官方的话：索引是帮助MySQL高效获取数据的排好序的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;索引的数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉查找树&lt;strong&gt;(不使用，缺点是因为会变成一颗斜树)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/110901758.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/110930860.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;红黑树（特化二叉平衡树AVL）&lt;ul&gt;
&lt;li&gt;缺点：维护平衡二叉树的代价非常大，&lt;strong&gt;树的高度会很大&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hash表&lt;/li&gt;
&lt;li&gt;B-Tree（）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="面经总结" scheme="http://zhuuu.work/tags/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    
      <category term="索引优化" scheme="http://zhuuu.work/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-238-除自身以外数组的乘积</title>
    <link href="http://zhuuu.work/2020/06/04/Leetcode/Leetcode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <id>http://zhuuu.work/2020/06/04/Leetcode/Leetcode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</id>
    <published>2020-06-04T07:33:53.000Z</published>
    <updated>2020-06-05T01:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-238-Product-of-Array-Except-Self"><a href="#Leecode-238-Product-of-Array-Except-Self" class="headerlink" title="Leecode-238-Product of Array Except Self"></a>Leecode-238-<a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">Product of Array Except Self</a></h1><h2 id="思路：左右乘积列表"><a href="#思路：左右乘积列表" class="headerlink" title="思路：左右乘积列表"></a>思路：左右乘积列表</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个长度为 n 的整数数组 nums，</span><br><span class="line">其中 n &gt; 1，返回输出数组 output ，</span><br><span class="line">其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong>题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p><p><strong>说明:</strong> 请<strong>不要使用除法，</strong>且在 O(<em>n</em>) 时间复杂度内完成此题。</p><p><strong>进阶：</strong><br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p><a id="more"></a><h2 id="方法一：左右两个列表保存前缀和后缀乘积"><a href="#方法一：左右两个列表保存前缀和后缀乘积" class="headerlink" title="方法一：左右两个列表保存前缀和后缀乘积"></a>方法一：左右两个列表保存前缀和后缀乘积</h2><p>思路： 不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/085330808.png" alt="mark"></p><ul><li><p>对于给定索引 i，我们将使用它左边所有数字的乘积乘以右边所有数字的乘积。下面让我们更加具体的描述这个算法。</p></li><li><p>初始化两个空数组L 和 R ,对于给定的索引i ,L[i] 代表i 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</p></li><li><p>我们需要用两个循环来填充 L 和 R 数组的值。对于数组 L，L[0] 应该是 1，因为第一个元素的左边没有元素。对于其他元素：<code>L[i] = L[i-1] * nums[i-1]</code>。</p></li></ul><ul><li>当 <code>R</code> 和 <code>L</code> 数组填充完成，我们只需要在输入数组上迭代，且索引 <code>i</code> 处的值为：<code>L[i] * R[i]</code>。</li></ul><p>举个例子：</p><ul><li>数组L 的形成</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/085545678.png" alt="mark"></p><ul><li>数组R的形成</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/085622095.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/085637517.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引是0的元素，因为左边没有元素，所以L[0] = 1</span></span><br><span class="line">        <span class="comment">// L[i]是索引i左侧所有元素的乘积</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引是 len - 1 的元素，因为右侧没有元素，所以R[len - 1] = 1</span></span><br><span class="line">        <span class="comment">// R[i] 是索引i右侧所有元素的乘积</span></span><br><span class="line">        R[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后算是前缀和后缀的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(n)。</strong>其中 N指的是数组 <code>nums</code> 的大小。预处理 <code>L</code> 和 <code>R</code> 数组以及最后的遍历计算都是 O(N)的时间复杂度。</li><li><strong>空间复杂度：O(n)。</strong> 其中 N指的是数组 <code>nums</code> 的大小。使用了 <code>L</code> 和 <code>R</code> 数组去构造答案，<code>L</code> 和 <code>R</code> 数组的长度为数组 <code>nums</code> 的大小。</li></ul><h2 id="方法二：-O-1-的空间复杂度"><a href="#方法二：-O-1-的空间复杂度" class="headerlink" title="方法二： O(1)的空间复杂度"></a>方法二： O(1)的空间复杂度</h2><p><strong>思路</strong></p><p>尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。</p><p>由于输出数组不算 空间复杂度 ，所以我们可以想到</p><ul><li>让输出数组代替原来的L 数组</li><li>同时让R 变成一个不断更新的整型变量</li></ul><p><strong>算法思想：</strong></p><ul><li>初始化 <code>answer</code> 数组，对于给定索引 <code>i</code>，<code>answer[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积。</li><li>构造方式与之前相同，只是我们试图节省空间，先把 <code>answer</code> 作为方法一的 <code>L</code> 数组。</li><li>这种方法的唯一区别是我们没有构造R数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组<code>answer[i] = answer[i] * R</code>, 同时<code>R = R*nums[i]</code>,这里的R表示的就是索引右侧数字的乘积。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/090333694.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 只需使用一个数组保存答案</span></span><br><span class="line">        <span class="comment">// 空间复杂度降到O(1)</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i]表示索引i左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// answer[0] = 1。因为索引为 '0' 的元素左侧没有元素</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R是一个整型变量，代表右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始最后一个元素右边没有元素，R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引i ,左边的成绩是answer[i] , 右边的乘积是R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// R需要包括右边所有元素的成绩，所以计算结果更新到R上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-238-Product-of-Array-Except-Self&quot;&gt;&lt;a href=&quot;#Leecode-238-Product-of-Array-Except-Self&quot; class=&quot;headerlink&quot; title=&quot;Leecode-238-Product of Array Except Self&quot;&gt;&lt;/a&gt;Leecode-238-&lt;a href=&quot;https://leetcode-cn.com/problems/product-of-array-except-self/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Product of Array Except Self&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：左右乘积列表&quot;&gt;&lt;a href=&quot;#思路：左右乘积列表&quot; class=&quot;headerlink&quot; title=&quot;思路：左右乘积列表&quot;&gt;&lt;/a&gt;思路：左右乘积列表&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给你一个长度为 n 的整数数组 nums，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中 n &amp;gt; 1，返回输出数组 output ，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [24,12,8,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 请&lt;strong&gt;不要使用除法，&lt;/strong&gt;且在 O(&lt;em&gt;n&lt;/em&gt;) 时间复杂度内完成此题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;br&gt;你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组&lt;strong&gt;不被视为&lt;/strong&gt;额外空间。）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Docker-09-网络原理</title>
    <link href="http://zhuuu.work/2020/06/03/Docker/Docker-09-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/06/03/Docker/Docker-09-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-03T06:44:24.000Z</published>
    <updated>2020-06-04T09:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-09-网络原理"><a href="#Docker-09-网络原理" class="headerlink" title="Docker-09-网络原理"></a>Docker-09-网络原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当你开始大规模使用Docker时，你会发现需要了解很多关于网络的知识。Docker作为目前最火的轻量级容器技术，有很多令人称道的功能，如Docker的镜像管理。然而，Docker同样有着很多不完善的地方，网络方面就是Docker比较薄弱的部分。因此，我们有必要深入了解Docker的网络知识，以满足更高的网络需求。本文首先介绍了Docker自身的4种网络工作方式，然后介绍一些自定义网络模式。</p><a id="more"></a><h2 id="1-理解-Docker-0"><a href="#1-理解-Docker-0" class="headerlink" title="1. 理解 Docker 0"></a>1. 理解 Docker 0</h2><ul><li>首先通过<code>ip addr</code> 查看ip环境</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/221802079.png" alt="mark"></p><p>可以明显的看到网络有三个地址。</p><p><strong>我们每启动一个docker 容器，docker就会给docker容器分配一个ip ，我们只要安装了docker ，就会有一个docker网卡<code>docker0</code></strong></p><ul><li><p><strong>使用的技术是evth-pair技术！（桥接模式）</strong></p><ul><li>在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备</li></ul></li><li><p>Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。</p><ul><li>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</li></ul></li><li><p><strong>每启动一个容器，就会多一对网络地址</strong></p></li><li><p><strong>所以docker容器之间都是可以互相ping通的！！！</strong></p></li></ul><p><strong>示意图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/224057604.png" alt="mark"></p><p><strong>结论：</strong></p><ul><li>所有的容器不指定网络的情况下，都是由docker0路由的，docker会给每一个容器分配一个可用的Ip</li><li>Docker中的所有网络都是虚拟的，这样转发的效率高。</li><li>只要容器删除，对应的网桥就没了。</li></ul><h2 id="2-使用–-link"><a href="#2-使用–-link" class="headerlink" title="2. 使用– link"></a>2. 使用– link</h2><p>接下来有个思考问题？</p><ul><li>如果宕机（或者重启），容器ip发生了变化，那么可以使用名字来访问容器吗？</li></ul><p><code># 如: 通过--link就可以解决</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name 服务名1 --link 服务名2 要启动的服务</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如: 通过--link就可以解决</span></span><br><span class="line">docker run -d -P --name tomcat01 --link tomcat02 tomcat</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">这样只能实现单向的联通</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>-- link</code> : 本质上就是在etc/hosts 中增加了另一个服务的映射</strong> </p></li><li><p>但是<code>-- link</code> 已经不推荐使用(Docker0 不支持容器名访问)</p></li></ul><h2 id="3-自定义网络"><a href="#3-自定义网络" class="headerlink" title="3. 自定义网络"></a>3. 自定义网络</h2><h3 id="3-1-网络模式"><a href="#3-1-网络模式" class="headerlink" title="3.1 网络模式"></a>3.1 网络模式</h3><p><strong>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host</strong></p><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Host</td><td>容器不会虚拟自己的网卡，配置自己的Ip地址，而是使用宿主机的ip和端口</td></tr><tr><td>Bridge</td><td>此模式会为了每一个容器分配，设置IP，并将容器连接到一个docker0的虚拟网桥，通过docker0网桥连接以及iptables nat表配置与宿主机的通信</td></tr><tr><td>none</td><td>该模式关闭了容器的网络功能</td></tr><tr><td>Container</td><td>创建的容器不会创建自己的网卡，配置自己的ip，而是和一个指定的容器共享ip，端口范围</td></tr><tr><td>自定义网络</td><td>略</td></tr></tbody></table><h3 id="3-2-默认网络"><a href="#3-2-默认网络" class="headerlink" title="3.2 默认网络"></a>3.2 默认网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">0147b8d16c64        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">2da931af3f0b        host                host                <span class="built_in">local</span></span><br><span class="line">63d31338bcd9        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/144135446.png" alt="mark"></p><ul><li><p>Docker内置这三个网络，运行容器时，你可以使用该–network标志来指定容器应连接到哪些网络。</p></li><li><p>该bridge网络代表docker0 所有Docker安装中存在的网络。除非你使用该docker run –network=选项指定，否则Docker守护程序默认使用Bridge模式</p></li></ul><h3 id="3-3-自定义网络"><a href="#3-3-自定义网络" class="headerlink" title="3.3 自定义网络"></a>3.3 自定义网络</h3><ul><li><strong>建议使用自定义网桥来控制哪些容器之间可以相互通信，还可以自动DNS解析容器名称到ip地址</strong></li><li><strong>Docker提供了创建这些网络的默认网络驱动程序，你可以创建一个新的Bridge网络，Overlay或Macvlan网络</strong></li></ul><p>接下来介绍Dokcer的内置网络驱动程序。</p><ol><li><strong>Bridge</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br></pre></td></tr></table></figure><ul><li>一个bridge网络是Docker中最常用的网络类型。</li><li>桥接网络类似于默认bridge网络，但添加一些新功能并删除一些旧的能力。</li></ul><p>创建成功后结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">38cf4307d18e        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">227d5be3657a        host                host                <span class="built_in">local</span></span><br><span class="line">b1ae1f4f0884        mynet               bridge              <span class="built_in">local</span></span><br><span class="line">84aeff069277        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker network inspect mynet</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"mynet"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"b1ae1f4f088456d79d05194b76b69a2ecc543249bc061f5dca8cccf88cf0dd18"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2020-06-04T14:50:29.74809742+08:00"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"192.168.0.0/16"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"192.168.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>测试：创建两个tomcat容器并丢入我们自己创建的网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker run -d -P --name tomcat-net-01 --net mynet tomcat</span></span><br><span class="line">9e43abf5054091f38d76ccd85c1b7324f266920ef31576d33293faf3281c2b34</span><br><span class="line">root@Zhuuu:~<span class="comment"># docker run -d -P --name tomcat-net-02 --net mynet tomcat</span></span><br><span class="line">1ce722ed205dc443ec308665e0bffd5d9e2c148d65728c278b2f5e5aa13ac9b0</span><br></pre></td></tr></table></figure><p>再次查看：发现多出了两个容器在这个网络中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker network inspect mynet</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"mynet"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"b1ae1f4f088456d79d05194b76b69a2ecc543249bc061f5dca8cccf88cf0dd18"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2020-06-04T14:50:29.74809742+08:00"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"192.168.0.0/16"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"192.168.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"1ce722ed205dc443ec308665e0bffd5d9e2c148d65728c278b2f5e5aa13ac9b0"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"tomcat-net-02"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"dc2f31d7e5955a2d43945b30b16f70bc017a7eb60fc5556c27ca76b579c96d6e"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:00:03"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.0.3/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"9e43abf5054091f38d76ccd85c1b7324f266920ef31576d33293faf3281c2b34"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"tomcat-net-01"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"b18174355605a296f99d10182219e41d746da84cab390d5682f3c870e598bc4d"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.0.2/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>优点：<ul><li>不使用 – link 也可以让容器通过网桥互通</li><li>自定义的网络已经维护好了对应的关系</li><li>推荐使用自定义网络</li><li>不同集群之间网络是可以互相隔离的</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker exec -it tomcat-net-01 ping tomcat-net-02</span></span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.125 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.093 ms</span><br><span class="line">^Z64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.106 ms</span><br></pre></td></tr></table></figure><h3 id="3-4-自定义网络连通"><a href="#3-4-自定义网络连通" class="headerlink" title="3.4 自定义网络连通"></a>3.4 自定义网络连通</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/145925139.png" alt="mark"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令使用</span></span><br><span class="line">docker network connect  网卡 容器名</span><br></pre></td></tr></table></figure><p>测试</p><ol><li>在docker0上新建两个tomcat容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span><br><span class="line">root@Zhuuu:~<span class="comment"># docker run -d -P --name tomcat02 tomcat</span></span><br></pre></td></tr></table></figure><ol start="2"><li>目前网络图</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/150159939.png" alt="mark"></p><ol start="3"><li>打通网络(tomcat02 加入到 mynet中)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect  mynet tomcat02</span><br></pre></td></tr></table></figure><p><strong>结果：将tomcat02加入到了mynet网络中（一个容器，两个ip）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker network connect mynet tomcat02</span></span><br><span class="line">root@Zhuuu:~<span class="comment"># docker exec -it tomcat02 ping tomcat-net-01</span></span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.092 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.079 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.094 ms</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/150723389.png" alt="mark"></p><h2 id="4-网络实战"><a href="#4-网络实战" class="headerlink" title="4. 网络实战"></a>4. 网络实战</h2><h3 id="4-1-部署redis集群"><a href="#4-1-部署redis集群" class="headerlink" title="4.1 部署redis集群"></a>4.1 部署redis集群</h3><ul><li>分片 + 高可用 + 负载均衡</li></ul><ol><li>创建集群网络环境</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create redis --subnet 172.38.0.0/16</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/154127625.png" alt="mark"></p><ol start="2"><li>创建6个redis服务并修改配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> $(seq 1 6);\</span><br><span class="line"><span class="keyword">do</span> \</span><br><span class="line">mkdir -p /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf</span><br><span class="line">touch /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1<span class="variable">$&#123;port&#125;</span></span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动6个服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 637<span class="variable">$&#123;port&#125;</span>:6379 -p 1637<span class="variable">$&#123;port&#125;</span>:16379 --name redis-<span class="variable">$&#123;port&#125;</span> \</span><br><span class="line">-v /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/data:/data \</span><br><span class="line">-v /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.0<span class="variable">$&#123;port&#125;</span> redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \</span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;port&#125;就代表自身的端口号</span></span><br></pre></td></tr></table></figure><ol start="4"><li>进入redis配置集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis配置集群</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis-1 /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置集群</span></span><br><span class="line">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span><br></pre></td></tr></table></figure><h3 id="4-2-SpringBoot-微服务打包Docker镜像"><a href="#4-2-SpringBoot-微服务打包Docker镜像" class="headerlink" title="4.2 SpringBoot 微服务打包Docker镜像"></a>4.2 SpringBoot 微服务打包Docker镜像</h3><ol><li>构建SpringBoot 项目</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,朱酱酱"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>打包应用</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/164856776.png" alt="mark"></p><ol start="3"><li>编写dockerfile</li></ol><ul><li>在idea中装一个插件</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/165026808.png" alt="mark"></p><p>安装成功之后：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/165114532.png" alt="mark"></p><ul><li>编写dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> *.jar /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"--server.port=8080"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>发布运行</li></ol><ul><li>只需要把生成的jar包和dockerfile放到服务器上即可</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/165658531.png" alt="mark"></p><ul><li>服务端构建镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t zhuuu666 .</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/170105165.png" alt="mark"></p><ul><li>最后启动测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name testproject-web zhuuu666</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/171154131.png" alt="mark"></p><p><strong>搞定收工！！！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-09-网络原理&quot;&gt;&lt;a href=&quot;#Docker-09-网络原理&quot; class=&quot;headerlink&quot; title=&quot;Docker-09-网络原理&quot;&gt;&lt;/a&gt;Docker-09-网络原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当你开始大规模使用Docker时，你会发现需要了解很多关于网络的知识。Docker作为目前最火的轻量级容器技术，有很多令人称道的功能，如Docker的镜像管理。然而，Docker同样有着很多不完善的地方，网络方面就是Docker比较薄弱的部分。因此，我们有必要深入了解Docker的网络知识，以满足更高的网络需求。本文首先介绍了Docker自身的4种网络工作方式，然后介绍一些自定义网络模式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
</feed>
