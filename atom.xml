<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱酱酱的学习博客</title>
  <icon>https://www.gravatar.com/avatar/336d255f627c733c7a50883547bcec06</icon>
  <subtitle>From Zero to Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuuu.work/"/>
  <updated>2020-10-08T02:25:26.366Z</updated>
  <id>http://zhuuu.work/</id>
  
  <author>
    <name>Zhuuu</name>
    <email>353446503@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-303-区域和检索</title>
    <link href="http://zhuuu.work/2020/10/09/Leetcode/Leetcode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/"/>
    <id>http://zhuuu.work/2020/10/09/Leetcode/Leetcode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/</id>
    <published>2020-10-09T01:52:53.000Z</published>
    <updated>2020-10-08T02:25:26.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-303-区域和检索-数组不可变"><a href="#Leetcode-303-区域和检索-数组不可变" class="headerlink" title="Leetcode-303-区域和检索 - 数组不可变"></a>Leetcode-303-<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设数组不可变。<br>会多次调用 sumRange 方法。</p><a id="more"></a><h2 id="思路-：-前缀和"><a href="#思路-：-前缀和" class="headerlink" title="思路 ： 前缀和"></a>思路 ： 前缀和</h2><ul><li>一上来我们不说前缀和这个思路，先说个普通的暴力解法</li></ul><p><strong>暴力解法</strong></p><ul><li>每次调用 <code>sumrange</code> 时，我们都使用for循环将索引 i 到 j 之间的每个元素相加。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    data = nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">        sum += data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：每次查询的时间 O(n)，每个 sumrange 查询需要 O(n)时间。</li><li>空间复杂度：O(1)，请注意，data 是对 nums 的引用，不是它的副本。</li></ul><p><strong>前缀和</strong></p><ul><li>假设我们预先计算了从数字 0 到 k的累积和。我们可以用这个信息得出 <code>sum(i，j)</code>吗？</li><li>让我们将 s<strong>u</strong>m[k] 定义为<code>nums[0⋯k−1]</code> 的累积和（包括这两个值）：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/102327279.png" alt="mark"></p><ul><li>现在，我们可以计算 <code>sumrange</code>如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/102342287.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sum[0] = 0</span></span><br><span class="line">    <span class="comment">// sum[] 数组用于计算前缀和</span></span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算索引下标区间内的求和公式</span></span><br><span class="line">    <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>注意，在上面的代码中，我们插入了一个虚拟 0 作为 sum 数组中的第一个元素。这个技巧可以避免在 <code>sumrange</code> 函数中进行额外的条件检查。</li></ul><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：每次查询的时间 O(1)，</p><ul><li>O(N)预计算时间。由于累积和被缓存，每个<code>sumrange</code>都可以用 O(1)时间计算。</li></ul></li><li><p>空间复杂度：O(n).</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-303-区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#Leetcode-303-区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-303-区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;Leetcode-303-&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区域和检索 - 数组不可变&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定 nums &amp;#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(0, 2) -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(2, 5) -&amp;gt; -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(0, 5) -&amp;gt; -3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;你可以假设数组不可变。&lt;br&gt;会多次调用 sumRange 方法。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-11-经典进程同步互斥问题</title>
    <link href="http://zhuuu.work/2020/10/09/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/10/09/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-09T00:00:53.000Z</published>
    <updated>2020-10-09T01:38:34.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-11-经典进程同步互斥问题"><a href="#操作系统-11-经典进程同步互斥问题" class="headerlink" title="操作系统-11-经典进程同步互斥问题"></a>操作系统-11-经典进程同步互斥问题</h1><h2 id="1-消费者-生产者问题"><a href="#1-消费者-生产者问题" class="headerlink" title="1. 消费者-生产者问题"></a>1. 消费者-生产者问题</h2><p><strong>1. 问题描述</strong></p><ul><li>系统中有<code>一组生产者进程</code>和<code>一组消费者进程</code>，生产者进程每次<code>生产一个</code>产品放入缓冲区，消费者进程每次从缓冲区中<code>取出一个</code>产品并使用。(注: 这里的“产品”理解为某种数据)</li><li>生产者、消费者<code>共享</code>一个初始为空、大小为n的<code>缓冲区</code>。</li><li>只有缓冲区<code>没满</code>时，<code>生产者</code>才能把产品<code>放入</code>缓冲区，否则必须等待。</li><li>只有缓冲区<code>不空</code>时，<code>消费者</code>才能从中<code>取出</code>产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须<code>互斥</code>地访问。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091536548.png" alt="mark"></p><a id="more"></a><ol start="2"><li><strong>问题分析</strong></li></ol><ul><li><strong>1)关系分析</strong>。生产者和消费者对缓冲区互斥访问是<code>互斥关系</code>，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后,消费者才能消费，它们也是<code>同步关系</code>。</li><li><strong>2)整理思路</strong>。根据各进程的操作流程确定P、V操作的大致顺序。<br>生产者每次要消耗(P）一个空闲缓冲区，并生产(V)一个产品。<br>消费者每次要消耗(P）一个产品，并释放一个空闲缓冲区(V)。<br>往缓冲区放入/取走产品需要互斥。</li><li><strong>3)信号量设置。</strong>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。( 互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091728863.png" alt="mark"></p><ol start="3"><li><strong>实现</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091816753.png" alt="mark"></p><p><strong>注意 ： 实现互斥的P操作一定要在实现同步的P操作之后（否则会有死锁问题）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092337577.png" alt="mark"></p><p><strong>单生产者-消费者回顾</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092555328.png" alt="mark"></p><h2 id="2-多生产者-消费者问题"><a href="#2-多生产者-消费者问题" class="headerlink" title="2. 多生产者-消费者问题"></a>2. 多生产者-消费者问题</h2><p>待补</p><h2 id="3-吸烟者问题"><a href="#3-吸烟者问题" class="headerlink" title="3. 吸烟者问题"></a>3. 吸烟者问题</h2><ol><li><strong>问题描述</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092714018.png" alt="mark"></p><ol start="2"><li><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5></li></ol><ul><li><strong>本质是单生产者 - 多消费者的问题</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093058018.png" alt="mark"></p><ol start="3"><li><strong>实现方法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093158353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093214151.png" alt="mark"></p><p><strong>回顾 :</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093805017.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-11-经典进程同步互斥问题&quot;&gt;&lt;a href=&quot;#操作系统-11-经典进程同步互斥问题&quot; class=&quot;headerlink&quot; title=&quot;操作系统-11-经典进程同步互斥问题&quot;&gt;&lt;/a&gt;操作系统-11-经典进程同步互斥问题&lt;/h1&gt;&lt;h2 id=&quot;1-消费者-生产者问题&quot;&gt;&lt;a href=&quot;#1-消费者-生产者问题&quot; class=&quot;headerlink&quot; title=&quot;1. 消费者-生产者问题&quot;&gt;&lt;/a&gt;1. 消费者-生产者问题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统中有&lt;code&gt;一组生产者进程&lt;/code&gt;和&lt;code&gt;一组消费者进程&lt;/code&gt;，生产者进程每次&lt;code&gt;生产一个&lt;/code&gt;产品放入缓冲区，消费者进程每次从缓冲区中&lt;code&gt;取出一个&lt;/code&gt;产品并使用。(注: 这里的“产品”理解为某种数据)&lt;/li&gt;
&lt;li&gt;生产者、消费者&lt;code&gt;共享&lt;/code&gt;一个初始为空、大小为n的&lt;code&gt;缓冲区&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;只有缓冲区&lt;code&gt;没满&lt;/code&gt;时，&lt;code&gt;生产者&lt;/code&gt;才能把产品&lt;code&gt;放入&lt;/code&gt;缓冲区，否则必须等待。&lt;/li&gt;
&lt;li&gt;只有缓冲区&lt;code&gt;不空&lt;/code&gt;时，&lt;code&gt;消费者&lt;/code&gt;才能从中&lt;code&gt;取出&lt;/code&gt;产品，否则必须等待。&lt;/li&gt;
&lt;li&gt;缓冲区是临界资源，各进程必须&lt;code&gt;互斥&lt;/code&gt;地访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091536548.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="进程互斥" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>java8-新特性-lambda</title>
    <link href="http://zhuuu.work/2020/10/08/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-lambda/"/>
    <id>http://zhuuu.work/2020/10/08/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-lambda/</id>
    <published>2020-10-08T14:30:53.000Z</published>
    <updated>2020-10-08T14:14:53.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8-新特性-lambda"><a href="#java8-新特性-lambda" class="headerlink" title="java8-新特性-lambda"></a>java8-新特性-lambda</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java8-新特性-lambda&quot;&gt;&lt;a href=&quot;#java8-新特性-lambda&quot; class=&quot;headerlink&quot; title=&quot;java8-新特性-lambda&quot;&gt;&lt;/a&gt;java8-新特性-lambda&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
    
      <category term="lambda表达式" scheme="http://zhuuu.work/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="java8" scheme="http://zhuuu.work/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-10-进程同步和互斥</title>
    <link href="http://zhuuu.work/2020/10/08/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/"/>
    <id>http://zhuuu.work/2020/10/08/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/</id>
    <published>2020-10-08T06:00:53.000Z</published>
    <updated>2020-10-08T14:04:23.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-10-进程同步和互斥"><a href="#操作系统-10-进程同步和互斥" class="headerlink" title="操作系统-10-进程同步和互斥"></a>操作系统-10-进程同步和互斥</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135327192.png" alt="mark"></p><a id="more"></a><h2 id="1-同步和互斥的概念"><a href="#1-同步和互斥的概念" class="headerlink" title="1. 同步和互斥的概念"></a>1. 同步和互斥的概念</h2><h3 id="1-1-进程同步"><a href="#1-1-进程同步" class="headerlink" title="1.1 进程同步"></a>1.1 进程同步</h3><ul><li><code>同步也称为直接制约关系。</code></li><li>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系,如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。</li><li>一个简单的例子来理解这个概念。</li><li>例如，让系统计算1 + 2x3，假设系统产生两个进程: 一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后,但实际上操作系统具有<code>异步性</code>,若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。</li></ul><blockquote><p>异步性：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p></blockquote><h3 id="1-2-进程互斥"><a href="#1-2-进程互斥" class="headerlink" title="1.2 进程互斥"></a>1.2 进程互斥</h3><ul><li><code>互斥，亦称间接制约关系</code>。<code>进程互斥</code>指当一个进程访问某临界资源时，另一个想要访问该<code>临界资源</code>的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li><li>在这里需复习一下<code>临界资源</code>的概念。</li><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135625431.png" alt="mark"></p><ul><li>为了禁止两个进程同时进入<code>临界区</code>，需遵循以下准则</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135640762.png" alt="mark"></p><h2 id="2-临界区进程互斥的实现方法"><a href="#2-临界区进程互斥的实现方法" class="headerlink" title="2. 临界区进程互斥的实现方法"></a>2. 临界区进程互斥的实现方法</h2><h3 id="2-1-软件实现方法"><a href="#2-1-软件实现方法" class="headerlink" title="2.1 软件实现方法"></a>2.1 软件实现方法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135912018.png" alt="mark"></p><ul><li>软件实现方法的思想：在进入区设置并检查一些标志 来标明是否有进程在临界区中,若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</li><li><code>入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</code></li></ul><ol><li><strong>单标志法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140023554.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140108733.png" alt="mark"></p><ol start="2"><li><strong>双标志先检查法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140538012.png" alt="mark"></p><ol start="3"><li><strong>双标志后检查法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140659932.png" alt="mark"></p><ol start="4"><li><strong>Peterson 算法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140915268.png" alt="mark"></p><h3 id="2-2-硬件实现方法"><a href="#2-2-硬件实现方法" class="headerlink" title="2.2 硬件实现方法"></a>2.2 硬件实现方法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141220331.png" alt="mark"></p><ol><li><strong>中断屏蔽</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141252814.png" alt="mark"></p><ol start="2"><li><strong><code>TestAndSet</code>指令</strong></li></ol><ul><li>执行<strong>TSL指令时</strong>，它的内部运转逻辑：<ul><li><strong>假设lock现在为false</strong>，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等</li><li><strong>假设lock为true</strong>，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141754753.png" alt="mark"></p><ol start="3"><li><strong>swap 指令</strong></li></ol><ul><li>old是每个进程都要进行的一步，都必须将<code>old=true</code></li><li>分析一下这样做的原因：<ul><li>因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化<code>old=true</code>，然后进入while循环进行交换，<strong>如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，</strong></li><li>同时因为交换，<code>lock=old=true</code>上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,<strong>当我使用完临界资源，则将<code>lock=false</code>,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142115031.png" alt="mark"></p><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142208661.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142319507.png" alt="mark"></p><h3 id="3-1-整型信号量"><a href="#3-1-整型信号量" class="headerlink" title="3.1 整型信号量"></a>3.1 整型信号量</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142307160.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142412015.png" alt="mark"></p><h3 id="3-2-记录型信号量"><a href="#3-2-记录型信号量" class="headerlink" title="3.2 记录型信号量"></a>3.2 记录型信号量</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142544410.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142843431.png" alt="mark"></p><ul><li><strong>一个案例：打印机资源为2访问</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142932870.png" alt="mark"></p><h3 id="3-3-信号量机制实现进程同步和互斥"><a href="#3-3-信号量机制实现进程同步和互斥" class="headerlink" title="3.3 信号量机制实现进程同步和互斥"></a>3.3 信号量机制实现进程同步和互斥</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143121739.png" alt="mark"></p><h4 id="3-3-1-互斥"><a href="#3-3-1-互斥" class="headerlink" title="3.3.1 互斥"></a>3.3.1 互斥</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143219225.png" alt="mark"></p><h4 id="3-3-2-同步"><a href="#3-3-2-同步" class="headerlink" title="3.3.2 同步"></a>3.3.2 同步</h4><ul><li>想象一下四则运算的顺序，加减乘除；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143432682.png" alt="mark"></p><ul><li>要想理解这一部分知识，必须知道P、V操作的内部实现原理</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143455765.png" alt="mark"></p><h4 id="3-3-3-前驱关系"><a href="#3-3-3-前驱关系" class="headerlink" title="3.3.3 前驱关系"></a>3.3.3 前驱关系</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/144126344.png" alt="mark"></p><h2 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220151031.png" alt="mark"></p><h3 id="4-1-为什么要引入管程？"><a href="#4-1-为什么要引入管程？" class="headerlink" title="4.1 为什么要引入管程？"></a>4.1 为什么要引入管程？</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220216654.png" alt="mark"></p><h3 id="4-2-管程的基本组成"><a href="#4-2-管程的基本组成" class="headerlink" title="4.2 管程的基本组成"></a>4.2 管程的基本组成</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220241848.png" alt="mark"></p><h3 id="4-3-管程实现消费者生产者问题"><a href="#4-3-管程实现消费者生产者问题" class="headerlink" title="4.3 管程实现消费者生产者问题"></a>4.3 管程实现消费者生产者问题</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220333491.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220352798.png" alt="mark"></p><h3 id="4-4-java中的管程"><a href="#4-4-java中的管程" class="headerlink" title="4.4 java中的管程"></a>4.4 java中的管程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220416205.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-10-进程同步和互斥&quot;&gt;&lt;a href=&quot;#操作系统-10-进程同步和互斥&quot; class=&quot;headerlink&quot; title=&quot;操作系统-10-进程同步和互斥&quot;&gt;&lt;/a&gt;操作系统-10-进程同步和互斥&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135327192.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="进程互斥" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>partition-合集</title>
    <link href="http://zhuuu.work/2020/10/07/LeetcodeExplore/partition-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/10/07/LeetcodeExplore/partition-%E5%90%88%E9%9B%86/</id>
    <published>2020-10-07T02:52:53.000Z</published>
    <updated>2020-10-07T07:33:36.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="partition-合集"><a href="#partition-合集" class="headerlink" title="partition-合集"></a>partition-合集</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/101823939.png" alt="mark"></p><h2 id="1-什么是-partition-？"><a href="#1-什么是-partition-？" class="headerlink" title="1. 什么是 partition ？"></a>1. 什么是 partition ？</h2><p>我们在学习 快速排序 的时候知道，可以选择一个标定元素（称为 pivot ，一般而言随机选择），然后通过一次扫描，把数组分成三个部分：</p><ul><li>第 1 部分严格小于 pivot 元素的值；</li><li>第 2 部分恰好等于 pivot 元素的值；</li><li>第 3 部分严格大于 pivot 元素的值。</li><li>第 2 部分元素就是排好序以后它们应该在的位置，接下来只需要递归处理第 1 部分和第 3 部分的元素。</li></ul><p>经过一次扫描把整个数组分成 3 个部分，正好符合当前问题的场景。写对这道题的方法是：把循环不变量的定义作为注释写出来，然后再编码。</p><a id="more"></a><h2 id="2-Leetcode-75-颜色分类-（荷兰旗问题）"><a href="#2-Leetcode-75-颜色分类-（荷兰旗问题）" class="headerlink" title="2. Leetcode-75. 颜色分类 （荷兰旗问题）"></a>2. Leetcode-<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a> （荷兰旗问题）</h2><p><strong>题目描述</strong></p><ul><li>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</li><li>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</li></ul><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h3 id="2-1-循环不变量"><a href="#2-1-循环不变量" class="headerlink" title="2.1 循环不变量"></a>2.1 循环不变量</h3><p><strong>循环不变量</strong>：声明的变量在遍历的过程中需要保持定义不变。</p><h3 id="2-2-循环不变量的设计原则"><a href="#2-2-循环不变量的设计原则" class="headerlink" title="2.2 循环不变量的设计原则"></a>2.2 循环不变量的设计原则</h3><ul><li>说明：设计循环不变量的原则是 <strong>不重不漏</strong>。</li></ul><p><strong>本题的分界线定义（变量定义）</strong></p><ul><li>len 是数组的长度；</li><li><strong>变量 zero</strong> 是前两个子区间的<strong>分界点</strong>，一个是闭区间，另一个就必须是开区间；</li><li><strong>变量 i 是循环变量</strong>，一般设置为开区间，表示 i 之前的元素是遍历过的；</li><li><strong>two 是另一个分界线</strong>，我设计成闭区间。</li></ul><p><strong>循环不变量定</strong>义如下：</p><ul><li>所有在子区间 [0, zero) 的元素都等于 0；</li><li>所有在子区间 [zero, i) 的元素都等于 1；</li><li>所有在子区间 [two, len - 1] 的元素都等于 2。</li></ul><p>于是<strong>编码要解决以下三个问题</strong>：</p><ul><li>变量初始化应该如何定义；</li><li>在遍历的时候，是先加减还是先交换；</li><li>什么时候循环终止。</li></ul><p><strong>处理这三个问题，完全看循环不变量的定义。</strong></p><ul><li>编码的时候，<code>**zero</code> 和 <code>two</code> 初始化的值就应该保证上面的三个子区间全为空；**</li><li>在遍历的过程中，「下标先加减再交换」、还是「先交换再加减」就看初始化的时候变量在哪里；</li><li><strong>退出循环的条件也看上面定义的循环不变量，在<code>i == two</code> 成立的时候</strong>，上面的三个子区间就正好 <strong>不重不漏 地覆盖了整个数组</strong>，并且给出的性质成立，题目的任务也就完成了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// all in [0, zero) = 0</span></span><br><span class="line">        <span class="comment">// all in [zero, i) = 1</span></span><br><span class="line">        <span class="comment">// all in [two, len - 1] = 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环终止的条件的 i == two 那么循环可以继续等待的条件是 i &lt; two</span></span><br><span class="line">        <span class="comment">// 为了保证初始化的时候[0,zero) 为空  , 设置 zero = 0；</span></span><br><span class="line">        <span class="comment">// 所以下面遍历到 0 的时候，先交换，再加</span></span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证初始化的时候[two, len - 1] 为空 设置 two = len</span></span><br><span class="line">        <span class="comment">// 所以下面遍历到2的时候，先减 在交换</span></span><br><span class="line">        <span class="keyword">int</span> two = len;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 i == two 上面的三个子区间正好覆盖了全部数组</span></span><br><span class="line">        <span class="comment">// 因为 循环可以继续的条件是 i  &lt; two</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; two)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,i,zero);</span><br><span class="line">                zero++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                two--;</span><br><span class="line">                swap(nums,i,two);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)，这里 N是输入数组的长度；</li><li>空间复杂度：O(N)。</li></ul><p><strong>这种做法是在 Java 的 JDK 的源码中 <code>Arrays.sort()</code> 中学到的。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/102513784.png" alt="mark"></p><h2 id="3-复习-partition习题"><a href="#3-复习-partition习题" class="headerlink" title="3. 复习 partition习题"></a>3. 复习 partition习题</h2><h3 id="3-1-「力扣」第-215-题：数组中的第-K-个最大元素（中等）"><a href="#3-1-「力扣」第-215-题：数组中的第-K-个最大元素（中等）" class="headerlink" title="3.1 「力扣」第 215 题：数组中的第 K 个最大元素（中等）"></a>3.1 「力扣」第 215 题：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第 K 个最大元素</a>（中等）</h3><p><strong>题目描述</strong></p><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/144137037.png" alt="mark"></p><p><strong>解法一 ： 优先队列</strong></p><ul><li>这是直接明了的方法 使用 最小堆去做</li><li>虽然与本系列无关，但仍然是最快捷简单的方法</li></ul><p><strong>思路分析</strong> [参考链接][<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/]" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/]</a></p><ul><li><p>优先队列的思路是很朴素的。因为第 K 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以<strong>维护一个有 K 个元素的最小堆：</strong></p><p>1、如果当前堆不满，直接添加；</p><p>2、堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新都到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。</p></li><li><p>说明：这里最合适的操作其实是 replace，即直接把新读进来的元素放在堆顶，然后执行下沉（siftDown）操作。Java 当中的 <code>PriorityQueue</code> 没有提供这个操作，只好先 <code>poll()</code>再 <code>offer()</code>。</p></li></ul><ul><li><strong>思路1</strong>：把 <code>len</code>个元素都放入一个最小堆中，然后再 <code>pop()</code>出 len - k 个元素，此时最小堆只剩下 k 个元素，堆顶元素就是数组中的第 k 个最大元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一个含有len个元素的最小堆，默认是最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 len 个元素都放入一个最小堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后再 pop() 出 len - k 个元素，此时最小堆只剩下 k 个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len - k;i++)&#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 堆顶元素就是数组中的第 k 个最大元素。</span></span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路 2：综合考虑以上两种情况，总之都是为了节约空间复杂度。即 <code>k</code> 较小的时候使用最小堆，<code>k</code> 较大的时候使用最大堆。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 k 的不同，选最大堆和最小堆，目的是让堆中的元素更小</span></span><br><span class="line">    <span class="comment">// 思路 1：k 要是更靠近 0 的话，此时 k 是一个较大的数，用最大堆</span></span><br><span class="line">    <span class="comment">// 例如在一个有 6 个元素的数组里找第 5 大的元素</span></span><br><span class="line">    <span class="comment">// 思路 2：k 要是更靠近 len 的话，用最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以分界点就是 k = len - k</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= len - k) &#123;</span><br><span class="line">            <span class="comment">// System.out.println("使用最小堆");</span></span><br><span class="line">            <span class="comment">// 特例：k = 1，用容量为 k 的最小堆</span></span><br><span class="line">            <span class="comment">// 使用一个含有 k 个元素的最小堆</span></span><br><span class="line">            PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                minHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">                Integer topEle = minHeap.peek();</span><br><span class="line">                <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; topEle) &#123;</span><br><span class="line">                    minHeap.poll();</span><br><span class="line">                    minHeap.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// System.out.println("使用最大堆");</span></span><br><span class="line">            <span class="keyword">assert</span> k &gt; len - k;</span><br><span class="line">            <span class="comment">// 特例：k = 100，用容量为 len - k + 1 的最大堆</span></span><br><span class="line">            <span class="keyword">int</span> capacity = len - k + <span class="number">1</span>;</span><br><span class="line">            PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(capacity, (a, b) -&gt; b - a);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">                maxHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = capacity; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">                Integer topEle = maxHeap.peek();</span><br><span class="line">                <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; topEle) &#123;</span><br><span class="line">                    maxHeap.poll();</span><br><span class="line">                    maxHeap.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二 ： 暴力</strong></p><ul><li>最简单同时也一定是最容易编码的，编码成功的几率最高，可以用这个最简单思路编码的结果和其它思路编码的结果进行比对，验证高级算法的正确性；</li><li>在数据规模小、对时间复杂度、空间复杂度要求不高的时候，简单问题简单做；</li></ul><p>题目要求我们找到“数组排序后的第 k个最大的元素，而不是第 k个不同的元素” ，</p><ul><li>语义是从右边往左边数第 k个元素（从 1开始），那么从左向右数是第几个呢，我们列出几个找找规律就好了。</li><li>一共 6 个元素，找第 2 大，索引是 44；</li><li>一共 6个元素，找第 4 大，索引是 2。</li></ul><p>因此，升序排序以后，<strong>目标元素的索引是 <code>len - k</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[len - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(NlogN)，这里 NN 是数组的长度，算法的性能消耗主要在排序，JDK 默认使用快速排序，因此时间复杂度为 O(NlogN)。</li><li><strong>空间复杂度</strong>：O(1)，这里是原地排序，没有借助额外的辅助空间。</li></ul><p><strong>解法三 ： partition</strong></p><ul><li>学习过 “快速排序” 的朋友，一定知道一个操作叫 partition，它是 “分而治之” 思想当中 “分” 的那一步。</li><li><strong>经过 partition 操作以后，每一次都能排定一个元素，并且这个元素左边的数都不大于它，这个元素右边的数都不小于它，并且我们还能知道排定以后的元素的索引</strong>。</li><li>于是可以应用 “减而治之”（分治思想的特例）的思想，把问题规模转化到一个更小的范围里。</li></ul><p><strong>思路  ： 借助 partition 操作定位到最终排定以后索引为 <code>len - k</code> 的那个元素</strong></p><blockquote><p>快速排序虽然快，但是如果实现得不好，在遇到特殊测试用例的时候，时间复杂度会变得很高。如果你使用 partition 的方法完成这道题，时间排名不太理想，可以考虑一下是什么问题，这个问题很常见。</p></blockquote><p>以下的描述基于 “快速排序” 算法知识的学习，如果忘记的朋友们可以翻一翻自己的《数据结构与算法》教材，复习一下，partition 过程、分治思想和 “快速排序” 算法的优化。</p><ul><li>分析：我们在学习 “快速排序” 的时候，接触的第 1 个操作就是 partition（切分），简单介绍如下：</li><li>partition（切分）操作，使得：<ul><li>对于某个索引 j，nums[j] 已经排定，即 nums[j] 经过 partition（切分）操作以后会放置在它 “最终应该放置的地方”；</li><li><code>nums[left]</code>到 <code>nums[j - 1]</code> 中的所有元素都不大于<code>nums[j]</code>；</li><li><code>nums[j + 1]</code>到 <code>nums[right]</code> 中的所有元素都不小于 <code>nums[j]</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/151535827.png" alt="mark"></p><ul><li><p><strong><code>partition</code>（切分）操作总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次 <code>partition（切分）</code>操作就能缩小搜索的范围，这样的思想叫做 “减而治之”（是 “分而治之” 思想的特例）。</strong></p></li><li><p>切分过程可以不借助额外的数组空间，仅通过交换数组元素实现</p></li></ul><p><strong>代码一 ： 正常的pivot</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据题意，第k大元素索引是len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums,left,right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(index == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &lt; target)&#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置</span></span><br><span class="line"><span class="comment">    * 在遍历过程中保持循环不变量的语义</span></span><br><span class="line"><span class="comment">    * 1、[left + 1, j] &lt; nums[left]</span></span><br><span class="line"><span class="comment">    * 2、(j, i] &gt;= nums[left]</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span>;i &lt;= right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; pivot)&#123;</span><br><span class="line">                <span class="comment">// 小于pivot的元素都交换到pivot前面</span></span><br><span class="line">                j++;</span><br><span class="line">                swap(nums,j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在之前的遍历过程中，满足[left + 1,j] &lt; pivot 并且 (j,i] &gt;= pivot</span></span><br><span class="line">        swap(nums,j,left);</span><br><span class="line">        <span class="comment">// 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，这里 N 是数组的长度</li><li><strong>空间复杂度</strong>：O(1)，原地排序，没有借助额外的辅助空间。</li></ul><p><strong>代码二： random随机化pivot</strong></p><blockquote><p><strong>注意：本题必须随机初始化 <code>pivot</code> 元素，否则通过时间会很慢，因为测试用例中有极端测试用例。</strong></p></blockquote><ul><li><p><strong>为了应对极端测试用例，使得递归树加深，</strong>可以在循环一开始的时候，随机交换第 1个元素与它后面的任意 1 个元素的位置；</p></li><li><p>说明：最极端的是顺序数组与倒序数组，此时递归树画出来是链表，时间复杂度是 O(N^2) 根本达不到减治的效果。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在区间 [left, right] 这个区间执行 partition 操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomIndex = left + <span class="number">1</span> + random.nextInt(right - left);</span><br><span class="line">            swap(nums, left, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码三 : 使用双指针，将与 <code>pivot</code> 相等的元素等概论地分到 <code>pivot</code> 最终排定位置的两边。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomIndex = left + <span class="number">1</span> + random.nextInt(right - left);</span><br><span class="line">            swap(nums, left, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将等于 pivot 的元素分散到两边</span></span><br><span class="line">        <span class="comment">// [left, lt) &lt;= pivot</span></span><br><span class="line">        <span class="comment">// (rt, right] &gt;= pivot</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lt = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rt = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= rt &amp;&amp; nums[lt] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= rt &amp;&amp; nums[rt] &gt; pivot) &#123;</span><br><span class="line">                rt--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lt &gt; rt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, lt, rt);</span><br><span class="line">            lt++;</span><br><span class="line">            rt--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(nums, left, rt);</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;partition-合集&quot;&gt;&lt;a href=&quot;#partition-合集&quot; class=&quot;headerlink&quot; title=&quot;partition-合集&quot;&gt;&lt;/a&gt;partition-合集&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/101823939.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-什么是-partition-？&quot;&gt;&lt;a href=&quot;#1-什么是-partition-？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是 partition ？&quot;&gt;&lt;/a&gt;1. 什么是 partition ？&lt;/h2&gt;&lt;p&gt;我们在学习 快速排序 的时候知道，可以选择一个标定元素（称为 pivot ，一般而言随机选择），然后通过一次扫描，把数组分成三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 1 部分严格小于 pivot 元素的值；&lt;/li&gt;
&lt;li&gt;第 2 部分恰好等于 pivot 元素的值；&lt;/li&gt;
&lt;li&gt;第 3 部分严格大于 pivot 元素的值。&lt;/li&gt;
&lt;li&gt;第 2 部分元素就是排好序以后它们应该在的位置，接下来只需要递归处理第 1 部分和第 3 部分的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过一次扫描把整个数组分成 3 个部分，正好符合当前问题的场景。写对这道题的方法是：把循环不变量的定义作为注释写出来，然后再编码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="partition" scheme="http://zhuuu.work/tags/partition/"/>
    
      <category term="循环不变量" scheme="http://zhuuu.work/tags/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-09-进程调度算法</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-06T07:22:53.000Z</published>
    <updated>2020-10-07T04:05:21.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-09-进程调度算法"><a href="#Linux-09-进程调度算法" class="headerlink" title="Linux-09-进程调度算法"></a>Linux-09-进程调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><ul><li>进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。</li><li>当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</li></ul><p>什么时候会发生 CPU 调度呢？通常有以下情况：</p><ol><li>当进程从运行状态转到等待状态；</li><li>当进程从运行状态转到就绪状态；</li><li>当进程从等待状态转到就绪状态；</li><li>当进程从运行状态转到终止状态；</li></ol><p>其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。</p><ul><li><strong>非抢占式</strong>的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。</li><li>而<strong>抢占式调度</strong>，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</li></ul><a id="more"></a><ul><li>你可能会好奇为什么第 3 种情况也会发生 CPU 调度呢？<ul><li>假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态</li><li>一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度。</li></ul></li></ul><ul><li>那第 2 种状态通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU。</li></ul><p>调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程正在使用 CPU 的时间和 I/O 时间。</p><p>接下来，说说常见的调度算法：</p><ul><li>先来先服务调度算法</li><li>最短作业优先调度算法</li><li>高响应比优先调度算法</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法</li></ul><h2 id="1-进程调度算法"><a href="#1-进程调度算法" class="headerlink" title="1. 进程调度算法"></a>1. 进程调度算法</h2><h3 id="1-1-先来先服务调度算法"><a href="#1-1-先来先服务调度算法" class="headerlink" title="1.1 先来先服务调度算法"></a>1.1 先来先服务调度算法</h3><ul><li>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（First Come First Severd, FCFS）算法</strong>了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114729145.jpg" alt="mark"></p><ul><li>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></li></ul><p><strong>缺点：</strong></p><ul><li>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。（<strong>不会导致饥饿的产生</strong>）</li><li>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153514117.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153527091.png" alt="mark"></p><h3 id="1-2-最短作业优先调度算法"><a href="#1-2-最短作业优先调度算法" class="headerlink" title="1.2 最短作业优先调度算法"></a>1.2 最短作业优先调度算法</h3><ul><li><strong>最短作业优先（Shortest Job First, SJF）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114846841.jpg" alt="mark"></p><p><strong>缺点：</strong></p><ul><li>这显然对长作业不利，很容易造成一 种极端现象。（<strong>进程饥饿</strong>）</li><li>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153545137.png" alt="mark"></p><p><strong>非抢占式—SJF</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153623881.png" alt="mark"></p><p><strong>抢占式—SJF(SRTN)</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153635107.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153640245.png" alt="mark"></p><h3 id="1-3-高响应比优先调度算法"><a href="#1-3-高响应比优先调度算法" class="headerlink" title="1.3 高响应比优先调度算法"></a>1.3 高响应比优先调度算法</h3><ul><li>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</li><li>那么，<strong>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法</strong>主要是权衡了短作业和长作业。</li><li><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135439932.png" alt="mark"></p><p>从上面的公式，可以发现：</p><ul><li><p><strong>如果两个进程的「等待时间」相同时</strong>，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</p></li><li><p><strong>如果两个进程「要求的服务时间」相同时</strong>，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</p></li><li><p><strong>不会导致饥饿</strong></p></li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153711214.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153719376.png" alt="mark"></p><p><strong>上面三种算法注重的是进程调度的性能</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120514747.png" alt="mark"></p><hr><p><strong>下面三种算法注重的是用户交互的功能和性能的综合</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120440278.png" alt="mark"></p><h3 id="1-4-时间片轮转调度算法"><a href="#1-4-时间片轮转调度算法" class="headerlink" title="1.4 时间片轮转调度算法"></a>1.4 时间片轮转调度算法</h3><ul><li>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135825753.png" alt="mark"></p><p><strong>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长；</li></ul><p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><p><strong>小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115816124.png" alt="mark"></p><p><strong>例题分析</strong></p><ul><li><strong>时间片为2举例</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115903072.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115911628.png" alt="mark"></p><ul><li><strong>以时间片为5举例</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115927677.png" alt="mark"></p><ul><li><strong>可能出现的问题，比如与FCFS对比</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115941047.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120001175.png" alt="mark"></p><h3 id="1-5-最高优先级调度算法"><a href="#1-5-最高优先级调度算法" class="headerlink" title="1.5 最高优先级调度算法"></a>1.5 最高优先级调度算法</h3><ul><li>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</li><li>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法</strong>。</li></ul><p>进程的优先级可以分为，静态优先级或动态优先级：</p><ul><li><strong>静态优先级</strong>：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li><strong>动态优先级</strong>：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式</p><ul><li><strong>非抢占式</strong>：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li><strong>抢占式</strong>：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p><strong>缺点：</strong></p><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><p><strong>小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120040368.png" alt="mark"></p><ul><li><strong>非抢占式例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120142289.png" alt="mark"></p><ul><li><strong>抢占式例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120158415.png" alt="mark"></p><ul><li><strong>优先级原则</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120213748.png" alt="mark"></p><h3 id="1-6-多级反馈队列调度算法"><a href="#1-6-多级反馈队列调度算法" class="headerlink" title="1.6 多级反馈队列调度算法"></a>1.6 多级反馈队列调度算法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120242696.png" alt="mark"></p><ul><li><strong>多级反馈队列（Multilevel Feedback Queue）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</li></ul><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/140252098.png" alt="mark"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li><strong>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行</strong>。</li><li>如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；(<strong>抢占式</strong>)</li></ul><p><strong>缺点：</strong></p><ul><li><strong>会导致进程饥饿</strong></li></ul><p><strong>小结：</strong></p><p>可以发现，对于<strong>短作业</strong>可能可以在第一级队列很快被处理完。</p><p>对于<strong>长作业</strong>，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120339197.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120356739.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120402334.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120409886.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120414590.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120423613.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120430247.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-09-进程调度算法&quot;&gt;&lt;a href=&quot;#Linux-09-进程调度算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-09-进程调度算法&quot;&gt;&lt;/a&gt;Linux-09-进程调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。&lt;/li&gt;
&lt;li&gt;当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候会发生 CPU 调度呢？通常有以下情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当进程从运行状态转到等待状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从等待状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到终止状态；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非抢占式&lt;/strong&gt;的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;抢占式调度&lt;/strong&gt;，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-08-进程调度</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-08-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-08-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</id>
    <published>2020-10-06T07:20:53.000Z</published>
    <updated>2020-10-06T07:32:24.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-08-进程调度"><a href="#操作系统-08-进程调度" class="headerlink" title="操作系统-08-进程调度"></a>操作系统-08-进程调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152620848.png" alt="mark"></p><a id="more"></a><h2 id="1-进程调度的时机"><a href="#1-进程调度的时机" class="headerlink" title="1. 进程调度的时机"></a>1. 进程调度的时机</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152708655.png" alt="mark"></p><p><strong>那么什么时候不能进行进程调度呢？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152758459.png" alt="mark"></p><h2 id="2-进程调度的方式"><a href="#2-进程调度的方式" class="headerlink" title="2. 进程调度的方式"></a>2. 进程调度的方式</h2><ul><li><strong>所谓进程调度方式</strong>，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153113771.png" alt="mark"></p><h2 id="3-进程的切换"><a href="#3-进程的切换" class="headerlink" title="3. 进程的切换"></a>3. 进程的切换</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153208197.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-08-进程调度&quot;&gt;&lt;a href=&quot;#操作系统-08-进程调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统-08-进程调度&quot;&gt;&lt;/a&gt;操作系统-08-进程调度&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152620848.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-07-CPU调度</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-07-CPU%E8%B0%83%E5%BA%A6/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-07-CPU%E8%B0%83%E5%BA%A6/</id>
    <published>2020-10-06T07:00:53.000Z</published>
    <updated>2020-10-06T07:25:55.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-07-CPU调度"><a href="#操作系统-07-CPU调度" class="headerlink" title="操作系统-07-CPU调度"></a>操作系统-07-CPU调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152136370.png" alt="mark"></p><h2 id="1-调度的基本概念"><a href="#1-调度的基本概念" class="headerlink" title="1. 调度的基本概念"></a>1. 调度的基本概念</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152233238.png" alt="mark"></p><a id="more"></a><h2 id="2-调度的三个层次"><a href="#2-调度的三个层次" class="headerlink" title="2. 调度的三个层次"></a>2. 调度的三个层次</h2><h5 id="（1）高级调度（-作业调度）"><a href="#（1）高级调度（-作业调度）" class="headerlink" title="（1）高级调度（ 作业调度）"></a>（1）高级调度（ 作业调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152300101.png" alt="mark"></p><h5 id="（2）中级调度（内存调度）"><a href="#（2）中级调度（内存调度）" class="headerlink" title="（2）中级调度（内存调度）"></a>（2）中级调度（内存调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152329541.png" alt="mark"></p><h5 id="（3）进程的挂起状态与七状态模型"><a href="#（3）进程的挂起状态与七状态模型" class="headerlink" title="（3）进程的挂起状态与七状态模型"></a>（3）进程的挂起状态与七状态模型</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152353463.png" alt="mark"></p><h5 id="（4）低级调度（进程调度）"><a href="#（4）低级调度（进程调度）" class="headerlink" title="（4）低级调度（进程调度）"></a>（4）低级调度（进程调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152402582.png" alt="mark"></p><h5 id="三层调度的联系和对比"><a href="#三层调度的联系和对比" class="headerlink" title="三层调度的联系和对比"></a>三层调度的联系和对比</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152427705.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-07-CPU调度&quot;&gt;&lt;a href=&quot;#操作系统-07-CPU调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统-07-CPU调度&quot;&gt;&lt;/a&gt;操作系统-07-CPU调度&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152136370.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-调度的基本概念&quot;&gt;&lt;a href=&quot;#1-调度的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 调度的基本概念&quot;&gt;&lt;/a&gt;1. 调度的基本概念&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152233238.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-018-四数之和</title>
    <link href="http://zhuuu.work/2020/10/05/Leetcode/Leetcode-018-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/10/05/Leetcode/Leetcode-018-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-10-05T11:52:53.000Z</published>
    <updated>2020-10-06T12:33:44.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-18-四数之和"><a href="#Leecode-18-四数之和" class="headerlink" title="Leecode-18. 四数之和"></a>Leecode-<a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h1><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路（同leetcode015 所以这里不再阐述 有15题基础看代码就秒懂了）</strong></p><ul><li>首先对排序后的数组进行遍历，固定一个nums[i] 。</li><li>其次使用一个指针L指向 <code>i + 1</code> 的位置，一个指针R指向 <code>nums.length - 1</code>的位置，同时计算<code>nums[i] + nums[L] + nums[R]</code>,计算这三个数的和是否等于0</li><li>细节条件一定要注意<ul><li>如果<code>nums[i] &gt; 0</code> ，那么这三个数的和比不可能等于0</li><li>如果<code>nums[i] == nums[i -1]</code> ,则说明该数字重复，会导致结果的重复，所以应该跳过</li><li>当sum == 0的时候，如果<code>nums[L] == nums[L+1]</code>,则会导致结果的重复，应该跳过，(L++)</li><li>当sum == 0的时候，如果<code>nums[R] == nums[R - 1]</code>,则会导致结果的重复，应该跳过，(R–)</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li><strong>首先进行排序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100358932.png" alt="mark"></p><ol start="2"><li><strong>第一轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100418544.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100451353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100458185.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100504327.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100511291.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100527129.png" alt="mark"></p><ol start="3"><li><strong>第二轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100538257.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100548763.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100554929.png" alt="mark"></p><ol start="4"><li><strong>第三轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100609939.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100615721.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 双指针遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[len - <span class="number">3</span>] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j  &lt; len - <span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="comment">// 剪枝操作</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 双指针操作</span></span><br><span class="line">                <span class="keyword">int</span> left  = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到对应的结果</span></span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去重操作</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去重操作</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        <span class="comment">// 和小于target</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 和大于target</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(fourSum(arr,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度</strong>：O（n^3） 排序O(nlogn) + 循环O（n^3） = O(n^3)</p></li><li><p><strong>空间复杂度</strong>：O(n)，其中 n 是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组 nums，实际情况中不一定允许，因此也可以看成使用了一个额外的<strong>数组存储了数组nums 的副本并排序</strong>，空间复杂度为 O(n)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-18-四数之和&quot;&gt;&lt;a href=&quot;#Leecode-18-四数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-18. 四数之和&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;18. 四数之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案中不可以包含重复的四元组。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定数组 nums &amp;#x3D; [1, 0, -1, 0, -2, 2]，和 target &amp;#x3D; 0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;满足要求的四元组集合为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1,  0, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-2, -1, 1, 2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-2,  0, 0, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Netty-03-零拷贝</title>
    <link href="http://zhuuu.work/2020/10/05/Netty/Netty-03-%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://zhuuu.work/2020/10/05/Netty/Netty-03-%E9%9B%B6%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-10-05T03:05:24.000Z</published>
    <updated>2020-10-07T14:26:01.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-03-零拷贝"><a href="#Netty-03-零拷贝" class="headerlink" title="Netty-03-零拷贝"></a>Netty-03-零拷贝</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netty-03-零拷贝&quot;&gt;&lt;a href=&quot;#Netty-03-零拷贝&quot; class=&quot;headerlink&quot; title=&quot;Netty-03-零拷贝&quot;&gt;&lt;/a&gt;Netty-03-零拷贝&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-06-线程</title>
    <link href="http://zhuuu.work/2020/10/05/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/10/05/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-10-05T02:00:53.000Z</published>
    <updated>2020-10-04T10:59:25.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-06-线程"><a href="#操作系统-06-线程" class="headerlink" title="操作系统-06-线程"></a>操作系统-06-线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185326649.png" alt="mark"></p><a id="more"></a><h2 id="1-为什么要引入线程？"><a href="#1-为什么要引入线程？" class="headerlink" title="1. 为什么要引入线程？"></a>1. 为什么要引入线程？</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185358306.png" alt="mark"></p><ul><li>为了方便于理解，我打开了我的任务管理器，可以看出chrome一个进程，下面有很多分支，可以把这些分支当做线程看待，PID即进程和线程都有的标识符。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185415092.png" alt="mark"></p><h2 id="2-线程的定义"><a href="#2-线程的定义" class="headerlink" title="2. 线程的定义"></a>2. 线程的定义</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185431932.png" alt="mark"></p><ul><li>资源分配、调度<br>传统进程机制中，<strong>进程是资源分配、调度的基本单位</strong><br><strong>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</strong></li><li>并发性<br>传统进程机制，只能进程间并发<br>现在各线程之间也能并发</li><li>系统开销<br>传统进程并发，需要<strong>切换进程的运行环境，系统开销大</strong><br><strong>同一个进程内的线程间并发，不需要切换环境，开销小</strong></li></ul><h2 id="3-线程的属性"><a href="#3-线程的属性" class="headerlink" title="3. 线程的属性"></a>3. 线程的属性</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185546111.png" alt="mark"></p><p>内核线程是处理机调度的单位，线程几乎不拥有系统资源，同一个进程的线程间共享进程资源，各个线程可以占用不同的CPU。 线程有自己的ID，线程控制块TCP，线程也有就绪、阻塞、运行三种基本状态。 同一进程内的线程通信无需系统干预，线程切换不会引起进程切换，系统开销很小。 不同进程的线程切换会导致进程切换。</p><h2 id="4-线程的实现方式"><a href="#4-线程的实现方式" class="headerlink" title="4. 线程的实现方式"></a>4. 线程的实现方式</h2><p><strong>用户级线程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185636034.png" alt="mark"></p><p><strong>内核级线程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185659747.png" alt="mark"></p><p><strong>组合方式</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185720348.png" alt="mark"></p><h2 id="5-多线程模型"><a href="#5-多线程模型" class="headerlink" title="5. 多线程模型"></a>5. 多线程模型</h2><p><strong>多对一模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185810274.png" alt="mark"></p><p><strong>一对一模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185824641.png" alt="mark"></p><p><strong>多对多模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185839178.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-06-线程&quot;&gt;&lt;a href=&quot;#操作系统-06-线程&quot; class=&quot;headerlink&quot; title=&quot;操作系统-06-线程&quot;&gt;&lt;/a&gt;操作系统-06-线程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185326649.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>好文阅读-01-后端学习路线</title>
    <link href="http://zhuuu.work/2020/10/04/recommendation/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB-01-%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://zhuuu.work/2020/10/04/recommendation/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB-01-%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2020-10-04T10:32:24.000Z</published>
    <updated>2020-10-04T14:30:00.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好文阅读-01-后端学习路线"><a href="#好文阅读-01-后端学习路线" class="headerlink" title="好文阅读-01-后端学习路线"></a>好文阅读-01-后端学习路线</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>说到后端开发，难免会遇到各种所谓高大上的「关键词 」，对于我们应届生小白，难免会觉得比较陌生，因为在学校确实比较少遇见这些所谓高大上的东西，那么今天就带着学习的态度和大家分享这些看似可以装逼可以飞的带逼格的关键词吧。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/152056275.jpg" alt="mark"></p><a id="more"></a><h2 id="1-分布式"><a href="#1-分布式" class="headerlink" title="1. 分布式"></a>1. 分布式</h2><blockquote><p>在学校里的项目中，一个 Web 系统可能咋们一个人就搞定，因为几乎不考虑并发量，性能咋样，所谓「<strong>过得去</strong> 」足矣，但是为了面试考虑，我们又不得不找点类似<strong>秒杀系统</strong>作为我们简历的支撑项目(即使已经烂大街)。那么先问你第一个问题，为什么就采用了<strong>分布式</strong>的方案落地这个项目？</p></blockquote><ul><li>当一个人或者几十个使用你的系统，哎呀我去，请求秒回，效果倍棒，于是乎简历砰砰写上却多么牛X，当面试官就会问你你这项目做了啥，测试过没，并发量如何，性能如何？你就…..</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/155639381.gif" alt="mark"></p><ul><li>当访问系统的用户越来越多，可是我们的系统资源有限，所以需要更多的 <strong>CPU</strong> 和<strong>内存</strong>去处理用户的计算请求，当然也就要求更大的<strong>网络带宽</strong>去处理数据的传输，也需要更多的磁盘空间存储数据。资源不够，消耗过度，服务器崩溃，系统也就不干活了，那么在这样的情况怎么处理？</li></ul><h3 id="1-1-垂直伸缩"><a href="#1-1-垂直伸缩" class="headerlink" title="1.1 垂直伸缩"></a>1.1 垂直伸缩</h3><blockquote><p>纵向生长。通过提升<strong>单台</strong>服务器的<strong>计算处理</strong>能力来抵抗更大的请求访问量。比如使用更快频率的CPU，更快的网卡，塞更多的磁盘等。其实这样的处理方式在电信，银行等企业比较常见，让摩托车变为小汽车，更强大的计算机，处理能力也就越强，但是对于运维而言也就越来越复杂。那真的就这样花钱买设备就完事了？</p></blockquote><ul><li>当然不，单台服务器的计算处理能力是有限的，而且也会严重受到计算机硬件水平的制约。</li></ul><h3 id="1-2-水平伸缩"><a href="#1-2-水平伸缩" class="headerlink" title="1.2 水平伸缩"></a>1.2 水平伸缩</h3><blockquote><p>一台机器处理不过来，我就用多台<strong>廉价</strong>的机器合并同时处理，人多力量大嘛，通过多台服务器构成分布式集群从而提升系统的整体处理能力。这里说到了分布式，那我们看看分布式的成长过程</p></blockquote><p>记住一句话：<strong>系统的技术架构是需求所驱动</strong></p><ul><li>最初的<strong>单体系统</strong>，只需要部分用户访问，</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160035576.png" alt="mark"></p><p>做系统的原因当然是有需求，有价值，可赚钱。</p><p>随着使用系统的用户越来越多，这时候关注的人越来越多，单台服务器扛不住了，关注的人觉得响应真慢，没啥意思，就开始吐槽，但是这一吐槽，导致用户更多，毕竟大家都爱吃瓜。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160108772.gif" alt="mark"></p><ul><li>这样下去不得不进行系统的升级，将<strong>数据库和应用</strong>分离。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160133438.png" alt="mark"></p><p>这样子，咋们将数据库和应用程序分离后，部署在不同的服务器中，从1台服务器变为多台服务器，处理响应更快，内容也够干，访问的用户呈<strong>指数增长</strong>，这多台服务器都有点扛不住了，怎么办？</p><p>加一个<strong>缓存</strong>吧，我们不每次从数据库中读取数据，而将应用程序需要的数据暂存在<strong>缓冲</strong>中。缓存呢，又分为<strong>本地缓存</strong>和<strong>分布式的缓存</strong>。分布式缓存，顾名思义，使用多台服务器构成集群，存储更多的数据并提供缓存服务，从而提升缓存的能力。</p><ul><li><strong>加了缓存哪些好处？</strong></li></ul><p>应用程序不再直接访问数据库，提升访问效率。因为缓存内容在内存中，不用每次连接存放磁盘中的数据库，</p><p>系统越来越火，于是考虑将应用服务器也作为<strong>集群</strong>。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160223826.png" alt="mark"></p><h2 id="2-缓存架构"><a href="#2-缓存架构" class="headerlink" title="2. 缓存架构"></a>2. 缓存架构</h2><blockquote><p>干啥啥不行，缓存第一名。不吹牛，缓存应用在计算机的各个角落。<strong>缓存</strong>可说是软件技术中的的杀手锏，无论是程序代码使用buffer，还是网络架构中使用缓存，虚拟机也会使用大量的缓存。其实最初在CPU中也就开始使用缓存。缓存分为两种，一种是<strong>通读缓存</strong>，一种是<strong>旁路缓存</strong></p></blockquote><h3 id="2-1-通读缓存"><a href="#2-1-通读缓存" class="headerlink" title="2.1 通读缓存"></a>2.1 通读缓存</h3><ul><li>假设当前应用程序获取数据，如果数据存在于通读缓存中就直接返回。如果不存在于通读缓存，那么就访问数据源，同时将数据存放于缓存中。下次访问就直接从缓存直接获取。比较常见的为<strong>CDN</strong>和<strong>反向代理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160318763.png" alt="mark"></p><p><strong>CDN</strong></p><blockquote><p>CDN称为内容分发网络。想象我们京东购物的时候，假设我们在成都，如果买的东西在成都仓库有就直接给我们寄送过来，可能半天就到了，用户体验也非常好，就不用从北京再寄过来。同样的道理，用户就可以近距离获得自己需要的数据，既提高了响应速度，又节约了网络带宽和服务器资源。</p></blockquote><h3 id="2-2-旁路缓存"><a href="#2-2-旁路缓存" class="headerlink" title="2.2 旁路缓存"></a>2.2 旁路缓存</h3><ul><li>应用程序需要自己从数据源读取数据，然后将这个数据写入到<strong>旁路缓存</strong>中。</li><li>这样，下次应用程序需要数据的时候，就可以通过旁路缓存直接获得数据了</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160429403.png" alt="mark"></p><p><strong>缓存的好处</strong></p><ul><li>因为大部分缓存的数据存储在内存中，相比于硬盘或者从网络中获取效率更高，响应时间更快，性能更好</li><li>通过 <strong>CDN</strong> 等通读缓存可以降低服务器的负载能力。</li><li>因为缓存通常会记录计算结果。如果缓存命中直接返回，否则需要进行大量的运算。所以使用缓存也减少了<strong>CPU</strong> 的计算消耗，加快处理速度</li></ul><p><strong>缓存缺点</strong></p><ul><li><p>我们缓存的数据来自源数据，如果源数据被修改了，俺么缓存数据很肯能也是被修改过的，成为脏数据，所以怎么办？</p></li><li><p>过期失效</p></li></ul><blockquote><p>在每次写入缓存数据的时候标记失效时间，读取数据的时候检查数据是否失效，如果失效了就重新从数据源获取数据。、</p></blockquote><ul><li>失效通知</li></ul><blockquote><p>应用程序在更新数据源的时候，通知清除缓存中的数据。</p></blockquote><p><strong>是不是数据使用缓存都有意义呢？</strong></p><ul><li>非也，通常放入缓存中的数据都是带有热点的数据，比如当日热卖商品，或者热门吃瓜新闻，这样将数据存放在缓存中，会被多次读取，从而缓存的命中率也会比较高</li></ul><h2 id="3-异步架构"><a href="#3-异步架构" class="headerlink" title="3. 异步架构"></a>3. 异步架构</h2><blockquote><p>在前面中，通过缓存实际上很多时候是解决了读的问题，加快了读取数据的能力。因为缓存通常很难保证数据的持久性和一致性，所以我们通常不会将数据直接写入缓存中，而是写入 RDBMAS 等数据中，那如何提升系统的<strong>写操作性能</strong>呢？</p></blockquote><p><strong>场景：</strong></p><blockquote><p>此时假设两个系统分别为A,B，其中A系统<strong>依赖</strong>B系统，两者通信采用<strong>远程调用</strong>的方式，此时如果B系统出故障，很可能引起A系统出故障。</p><p>从而不得不单独进行升级，怎么办？</p></blockquote><ul><li>使用<strong>消息队列</strong>的异步架构，也称为事件驱动模型。</li></ul><p><strong>异步相对于同步</strong>而言，同步通常是当应用程序调用服务的时候，不得不阻塞等待服务期完成，此时CPU空闲比较浪费，直到返回服务结果后才会继续执行。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160754809.png" alt="mark"></p><p><strong>同步举例子：</strong></p><blockquote><p>举个例子，小蓝今天想在系统中加一个发邮件的功能，通过SMTP和远程服务器通信，但是远程服务器有很多邮件需要等待发送呢，当前邮件就可能等待比较长时间才能发送成功，发送成功后反馈与应用程序。这个过程中，远程服务器发送邮件的时候，应用程序就阻塞，准确的说是执行应用程序的线程阻塞。</p></blockquote><blockquote><p>这样阻塞带来什么问题“？</p></blockquote><ul><li>不能释放占用的系统资源，导致系统资源不足，影响系统性能</li><li>无法快速给用户响应结果</li></ul><blockquote><p>但是在实际情况中，我们发送邮件，并不需要得到发送结果。比如用户注册，发送账号激活邮件，无论邮件是否发送成功都会收到”返回邮件已经发送，请查收邮件确认激活”，怎样才能让应用程序不阻塞？</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160906353.png" alt="mark"></p><p>此时就比较清晰了，调用者将消息发送给消息队列直接返回，应用程序收到返回以后继续执行，快读响应用户释放资源。有专门的消费队列程序从中消息队列取出数据并进行消费。如果远程服务出现故障，只会传递给消费者程序而不会影响到应用程序。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161031308.png" alt="mark"></p><h3 id="3-1-消息队列模型"><a href="#3-1-消息队列模型" class="headerlink" title="3.1 消息队列模型"></a>3.1 消息队列模型</h3><ul><li>消息队列模型中通常有三个角色，分别为<strong>生产者</strong>，<strong>消息队列</strong>和<strong>消费者</strong>。</li><li>生产者产生数据封装为消息发送给消息队列，专门的消费程序从消息队列中取出数据，消费数据。</li><li>在我看来，消息队列主要是缓冲消息，等待消费者消费。其中<strong>消费的方式分为两种</strong></li></ul><ol><li><strong>点对点</strong></li></ol><blockquote><p>对生产者多消费者的情况。一个消息被一个消费者消费</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161152869.png" alt="mark"></p><p>上述的发邮件例子就是典型的点对点模式。互不干扰，其中某个服务出现问题不会印象到全局</p><ol start="2"><li><strong>订阅模式</strong></li></ol><blockquote><p>开发人员在消息队列中设置主题，生产者往相应的主题发送数据，消费者从对应的主题中消费数据，每个消费者按照自己业务逻辑分别进行计算</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161242379.png" alt="mark"></p><p>这个比较好理解，比如在用户注册的时候，我们将注册信息放入主题用户中，消费者订阅了这个主题，可能有构造短信消息的消费者，也有推广产品的消费者，都可以根据自己业务逻辑进行数据处理。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161351841.png" alt="mark"></p><p><strong>使用异步模型的优点</strong></p><ul><li>快速响应</li></ul><blockquote><p>不在需要等待。生产者将数据发送消息队列后，可继续往下执行，不虚等待耗时的消费处理</p></blockquote><ul><li>削峰填谷(需要修改)</li></ul><blockquote><p>互联网产品会在不同的场景其并发请求量不同。互联网应用的访问压力随时都在变化，系统的访问高峰和低谷的并发压力可能也有非常大的差距。如果按照压力最大的情况部署服务器集群，那么服务器在绝大部分时间内都处于<strong>闲置状态</strong>。但利用消息队列，我们可以将需要处理的消息放入消息队列，而消费者可以控制消费速度，因此能够降低系统访问高峰时压力，而在访问低谷的时候还可以继续消费消息队列中<br>未处理的消息，保持系统的资源利用率</p></blockquote><ul><li>降低耦合</li></ul><blockquote><p>如果调用是同步，如果调用是同步的，那么意味着调用者和被调用者必然存在依赖，一方面是代码上的依赖，应用程序需要依赖发送邮件相关的代码，如果需要修改发送邮件的代码，就必须修改应用程序，而且如果要增加新的功能</p></blockquote><p><strong>那么目前主要的消息队列有哪些，其有缺点是什么？</strong>(好好记下这个高频题目啦)</p><h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h2><blockquote><p>一台机器扛不住了，需要多台机器帮忙，既然使用多台机器，就希望不要把压力都给一台机器，所以需要一种或者多种策略分散高并发的计算压力，从而引入负载均衡，那么到底是如何分发到不同的服务器的呢？</p></blockquote><ol><li><strong>砸钱</strong></li></ol><blockquote><p>最初实现负载均衡采取的方案很直接，直接上硬件，当然也就比较贵，互联网的普及，和各位科学家的无私奉献，各个企业开始部署自己的方案，从而出现负载均衡服务器</p></blockquote><ol start="2"><li><strong>HTTP重定向负载均衡</strong></li></ol><ul><li>也属于比较直接，当HTTP请求叨叨负载均衡服务器后，使用一套负载均衡算法计算到后端服务器的地址，然后将新的地址给用户浏览器，浏览器收到重定向响应后发送请求到新的应用服务器从而实现负载均衡，如下图所示</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222128709.png" alt="mark"></p><p>优点：</p><ul><li>简单，如果是java开发工程师，只需要servlet中几句代码即可</li></ul><p>缺点：</p><ul><li>加大请求的工作量。第一次请求给负载均衡服务器，第二次请求给应用服务器</li><li>因为要先计算到应用服务器的 IP 地址，所以 IP 地址可能暴露在公网，既然暴露在了公网还有什么安全可言</li></ul><ol start="3"><li><strong>DNS负载均衡</strong></li></ol><blockquote><p>了解计算机网络的你应该很清楚如何获取 IP 地址，其中比较常见的就是 DNS 解析获取 IP 地址。用户通过浏览器发起HTTP请求的时候，DNS 通过对域名进行即系得到 IP 地址，用户委托协议栈的 IP 地址简历 HTTP 连接访问真正的服务器。这样不同的用户进行域名解析将会获取不同的IP地址从而实现负载均衡</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222244275.png" alt="mark"></p><p>乍一看，和HTTP重定向的方案不是很相似吗而且还有 DNS 解析这一步骤，也会解析出 IP 地址，不一样的暴露？每次都需要解析吗，当然不，通常本机就会有缓存，在实际的工程项目中通常是怎么样的呢</p><ul><li>通过 DNS 解析获取负载均衡集群某台服务器的地址</li><li><strong>负载均衡服务器再一次获取某台应用服务器</strong>，这样子就不会将应用服务器的 IP 地址暴露在官网了</li></ul><ol start="4"><li><strong>反向代理负载均衡</strong></li></ol><blockquote><p>这里典型的就是Nginx提供的反向代理和负载均衡功能。用户的请求直接叨叨反向代理服务器，服务器先看本地是缓存过，有直接返回，没有则发送给后台的应用服务器处理。</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222406909.png" alt="mark"></p><ol start="5"><li><strong>IP负载均衡</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222457447.png" alt="mark"></p><ul><li>注意，这种方案通常属于内核级别，如果数据比较小还好，但是大部分情况是图片等资源文件，这样负载均衡服务器会出现响应或者请求过大所带来的瓶颈</li></ul><ol start="6"><li><strong>数据链路负载均衡</strong></li></ol><blockquote><p>它可以解决因为数据量太大而导致负载均衡服务器带宽不足这个问题。怎么实现的呢。它不修改数据包的IP地址，而是更改mac地址。应用服务器和负载均衡服务器使用相同的虚拟IP</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222553607.png" alt="mark"></p><p>以上介绍了几种负载均衡的方式，但是很重要的<strong>负载均衡算法却没有设计，其中包含了轮询，随机</strong></p><h2 id="5-数据存储"><a href="#5-数据存储" class="headerlink" title="5. 数据存储"></a>5. 数据存储</h2><ul><li>公司存在的价值在于流量，流量需要数据，可想而知数据的存储，数据的高可用可说是公司的灵魂。那么改善数据的存储都有哪些手段或方法呢？</li></ul><ol><li><strong>数据主从复制</strong></li></ol><blockquote><p>主从复制比较好理解，需要使用两个数据库存储一样的数据。</p><p>其原理为当应用程序A发送更新命令到主服务器的时候，数据库会将这条命令同步记录到Binlog中，然后其他线程会从Binlog中读取并通过远程通讯的方式复制到另外服务器。服务器收到这更新日志后加入到自己Relay Log中，</p><p>然后SQL执行线程从Relay Log中读取次日志并在本地数据库执行一遍，从而实现主从数据库同样的数据。</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222817995.png" alt="mark"></p><ul><li>主从复制可以方便进行读写分离，可以使用一主多从的方式保证高可用，如果从数据库A挂了，可以将读操作迁移到从数据库完成高可用。</li><li>但是如果主数据库挂了咋搞，那就Mysql的主主复制。可是不管上面说的那种方式都不是提升它的存储能力，这就需要进行<strong>数据库的分片</strong>了</li></ul><ol start="2"><li><strong>数据库分片</strong></li></ol><blockquote><p>将一张表分成若干片，其中每一片都包含一部分行记录，然后将每一片存储在不同的服务器中，这样就实现一张表存放在多台服务器中，哪都有哪些分片存储的方案？</p></blockquote><ul><li>最开始使用<strong>“硬编码”</strong>的方式，此方式从字面上可以理解为直接在代码中指定。假定表为用户表，通过ID的奇偶存放在不同的服务器上，如下图</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222949802.png" alt="mark"></p><p>这种方式的<strong>缺点</strong>很明显，当需要增加服务器的时候，就需要改动代码，这就不友好了。比较常见的数据库分片算法是通过余数Hash算法，根据主键ID和服务器的数量取模，根据余数确定服务器</p><p><strong>参考博客</strong> ： <a href="https://mp.weixin.qq.com/s/co6ZiALBCUHxc-8SpcKxPw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/co6ZiALBCUHxc-8SpcKxPw</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;好文阅读-01-后端学习路线&quot;&gt;&lt;a href=&quot;#好文阅读-01-后端学习路线&quot; class=&quot;headerlink&quot; title=&quot;好文阅读-01-后端学习路线&quot;&gt;&lt;/a&gt;好文阅读-01-后端学习路线&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;说到后端开发，难免会遇到各种所谓高大上的「关键词 」，对于我们应届生小白，难免会觉得比较陌生，因为在学校确实比较少遇见这些所谓高大上的东西，那么今天就带着学习的态度和大家分享这些看似可以装逼可以飞的带逼格的关键词吧。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/152056275.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后端学习路线" scheme="http://zhuuu.work/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
      <category term="好文阅读" scheme="http://zhuuu.work/tags/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-05-进程通信</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-05-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-05-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-10-04T09:00:53.000Z</published>
    <updated>2020-10-04T08:57:56.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-05-进程通信"><a href="#操作系统-05-进程通信" class="headerlink" title="操作系统-05-进程通信"></a>操作系统-05-进程通信</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151330566.png" alt="mark"></p><ul><li>很明显，在这一场面试中， 张三在<strong>进程间通信</strong>这一块没复习好，虽然列出了进程间通信的方式，但这只是表面功夫，<strong>应该需要进一步了解每种通信方式的优缺点及应用场景。</strong></li></ul><a id="more"></a><h2 id="1-思维导图"><a href="#1-思维导图" class="headerlink" title="1. 思维导图"></a>1. 思维导图</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151432253.png" alt="mark"></p><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><ul><li><strong>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151456483.png" alt="mark"></p><p>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？</p><h3 id="2-1-管道"><a href="#2-1-管道" class="headerlink" title="2.1 管道"></a>2.1 管道</h3><p><strong>匿名管道</strong></p><ul><li>如果你学过 Linux 命令，那你肯定很熟悉「<code>|</code>」这个竖线。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps auxf | grep mysql</span><br></pre></td></tr></table></figure><ul><li>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。<ul><li>同时，我们得知上面这种管道是没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</li></ul></li></ul><p><strong>命名管道</strong></p><ul><li>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。<ul><li>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo myPipe</span><br></pre></td></tr></table></figure><ul><li><code>myPipe</code>就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure><ul><li>接下来，我们往 myPipe 这个管道写入数据：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello&quot; &gt; myPipe  &#x2F;&#x2F; 将数据写进管道</span><br><span class="line">                         &#x2F;&#x2F; 停住了 ...</span><br></pre></td></tr></table></figure><ul><li><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p></li><li><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; myPipe  &#x2F;&#x2F; 读取管道里的数据</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p></li><li><p>我们可以看出，<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p></li></ul><blockquote><p>那管道如何创建呢，背后原理是什么？</p></blockquote><p><strong>匿名管道</strong>的创建，需要通过下面这个系统调用：</p><p><code>int pipe(int fd[2])</code></p><ul><li>这里表示创建一个匿名管道，并返回了两个描述符，<ul><li>一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。</li><li>注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163516413.png" alt="mark"></p><ul><li>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</li><li>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</li><li>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163605213.png" alt="mark"></p><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 <code>fd[0]</code>，只保留写入的<code>fd[1]</code>；</li><li>子进程关闭写入的<code>fd[1]</code>，只保留读取的<code>fd[0]</code>；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163701458.png" alt="mark"></p><p><strong>所以说如果需要双向通信，则应该创建两个管道。</strong></p><ul><li>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，<strong>但是在我们 shell 里面并不是这样的。</strong><ul><li>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163801175.png" alt="mark"></p><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p><strong>小结：</strong></p><ul><li><p><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p></li><li><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p></li><li><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p></li></ul><h3 id="2-2-消息队列"><a href="#2-2-消息队列" class="headerlink" title="2.2 消息队列"></a>2.2 消息队列</h3><ul><li>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</li><li>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</li><li>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，<strong>消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。</strong></li><li>如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</li><li>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</li><li>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</li></ul><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><ul><li><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</li><li><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</li></ul><h3 id="2-3-共享内存"><a href="#2-3-共享内存" class="headerlink" title="2.3 共享内存"></a>2.3 共享内存</h3><ul><li>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</li><li>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</li><li><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164240759.png" alt="mark"></p><h3 id="2-4-信号量"><a href="#2-4-信号量" class="headerlink" title="2.4 信号量"></a>2.4 信号量</h3><ul><li>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</li><li>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</li></ul><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p><strong>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</strong></p><p><strong>互斥访问</strong></p><ul><li>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164357574.png" alt="mark"></p><p>具体的过程如下：</p><ul><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p><strong>同步访问</strong></p><ul><li>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</li><li>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这<strong>两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</strong></li></ul><p>那么这时候，就可以用信号量来实现多<strong>进程同步的方式，我们可以初始化信号量为 <code>0</code>。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164459468.png" alt="mark"></p><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><h3 id="2-5-信号"><a href="#2-5-信号" class="headerlink" title="2.5 信号"></a>2.5 信号</h3><ul><li>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164625864.png" alt="mark"></p><ul><li>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</li><li><strong>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p><strong>1. 运行在 shell 终端的进程</strong>，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p><strong>2. 如果进程在后台运行</strong>，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p><strong>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</strong></p><ul><li><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的<code>SIGTERM</code>信号，就是终止进程的意思。<code>Core</code>的意思是<code>Core Dump</code>，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p></li></ul><h3 id="2-6-Socket"><a href="#2-6-Socket" class="headerlink" title="2.6 Socket"></a>2.6 Socket</h3><ul><li><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p></li><li><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p></li></ul><p><code>int socket(int domain, int type, int protocal)</code></p><p><strong>三个参数分别代表：</strong></p><ul><li><code>domain</code> 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</li><li><code>type</code>参数用来指定通信特性，比如 <code>SOCK_STREAM</code>表示的是字节流，对应<code>TCP</code>、<code>SOCK_DGRAM</code>表示的是数据报，对应 <code>UDP</code>、<code>SOCK_RAW</code>表示的是原始套接字；</li><li><code>protocal</code> 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p><strong>根据创建 socket 类型的不同，通信的方式也就不同：</strong></p><ul><li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p><strong>接下来，简单说一下这三种通信的编程模式。</strong></p><h4 id="2-6-1-针对-TCP-协议通信的-socket-编程模型"><a href="#2-6-1-针对-TCP-协议通信的-socket-编程模型" class="headerlink" title="2.6.1 针对 TCP 协议通信的 socket 编程模型"></a>2.6.1 针对 TCP 协议通信的 socket 编程模型</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/165037742.png" alt="mark"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h4 id="2-6-2-针对-UDP-协议通信的-socket-编程模型"><a href="#2-6-2-针对-UDP-协议通信的-socket-编程模型" class="headerlink" title="2.6.2 针对 UDP 协议通信的 socket 编程模型"></a>2.6.2 针对 UDP 协议通信的 socket 编程模型</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/165208111.png" alt="mark"></p><ul><li>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</li><li>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个<code>socket</code> 多台机器就可以任意通信，因此每一个 <code>UDP</code> 的 <code>socket</code>都需要 bind。</li></ul><p>另外，每次通信时，调用<code>sendto</code> 和 <code>recvfrom</code>，都要传入目标主机的 IP 地址和端口。</p><h4 id="2-6-3-针对本地进程间通信的-socket-编程模型"><a href="#2-6-3-针对本地进程间通信的-socket-编程模型" class="headerlink" title="2.6.3 针对本地进程间通信的 socket 编程模型"></a>2.6.3 针对本地进程间通信的 socket 编程模型</h4><p>本地 socket  被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，<strong>可以支持「字节流」和「数据报」两种协议；</strong></li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><h3 id="3-1-进程的通信方式"><a href="#3-1-进程的通信方式" class="headerlink" title="3.1 进程的通信方式"></a>3.1 进程的通信方式</h3><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><ul><li><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</li><li><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</li></ul><ul><li><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></li></ul><ul><li><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p></li><li><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p></li></ul><ul><li>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</li></ul><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><h3 id="3-2-线程的通信方式"><a href="#3-2-线程的通信方式" class="headerlink" title="3.2 线程的通信方式"></a>3.2 线程的通信方式</h3><p><strong>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</strong></p><ul><li><p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p></li><li><p>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</p></li><li><p>同步的方式，可保证线程 A 应在线程 B 之前执行；</p></li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-05-进程通信&quot;&gt;&lt;a href=&quot;#操作系统-05-进程通信&quot; class=&quot;headerlink&quot; title=&quot;操作系统-05-进程通信&quot;&gt;&lt;/a&gt;操作系统-05-进程通信&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151330566.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很明显，在这一场面试中， 张三在&lt;strong&gt;进程间通信&lt;/strong&gt;这一块没复习好，虽然列出了进程间通信的方式，但这只是表面功夫，&lt;strong&gt;应该需要进一步了解每种通信方式的优缺点及应用场景。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程通信" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-04-进程控制</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-04-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-04-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-10-04T06:00:53.000Z</published>
    <updated>2020-10-04T07:11:03.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-04-进程控制"><a href="#操作系统-04-进程控制" class="headerlink" title="操作系统-04-进程控制"></a>操作系统-04-进程控制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>什么是进程控制？<br>进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简而言之就是实现进程状态切换。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150250419.png" alt="mark"></p><a id="more"></a><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150328172.png" alt="mark"></p><ul><li><strong>使用原语进行实现</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150428635.png" alt="mark"></p><ul><li><strong>大致流程</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150533562.png" alt="mark"></p><blockquote><p>这里说明一下调度和切换的区别：<br><code>调度</code>是指决定资源分配给哪个进程的行为，是一种决策行为<br><code>切换</code>是指实际分配的行为，是执行行为<br>一般来说现有资源调度，后有进程切换</p></blockquote><h2 id="2-进程控制相关原语"><a href="#2-进程控制相关原语" class="headerlink" title="2. 进程控制相关原语"></a>2. 进程控制相关原语</h2><p>进程控制会导致进程状态的转换。<strong>无论哪个原语,要做的无非三类事情:</strong> </p><ol><li><p><strong>更新PCB中的信息</strong>(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)    </p><p>a.所有的进程控制原语一定都会修改进程状态标志    </p><p>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境    </p><p>c.某进程开始运行前必然要恢复期运行环境 </p></li><li><p><strong>将PCB插入合适的队列</strong> </p></li><li><p><strong>分配/回收资源</strong></p></li></ol><p>以下针对每种原语进行说明：</p><ul><li><p><strong>进程创建</strong></p><ul><li><p>创建原语<br>1.申请空白PCB<br>​2.为新进程分配所需资源<br>3.初始化PCB<br>4.将PCB插入就绪队列​</p></li><li><p>引发事件<br>1.分时系统，用户登录<br>2.多道批处理系统，新的作业提交到内存<br>3.用户向操作系统提取请求<br>4.用户进程自动请求创建子进程​</p></li></ul></li><li><p><strong>进程终止</strong></p><ul><li><p>撤销原语<br>1.从PCB集合找到终止进程的PCB<br>2.若进程正在运行，立即剥夺CPU，将CPU分配给其它进程<br>3.终止其所有子进程<br>4.回收资源给父进程或者操作系统<br>5.删除PCB​​</p></li><li><p>引发事件<br>1.正常结束<br>2.异常结束<br>3.外界干预​</p></li></ul></li><li><p><strong>进程阻塞</strong></p><ul><li><p>阻塞原语<br>1.找到进程对于的PCB<br>2.保护进程运行现场，设置PCB状态为阻塞态，暂停进程运行<br>3.将PCB插入对应的事件等待队列</p></li><li><p>引发事件<br>1.需要等待系统分配某种资源<br>2.需要等待相互合作的其它进程完成工作</p></li></ul></li><li><p><strong>进程唤醒</strong></p><ul><li><p>唤醒原语<br>1.在事件等待队列中找到PCB<br>​2.将其从等待队列移除，设置进程为就绪态<br>3.将PCB插入就绪队列，等待被调度</p></li><li><p>引发原因<br>因何事阻塞，因何事唤醒<br>阻塞和唤醒成对出现</p></li></ul></li><li><p><strong>进程切换</strong></p><ul><li><p>切换原语<br>1.保存运行环境到PCB<br>2.PCB移入相应队列<br>3.选择另一个PCB执行，更新其PCB<br>4.根据PCB恢复新进程的运行环境​</p></li><li><p>引发原因<br>1.当前进程时间片用完<br>2.更高优先级进程达到<br>3.当前进程主动阻塞<br>4.当前进程终止​</p></li></ul></li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-04-进程控制&quot;&gt;&lt;a href=&quot;#操作系统-04-进程控制&quot; class=&quot;headerlink&quot; title=&quot;操作系统-04-进程控制&quot;&gt;&lt;/a&gt;操作系统-04-进程控制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是进程控制？&lt;br&gt;进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简而言之就是实现进程状态切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150250419.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-03-进程状态</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-03-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-03-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</id>
    <published>2020-10-04T05:00:53.000Z</published>
    <updated>2020-10-04T07:01:02.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-03-进程状态"><a href="#操作系统-03-进程状态" class="headerlink" title="操作系统-03-进程状态"></a>操作系统-03-进程状态</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇博客介绍了进程的定义和特性等等</li><li>本篇单独开篇就是讲进程的状态，因为是个重要的知识点得单独说</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145220849.png" alt="mark"></p><a id="more"></a><h2 id="1-进程的状态"><a href="#1-进程的状态" class="headerlink" title="1. 进程的状态"></a>1. 进程的状态</h2><ul><li><strong>运行状态(Running)</strong><br>占有CPU，并在CPU上运行<br>单核处理器一个时刻只有一个进程处于运行态，双核两个</li><li><strong>就绪状态(Ready)</strong><br>进程已经具备一切运行条件，除了没有空闲CPU，导致暂时不能运行<br>万事俱备，只差CPU</li><li><strong>阻塞状态(Waiting/Blocked)</strong><br>等待某一事件而暂时不能运行，比如等待操作系统分配打印机、等待磁盘读写<br>为了提高CPU利用效率，进程需要先准备好其它所需资源，才能得到CPU的服务</li><li>创建状态(New)<br>操作系统为该进程分配所需内存等系统资源，为其创建、初始化PCB(分配PID等等)</li><li>终止状态(Terminated)<br>进程运行结束，或者出现Bug导致无法继续执行，操作系统需要撤销进程<br>完成资源回收，撤销PCB​</li></ul><p><strong>注意 ：</strong> </p><ul><li><strong>基本状态：运行、就绪、阻塞/等待态</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145824038.png" alt="mark"></p><ul><li>创建态和结束态</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145834883.png" alt="mark"></p><p><strong>创建态</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145927447.png" alt="mark"></p><p><strong>结束态</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145954012.png" alt="mark"></p><h2 id="2-进程状态之间的转换"><a href="#2-进程状态之间的转换" class="headerlink" title="2. 进程状态之间的转换"></a>2. 进程状态之间的转换</h2><ul><li>进程一共有如下5种状态，那么他们之间如何实现切换呢？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145456852.png" alt="mark"></p><ul><li>来一张形象生动的图片感受一下5种状态之间的切换</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150053112.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-03-进程状态&quot;&gt;&lt;a href=&quot;#操作系统-03-进程状态&quot; class=&quot;headerlink&quot; title=&quot;操作系统-03-进程状态&quot;&gt;&lt;/a&gt;操作系统-03-进程状态&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇博客介绍了进程的定义和特性等等&lt;/li&gt;
&lt;li&gt;本篇单独开篇就是讲进程的状态，因为是个重要的知识点得单独说&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145220849.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-02-进程管理</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-04T04:00:53.000Z</published>
    <updated>2020-10-04T06:49:57.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-02-进程管理"><a href="#操作系统-02-进程管理" class="headerlink" title="操作系统-02-进程管理"></a>操作系统-02-进程管理</h1><h2 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1. 进程的定义"></a>1. 进程的定义</h2><ol><li><strong>程序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143830157.png" alt="mark"></p><ol start="2"><li><strong>进程</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143852853.png" alt="mark"></p><ul><li>进程和程序的区别和联系：</li></ul><blockquote><p>区别：<br>(1) 进程是动态的;程序是静态的。<br>(2) 进程有独立性，能并发执行;程序不能并发执行。<br>(3) 二者无一一对应关系。<br>(4) 进程异步运行，会相互制约;程序不具备此特征。<br>但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。<br>(5) 组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。<br>(6) 程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。<br>(7) 进程由程序段、数据段和PCB构成,会占用系统如CPU、内存等运行资源。<br>(8) 一个程序可以启动多个进程来共同完成。<br>联系：进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。</p></blockquote><a id="more"></a><p><strong>进程定义</strong></p><ul><li>程序段、数据段、PCB三部分组成了进程实体(进程映像) 。<ul><li>一般情况下,我们把进程实体就简称为进程,</li><li>例如,所谓创建进程,实质上是创建进程实体中的PCB;</li><li>而撤销进程,实质上是撤销进程实体中的PCB.</li><li><strong>注意: PCB是进程存在的唯一标志!</strong>从不同的角度,进程可以有不同的定义,比较传统典型的定义有:<ul><li>1,进程是程序的一次执行过程。 </li><li>2,进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 </li><li>3,进程是具有独立功能的程序在数据集合上运行的过程,它是<strong>系统进行资源分配和调度的一个独立单位（强调“动态性”）</strong> </li><li>引入进程实体的概念后,可把进程定义为:进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位。</li></ul></li></ul></li></ul><h2 id="2-进程的组成"><a href="#2-进程的组成" class="headerlink" title="2. 进程的组成"></a>2. 进程的组成</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144324116.png" alt="mark"></p><ul><li><p><strong>程序段</strong><br>存放程序代码本身</p></li><li><p><strong>数据段</strong><br>存放程序运行过程中处理的各种数据</p></li><li><p><strong>PCB</strong></p><p>进程管理所需的数据都放在这里<br>​PCB是进程存在的唯一标志</p><ul><li><p>进程描述信息</p><ul><li><p>进程标识符 PID</p></li><li><p>用户标识符 UID</p></li><li><p>父进程 PID</p></li><li><p>子进程 PID</p></li></ul></li><li><p>进程控制和管理信息</p><ul><li><p>进程优先级</p></li><li><p>进程当前状态</p></li><li><p>进程阻塞原因</p></li><li><p>进程同步和通信机制</p></li><li><p>其它调度所需的信息</p></li></ul></li><li><p>资源分配清单</p><ul><li><p>程序段指针</p></li><li><p>数据段指针</p></li><li><p>外设资源</p></li></ul></li><li><p>处理器现场信息</p><ul><li>各种寄存器的值<br>进程切换时需要把当前进程的运行状态保存在PCB里面<br>比如程序计数器的值记录了当前程序执行到那一句了，通用寄存器，程序状态字寄存器，栈指针等等</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144521644.png" alt="mark"></p><p><strong>注意</strong></p><ul><li>而其中最重要的就是<code>进程控制块PCB</code>（Process Control Block）</li><li>在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。</li><li>所以说，PCB是进程存在的唯一标志。</li></ul><h2 id="3-进程的组织方式"><a href="#3-进程的组织方式" class="headerlink" title="3. 进程的组织方式"></a>3. 进程的组织方式</h2><h3 id="3-1-链接方式"><a href="#3-1-链接方式" class="headerlink" title="3.1 链接方式"></a>3.1 链接方式</h3><ul><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向个个队列的指针</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144740393.png" alt="mark"></p><h3 id="3-2-索引方式"><a href="#3-2-索引方式" class="headerlink" title="3.2 索引方式"></a>3.2 索引方式</h3><ul><li>根据进程状态不同，建立几张索引表</li><li>操作系统持有指向各索引表的指针</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144755298.png" alt="mark"></p><h2 id="4-进程的特征"><a href="#4-进程的特征" class="headerlink" title="4. 进程的特征"></a>4. 进程的特征</h2><ul><li><strong>动态性</strong><br><strong>最基本特征</strong>。进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li>并发性<br>内存中有多个进程实体，各进程可以并行执行</li><li>独立性<br>进程是能独立运行、获得资源、接受调度的基本单位</li><li>异步性<br>各进程按各自独立的、不可预测的速度向前推进，异步性会导致并发程序执行结果的不确定性，操作系统要提供“进程同步机制”来解决异步问题</li><li>结构性<br>每一个进程都会配置PCB</li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-02-进程管理&quot;&gt;&lt;a href=&quot;#操作系统-02-进程管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-02-进程管理&quot;&gt;&lt;/a&gt;操作系统-02-进程管理&lt;/h1&gt;&lt;h2 id=&quot;1-进程的定义&quot;&gt;&lt;a href=&quot;#1-进程的定义&quot; class=&quot;headerlink&quot; title=&quot;1. 进程的定义&quot;&gt;&lt;/a&gt;1. 进程的定义&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;程序&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143830157.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143852853.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程和程序的区别和联系：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;区别：&lt;br&gt;(1) 进程是动态的;程序是静态的。&lt;br&gt;(2) 进程有独立性，能并发执行;程序不能并发执行。&lt;br&gt;(3) 二者无一一对应关系。&lt;br&gt;(4) 进程异步运行，会相互制约;程序不具备此特征。&lt;br&gt;但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。&lt;br&gt;(5) 组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。&lt;br&gt;(6) 程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。&lt;br&gt;(7) 进程由程序段、数据段和PCB构成,会占用系统如CPU、内存等运行资源。&lt;br&gt;(8) 一个程序可以启动多个进程来共同完成。&lt;br&gt;联系：进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-977-有序数组的平方</title>
    <link href="http://zhuuu.work/2020/10/03/Leetcode/Leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <id>http://zhuuu.work/2020/10/03/Leetcode/Leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</id>
    <published>2020-10-03T07:52:53.000Z</published>
    <updated>2020-10-03T12:16:53.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges"><a href="#Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges" class="headerlink" title="Leecode-977. 有序数组的平方https://leetcode-cn.com/problems/rotting-oranges/)"></a>Leecode-<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a>)</h1><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><p><strong>题目描述</strong></p><ul><li>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">-10000 &lt;&#x3D; A[i] &lt;&#x3D; 10000</span><br><span class="line">A 已按非递减顺序排序。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>思路： 双指针</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || (length = A.length) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 一遍数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(A[i] * A[i] &gt; A[j] * A[j])&#123;</span><br><span class="line">                temp = A[i] * A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = A[j] * A[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result[k--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges&quot;&gt;&lt;a href=&quot;#Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges&quot; class=&quot;headerlink&quot; title=&quot;Leecode-977. 有序数组的平方https://leetcode-cn.com/problems/rotting-oranges/)&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://leetcode-cn.com/problems/squares-of-a-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;977. 有序数组的平方&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotting-oranges/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/rotting-oranges/&lt;/a&gt;)&lt;/h1&gt;&lt;h2 id=&quot;思路：双指针&quot;&gt;&lt;a href=&quot;#思路：双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：双指针&quot;&gt;&lt;/a&gt;思路：双指针&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一个按非递减顺序排序的整数数组 &lt;code&gt;A&lt;/code&gt;，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[-4,-1,0,3,10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[0,1,9,16,100]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[-7,-3,2,3,11]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,9,9,49,121]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;提示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10000 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A 已按非递减顺序排序。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-01-概述</title>
    <link href="http://zhuuu.work/2020/10/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/10/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-10-03T04:00:53.000Z</published>
    <updated>2020-10-03T04:01:13.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-01-概述"><a href="#操作系统-01-概述" class="headerlink" title="操作系统-01-概述"></a>操作系统-01-概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>是系统最基本最核心的软件，属于系统软件</li><li>控制和管理整个计算机的硬件和软件资源</li><li>合理的组织、调度计算机的工作与资源的分配</li><li>为用户和其它软件提供方便的接口和环境</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/103437449.png" alt="mark"></p><a id="more"></a><h2 id="1-基本特征"><a href="#1-基本特征" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h2><ol><li><strong>并发</strong></li></ol><ul><li><code>并发</code>：两个或多个事件在同一<code>时间间隔内</code>发生，这些事件在宏观上是同时发生的，在微观上是交替发生的， 操作系统的并发性指系统中同时存在着多个运行的程序</li><li><code>并行</code>：两个或多个事件在同一<code>时刻</code>发生</li><li>一个单核(CPU)同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</li></ul><ol start="2"><li><strong>共享</strong></li></ol><ul><li>互斥共享<br>同一个时间段只允许一个进程访问资源(摄像头/麦克风)</li><li>同时共享<br>允许一个时间段多个进程“同时”(宏观上)访问某些资源（微观上是分时共享），比如硬盘读写</li></ul><ol start="3"><li><strong>虚拟</strong></li></ol><ul><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的,而逻辑上对应物(后者)是用户感受到的。<ul><li><strong>空分复用</strong>(虚拟储存技术)<ul><li>物理4GB内存，用户看来远大于4GB</li></ul></li><li><strong>时分复用</strong>(虚拟处理器技术)<ul><li>一个CPU看上去是几个CPU,多个程序并发运行</li></ul></li></ul></li></ul><ol start="4"><li><strong>异步</strong></li></ol><ul><li>异步是指,在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,是走走停停（等待资源进程阻塞）,以不可预知的速度向前推异步性。</li></ul><h2 id="2-发展和分类"><a href="#2-发展和分类" class="headerlink" title="2. 发展和分类"></a>2. 发展和分类</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105010362.png" alt="mark"></p><ol><li><p><strong>手工操作阶段</strong>(IO靠纸带打孔，资源利用率低)</p></li><li><p><strong>批处理阶段</strong></p><ul><li><p>单道批处理系统<br>引入了脱机输入/输出技术（磁带），通过监督程序（操作系统雏形）控制作业输入输出</p><p>外围机负责把输入纸带录入磁带</p><p>缓解了人机速度矛盾，提高了资源利用率，但是CPU是串行的，大量CPU时间浪费在I/O等待上</p></li><li><p>多道批处理系统<br>磁带往内存输入多道程序，并发执行，输入、计算、输出互不干扰</p><p>操作系统诞生，引入了中断技术，资源利用率大幅上升，但是缺少人机交互功能，用户响应时间长（用户提交作业之后只能等待作业完成）</p></li></ul></li><li><p><strong>分时操作系统</strong></p><ul><li>分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务,各个用户可通过终端与计算机进行交互。</li><li>主要优点:用户请求可以被即时响应,解决了人机交互问题。允许多个用户同时使用一台计算机,并且用户对计算机的操作相互独立,感受不到别人的存在。</li><li>主要缺点:不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的,循环地为每个用户/作业服务一个时间片,不区分任务的紧急性。</li></ul></li></ol><ol start="4"><li><strong>网络操作系统</strong><ul><li>网络操作系统:是伴随着计算机网络的发展而诞生的,能把网络中各个计算机有机地结合起来,实现数据传送等功能,实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信。(如: Windows NT就是一种典型的网络操作系统,网站服务器就可以使用)</li></ul></li></ol><ol start="5"><li><strong>分布式操作系统</strong><ul><li>分布式操作系统:主要特点是分布性和并行性。系统中的各台计算机地位相同,任何工作都可以分布在这些计算机上,由它们并行、协同完成这个任务。</li></ul></li></ol><ol start="6"><li><p><strong>PC操作系统</strong></p><ul><li><p>Windows10</p></li><li><p>MacOS</p></li><li><p>Ubuntu</p></li></ul></li></ol><p><strong>小结：发展历程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105106471.png" alt="mark"></p><h2 id="3-运行机制和体系结构"><a href="#3-运行机制和体系结构" class="headerlink" title="3. 运行机制和体系结构"></a>3. 运行机制和体系结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105349798.png" alt="mark"></p><h3 id="3-1-运行机制"><a href="#3-1-运行机制" class="headerlink" title="3.1 运行机制"></a>3.1 运行机制</h3><ul><li><p><strong>指令</strong></p><ul><li><p><strong>特权指令</strong></p><ul><li>内存清零指令</li></ul></li><li><p><strong>非特权指令</strong></p><ul><li>加减乘除运算指令</li></ul></li></ul></li></ul><ul><li><p><strong>处理器状态</strong></p><ul><li><p><strong>核心态(目管态)</strong></p><ul><li>PSW=0，<strong>运行执行特权指令</strong><br>PSW 程序状态字寄存器，通过标志位标识处理器的运行状态</li></ul></li><li><p><strong>用户态(目态)</strong></p><ul><li>PSW=1，<strong>只能使用非特权指令</strong></li></ul></li></ul></li></ul><ul><li><p><strong>程序</strong></p><ul><li><p><strong>应用程序</strong><br>为了安全，运行在用户态</p></li><li><p><strong>内核程序</strong><br>系统管理者，运行在核心态</p></li></ul></li></ul><h3 id="3-2-体系结构"><a href="#3-2-体系结构" class="headerlink" title="3.2 体系结构"></a>3.2 体系结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/112129093.png" alt="mark"></p><ul><li><strong>大内核</strong><br>将操作系统的主要功能模块都作为系统内核，运行在核心态<br>高性能，但是内核代码庞大难以维护</li><li><strong>微内核</strong><br>只把基本概念保留在内核<br>功能少，功能清晰方便维护，但是需要频繁的在核心态和用户态之间切换，性能低</li></ul><h3 id="3-3-OS内核结构"><a href="#3-3-OS内核结构" class="headerlink" title="3.3 OS内核结构"></a>3.3 OS内核结构</h3><ul><li><p><strong>时钟管理</strong></p><ul><li>用于计时</li><li>通过时钟中断的管理,可以实现进程的切换</li></ul></li><li><p><strong>中断处理</strong></p></li><li><p><strong>原语</strong></p><ul><li>运行时间短，调用频繁，原子性运行只能一气呵成，不可中断</li></ul></li><li><p><strong>系统资源管理</strong></p><p>有的操作系统不把这个作为“内核功能”（微内核）</p><ul><li><p>进程管理</p></li><li><p>储存器管理</p></li><li><p>设备管理</p></li></ul></li></ul><h2 id="4-中断和异常"><a href="#4-中断和异常" class="headerlink" title="4. 中断和异常"></a>4. 中断和异常</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/112855093.png" alt="mark"></p><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><ul><li>发生了中断,就意味着需要操作系统介入,开展管理工作。 </li><li>由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要<strong>使用特权指令</strong>,<strong>因此CPU要从用户态转为核心态</strong>。 </li><li>中断可以使CPU从用户态切换为核心态,使操作系统获得计算机的控制权。有了中断才能实现多道程序并发执行。 </li><li><strong>中断是CPU从用户态-&gt;核心态切换的唯一途径。</strong> </li><li><strong>核心态-&gt;用户态切换只需要执行一个特权指令</strong>，<code>将PSW设置为0</code></li></ul><h3 id="4-2-中断分类"><a href="#4-2-中断分类" class="headerlink" title="4.2 中断分类"></a>4.2 中断分类</h3><ul><li><p><strong>内中断(异常/例外/陷入)</strong></p><p><strong>信号来源CPU内部，与当前执行的指令有关</strong></p><ul><li><p>自愿中断(指令中断)<br>系统调用时使用的访管指令(陷入指令/trap指令)</p></li><li><p>强迫中断</p><ul><li><p>硬件故障<br>缺页错误</p></li><li><p>软件中断<br>除0错误</p></li></ul></li></ul></li><li><p><strong>外中断(狭义中断)</strong></p><p><strong>信号来源CPU外部，与当前执行的指令无关</strong></p><ul><li><p>外设请求<br>外设(比如打印机)I/O操作完成发出中断信号<br>键盘输入一个字符</p></li><li><p>人工干预<br>用户强制终止一个进程</p></li></ul></li></ul><h3 id="4-3-中断处理的过程"><a href="#4-3-中断处理的过程" class="headerlink" title="4.3 中断处理的过程"></a>4.3 中断处理的过程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/114138459.png" alt="mark"></p><p><strong>大致处理过程</strong></p><ul><li>Step 1:执行完每个指令之后, CPU都要检查当前是否有外部中断信号 </li><li>Step 2:如果检测到外部中断信号,则需要保护被中断进程的CPU环境(如程序状态字Psw、程序计数器PC、各种通用寄存器) </li><li>Step 3:根据中断信号类型转入相应的中断处理程序(进入核心态) </li><li>Step 4:恢复原进程的CPU环境并退出中断,返回原进程继续往下执行</li></ul><h2 id="5-系统调用"><a href="#5-系统调用" class="headerlink" title="5. 系统调用"></a>5. 系统调用</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/114523218.png" alt="mark"></p><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><ul><li>“系统调用”是操作系统提供给应用程序(程序员/编程人员)使用的接口,可以理解为一种可供应用程序调用的特殊函数,应用程序可以<strong>发出系统调用请求来获得操作系统的服务</strong>。 </li><li>应用程序通过系统调用请求操作系统的服务。 系统中的各种共享资源都由操作系统统一掌管,因此在用户程序中,凡是与资源有关的操作(如存储分配、1/0操作、文件管理等) ,都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成。</li><li><strong>这样可以保证系统的稳定性和安全性,防止用户进行非法操作。</strong> </li><li><strong>系统调用相关的处理需要在核心态下完成。</strong></li></ul><h3 id="5-2-系统调用和库函数的区别"><a href="#5-2-系统调用和库函数的区别" class="headerlink" title="5.2 系统调用和库函数的区别"></a>5.2 系统调用和库函数的区别</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/115154503.png" alt="mark"></p><h3 id="5-3-系统调用过程"><a href="#5-3-系统调用过程" class="headerlink" title="5.3 系统调用过程"></a>5.3 系统调用过程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/115353845.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-01-概述&quot;&gt;&lt;a href=&quot;#操作系统-01-概述&quot; class=&quot;headerlink&quot; title=&quot;操作系统-01-概述&quot;&gt;&lt;/a&gt;操作系统-01-概述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;是系统最基本最核心的软件，属于系统软件&lt;/li&gt;
&lt;li&gt;控制和管理整个计算机的硬件和软件资源&lt;/li&gt;
&lt;li&gt;合理的组织、调度计算机的工作与资源的分配&lt;/li&gt;
&lt;li&gt;为用户和其它软件提供方便的接口和环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/103437449.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-717-1比特与2比特字符</title>
    <link href="http://zhuuu.work/2020/10/02/Leetcode/Leetcode-717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
    <id>http://zhuuu.work/2020/10/02/Leetcode/Leetcode-717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</id>
    <published>2020-10-02T05:24:53.000Z</published>
    <updated>2020-10-02T02:29:18.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-717-1比特与2比特字符"><a href="#Leetcode-717-1比特与2比特字符" class="headerlink" title="Leetcode-717-1比特与2比特字符"></a>Leetcode-717-<a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/" target="_blank" rel="noopener">1比特与2比特字符</a></h1><p><strong>题目描述：</strong></p><p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。</p><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li><li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li></ul><a id="more"></a><h2 id="思路-：-线性扫描"><a href="#思路-：-线性扫描" class="headerlink" title="思路 ： 线性扫描"></a>思路 ： 线性扫描</h2><ul><li>我们可以对bits数组从左到右扫描来判断最后一位是否是一比特字符<ul><li>当扫描到第i位的时候，如果bits[i] = 1, 那么说明这是一个两比特字符，那么将步长调整为2（也就是i的值加2）</li><li>当扫描到第i位的时候，如果bits[i] = 0,说明这是个一比特字符,步长设置为1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bits.length - <span class="number">1</span>) &#123;</span><br><span class="line">            i += bits[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == bits.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中 n是 bits 数组的长度。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-717-1比特与2比特字符&quot;&gt;&lt;a href=&quot;#Leetcode-717-1比特与2比特字符&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-717-1比特与2比特字符&quot;&gt;&lt;/a&gt;Leetcode-717-&lt;a href=&quot;https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1比特与2比特字符&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。&lt;/p&gt;
&lt;p&gt;现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bits &amp;#x3D; [1, 0, 0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bits &amp;#x3D; [1, 1, 1, 0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: False&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= len(bits) &amp;lt;= 1000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bits[i]&lt;/code&gt; 总是&lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-771-宝石与石头</title>
    <link href="http://zhuuu.work/2020/10/02/Leetcode/Leetcode-771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/"/>
    <id>http://zhuuu.work/2020/10/02/Leetcode/Leetcode-771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</id>
    <published>2020-10-02T02:22:53.000Z</published>
    <updated>2020-10-02T02:14:07.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-771-宝石与石头"><a href="#Leetcode-771-宝石与石头" class="headerlink" title="Leetcode-771-宝石与石头"></a>Leetcode-771-<a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">宝石与石头</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p></li><li><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul><a id="more"></a><h2 id="思路-1：-HashSet"><a href="#思路-1：-HashSet" class="headerlink" title="思路 1： HashSet"></a>思路 1： HashSet</h2><ul><li>标签：字符串</li><li>首先对J进行遍历，将字符分别存到HashSet中，以便之后遍历S的时候查找</li><li>遍历S，并将每个字符与HashSet中的进行比对，如果存在，则结果res++，遍历结束，返回res</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 把J中字符都加入到hashset中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; J.length();i++)&#123;</span><br><span class="line">            set.add(J.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断 S中是否有对应的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(S.charAt(i)))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong> </p><ul><li>时间复杂度：O(m+n)，m为J的长度，n为S的长度</li><li>空间复杂度： O(m) 需要把J中字符都加入到hashset中</li></ul><h2 id="思路2：暴力求解"><a href="#思路2：暴力求解" class="headerlink" title="思路2：暴力求解"></a>思路2：暴力求解</h2><ul><li>暴力法的思路很直观，遍历字符串 S<em>S</em>，对于 S<em>S</em> 中的每个字符，遍历一次字符串 J，如果其和 J中的某一个字符相同，则是宝石。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = J.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = S.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2;++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr = S.charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len1;++j)&#123;</span><br><span class="line">                <span class="keyword">char</span> jewel = J.charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(curr == jewel)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><strong>时间复杂度：O(mn)</strong>，其中 mm 是字符串 J的长度，n 是字符串 S的长度。遍历字符串 S 的时间复杂度是 O(n)，对于 SS 中的每个字符，需要遍历字符串 J判断是否是宝石，时间复杂度是 O(m)，因此总时间复杂度是 O(mn)。</li><li><strong>空间复杂度：O(1)</strong>。只需要维护常量的额外空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-771-宝石与石头&quot;&gt;&lt;a href=&quot;#Leetcode-771-宝石与石头&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-771-宝石与石头&quot;&gt;&lt;/a&gt;Leetcode-771-&lt;a href=&quot;https://leetcode-cn.com/problems/jewels-and-stones/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;宝石与石头&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: J &amp;#x3D; &amp;quot;aA&amp;quot;, S &amp;#x3D; &amp;quot;aAAbbbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: J &amp;#x3D; &amp;quot;z&amp;quot;, S &amp;#x3D; &amp;quot;ZZ&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;J&lt;/code&gt; 最多含有50个字母。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt; 中的字符不重复。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-02-NIO实战及原理</title>
    <link href="http://zhuuu.work/2020/10/01/Netty/Netty-02-NIO%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/01/Netty/Netty-02-NIO%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86/</id>
    <published>2020-10-01T03:05:24.000Z</published>
    <updated>2020-10-09T02:46:12.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-02-NIO实战及原理"><a href="#Netty-02-NIO实战及原理" class="headerlink" title="Netty-02-NIO实战及原理"></a>Netty-02-NIO实战及原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>Java NIO 全称 <code>java non-blocking IO</code>，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)，是<strong>同步非阻塞</strong>的</p></li><li><p>NIO 相关类都被放在 <code>java.nio</code> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。</p></li><li><p>NIO 有三大核心部分：<strong>Channel(通道)</strong>，<strong>Buffer(缓冲区)</strong>, <strong>Selector(选择器)</strong></p></li><li><p>NIO是 面向<strong>缓</strong>冲区 ，或者面向 <strong>块</strong> 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供<strong>非阻塞</strong>式的高伸缩性网络</p></li><li><p><code>Java NIO</code>的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而<strong>不是保持线程阻塞</strong>，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p></li><li><p>通俗理解：<code>NIO</code>是可以做到用一个线程来处理多个操作的。假设有<code>10000</code>个请求过来,根据实际情况，可以分配<code>50</code>或者<code>100</code>个线程来处理。不像之前的阻塞<code>IO</code>那样，非得分配<code>10000</code>个。</p></li><li><p><code>HTTP2.0</code>使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比<code>HTTP1.1</code>大了好几个数量级。</p></li></ul><a id="more"></a><h2 id="1-NIO三大核心概述"><a href="#1-NIO三大核心概述" class="headerlink" title="1. NIO三大核心概述"></a>1. NIO三大核心概述</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/111307133.png" alt="mark"></p><p><strong>Buffer：</strong></p><ul><li>缓存数组，就是一个内存块，底层用数组实现</li><li>与<code>Channel</code>进行数据的读写。</li><li>数据的读取写入是通过<code>Buffer</code>, 这个和<code>BIO</code> 一样, 而<code>BIO</code> 中要么是输入流，或者是输出流, 不能双向，但是<code>NIO</code>的<code>Buffer</code> 是可以读也可以写, 需要 <code>flip</code> 方法切换。</li></ul><p><strong>Channel：</strong></p><ul><li>通信通道，每个客户端连接都会建立一个<code>Channel</code>通道</li><li>客户端直接与<code>Channel</code>进行通信，当客户端发送消息时，消息就流通到<code>Channel</code>里面，本地程序需要将<code>Channel</code>里面的数据存放在<code>Buffer</code>里面，才可以查看；当本地需要发送消息时，先把消息存在<code>Buffer</code>里面，再将<code>Buffer</code>里面的数据放入<code>Channel</code>，数据就流通到了客户端</li><li>总而言之：<code>Buffer</code>就是本地程序与<code>Channel</code>数据交换的一个中间媒介。</li></ul><p><strong>Selector</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/111954021.png" alt="mark"></p><ul><li>NIO之所以是非阻塞的，关键在于它一个线程可以同时处理多个客户端的通信。而<code>Selector</code>就是它一个线程如何处理多个客户端通信的关键，一个<code>Selector</code>就对应一个线程</li><li>首先在创建与客户端连接的<code>Channel</code>时，应该调用 <code>Channel.register()</code>方法，将Channel注册到一个<code>Selector</code>上面。调用该方法后，会返回一个<code>SelectionKey</code>对象，该对象与<code>Channel</code>是一一对应的。而<code>Selector</code>则通过管理<code>SelectionKey</code>的集合间接的去管理各个<code>Channel</code>。示例图如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/112011816.png" alt="mark"></p><p><code>Selector</code>具体是如何管理这么多个通信的呢？这就引出了<strong>事件</strong>。</p><p><strong>事件、以及NIO的工作流程介绍</strong></p><ul><li><strong>事件：</strong>当将<code>Channel</code>绑定到<code>Selector</code>上面时，必须同时为该<code>Channel</code>声明一个监听该<code>Channel</code>的事件（由<code>Channel</code>和该<code>Channel的事件</code>一起组成了<code>SelectionKey</code>），并将<code>SelectionKey</code>加入到<code>Selector</code>的<code>Set</code>集合中去</li><li>当有客户端建立连接或者进行通信，会在对应的各个<code>Channel</code>中产生不同的事件。</li><li><code>Selector</code>会一直监听所有的事件，当他监听到某个<code>SelectionKey</code>中有事件产生时，会将所有产生事件的<code>SelectionKey</code>统一加入到一个集合中去</li><li>而我们则需要获取到这个集合，首先对集合中的各个<code>SelectionKey</code>进行判断，判断它产生的是什么事件，再根据不同的事件进行不同的处理。</li><li>在操作这个<code>SelectionKey</code>集合的时候，其实我们就是在一个线程里面对几个不同客户端的连接进行操作。具体的关系图如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/184806838.png" alt="mark"></p><h2 id="2-Buffer"><a href="#2-Buffer" class="headerlink" title="2. Buffer"></a>2. Buffer</h2><ul><li>缓冲区（Buffer）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个容器对象（<strong>含数组</strong>），</li><li>该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。</li><li><code>Channel</code>提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由<code>Buffer</code>。</li></ul><h3 id="2-1-Buffer类介绍"><a href="#2-1-Buffer类介绍" class="headerlink" title="2.1 Buffer类介绍"></a>2.1 Buffer类介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The characteristics of Spliterators that traverse and split elements</span></span><br><span class="line"><span class="comment">     * maintained in Buffers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPLITERATOR_CHARACTERISTICS =</span><br><span class="line">        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used only by direct buffers</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> hoisted here for speed in JNI GetDirectBufferAddress</span></span><br><span class="line">    <span class="keyword">long</span> address;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185018679.png" alt="mark"></p><ul><li><p>基类是<code>Buffer</code>抽象类</p></li><li><p>基类派生出基于基本数据类型的7个<code>xxxBuffer</code> 抽象类，没有<code>boolean</code>相关的<code>buffer</code>类。</p></li><li><p>除了<code>ByteBuffer</code>外，每个基本数据的抽象类 <code>xxxBuffer</code> 类下面都派生出转向 <code>ByteBuffer</code> 的类 <code>ByteBufferXxxAsBufferL</code> 和 <code>ByteBufferAsXxxBufferB</code>实现类；以及 <code>DirectXxxBufferU</code> 和 <code>DirectXxxBufferS</code> 和 <code>HeapXxxBuffer</code>==（具体实例对象类）==这五个类。</p></li><li><p>就只有抽象类<code>CharBuffer</code> 派生出了第六个类<code>StringCharBuffer</code>。</p></li><li><p><code>ByteBuffer</code>只派生出了 <code>HeapByteBuffer</code> 和 <code>MappedByteBufferR</code> 两个类</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185139008.png" alt="mark"></p><h3 id="2-2-Buffer-属性"><a href="#2-2-Buffer-属性" class="headerlink" title="2.2 Buffer 属性"></a>2.2 Buffer 属性</h3><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Capacity</td><td>容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</td></tr><tr><td>Limit</td><td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的</td></tr><tr><td>Position</td><td>位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变改值，为下次读写作准备</td></tr><tr><td>Mark</td><td>标记 ，一般不会主动修改，在<code>flip()</code>被调用后，mark就作废了。</td></tr></tbody></table><blockquote><p>mark &lt;= position &lt;= limit &lt;= capacity</p></blockquote><h3 id="2-3-简单使用"><a href="#2-3-简单使用" class="headerlink" title="2.3 简单使用"></a>2.3 简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 举例说明Buffer的使用</span></span><br><span class="line">        <span class="comment">// 创建一个IntBuffer,大小为5,即存放5个int类型</span></span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 向Buffer中存储数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;</span><br><span class="line">            intBuffer.put(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从Buffer中读取数据</span></span><br><span class="line">        <span class="comment">// 将buffer进行读写切换（重要）</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Buffer<code>刚创建时，</code>capacity = 5<code>，固定不变。</code>limit<code>指针指向</code>5<code>，</code>position<code>指向</code>0<code>，</code>mark<code>指向</code>-1</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185326111.png" alt="mark"></p><ul><li>之后调用 <code>intBuffer.put</code>方法，向<code>buffer</code>中添加数据，会不断移动<code>position</code>指针，最后<code>position</code>变量会和<code>limit</code>指向相同。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185351549.png" alt="mark"></p><ul><li>调用 <code>buffer.flip()</code>实际上是重置了<code>position</code>和<code>limit</code>两个变量，将<code>limit</code>放在<code>position</code>的位置，<code>position</code>放在<code>0</code>的位置。这里只是最后的<code>position</code>和<code>limit</code>位置相同，所以<code>flip</code>后<code>limit</code>位置没变。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185407014.png" alt="mark"></p><ul><li>调用 <code>intBuffer.get()</code>实际上是不断移动<code>position</code>指针，直到它移动到<code>limit</code>的位置</li></ul><h3 id="2-4-Buffer-类方法"><a href="#2-4-Buffer-类方法" class="headerlink" title="2.4 Buffer 类方法"></a>2.4 Buffer 类方法</h3><h5 id="Buffer基类（抽象类）"><a href="#Buffer基类（抽象类）" class="headerlink" title="Buffer基类（抽象类）"></a>Buffer基类（抽象类）</h5><ul><li><code>public final int capacity();</code><ul><li>直接返回了此缓冲区的容量，<code>capacity</code></li></ul></li><li><code>public final int position();</code><ul><li>直接返回了此缓冲区指针的当前位置</li></ul></li><li><code>public final Buffer position(int newPosition);</code><ul><li>设置此缓冲区的位置，设置<code>position</code></li></ul></li><li><code>public final int limit();</code><ul><li>返回此缓冲区的限制</li></ul></li><li><code>public final Buffer limit(int newLimit);</code><ul><li>设置此缓冲区的限制，设置<code>limit</code></li></ul></li><li><code>public final Buffer clear();</code><ul><li>清除此缓冲区，即将各个标记恢复到初识状态， <code>position = 0;limit = capacity; mark = -1</code>，但是并没有删除数据。</li></ul></li><li><code>public final Buffer flip();</code><ul><li>反转此缓冲区， <code>limit = position;position = 0;mark = -1</code>。</li><li>当指定数据存放在缓冲区中后，<code>position</code>所指向的即为此缓冲区数据最后的位置。只有当数据大小和此缓冲区大小相同时，<code>position</code>才和<code>limit</code>的指向相同。</li><li><code>flip()</code>方法将<code>limit</code>置向<code>position</code>， <code>position</code>置<code>0</code>，那么从<code>position</code>读取数据到<code>limit</code>即为此缓冲区中所有的数据。</li></ul></li><li><code>public final boolean hasRemaining();</code><ul><li>告知当前位置和限制之间是否有元素。<code>return position &lt; limit;</code></li></ul></li><li><code>public abstract boolean isReadOnly();</code><ul><li>此方法为抽象方法，告知此缓冲区是否为只读缓冲区，具体实现在各个实现类中。</li></ul></li><li><code>public abstract boolean hasArray();</code><ul><li>告知此缓冲区是否具有可访问的底层实现数组</li></ul></li><li><code>public abstract Object array();</code><ul><li>返回此缓冲区的底层实现数组</li></ul></li></ul><h3 id="2-5-ByteBuffer的使用"><a href="#2-5-ByteBuffer的使用" class="headerlink" title="2.5 ByteBuffer的使用"></a>2.5 ByteBuffer的使用</h3><p>从前面可以看出来对于Java中的基本数据类型（<strong>boolean除外</strong>），都有一个<code>Buffer</code>类型与之对应，最常用的自然是<code>ByteBuffer</code>类（二进制数据），该类的主要方法如下：</p><ul><li><code>public static ByteBuffer allocateDirect(int capacity);</code><ul><li>创建直接缓冲区</li></ul></li><li><code>public static ByteBuffer allocate(int capacity) ;</code><ul><li>设置缓冲区的初识容量</li></ul></li><li><code>public abstract byte get();</code><ul><li>从当前位置<code>position</code>上<code>get</code>数据，获取之后，<code>position</code>会自动加<code>1</code></li></ul></li><li><code>public abstract byte get(int index);</code><ul><li>通过绝对位置获取数据。</li></ul></li><li><code>public abstract ByteBuffer put(byte b);</code><ul><li>从当前位置上添加，<code>put</code>之后，<code>position</code>会自动加<code>1</code></li></ul></li><li><code>public abstract ByteBuffer put(int index, byte b);</code><ul><li>从绝对位置上添加数据</li></ul></li><li><code>public abstract ByteBuffer putXxx(Xxx value [, int index]);</code><ul><li>从<code>position</code>当前位置插入元素。<code>Xxx</code>表示基本数据类型</li><li>此方法时类型化的 <code>put</code> 和 <code>get</code>，<code>put</code>放入的是什么数据类型，<code>get</code>就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。</li></ul></li></ul><p><strong>demo01</strong> :  <em>当取出的顺序和上面插入的数据类型的顺序不对时，就会抛出BufferUnderflowException异常</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型化方式放入数据</span></span><br><span class="line">buf.putInt(<span class="number">100</span>);</span><br><span class="line">buf.putLong(<span class="number">20</span>);</span><br><span class="line">buf.putChar(<span class="string">'上'</span>);</span><br><span class="line">buf.putShort((<span class="keyword">short</span>)<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出，当取出的顺序和上面插入的数据类型的顺序不对时，就会抛出BufferUnderflowException异常</span></span><br><span class="line">buf.flip();</span><br><span class="line">System.out.println(buf.getInt());</span><br><span class="line">System.out.println(buf.getLong());</span><br><span class="line">System.out.println(buf.getChar());</span><br><span class="line">System.out.println(buf.getShort());</span><br></pre></td></tr></table></figure><p><strong>demo02 : 可以将一个普通的Buffer转成只读的Buffer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Buffer</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">byteBuffer.flip();</span><br><span class="line"><span class="comment">//得到一个只读的Buffer</span></span><br><span class="line">ByteBuffer readOnlyBuffer = byteBuffer.asReadOnlyBuffer();</span><br><span class="line">System.out.println(readOnlyBuffer.getClass());</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line"><span class="keyword">while</span> (readOnlyBuffer.hasRemaining())&#123;</span><br><span class="line">    System.out.println(readOnlyBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">readOnlyBuffer.put((<span class="keyword">byte</span>)<span class="number">100</span>); <span class="comment">//会抛出 ReadOnlyBufferException</span></span><br></pre></td></tr></table></figure><p><strong>demo03: <code>MappedByteBuffer</code>可以让文件直接在内存（堆外内存）中进行修改，而如何同步到文件由NIO来完成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、MappedByteBuffer可以让文件直接在内存中（堆外内存）修改，操作系统不需要拷贝一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    <span class="comment">//获取对应的文件通道</span></span><br><span class="line">    FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数1: FileChannel.MapMode.READ_WRITE，使用的读写模式</span></span><br><span class="line"><span class="comment">    * 参数2: 0，可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">    * 参数3: 5，是映射到内存的大小(不是文件中字母的索引位置），即将 1.txt 的多少个字节映射到内存，也就是可以直接修改的范围就是 [0, 5)</span></span><br><span class="line"><span class="comment">    * 实际的实例化类型：DirectByteBuffer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    mappedByteBuffer.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="string">'N'</span>);</span><br><span class="line">    mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>)<span class="string">'M'</span>);</span><br><span class="line">    mappedByteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>)<span class="string">'Y'</span>); <span class="comment">//会抛出 IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">    randomAccessFile.close();</span><br><span class="line">    System.out.println(<span class="string">"修改成功~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-通道（Channel）"><a href="#3-通道（Channel）" class="headerlink" title="3. 通道（Channel）"></a>3. 通道（Channel）</h2><h3 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h3><p>NIO的通道类似于流，但有些区别</p><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓存读数据，也可以写数据到缓存</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/190004844.png" alt="mark"></p><ul><li>BIO 中的 <code>stream</code> 是单向的，例如：<code>FileInputStream</code>对象只能进行读取数据的操作，而NIO中的通道（Channel）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 NIO 中是一个接口：<code>public interface Channel extends Closeable{}</code></li><li>常用的<code>Channel</code>类有：<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code>（类似<code>ServerSocket</code>）、<code>SocketChannel</code>（类似<code>Socket</code>）</li><li><code>FileChannel</code> 用于<strong>文件</strong>数据的读写，<code>DatagramChannel</code>用于<strong>UDP</strong>数据的读写，<code>ServerSocketChannel</code>和<code>SocketChannel</code>用于<strong>TCP</strong>数据读写</li></ul><p><strong>类关系图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/190142717.png" alt="mark"></p><h3 id="3-2-FileChannel"><a href="#3-2-FileChannel" class="headerlink" title="3.2 FileChannel"></a>3.2 FileChannel</h3><ul><li><pre><code>public int read(ByteBuffer dst)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 从通道读取数据并放到缓冲区中</span><br><span class="line">  - 此操作也会移动 &#96;Buffer&#96; 中的&#96;position&#96;指针，不断往&#96;position&#96;中放数据，&#96;read&#96;完成后&#96;position&#96;指向&#96;limit&#96;。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>public int write(ByteBuffer src)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 把缓冲区的数据写到通道中</span><br><span class="line">  - 此操作也会不断移动&#96;Buffer&#96;中的&#96;position&#96;位置直到&#96;limit&#96;，读取到的数据就是&#96;position&#96;到&#96;limit&#96;这两个指针之间的数据。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>public long transferFrom(ReadableByteChannel src, long position, long count)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 从目标通道中复制数据到当前通道</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>public long transferTo(long position, long count, WritableByteChannel target)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 把数据从当前通道复制给目标通道</span><br><span class="line">  - 该方法拷贝数据使用了**零拷贝**，通常用来在网络&#96;IO&#96;传输中，将&#96;FileChannel&#96;里面的文件数据直接拷贝到与客户端或者服务端连接的&#96;Channel&#96;里面从而达到文件传输。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**应用实例**</span><br><span class="line"></span><br><span class="line">**实例1：将数据写入到本地文件**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">String str &#x3D; &quot;hello,尚硅谷&quot;;</span><br><span class="line">&#x2F;&#x2F;创建一个输出流 -&gt; Channel</span><br><span class="line">FileOutputStream fileOutputStream &#x3D; new FileOutputStream(&quot;d:\\file01.txt&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过 FileOutputStream 获取对应的 FileChannel</span><br><span class="line">&#x2F;&#x2F;这个 FileChannel 真实类型是 FileChannelImpl</span><br><span class="line">FileChannel fileChannel &#x3D; fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个缓冲区 ByteBuffer</span><br><span class="line">ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">&#x2F;&#x2F;将str放入ByteBuffer</span><br><span class="line">byteBuffer.put(str.getBytes());</span><br><span class="line">&#x2F;&#x2F;对ByteBuffer进行反转，开始读取</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">&#x2F;&#x2F;将ByteBuffer数据写入到FileChannel</span><br><span class="line">&#x2F;&#x2F;此操作会不断移动 Buffer中的 position到 limit 的位置</span><br><span class="line">fileChannel.write(byteBuffer);</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><strong>实例2：从本地文件读取数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件的输入流</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\file01.txt"</span>);</span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">//通过fileInputStream 获取对应的FileChannel -&gt; 实际类型 FileChannelImpl</span></span><br><span class="line">FileChannel fileChannel = fileInputStream.getChannel();</span><br><span class="line"><span class="comment">//创建缓冲区</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) file.length());</span><br><span class="line"><span class="comment">//将通道的数据读入到buffer</span></span><br><span class="line">fileChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将ByteBuffer 的字节数据转成String</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure><p>实例1、2的示例图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/190523361.png" alt="mark"></p><p><strong>实例3：使用一个Buffer完成文件的读取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">FileChannel fileChannel1 = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>);</span><br><span class="line">FileChannel fileChannel2 = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//清空buffer，由于循环的最后执行了 write 操作，会将 position 移动到 limit 的位置</span></span><br><span class="line">    <span class="comment">//清空 Buffer的操作才为上一次的循环重置position的位置</span></span><br><span class="line">    <span class="comment">// 如果没有重置position，那么上次读取后，position和limit位置一样，读取后read的值永远为0</span></span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    <span class="comment">//将数据存入 ByteBuffer，它会基于 Buffer 此刻的 position 和 limit 的值，</span></span><br><span class="line">    <span class="comment">// 将数据放入position的位置，然后不断移动position直到其与limit相等；</span></span><br><span class="line">    <span class="keyword">int</span> read = fileChannel1.read(byteBuffer);</span><br><span class="line">    System.out.println(<span class="string">"read="</span> + read);</span><br><span class="line">    <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将buffer中的数据写入到 FileChannel02 ---- 2.txt</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    fileChannel2.write(byteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭相关的流</span></span><br><span class="line">fileInputStream.close();</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/190859988.png" alt="mark"></p><p><strong>实例4：拷贝文件 transferFrom 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建相关流</span></span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\a.gif"</span>);</span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\a2.gif"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取各个流对应的FileChannel</span></span><br><span class="line">FileChannel source = fileInputStream.getChannel();</span><br><span class="line">FileChannel dest = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 transferForm 完成拷贝</span></span><br><span class="line">dest.transferFrom(source, <span class="number">0</span>, source.size());</span><br><span class="line"><span class="comment">//关闭相关的通道和流</span></span><br><span class="line">source.close();</span><br><span class="line">dest.close();</span><br><span class="line">fileInputStream.close();</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><ul><li>实例4相当于封装了实例3</li></ul><h3 id="3-3-ServerSocketChannel-和-SocketChannel-类"><a href="#3-3-ServerSocketChannel-和-SocketChannel-类" class="headerlink" title="3.3 ServerSocketChannel 和 SocketChannel 类"></a>3.3 ServerSocketChannel 和 SocketChannel 类</h3><p><strong>ServerSocketChannel</strong>：主要用于在<strong>服务器监听新的客户端<code>Socket</code>连接</strong></p><ul><li><code>public static ServerSocketChannel open()</code><ul><li>得到一个 <code>ServerSocketChannel</code> 通道</li></ul></li><li><code>public final ServerSocketChannel bind(SocketAddress local)</code><ul><li>设置服务器监听端口</li></ul></li><li><code>public final SelectableChannel configureBlocking(boolean block)</code><ul><li>用于设置阻塞或非阻塞模式，取值 <code>false</code> 表示采用非阻塞模式</li><li>此方法位于 <code>ServerSocketChannel</code> 和 <code>SocketChannel</code>的共同父类<code>AbstractSelectableChannel</code>类中</li></ul></li><li><code>public abstract SocketChannel accept()</code><ul><li>接受一个连接，返回代表这个连接的通道对象</li></ul></li><li><code>public final SelectionKey register(Selector sel, int ops)</code><ul><li>将<code>Channel</code>注册到选择器并设置监听事件，也可以在绑定的同时注册多个事件，如下所示：</li><li><code>channel.register(selector,Selectionkey.OP_READ | Selectionkey.OP_CONNECT)</code></li></ul></li></ul><p><strong>SocketChannel</strong>：网络IO通道，<strong>具体负责进行读写操作</strong>。NIO把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区</p><ul><li><code>public static SocketChannel open()</code><ul><li>得到一个<code>SocketChannel</code>通道</li></ul></li><li><code>public final SelectableChannel configureBlocking(boolean block)</code><ul><li>设置阻塞或非阻塞模式，取值 false表示采用非阻塞模式</li><li>此方法位于 <code>ServerSocketChannel</code> 和 <code>SocketChannel</code>的共同父类<code>AbstractSelectableChannel</code>类中</li></ul></li><li><code>public abstract boolean connect(SocketAddress remote)</code><ul><li>连接服务器</li></ul></li><li><code>public boolean finishConnect()</code><ul><li>如果上面的方法连接失败，接下来就要通过该方法完成连接操作</li></ul></li><li><code>public int write(ByteBuffer src)</code><ul><li>往通道里写数据</li><li>这里写入的是<code>buffer</code>里面<code>position</code>到<code>limit</code>这个之间的数据</li></ul></li><li><code>public int read(ByteBuffer dst)</code><ul><li>从通道里读数据</li></ul></li><li><code>public final SelectionKey register(Selector sel, int ops, Object att)</code><ul><li>注册<code>Channel</code>到选择器并设置监听事件，最后一个参数可以设置共享数据</li></ul></li><li><code>public final void close()</code><ul><li>关闭通道</li></ul></li></ul><p><strong>应用实例</strong></p><ul><li>通过<code>Buffer</code>数组来完成读写操作，即<code>Scattering</code>和<code>Gathering</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Scattering：将数据写入到buffer时，可以采用buffer数组，初次写入 【分散】</span></span><br><span class="line"><span class="comment">* Gathering：从buffer读取数据时，也可以采用buffer数组，依次读</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//使用 ServerSocketChannel 和 SocketChannel</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7000</span>);</span><br><span class="line">    <span class="comment">//绑定端口到socket，并启动</span></span><br><span class="line">    serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line">    <span class="comment">//创建一个Buffer数组</span></span><br><span class="line">    ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">    byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待客户端的连接（Telnet）</span></span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="keyword">int</span> msgLength = <span class="number">8</span>; <span class="comment">//假定从客户端接受8个字节</span></span><br><span class="line">    <span class="comment">//循环的读取</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (byteRead &lt; msgLength) &#123;</span><br><span class="line">            <span class="keyword">long</span> l = socketChannel.read(byteBuffers);</span><br><span class="line">            byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">            System.out.println(<span class="string">"byteRead= "</span> + byteRead);</span><br><span class="line">            <span class="comment">//使用流打印，看看当前这个buffer的position和limit</span></span><br><span class="line">            Arrays.stream(byteBuffers)</span><br><span class="line">                .map(buffer -&gt; <span class="string">"position="</span> + buffer.position() + <span class="string">", limit = "</span> + buffer.limit())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读书数据后需要将所有的buffer进行flip</span></span><br><span class="line">        Arrays.asList(byteBuffers).forEach(Buffer::flip);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">        <span class="keyword">long</span> byteWrite = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (byteWrite &lt; msgLength) &#123;</span><br><span class="line">            <span class="keyword">long</span> l = socketChannel.write(byteBuffers);</span><br><span class="line">            byteWrite += l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将所有的 buffer 进行clear操作</span></span><br><span class="line">        Arrays.asList(byteBuffers).forEach(Buffer::clear);</span><br><span class="line">        System.out.println(<span class="string">"byteRead="</span> + byteRead + <span class="string">", byteWrite="</span> + byteWrite</span><br><span class="line">                           + <span class="string">", msgLength="</span> + msgLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Selector-选择器"><a href="#4-Selector-选择器" class="headerlink" title="4. Selector(选择器)"></a>4. Selector(选择器)</h2><h3 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h3><ul><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到<strong>Selector</strong>(选择器)</li><li><code>Selector</code>能够检测多个注册的通道上是否有事件发生(注意:多个Channel以<strong>事件</strong>的方式可以注册到同一个<code>Selector</code>)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li><li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/202710545.png" alt="mark"></p><p>其中 : <code>Netty</code>的<code>IO</code>线程<code>NioEventLoop</code>聚合了<code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</p><ul><li><p>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</p></li><li><p>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</p></li><li><p>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</p></li><li><p>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p></li></ul><h3 id="4-2-SelectionKey-介绍"><a href="#4-2-SelectionKey-介绍" class="headerlink" title="4.2 SelectionKey 介绍"></a>4.2 SelectionKey 介绍</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/203002487.png" alt="mark"></p><ul><li><code>Selector</code>通过管理<code>SelectionKey</code>的集合从而去监听各个<code>Channel</code>。</li><li>当<code>Channel</code>注册到<code>Selector</code>上面时，会携带该<code>Channel</code>关注的事件<strong>（SelectionKey包含Channel以及与之对应的事件）</strong>，并会返回一个<code>SelectionKey</code>的对象，<code>Selector</code>将该对象加入到它统一管理的集合中去，从而对<code>Channel</code>进行管理。</li><li><code>SelectionKey</code>表示的是<code>Selector</code>和网络通道的注册关系，故<code>FileChannel</code>是没有办法通过<code>SelectionKey</code>注册到<code>Selector</code>上去的。</li></ul><p><strong>四大事件</strong></p><ul><li><code>public static final int OP_READ = 1 &lt;&lt; 0</code><ul><li>值为<code>1</code>，表示读操作，</li><li>代表本<code>Channel</code>已经接受到其他客户端传过来的消息，需要将<code>Channel</code>中的数据读取到<code>Buffer</code>中去</li></ul></li><li><code>public static final int OP_WRITE = 1 &lt;&lt; 2</code><ul><li>值为<code>4</code>，表示写操作</li><li>一般临时将<code>Channel</code>的事件修改为它，在处理完后又修改回去。</li></ul></li><li><code>public static final int OP_CONNECT = 1 &lt;&lt; 3</code><ul><li>值为<code>8</code>，代表建立连接。</li><li>一般在<code>ServerSocketChannel</code>上绑定该事件，结合 <code>channel.finishConnect()</code>在连接建立异常时进行异常处理</li></ul></li><li><code>public static final int OP_ACCEPT = 1 &lt;&lt; 4</code><ul><li>值为<code>16</code>，表示由新的网络连接可以<code>accept</code>。</li><li>与<code>ServerSocketChannel</code>进行绑定，用于创建新的<code>SocketChannel</code>，并把其注册到<code>Selector</code>上去</li></ul></li></ul><p><strong>相关方法</strong></p><ul><li><code>public abstract Selector selector()</code><ul><li>得到该<code>SelectionKey</code>具体是属于哪个<code>Selector</code>对象的</li></ul></li><li><code>public abstract SelectableChannel channel()</code><ul><li>通过<code>SelectionKey</code>的到对应的<code>Channel</code></li></ul></li><li><code>public final Object attachment()</code><ul><li>得到与之关联的共享数据，一般用于获取<code>buffer</code></li><li>在使用<code>register</code>注册通道时，也可以为该<code>Channel</code>绑定一个<code>Buffer</code>，可以通过本方法获取这个<code>Buffer</code>。</li><li>通过<code>selectionKey.attach(Object ob)</code>绑定的数据，也是通过该方法获取</li></ul></li><li><code>public abstract SelectionKey interestOps()</code><ul><li>获取该<code>SelectionKey</code>下面的事件</li></ul></li><li><code>public abstract SelectionKey interestOps(int ops)</code><ul><li>用于设置或改变某个<code>Channel</code>关联的事件</li><li>增加事件：<code>key.interestOps(key.interestOps | SelectionKey.OP_WRITE)</code></li><li>减少事件：<code>key.interestOps(key.interestOps &amp; ~SelectionKey.OP_WRITE)</code></li></ul></li><li><code>public final boolean isAcceptable(),isReadable(),isWritable(),isConnectable()</code><ul><li>用于判断这个<code>SelectionKey</code>产生的是什么事件，与上面的事件类型一一对应</li></ul></li></ul><h3 id="4-3-Selector-常见方法"><a href="#4-3-Selector-常见方法" class="headerlink" title="4.3 Selector 常见方法"></a>4.3 Selector 常见方法</h3><ul><li><code>public static Selector open();</code><ul><li>得到一个选择器对象，实例化出 <code>WindowsSelectorImpl</code>对象。</li></ul></li><li><code>public int select(long timeout)</code><ul><li>监控所有注册的通道，当其中有<code>IO</code>操作可以进行时，将对应的<code>SelectionKey</code>加入到内部集合中并返回，返回的结果为<code>Channel</code>响应的事件总和，当结果为<code>0</code>时，表示本<code>Selector</code>监听的所有<code>Channel</code>中没有<code>Channel</code>产生事件。</li><li>如果不传入<code>timeout</code>值，就会阻塞线程，传入值则为阻塞多少毫秒，通过它设置超时时间。</li><li>之所以需要传入时间，是为了让它等待几秒钟再看有没有<code>Channel</code>会产生事件，从而获取一段时间内产生事件的<code>Channel</code>的总集合再一起处理。</li></ul></li><li><code>selector.selectNow();</code><ul><li>不会阻塞，立马返回冒泡的事件数</li></ul></li><li><code>public Set&lt;SelectionKey&gt; selectedKeys()</code><ul><li>从内部集合中得到所有的<code>SelectionKey</code></li></ul></li></ul><h3 id="4-4-Demo-实例"><a href="#4-4-Demo-实例" class="headerlink" title="4.4 Demo 实例"></a>4.4 Demo 实例</h3><p><strong>编码步骤</strong></p><ol><li>当客户端连接时，会通过<code>ServerSocketChannel</code> 得到 <code>SocketChannel</code></li><li><code>Selector</code> 进行监听 <code>select</code>方法, 返回有事件发生的通道的个数.</li><li>将<code>socketChannel</code>注册到<code>Selector</code>上, register(Selector sel, <strong>int</strong> ops), 一个<code>selector</code>上可以注册多个<code>SocketChannel</code></li><li>注册后返回一个 <code>SelectionKey</code>, 会和该<code>Selector</code> 关联(集合)</li><li>进一步得到各个 <code>SelectionKey</code> (有事件发生)</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code> , 方法 <code>channel()</code></li><li>判断该<code>Channel</code>的事件类型，对不同事件进行不同的业务处理</li></ol><p><strong>NIO入门案例：实现服务器和客户端的简单通讯</strong></p><ul><li><strong>服务器端</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建ServerSocketChannel -&gt; ServerSocket</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">//得到一个Selector对象</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">//绑定一个端口6666</span></span><br><span class="line">    serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">    <span class="comment">//设置非阻塞</span></span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把 serverSocketChannel 注册到 selector ，关心事件为：OP_ACCEPT，有新的客户端连接</span></span><br><span class="line">    SelectionKey register = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//等待1秒，如果没有事件发生，就返回</span></span><br><span class="line">        <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"服务器等待了1秒，无连接"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果返回的 &gt; 0,表示已经获取到关注的事件</span></span><br><span class="line">        <span class="comment">// 就获取到相关的 selectionKey 集合，反向获取通道</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 Set&lt;SelectionKey&gt;，使用迭代器遍历</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//获取到SelectionKey</span></span><br><span class="line">            SelectionKey key = keyIterator.next();</span><br><span class="line">            <span class="comment">//根据 key 对应的通道发生的事件，做相应的处理</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">//如果是 OP_ACCEPT，有新的客户端连接</span></span><br><span class="line">                <span class="comment">//该客户端生成一个 SocketChannel</span></span><br><span class="line">                SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                System.out.println(<span class="string">"客户端连接成功，生成了一个SocketChannel："</span> + socketChannel.hashCode());</span><br><span class="line">                <span class="comment">//将SocketChannel设置为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//将socketChannel注册到selector，关注事件为 OP_READ，同时给SocketChannel关联一个Buffer</span></span><br><span class="line">                socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="comment">//通过key，反向获取到对应的Channel</span></span><br><span class="line">                SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                <span class="comment">//获取到该channel关联的Buffer</span></span><br><span class="line">                ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                channel.read(buffer);</span><br><span class="line">                System.out.println(<span class="string">"from 客户端："</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//手动从集合中移除当前的 selectionKey，防止重复操作</span></span><br><span class="line">            keyIterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>客户端</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//得到一个网络通道</span></span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">    <span class="comment">//设置非阻塞</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//提供服务器端的IP和端口</span></span><br><span class="line">    InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (!socketChannel.connect(socketAddress))&#123; <span class="comment">//如果不成功</span></span><br><span class="line">        <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">            System.out.println(<span class="string">"因为连接需要时间，客户端不会阻塞，可以做其他工作。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果连接成功，就发送数据</span></span><br><span class="line">    String str = <span class="string">"hello, 尚硅谷"</span>;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">    <span class="comment">//发送数据,实际上就是将buffer数据写入到channel</span></span><br><span class="line">    socketChannel.write(byteBuffer);</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-NIO-实战-群聊系统demo"><a href="#5-NIO-实战-群聊系统demo" class="headerlink" title="5. NIO 实战(群聊系统demo)"></a>5. NIO 实战(群聊系统demo)</h2><ul><li>需要实现客户端和服务器端之间的数据通讯，服务端能够将数据转发给其他所有客户端。</li></ul><h3 id="5-1-服务端"><a href="#5-1-服务端" class="headerlink" title="5.1 服务端"></a>5.1 服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> GroupChat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6677</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 打开连接通道</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">// 设置非阻塞</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到选择器上</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123; <span class="comment">// 返回就绪的socket的数量</span></span><br><span class="line">                    <span class="comment">// 遍历得到SelectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取key</span></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 反向获取accept的事件的channel</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                        SocketChannel socketChannel = listenChannel.accept();</span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将socketChannel 注册到选择器上</span></span><br><span class="line">                        socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 提示客户端上线了</span></span><br><span class="line">                        System.out.println(socketChannel.getRemoteAddress().toString().substring(<span class="number">1</span>) + <span class="string">"上线了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable())&#123; <span class="comment">// 通道数据为可读的状态</span></span><br><span class="line">                        <span class="comment">// 读取数据</span></span><br><span class="line">                        readData(key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 删除当前的key,防止重复处理</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e2)&#123;</span><br><span class="line">            e2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端发送的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个socketChannel</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建buffer</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> read = channel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 缓存区的数据转存到字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                <span class="comment">// 输出消息</span></span><br><span class="line">                System.out.println(<span class="string">"来自客户端的消息"</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将服务器消息转发给其他用户</span></span><br><span class="line">                sendToOthers(msg,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123; <span class="comment">// 表示客户端此时下线了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">"离线了...."</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2)&#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息转发给其他用户</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendToOthers</span><span class="params">(String msg,SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器消息转发中..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历已经注册到selector 的 socketchannel，排除掉自己</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">// 通过key取出对应的SocketChannel</span></span><br><span class="line">            Channel channel = key.channel();</span><br><span class="line">            <span class="comment">// 排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(channel <span class="keyword">instanceof</span> SocketChannel &amp; channel != self)&#123;</span><br><span class="line">                <span class="comment">// 转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel) channel;</span><br><span class="line">                <span class="comment">// 将msg放入buffer中</span></span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">// 将buffer数据写入到通道</span></span><br><span class="line">                dest.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-客户端"><a href="#5-2-客户端" class="headerlink" title="5.2 客户端"></a>5.2 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> GroupChat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">6677</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector = <span class="keyword">this</span>.selector.open();</span><br><span class="line">        <span class="comment">//链接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册到selector上</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户名</span></span><br><span class="line">        userName = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(userName + <span class="string">"  is ok...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        info = userName + <span class="string">"说:"</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取从服务器回显的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (select &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明有可用的通道</span></span><br><span class="line">                <span class="comment">// 获取key集合</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="comment">// 迭代</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">// 得到相关通道</span></span><br><span class="line">                        SocketChannel  channel = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 得到一个buffer</span></span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">// 读取数据</span></span><br><span class="line">                        channel.read(byteBuffer);</span><br><span class="line">                        <span class="comment">// 将数据转换成字符串</span></span><br><span class="line">                        String s = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                        System.out.println(s.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 读完了删除这个key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 这里可以干点别的东西</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GroupChatClient groupChatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启一个线程读取数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">while</span> (<span class="keyword">true</span>)&#123;groupChatClient.readInfo();&#125;&#125;).start();</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextLine())&#123;</span><br><span class="line">            String s= sc.nextLine();</span><br><span class="line">            groupChatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><p>使用<code>int read = channel.read(buffer)</code></p><p><strong>读取数据时</strong>，读取的结果情况：</p><ul><li>当<code>read=-1</code>时，说明客户端的数据发送完毕，并且主动的关闭<code>socket</code>。所以这种情况下，服务器程序需要关闭<code>socketSocket</code>，并且取消<code>key</code>的注册。注意：这个时候继续使用<code>SocketChannel</code>进行读操作的话，就会抛出：==<strong>远程主机强迫关闭一个现有的连接</strong>==的IO异常</li><li>当<code>read = 0</code>时：<ul><li>某一时刻<code>SocketChannel</code>中当前没有数据可读。</li><li>客户端的数据发送完毕。</li><li><a href="https://blog.csdn.net/cao478208248/article/details/41648359" target="_blank" rel="noopener">详情见此博文</a></li><li>但是对于博文中的这一条，经过本人测试，这种情况下返回的是读取的数据的大小，而不是<code>0</code>：<strong><code>ByteBuffer</code>的<code>position</code>等于<code>limit</code>，这个时候也会返回<code>0</code></strong></li></ul></li></ul></li></ul><p><strong>参考博客</strong> : <a href="https://www.cnblogs.com/hyy9527/p/13059248.html" target="_blank" rel="noopener">https://www.cnblogs.com/hyy9527/p/13059248.html</a></p><p>​                    <a href="https://blog.csdn.net/qq_35751014/article/details/104411347" target="_blank" rel="noopener">https://blog.csdn.net/qq_35751014/article/details/104411347</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-02-NIO实战及原理&quot;&gt;&lt;a href=&quot;#Netty-02-NIO实战及原理&quot; class=&quot;headerlink&quot; title=&quot;Netty-02-NIO实战及原理&quot;&gt;&lt;/a&gt;Netty-02-NIO实战及原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java NIO 全称 &lt;code&gt;java non-blocking IO&lt;/code&gt;，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)，是&lt;strong&gt;同步非阻塞&lt;/strong&gt;的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NIO 相关类都被放在 &lt;code&gt;java.nio&lt;/code&gt; 包及子包下，并且对原 &lt;code&gt;java.io&lt;/code&gt; 包中的很多类进行改写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NIO 有三大核心部分：&lt;strong&gt;Channel(通道)&lt;/strong&gt;，&lt;strong&gt;Buffer(缓冲区)&lt;/strong&gt;, &lt;strong&gt;Selector(选择器)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NIO是 面向&lt;strong&gt;缓&lt;/strong&gt;冲区 ，或者面向 &lt;strong&gt;块&lt;/strong&gt; 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供&lt;strong&gt;非阻塞&lt;/strong&gt;式的高伸缩性网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Java NIO&lt;/code&gt;的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而&lt;strong&gt;不是保持线程阻塞&lt;/strong&gt;，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通俗理解：&lt;code&gt;NIO&lt;/code&gt;是可以做到用一个线程来处理多个操作的。假设有&lt;code&gt;10000&lt;/code&gt;个请求过来,根据实际情况，可以分配&lt;code&gt;50&lt;/code&gt;或者&lt;code&gt;100&lt;/code&gt;个线程来处理。不像之前的阻塞&lt;code&gt;IO&lt;/code&gt;那样，非得分配&lt;code&gt;10000&lt;/code&gt;个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;HTTP2.0&lt;/code&gt;使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比&lt;code&gt;HTTP1.1&lt;/code&gt;大了好几个数量级。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty-01-BIO实战</title>
    <link href="http://zhuuu.work/2020/10/01/Netty/Netty-01-BIO%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/01/Netty/Netty-01-BIO%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86/</id>
    <published>2020-10-01T03:02:24.000Z</published>
    <updated>2020-10-02T03:08:32.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-01-BIO实战及原理"><a href="#Netty-01-BIO实战及原理" class="headerlink" title="Netty-01-BIO实战及原理"></a>Netty-01-BIO实战及原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>参考书籍：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/105929076.png" alt="mark"></p><ul><li>Netty权威指南 以5.x版本编写，建议还是以Netty in action为主</li></ul><a id="more"></a><h2 id="1-Netty-介绍和应用场景"><a href="#1-Netty-介绍和应用场景" class="headerlink" title="1. Netty 介绍和应用场景"></a>1. Netty 介绍和应用场景</h2><ol><li><code>Netty</code>是由<code>JBOSS</code>提供的一个<code>Java</code>开源框架，现为<code>Github</code>上的独立项目</li><li><code>Netty</code>是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络<code>IO</code>程序</li><li><code>Netty</code>主要针对在<code>TCP</code>协议下，面向<code>Clients</code>端的高并发应用，或者<code>Peer-to-Peer</code>场景下的大量数据持续传输的应用。</li><li><code>Netty</code>本质是一个<code>NIO</code>框架，适用于服务器通讯相关的多种应用场景</li><li>要透彻理解<code>Netty</code> ， 需要先学习 <code>NIO</code> ， 这样我们才能阅读 <code>Netty</code> 的源码。</li></ol><p><strong>应用场景：</strong></p><ul><li>互联网行业<ul><li>分布式系统中，各个节点之间需要远程服务调用，高性能的<code>RPC</code>框架必不可少，<code>Netty</code>作为异步高性能的通信框架，往往作为基础通信组件被这些<code>RPC</code>框架使用</li><li>典型的应用有：阿里分布式服务框架<code>Dubbo</code>的<code>RPC</code>框架使用<code>Dubbo</code>协议进行节点间通信，<code>Dubbo</code>协议进行节点间通信，<code>Dubbo</code>协议默认使用<code>Netty</code>作为基础通信组件，用于实现各进程节点之间的内部通信</li></ul></li><li>游戏行业<ul><li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用</li><li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器</li><li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信</li></ul></li><li>大数据领域<ul><li>经典的 <code>Hadoop</code>的高性能通信和序列化组件<code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信</li><li>它的 <code>Netty Service</code> 基于 <code>Netty</code> 框架二次封装实现。</li></ul></li></ul><h2 id="2-Java-IO模型"><a href="#2-Java-IO模型" class="headerlink" title="2. Java IO模型"></a>2. Java IO模型</h2><ul><li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</li><li><code>Java</code>共支持3种网络编程模型IO模式：<code>BIO、NIO、AIO</code><ul><li><code>Java BIO</code> ： 同步并阻塞(<strong>传统阻塞型</strong>)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</li><li><code>Java NIO</code>： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理 </li><li><code>Java AIO(NIO.2)</code> ： <strong>异步非阻塞</strong>，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li></ul></li></ul><h2 id="3-BIO-简单实战"><a href="#3-BIO-简单实战" class="headerlink" title="3. BIO 简单实战"></a>3. BIO 简单实战</h2><h3 id="3-1-流程概述"><a href="#3-1-流程概述" class="headerlink" title="3.1 流程概述"></a>3.1 流程概述</h3><ul><li>服务端启动一个<code>ServerSocket</code></li><li>客户端启动<code>Socket</code>对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</li><li>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li><li>如果有响应，客户端线程会等待请求结束后，在继续执行</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/110804813.png" alt="mark"></p><h3 id="3-2-应用实例"><a href="#3-2-应用实例" class="headerlink" title="3.2 应用实例"></a>3.2 应用实例</h3><ul><li>使用<code>BIO</code>模型编写一个服务器端，监听<code>6666</code>端口，当有客户端连接时，就启动一个线程与之通讯。</li><li>要求使用线程池机制改善，可以连接多个客户端.</li><li>服务器端可以接收客户端发送的数据(通过<code>cmd</code>的<code>telnet</code> 方式即可)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建一个线程池</span></span><br><span class="line">        <span class="comment">//2、如果有客户端连接，就创建一个线程，与之通讯（单独写一个方法）</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息：id= "</span>+ Thread.currentThread().getId() + <span class="string">"; 线程名字："</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接"</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//重写Runnable方法，与客户端进行通讯</span></span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个Handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息：id= "</span>+ Thread.currentThread().getId() + <span class="string">"; 线程名字："</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程信息：id= "</span>+ Thread.currentThread().getId() + <span class="string">"; 线程名字："</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"read...."</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-BIO-问题分析"><a href="#3-3-BIO-问题分析" class="headerlink" title="3.3 BIO 问题分析"></a>3.3 BIO 问题分析</h3><ul><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code> 。</li><li>当并发数较大时，需要<strong>创建大量线程来处理连接</strong>，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-01-BIO实战及原理&quot;&gt;&lt;a href=&quot;#Netty-01-BIO实战及原理&quot; class=&quot;headerlink&quot; title=&quot;Netty-01-BIO实战及原理&quot;&gt;&lt;/a&gt;Netty-01-BIO实战及原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;参考书籍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/105929076.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty权威指南 以5.x版本编写，建议还是以Netty in action为主&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-17-主从复制原理</title>
    <link href="http://zhuuu.work/2020/09/24/Mysql/Mysql-17-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/09/24/Mysql/Mysql-17-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-09-24T08:02:27.000Z</published>
    <updated>2020-09-25T11:04:47.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-17-主从复制原理"><a href="#Mysql-17-主从复制原理" class="headerlink" title="Mysql-17-主从复制原理"></a>Mysql-17-主从复制原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>主从复制</strong>是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。</li></ul><h2 id="1-主从复制的原理"><a href="#1-主从复制的原理" class="headerlink" title="1. 主从复制的原理"></a>1. 主从复制的原理</h2><ul><li><p><code>MySql</code>主库在事务提交时会把数据变更作为事件记录在二进制日志<code>Binlog</code>中；</p></li><li><p>主库推送二进制日志文件<code>Binlog</code>中的事件到从库的中继日志<code>Relay Log</code>中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；</p></li><li><p><code>MySql</code>通过三个线程来完成主从库间的数据复制，其中<code>Binlog Dump</code>线程跑在主库上，I/O线程和<code>SQL</code>线程跑着从库上；</p></li><li><p>当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建<code>Binlog Dump</code>线程读取数据库事件并发送给<code>I/O</code>线程，<code>I/O</code>线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的<code>SQL</code>线程读取中继日志<code>Relay Log</code>中更新的数据库事件并应用，如下图所示。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/190401809.png" alt="mark"></p><a id="more"></a><p><strong>参考博客</strong> ： <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453141544&amp;idx=2&amp;sn=da0ea11633faed02e1a1c1e03944b529&amp;chksm=8cf2daabbb8553bd4c62e19855707cacca6b6d0c5fcf500305bd8ca729c78dbe8f8372bb7d4e&amp;mpshare=1&amp;scene=1&amp;srcid=0924EQob7Vlt43qQ2WiqWEOt&amp;sharer_sharetime=1600909299821&amp;sharer_shareid=28c303bffd97904e2336a200423a1133&amp;key=50c6d0ff50751a997508b262a322b559b1b0d4d10c76c70ca94b15f61e691441497eabafb2218f1e05ae9802c61778d5bf6130e7db891e0b29bd2b3d4eb04ed4738b52fb046116adde4c9dfb8f79df9d6d892478ece561576c9d0b88d1a80be411b19d0993bcb1b092885e57ef27b58b20043eb931b4f22fb2fd31695693632e&amp;ascene=1&amp;uin=MTU5MDExNDg2MQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=AWvlglZ%2BXI9nU%2BxmH77cjLU%3D&amp;pass_ticket=empX%2Byd3FBncFv9Y3htB8V3ce9CK6LHHJOlGyuSLskLcjwytQcRRiL0ELWZl3dk0&amp;wx_header=0" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453141544&amp;idx=2&amp;sn=da0ea11633faed02e1a1c1e03944b529&amp;chksm=8cf2daabbb8553bd4c62e19855707cacca6b6d0c5fcf500305bd8ca729c78dbe8f8372bb7d4e&amp;mpshare=1&amp;scene=1&amp;srcid=0924EQob7Vlt43qQ2WiqWEOt&amp;sharer_sharetime=1600909299821&amp;sharer_shareid=28c303bffd97904e2336a200423a1133&amp;key=50c6d0ff50751a997508b262a322b559b1b0d4d10c76c70ca94b15f61e691441497eabafb2218f1e05ae9802c61778d5bf6130e7db891e0b29bd2b3d4eb04ed4738b52fb046116adde4c9dfb8f79df9d6d892478ece561576c9d0b88d1a80be411b19d0993bcb1b092885e57ef27b58b20043eb931b4f22fb2fd31695693632e&amp;ascene=1&amp;uin=MTU5MDExNDg2MQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=AWvlglZ%2BXI9nU%2BxmH77cjLU%3D&amp;pass_ticket=empX%2Byd3FBncFv9Y3htB8V3ce9CK6LHHJOlGyuSLskLcjwytQcRRiL0ELWZl3dk0&amp;wx_header=0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-17-主从复制原理&quot;&gt;&lt;a href=&quot;#Mysql-17-主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;Mysql-17-主从复制原理&quot;&gt;&lt;/a&gt;Mysql-17-主从复制原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主从复制&lt;/strong&gt;是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-主从复制的原理&quot;&gt;&lt;a href=&quot;#1-主从复制的原理&quot; class=&quot;headerlink&quot; title=&quot;1. 主从复制的原理&quot;&gt;&lt;/a&gt;1. 主从复制的原理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MySql&lt;/code&gt;主库在事务提交时会把数据变更作为事件记录在二进制日志&lt;code&gt;Binlog&lt;/code&gt;中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主库推送二进制日志文件&lt;code&gt;Binlog&lt;/code&gt;中的事件到从库的中继日志&lt;code&gt;Relay Log&lt;/code&gt;中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MySql&lt;/code&gt;通过三个线程来完成主从库间的数据复制，其中&lt;code&gt;Binlog Dump&lt;/code&gt;线程跑在主库上，I/O线程和&lt;code&gt;SQL&lt;/code&gt;线程跑着从库上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建&lt;code&gt;Binlog Dump&lt;/code&gt;线程读取数据库事件并发送给&lt;code&gt;I/O&lt;/code&gt;线程，&lt;code&gt;I/O&lt;/code&gt;线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的&lt;code&gt;SQL&lt;/code&gt;线程读取中继日志&lt;code&gt;Relay Log&lt;/code&gt;中更新的数据库事件并应用，如下图所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/190401809.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux-09-进程调度算法</title>
    <link href="http://zhuuu.work/2020/09/22/Linux/Linux-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/09/22/Linux/Linux-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-22T03:22:53.000Z</published>
    <updated>2020-10-04T12:46:54.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-09-进程调度算法"><a href="#Linux-09-进程调度算法" class="headerlink" title="Linux-09-进程调度算法"></a>Linux-09-进程调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><ul><li>进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。</li><li>当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</li></ul><p>什么时候会发生 CPU 调度呢？通常有以下情况：</p><ol><li>当进程从运行状态转到等待状态；</li><li>当进程从运行状态转到就绪状态；</li><li>当进程从等待状态转到就绪状态；</li><li>当进程从运行状态转到终止状态；</li></ol><p>其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。</p><ul><li><strong>非抢占式</strong>的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。</li><li>而<strong>抢占式调度</strong>，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</li></ul><a id="more"></a><ul><li>你可能会好奇为什么第 3 种情况也会发生 CPU 调度呢？<ul><li>假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态</li><li>一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度。</li></ul></li></ul><ul><li>那第 2 种状态通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU。</li></ul><p>调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程正在使用 CPU 的时间和 I/O 时间。</p><p>接下来，说说常见的调度算法：</p><ul><li>先来先服务调度算法</li><li>最短作业优先调度算法</li><li>高响应比优先调度算法</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法</li></ul><h2 id="1-进程调度算法"><a href="#1-进程调度算法" class="headerlink" title="1. 进程调度算法"></a>1. 进程调度算法</h2><h3 id="1-1-先来先服务调度算法"><a href="#1-1-先来先服务调度算法" class="headerlink" title="1.1 先来先服务调度算法"></a>1.1 先来先服务调度算法</h3><ul><li>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（First Come First Severd, FCFS）算法</strong>了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114729145.jpg" alt="mark"></p><ul><li>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></li></ul><p><strong>缺点：</strong></p><ul><li>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。（<strong>不会导致饥饿的产生</strong>）</li><li>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。</li></ul><h3 id="1-2-最短作业优先调度算法"><a href="#1-2-最短作业优先调度算法" class="headerlink" title="1.2 最短作业优先调度算法"></a>1.2 最短作业优先调度算法</h3><ul><li><strong>最短作业优先（Shortest Job First, SJF）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114846841.jpg" alt="mark"></p><p><strong>缺点：</strong></p><ul><li>这显然对长作业不利，很容易造成一 种极端现象。（<strong>进程饥饿</strong>）</li><li>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</li></ul><h3 id="1-3-高响应比优先调度算法"><a href="#1-3-高响应比优先调度算法" class="headerlink" title="1.3 高响应比优先调度算法"></a>1.3 高响应比优先调度算法</h3><ul><li>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</li><li>那么，<strong>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法</strong>主要是权衡了短作业和长作业。</li><li><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135439932.png" alt="mark"></p><p>从上面的公式，可以发现：</p><ul><li><p><strong>如果两个进程的「等待时间」相同时</strong>，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</p></li><li><p><strong>如果两个进程「要求的服务时间」相同时</strong>，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</p></li><li><p><strong>不会导致饥饿</strong></p></li></ul><h3 id="1-4-时间片轮转调度算法"><a href="#1-4-时间片轮转调度算法" class="headerlink" title="1.4 时间片轮转调度算法"></a>1.4 时间片轮转调度算法</h3><ul><li>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135825753.png" alt="mark"></p><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长；</li></ul><p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><h3 id="1-5-最高优先级调度算法"><a href="#1-5-最高优先级调度算法" class="headerlink" title="1.5 最高优先级调度算法"></a>1.5 最高优先级调度算法</h3><ul><li>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</li><li>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</li></ul><p>进程的优先级可以分为，静态优先级或动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><h3 id="1-6-多级反馈队列调度算法"><a href="#1-6-多级反馈队列调度算法" class="headerlink" title="1.6 多级反馈队列调度算法"></a>1.6 多级反馈队列调度算法</h3><ul><li><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</li></ul><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/140252098.png" alt="mark"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul><p>可以发现，对于<strong>短作业</strong>可能可以在第一级队列很快被处理完。</p><p>对于<strong>长作业</strong>，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-09-进程调度算法&quot;&gt;&lt;a href=&quot;#Linux-09-进程调度算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-09-进程调度算法&quot;&gt;&lt;/a&gt;Linux-09-进程调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。&lt;/li&gt;
&lt;li&gt;当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候会发生 CPU 调度呢？通常有以下情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当进程从运行状态转到等待状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从等待状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到终止状态；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非抢占式&lt;/strong&gt;的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;抢占式调度&lt;/strong&gt;，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper-02-ZAB协议</title>
    <link href="http://zhuuu.work/2020/09/17/Zookeeper/ZooKeeper-02-ZAB%E5%8D%8F%E8%AE%AE/"/>
    <id>http://zhuuu.work/2020/09/17/Zookeeper/ZooKeeper-02-ZAB%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-09-17T09:38:38.000Z</published>
    <updated>2020-09-25T07:58:30.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZooKeeper-02-ZAB协议"><a href="#ZooKeeper-02-ZAB协议" class="headerlink" title="ZooKeeper-02-ZAB协议"></a>ZooKeeper-02-ZAB协议</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>Zab（Zookeeper Atomic Broadcast）</code>是为ZooKeeper协设计的崩溃恢复原子广播协议，它保证zookeeper集群数据的一致性和命令的全局有序性。</li></ul><a id="more"></a><h2 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h2><h3 id="1-1-集群角色"><a href="#1-1-集群角色" class="headerlink" title="1.1 集群角色"></a>1.1 集群角色</h3><ul><li><p><code>Leader</code>：同一时间集群总只允许有一个Leader，提供对客户端的读写功能，负责将数据同步至各个节点；</p></li><li><p><code>Follower</code>：提供对客户端读功能，写请求则转发给Leader处理，当Leader崩溃失联之后参与Leader选举；</p></li><li><p><code>Observer</code>：与Follower不同的是但不参与Leader选举。</p></li></ul><h3 id="1-2-服务状态"><a href="#1-2-服务状态" class="headerlink" title="1.2 服务状态"></a>1.2 服务状态</h3><ul><li><code>LOOKING</code>：当节点认为群集中没有Leader，服务器会进入LOOKING状态，目的是为了查找或者选举Leader；</li><li><code>FOLLOWING</code>：follower角色；</li><li><code>LEADING</code>：leader角色；</li><li><code>OBSERVING</code>：observer角色；</li></ul><p>可以知道Zookeeper是通过自身的状态来区分自己所属的角色，来执行自己应该的任务。</p><h3 id="1-3-ZAB四种状态"><a href="#1-3-ZAB四种状态" class="headerlink" title="1.3 ZAB四种状态"></a>1.3 ZAB四种状态</h3><ul><li><strong>ZAB状态</strong>Zookeeper还给ZAB定义的4种状态，反应Zookeeper从选举到对外提供服务的过程中的四个步骤。状态枚举定义：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/153730944.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. ELECTION: 集群进入选举状态，此过程会选出一个节点作为leader角色；</span><br><span class="line">2. DISCOVERY：连接上leader，响应leader心跳，并且检测leader的角色是否更改，通过此步骤之后选举出的leader才能执行真正职务；</span><br><span class="line">3. SYNCHRONIZATION：整个集群都确认leader之后，将会把leader的数据同步到各个节点，保证整个集群的数据一致性；</span><br><span class="line">4. BROADCAST：过渡到广播状态，集群开始对外提供服务。</span><br></pre></td></tr></table></figure><h3 id="1-4-ZXID"><a href="#1-4-ZXID" class="headerlink" title="1.4 ZXID"></a>1.4 ZXID</h3><ul><li><code>Zxid</code>是极为重要的概念，它是一个long型（64位）整数，分为两部分：纪元（epoch）部分和计数器（<code>counter</code>）部分，是一个<strong>全局有序</strong>的数字。<ul><li>epoch代表当前集群所属的哪个leader，leader的选举就类似一个朝代的更替，你前朝的剑不能斩本朝的官，用epoch代表当前命令的有效性，</li><li>counter是一个<strong>递增的数字</strong>。</li></ul></li></ul><h2 id="2-选举"><a href="#2-选举" class="headerlink" title="2. 选举"></a>2. 选举</h2><ul><li>基础概念介绍完了，下面开始介绍zab协议是怎么支持leader选举的。</li><li>进行leader有三个问题<ul><li>什么时候进行？</li><li>选举规则？</li><li>选择流程？</li></ul></li></ul><ol><li><p><strong>选举发生的时机</strong>Leader发生选举有两个时机，一个是服务启动的时候当整个集群都没有leader节点会进入选举状态，如果leader已经存在就会告诉该节点leader的信息，自己连接上leader，整个集群不用进入选举状态。</p><p>还有一个就是在服务运行中，可能会出现各种情况，服务宕机、断电、网络延迟很高的时候leader都不能再对外提供服务了，所有当其他几点通过<strong>心跳检测</strong>到leader失联之后，集群也会进入选举状态。（<strong>可能会出现脑裂问题）</strong></p></li></ol><ol start="2"><li><strong>选举规则</strong>进入投票选举流程，怎么才能选举出leader？或者说按照什么规则来让其他节点都能选举你当leader。<ul><li>zab协议是按照几个比较规则来进行投票的筛选，如果你的票比我更好，就修改自身的投票信息，改投你当leader。</li><li>下面代码是zookeeper投票比较规则：</li><li>当其他节点的纪元比自身高投它，如果纪元相同比较自身的zxid的大小，选举zxid大的节点，这里的zxid代表节点所提交事务最大的id，zxid越大代表该节点的数据越完整。</li><li>最后如果epoch和zxid都相等，则比较服务的serverId，这个Id是配置zookeeper集群所配置的，所以我们配置zookeeper集群的时候可以把服务性能更高的集群的serverId配置大些，让性能好的机器担任leader角色。</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/154615159.png" alt="mark"></p><ol start="3"><li><strong>选举流程</strong></li></ol><ul><li>时机和规则都有了，下面就是leader的选举流程：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/154749324.jpg" alt="mark"></p><ul><li>所有节点第一票先选举自己当leader，将投票信息广播出去；</li><li>从队列中接受投票信息；</li><li>按照规则判断是否需要更改投票信息，将更改后的投票信息再次广播出去；</li><li>判断是否有超过一半的投票选举同一个节点，如果是选举结束根据投票结果设置自己的服务状态，选举结束，否则继续进入投票流程。</li></ul><p><strong>举个例子</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/154846036.jpg" alt="mark"></p><h2 id="3-广播"><a href="#3-广播" class="headerlink" title="3. 广播"></a>3. 广播</h2><ul><li>集群在经过leader选举之后还会有连接leader和同步两个步骤，这里就不具体分析这两个步骤的流程了，主要介绍集群<strong>对外提供服务如何保证各个节点数据的一致性</strong>。</li></ul><p>zab在广播状态中保证以下特征</p><ul><li><strong>可靠传递:</strong> 如果消息m由一台服务器传递，那么它最终将由所有服务器传递。</li><li><strong>全局有序:</strong> 如果一个消息a在消息b之前被一台服务器交付，那么所有服务器都交付了a和b，并且a先于b。</li><li><strong>因果有序:</strong> 如果消息a在因果上先于消息b并且二者都被交付，那么a必须排在b之前。</li></ul><p><strong>有序性</strong>是zab协议必须要保证的一个很重要的属性，因为zookeeper是以类似目录结构的数据结构存储数据的，必须要求命名的有序性。（比如一个命名a创建路径为/test，然后命名b创建路径为/test/123，如果不能保证有序性b命名在a之前，b命令会因为父节点不存在而创建失败。）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/155158176.jpg" alt="mark"></p><p>如上图所示，整个写请求类似一个二阶段的提交。</p><p>当收到客户端的写请求的时候会经历以下几个步骤：</p><ol><li>Leader收到客户端的写请求，生成一个事务（Proposal），其中包含了zxid；</li><li>Leader开始广播该事务，需要注意的是所有节点的通讯都是由一个FIFO的队列维护的；</li><li>Follower接受到事务之后，将事务写入本地磁盘，写入成功之后返回Leader一个ACK；</li><li>Leader收到过半的ACK之后，开始提交本事务，并广播事务提交信息</li><li>从节点开始提交本事务。</li></ol><p><strong>有以上流程可知，zookeeper通过二阶段提交来保证集群中数据的一致性，因为只需要收到过半的ACK就可以提交事务，所以zookeeper的数据并不是强一致性。</strong></p><p>zab协议的有序性保证是通过几个方面来体现的，</p><ul><li>第一，服务之前用TCP协议进行通讯，保证在网络传输中的有序性；</li><li>第二，节点之前都维护了一个FIFO的队列，保证全局有序性；</li><li>第三，通过全局递增的zxid保证因果有序性。</li></ul><h2 id="4-状态流转"><a href="#4-状态流转" class="headerlink" title="4. 状态流转"></a>4. 状态流转</h2><ul><li>前面介绍了zookeeper服务状态有四种，ZAB状态也有四种。这里就简单介绍一个他们之间的状态流转，更能加深对zab协议在zookeeper工作流程中的作用。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/155422758.jpg" alt="mark"></p><ol><li>服务在启动或者和leader失联之后服务状态转为LOOKING；</li><li>如果leader不存在选举leader，如果存在直接连接leader，此时zab协议状态为ELECTION；</li><li>如果有超过半数的投票选择同一台server，则leader选举结束，被选举为leader的server服务状态为LEADING，其他server服务状态为FOLLOWING/OBSERVING；</li><li>所有server连接上leader，此时zab协议状态为DISCOVERY；</li><li>leader同步数据给learner，使各个从节点数据和leader保持一致，此时zab协议状态为SYNCHRONIZATION；</li><li>同步超过一半的server之后，集群对外提供服务，此时zab状态为BROADCAST。</li></ol><p><strong>可以知道整个zookeeper服务的工作流程类似一个状态机的转换，而zab协议就是驱动服务状态流转的关键，理解了zab就理解了zookeeper工作的关键原理</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ZooKeeper-02-ZAB协议&quot;&gt;&lt;a href=&quot;#ZooKeeper-02-ZAB协议&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper-02-ZAB协议&quot;&gt;&lt;/a&gt;ZooKeeper-02-ZAB协议&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Zab（Zookeeper Atomic Broadcast）&lt;/code&gt;是为ZooKeeper协设计的崩溃恢复原子广播协议，它保证zookeeper集群数据的一致性和命令的全局有序性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Zookeeper" scheme="http://zhuuu.work/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Linux-05-C10K</title>
    <link href="http://zhuuu.work/2020/09/10/Linux/Linux-05-C10K/"/>
    <id>http://zhuuu.work/2020/09/10/Linux/Linux-05-C10K/</id>
    <published>2020-09-10T07:12:53.000Z</published>
    <updated>2020-09-16T00:33:31.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-05-C10K"><a href="#Linux-05-C10K" class="headerlink" title="Linux-05-C10K"></a>Linux-05-C10K</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>随着互联网的普及，应用的用户群体几何倍增长，此时<strong>服务器性能问题就出现。最初的服务器是基于进程/线程模型。新到来一个TCP连接，就需要分配一个进程。假如有C10K，就需要创建1W个进程，可想而知单机是无法承受的。</strong></li><li>那么如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题，最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案。</li></ul><h2 id="C10的本质"><a href="#C10的本质" class="headerlink" title="C10的本质"></a>C10的本质</h2><ul><li><strong>C10K问题的本质上是操作系统的问题。</strong></li><li>对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是requests per second。</li><li>当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。</li></ul><p>可见, 解决C10K问题的关键就是尽可能减少这些CPU资源消耗。</p><a id="more"></a><h2 id="C10K的解决方案"><a href="#C10K的解决方案" class="headerlink" title="C10K的解决方案"></a>C10K的解决方案</h2><p>从网络编程技术的角度来说，主要思路：</p><ol><li><strong>每个连接分配一个独立的线程/进程</strong></li><li><strong>同一个线程/进程同时处理多个连接</strong></li></ol><p><strong>方案一：每个连接分配一个独立的线程/进程</strong></p><ul><li>该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以会使资源占用过多，可扩展性差</li></ul><p><strong>方法二： 每个进程/线程同时处理 多个连接(I/O多路复用)</strong></p><ul><li><p><strong>select方式：</strong>使用fd_set结构体告诉内核同时监控那些文件句柄，使用逐个排查方式去检查是否有文件句柄就绪或者超时。该方式有以下缺点：文件句柄数量是有上线的，逐个检查吞吐量低，每次调用都要重复初始化fd_set。</p></li><li><p><strong>poll方式：</strong></p><ul><li>该方式主要解决了select方式的2个缺点，文件句柄上限问题(链表方式存储)以及重复初始化问题(不同字段标注关注事件和发生事件)，</li><li>但是逐个去检查文件句柄是否就绪的问题仍然没有解决。</li></ul></li><li><p><strong>epoll方式：</strong></p><ul><li>该方式可以说是C10K问题的killer，他不去轮询监听所有文件句柄是否已经就绪。epoll只对发生变化的文件句柄感兴趣。</li><li>其工作机制是，使用”事件”的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。</li><li>而且epoll使用一个文件描述符管理多个描述符,将用户进程的文件描述符的事件存放到内核的一个事件表中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。</li><li>而且epoll是通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高。但是epoll是依赖系统的(Linux)。</li></ul></li></ul><p>以及异步I/O以及Windows，该方式在windows上支持很好</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-05-C10K&quot;&gt;&lt;a href=&quot;#Linux-05-C10K&quot; class=&quot;headerlink&quot; title=&quot;Linux-05-C10K&quot;&gt;&lt;/a&gt;Linux-05-C10K&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;随着互联网的普及，应用的用户群体几何倍增长，此时&lt;strong&gt;服务器性能问题就出现。最初的服务器是基于进程/线程模型。新到来一个TCP连接，就需要分配一个进程。假如有C10K，就需要创建1W个进程，可想而知单机是无法承受的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;那么如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题，最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;C10的本质&quot;&gt;&lt;a href=&quot;#C10的本质&quot; class=&quot;headerlink&quot; title=&quot;C10的本质&quot;&gt;&lt;/a&gt;C10的本质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C10K问题的本质上是操作系统的问题。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是requests per second。&lt;/li&gt;
&lt;li&gt;当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见, 解决C10K问题的关键就是尽可能减少这些CPU资源消耗。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="多路复用" scheme="http://zhuuu.work/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-final全家桶</title>
    <link href="http://zhuuu.work/2020/09/08/JavaInterview/Java-%E5%9F%BA%E7%A1%80-final%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <id>http://zhuuu.work/2020/09/08/JavaInterview/Java-%E5%9F%BA%E7%A1%80-final%E5%85%A8%E5%AE%B6%E6%A1%B6/</id>
    <published>2020-09-08T09:34:38.000Z</published>
    <updated>2020-09-19T08:51:48.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-final全家桶"><a href="#Java-基础-final全家桶" class="headerlink" title="Java-基础-final全家桶"></a>Java-基础-final全家桶</h1><h2 id="1-final"><a href="#1-final" class="headerlink" title="1. final"></a>1. final</h2><ul><li>在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。下面将对其详细介绍。</li></ul><h3 id="1-1-修饰类"><a href="#1-1-修饰类" class="headerlink" title="1.1 修饰类"></a>1.1 修饰类</h3><ul><li>当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，<strong>但要注意：</strong></li><li>final类中所有的成员方法都会隐式的定义为final方法。</li></ul><a id="more"></a><h3 id="1-2-修饰方法"><a href="#1-2-修饰方法" class="headerlink" title="1.2 修饰方法"></a>1.2 修饰方法</h3><ul><li>使用final方法的原因主要有两个：<ul><li>(1) 把方法锁定，以防止继承类对其进行更改。</li><li>(2) 效率，在早期的java版本中，会将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。</li></ul></li></ul><p>final方法意味着“最后的、最终的”含义，即此方法不能被重写。</p><p><strong>注意：</strong></p><ul><li><strong>若父类中final方法的访问权限为private，将导致子类中不能直接继承该方法，因此，此时可以在子类中定义相同方法名的函数，此时不会与重写final的矛盾，而是在子类中重新地定义了新方法。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在java中，String被设计成final类，那为什么平时使用时，String的值可以被改变呢？<ul><li>字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。</li><li>当我们对String对象值改变的时候，例如 String a=”A”; a=”B” 。a是String对象的一个引用（我们这里所说的String对象其实是指字符串常量）<ul><li>当a=“B”执行时，并不是原本String对象(“A”)发生改变，而是创建一个新的对象(“B”)，令a引用它。</li></ul></li></ul></li></ul><h3 id="1-3-修饰变量"><a href="#1-3-修饰变量" class="headerlink" title="1.3 修饰变量"></a>1.3 修饰变量</h3><ul><li><p>final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。类似于C++中的const。</p><ul><li>当final修饰一个<strong>基本数据类型</strong>时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li><li>如果final修饰一个<strong>引用类型时</strong>，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。</li></ul></li><li><p><strong>final修饰一个成员变量（属性），必须要显示初始化。**</strong>这里有两种初始化方式**，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</p></li><li><p>当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。</p></li></ul><h2 id="2-finally"><a href="#2-finally" class="headerlink" title="2. finally"></a>2. finally</h2><ul><li>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。（×）（这句话其实存在一定的问题）</li><li>很多人都认为finally语句块一定会执行，但真的是这样么？答案是否定的，例如下面这个例子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164140271.png" alt="mark"></p><p>当我们去掉注释的三行语句，执行结果为：</p><p><code>return 0</code></p><ul><li><p>为什么在以上两种情况下都没有执行finally语句呢，说明什么问题？</p><ul><li><strong>只有与<code>finally</code>对应的<code>try</code>语句块得到执行的情况下，<code>finally</code>语句块才会执行。以上两种情况在执行<code>try</code>语句块之前已经返回或抛出异常，所以try对应的<code>finally</code>语句并没有执行。</strong></li></ul></li><li><p>但是，在某些情况下，即使try语句执行了，finally语句也不一定执行。例如以下情况：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164323776.png" alt="mark"></p><ul><li>finally 语句块还是没有执行，为什么呢？因为我们在 try 语句块中执行了 <code>System.exit (0)</code>语句，终止了 Java 虚拟机的运行。那有人说了，在一般的 Java 应用中基本上是不会调用这个 <code>System.exit(0)</code> 方法的。OK ！没有问题，我们不调用 <code>System.exit(0)</code>这个方法，那么<code>finally</code> 语句块就一定会执行吗？</li><li>再一次让大家失望了，答案还是否定的。当一个线程在执行 try 语句块或者 catch 语句块时被打断（<code>interrupted</code>）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。</li><li>还有更极端的情况，就是在线程运行<code>try</code> 语句块或者 <code>catch</code> 语句块时，突然死机或者断电，<code>finally</code> 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。</li></ul><h3 id="2-1-一个易错点"><a href="#2-1-一个易错点" class="headerlink" title="2.1 一个易错点"></a>2.1 一个易错点</h3><ul><li>在try-catch-finally语句中执行return语句。我们看如下代码：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164625386.png" alt="mark"></p><p><strong>答案：4,4,4 。  为什么呢？</strong></p><ul><li>首先finally语句在改代码中一定会执行，从运行结果来看，每次return的结果都是4（即finally语句），仿佛其他return语句被屏蔽掉了。</li><li>事实也确实如此，因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。 </li></ul><h2 id="3-finalize"><a href="#3-finalize" class="headerlink" title="3. finalize"></a>3. finalize</h2><ul><li><p><code>finalize()</code>是在<code>java.lang.Object</code>里定义的，也就是说每一个对象都有这么个方法。</p></li><li><p><strong>这个方法在gc启动，该对象被回收的时候被调用</strong>。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 </p></li><li><p>特殊情况下，需要程序员实现<code>finalize</code>，当对象被回收的时候释放一些资源，比如：一个<code>socket</code>链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 </p></li></ul><p><strong>使用finalize还需要注意一个事，调用super.finalize();</strong></p><ul><li>一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了</li><li>然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。</li><li>所以，推荐不要使用finalize()方法，它跟析构函数不一样.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-final全家桶&quot;&gt;&lt;a href=&quot;#Java-基础-final全家桶&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-final全家桶&quot;&gt;&lt;/a&gt;Java-基础-final全家桶&lt;/h1&gt;&lt;h2 id=&quot;1-final&quot;&gt;&lt;a href=&quot;#1-final&quot; class=&quot;headerlink&quot; title=&quot;1. final&quot;&gt;&lt;/a&gt;1. final&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。下面将对其详细介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-修饰类&quot;&gt;&lt;a href=&quot;#1-1-修饰类&quot; class=&quot;headerlink&quot; title=&quot;1.1 修饰类&quot;&gt;&lt;/a&gt;1.1 修饰类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，&lt;strong&gt;但要注意：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;final类中所有的成员方法都会隐式的定义为final方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="final" scheme="http://zhuuu.work/tags/final/"/>
    
      <category term="finally" scheme="http://zhuuu.work/tags/finally/"/>
    
      <category term="finalize" scheme="http://zhuuu.work/tags/finalize/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-16-索引覆盖和索引下推</title>
    <link href="http://zhuuu.work/2020/09/08/Mysql/Mysql-16-%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E5%92%8C%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/"/>
    <id>http://zhuuu.work/2020/09/08/Mysql/Mysql-16-%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E5%92%8C%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</id>
    <published>2020-09-08T08:02:27.000Z</published>
    <updated>2020-09-22T13:49:21.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-16-索引覆盖和索引下推"><a href="#Mysql-16-索引覆盖和索引下推" class="headerlink" title="Mysql-16-索引覆盖和索引下推"></a>Mysql-16-索引覆盖和索引下推</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>数据表结构如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table user (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    sex varchar(5),</span><br><span class="line">    index(name)</span><br><span class="line">)engine&#x3D;innodb;</span><br><span class="line"></span><br><span class="line"># 接下来两个查询是截然不同的</span><br><span class="line">select id,name where name&#x3D;&#39;shenjian&#39;</span><br><span class="line"> </span><br><span class="line">select id,name,sex where name&#x3D;&#39;shenjian&#39;</span><br></pre></td></tr></table></figure><p><strong>多查询了一个属性，为何检索过程完全不同？</strong></p><p>　1. 　<strong>什么是回表查询？</strong></p><p>　2. 　<strong>什么是索引覆盖？</strong></p><p>　3. 　<strong>如何实现索引覆盖？</strong></p><p><strong>哪些场景，可以利用索引覆盖来优化SQL？</strong></p><p>PS： <em>本文试验基于MySQL5.6-InnoDB。</em></p><a id="more"></a><h2 id="1-回表查询"><a href="#1-回表查询" class="headerlink" title="1. 回表查询"></a>1. 回表查询</h2><p>这先要从<code>InnoDB</code>的索引实现说起，<code>InnoDB</code>有两大类索引：</p><ul><li>聚集索引(<code>clustered index</code>)</li><li>普通索引(<code>secondary index</code>)</li></ul><p><strong>InnoDB聚集索引和普通索引有什么差异？</strong></p><ul><li>InnoDB<strong>聚集索引</strong>的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：</li></ul><ol><li>关于聚集索引有如下特性：</li></ol><p>（1）如果表定义了PK，则PK就是聚集索引；</p><p>（2）如果表没有定义PK，则第一个<code>not NULL unique</code>列是聚集索引；</p><p>（3）否则，<code>InnoDB</code>会创建一个隐藏的<code>row-id</code>作为聚集索引；</p><p><em>画外音：所以PK查询非常快，直接定位行记录。</em></p><ol start="2"><li><strong>普通索引又叫做非聚集索引：存放主键值</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">举个栗子，不妨设有表：</span><br><span class="line"></span><br><span class="line">　　t(id PK, name KEY, sex, flag);</span><br><span class="line"></span><br><span class="line">画外音：id是聚集索引，name是普通索引。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">表中有四条记录：</span><br><span class="line"></span><br><span class="line">　　1, shenjian, m, A</span><br><span class="line"></span><br><span class="line">　　3, zhangsan, m, A</span><br><span class="line"></span><br><span class="line">　　5, lisi, m, A</span><br><span class="line"></span><br><span class="line">　　9, wangwu, f, B</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202123097.png" alt="mark"></p><p>两个B+树索引分别如上图：</p><ul><li>id为PK，聚集索引，叶子节点存储行记录；</li><li>name为KEY，普通索引，叶子节点存储PK值，即id；</li></ul><p>既然从普通索引无法直接定位行记录，那<strong>普通索引的查询过程是怎么样的呢？</strong></p><ul><li><strong>回表查询因此出现了</strong></li><li>通常情况下，需要扫码两遍索引树。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where name&#x3D;&#39;lisi&#39;;</span><br></pre></td></tr></table></figure><p><strong>是如何执行的呢？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202248321.png" alt="mark"></p><p>如<strong>粉红色</strong>路径，需要扫码两遍索引树：</p><p>（1）先通过普通索引定位到主键值id=5；</p><p>（2）在通过聚集索引定位到行记录；</p><p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><h2 id="2-索引覆盖"><a href="#2-索引覆盖" class="headerlink" title="2. 索引覆盖"></a>2. 索引覆盖</h2><ol><li><strong>什么是索引覆盖(Covering index)？</strong></li></ol><ul><li>借用一下SQL-Server官网的说法。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202458539.png" alt="mark"></p><ul><li>MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为<strong>Using index</strong>时，能够触发索引覆盖。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202522480.png" alt="mark"></p><p>不管是SQL-Server官网，还是MySQL官网，都表达了：<strong>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</strong></p><ol start="2"><li><strong>如何实现索引覆盖？</strong></li></ol><ul><li>常见的方法是：<strong>将被查询的字段，建立到联合索引里去。</strong></li></ul><p>仍是之前中的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    sex varchar(5),</span><br><span class="line">    index(name)</span><br><span class="line">)engine&#x3D;innodb;</span><br></pre></td></tr></table></figure><ul><li>第一个SQL语句：　<code>select</code> <code>id,name</code> <code>from</code> <code>user</code> <code>where</code> <code>name=&#39;shenjian&#39;;</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202917251.png" alt="mark"></p><p>能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。</p><p><em>画外音，Extra：<strong>Using index</strong>。</em></p><ul><li>第二个SQL语句： <code>select</code> <code>id,name,sex from</code> <code>user</code> <code>where</code> <code>name=&#39;shenjian&#39;;</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/203020049.png" alt="mark"></p><p>能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低。</p><p><em>画外音，Extra：<strong>Using index condition</strong>。</em></p><ul><li><strong>如果把(name)单列索引升级为联合索引(name, sex)就不同了。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    sex varchar(5),</span><br><span class="line">    index(name, sex)</span><br><span class="line">)engine&#x3D;innodb;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/203205054.png" alt="mark"></p><p><strong>可以看到：都能够命中索引覆盖，无需回表。</strong></p><p><em>画外音，Extra：<strong>Using index</strong>。</em></p><h2 id="3-索引覆盖的场景"><a href="#3-索引覆盖的场景" class="headerlink" title="3. 索引覆盖的场景"></a>3. 索引覆盖的场景</h2><p><strong>场景1：全表count查询优化</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/203321222.png" alt="mark"></p><p>原表为：</p><p><em>user(PK id, name, sex)；</em></p><ul><li><p>如果直接<code>select</code> <code>count(name) from</code> <code>user;</code>不能利用索引覆盖。</p></li><li><p>添加索引：<code>alter</code> <code>table</code> <code>user</code> <code>add</code> <code>key(name);</code>   就能够利用索引覆盖提效。</p></li></ul><p><strong>场景2：列查询回表优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select&#96; &#96;id,&#96;&#96;name&#96;&#96;,sex ... &#96;&#96;where&#96; &#96;name&#96;&#96;&#x3D;&#96;&#96;&#39;shenjian&#39;&#96;&#96;;</span><br></pre></td></tr></table></figure><ul><li>这个例子不再赘述，将单列索引(name)升级为联合索引(name, sex)，即可避免回表。</li></ul><p><strong>场景3：分页查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select&#96; &#96;id,&#96;&#96;name&#96;&#96;,sex ... &#96;&#96;order&#96; &#96;by&#96; &#96;name&#96; &#96;limit 500,100;</span><br></pre></td></tr></table></figure><ul><li>将单列索引(name)升级为联合索引(name, sex)，也可以避免回表。</li></ul><h2 id="4-索引下推"><a href="#4-索引下推" class="headerlink" title="4. 索引下推"></a>4. 索引下推</h2><ul><li><p><strong>索引下推</strong>（index condition pushdown ）简称ICP，在<strong>Mysql5.6</strong>的版本上推出，用于优化查询。</p></li><li><p><strong>在不使用ICP</strong>的情况下，在使用<strong>非主键索引（又叫普通索引或者二级索引）</strong>进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p></li><li><p><strong>在使用ICP的情况</strong>下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p></li></ul><p><strong>小结：</strong> </p><ul><li><strong>索引条件下推优化可以减少存储引擎查询基础表的次数（回表次数），也可以减少MySQL服务器从存储引擎接收数据的次数</strong>。</li></ul><h3 id="4-1-举个例子"><a href="#4-1-举个例子" class="headerlink" title="4.1 举个例子"></a>4.1 举个例子</h3><ul><li>在开始之前先先准备一张用户表(user)，其中主要几个字段有：<code>id、name、age、address</code>。建立<strong>联合索引（name，age）</strong>。</li><li>假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：</li></ul><p><code>SELECT * from user where  name like &#39;陈%&#39;</code></p><ul><li>根据 “最佳左前缀” 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</li><li><strong>问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户</strong>，此时的sql语句如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from user where  name like &#39;陈%&#39; and age&#x3D;20</span><br></pre></td></tr></table></figure><p>这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。</p><h3 id="4-2-Mysql5-6之前的版本"><a href="#4-2-Mysql5-6之前的版本" class="headerlink" title="4. 2 Mysql5.6之前的版本"></a>4. 2 Mysql5.6之前的版本</h3><ul><li>5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/214616079.png" alt="mark"></p><ul><li>会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要<strong>回表两次</strong>。</li></ul><h3 id="4-3-Mysql5-6及之后版本"><a href="#4-3-Mysql5-6及之后版本" class="headerlink" title="4.3 Mysql5.6及之后版本"></a>4.3 Mysql5.6及之后版本</h3><ul><li>5.6版本添加了索引下推这个优化，执行的过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/214701758.png" alt="mark"></p><ul><li>InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要<strong>回表一次</strong>。</li></ul><ul><li>当然上述的分析只是原理上的，我们可以实战分析一下，因此陈某装了Mysql5.6版本的Mysql，解析了上述的语句，如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/214754104.png" alt="mark"></p><ul><li>根据explain解析结果可以看出Extra的值为<strong>Using index condition</strong>，表示已经使用了索引下推。</li></ul><h3 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h3><ul><li>索引下推在<strong>非主键索引</strong>上的优化，可以有效减少回表的次数，大大提升了查询的效率。</li><li>关闭索引下推可以使用如下命令，配置文件的修改不再讲述了，毕竟这么优秀的功能干嘛关闭呢：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　set optimizer_switch&#x3D;&#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-16-索引覆盖和索引下推&quot;&gt;&lt;a href=&quot;#Mysql-16-索引覆盖和索引下推&quot; class=&quot;headerlink&quot; title=&quot;Mysql-16-索引覆盖和索引下推&quot;&gt;&lt;/a&gt;Mysql-16-索引覆盖和索引下推&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据表结构如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;create table user (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id int primary key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name varchar(20),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sex varchar(5),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    index(name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)engine&amp;#x3D;innodb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 接下来两个查询是截然不同的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select id,name where name&amp;#x3D;&amp;#39;shenjian&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select id,name,sex where name&amp;#x3D;&amp;#39;shenjian&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;多查询了一个属性，为何检索过程完全不同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　1. 　&lt;strong&gt;什么是回表查询？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　2. 　&lt;strong&gt;什么是索引覆盖？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　3. 　&lt;strong&gt;如何实现索引覆盖？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哪些场景，可以利用索引覆盖来优化SQL？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS： &lt;em&gt;本文试验基于MySQL5.6-InnoDB。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis-17-动态字符串SDS</title>
    <link href="http://zhuuu.work/2020/09/07/Redis/Redis-17-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/"/>
    <id>http://zhuuu.work/2020/09/07/Redis/Redis-17-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</id>
    <published>2020-09-07T10:32:24.000Z</published>
    <updated>2020-09-21T11:26:16.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-17-动态字符串SDS"><a href="#Redis-17-动态字符串SDS" class="headerlink" title="Redis-17-动态字符串SDS"></a>Redis-17-动态字符串SDS</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>面试场景</strong></p><p>面试官：Redis有哪些数据类型？</p><p>我：String，List，set，zset，hash</p><p>面试官：没了？</p><p><strong>我：哦哦哦，还有HyperLogLog，bitMap，GeoHash，BloomFilter</strong></p><p>面试官：就这？回家等通知吧。(GG)</p><ul><li><p>但是，一场面试少说都是半小时起步上不封顶，你这样一句话就回答了这么重要的五个知识点，这个结果是你想要的么？是面试官想要的么？</p></li><li><p>String在Redis底层是怎么存储的？这些数据类型在Redis中是怎么存放的？Redis快的原因就只有单线程和基于内存么？</p></li></ul><a id="more"></a><h2 id="1-SDS"><a href="#1-SDS" class="headerlink" title="1. SDS"></a>1. SDS</h2><ul><li>Redis是C语言开发的，C语言自己就有字符类型，但是Redis却没直接采用C语言的字符串类型，而是自己构建了<code>动态字符串（SDS）</code>的抽象类型。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/165529250.png" alt="mark"></p><ul><li><p>就好比这样的一个命令，其实我是在Redis创建了两个SDS，一个是名为<code>aobing</code>的Key SDS，另一个是名为<code>cool</code>的Value SDS，就算是字符类型的List，也是由很多的SDS构成的Key和Value罢了。</p></li><li><p>SDS在Redis中除了用作字符串，还用作缓冲区（buffer），那到这里大家都还是有点疑惑的，C语言的字符串不好么为啥用SDS？SDS长啥样？有什么优点呢?</p></li></ul><p><strong>去找到了Redis的源码，可以看到SDS值的结果大概是这样的，源码的在GitHub上是开源的大家一搜就有了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"> <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/165739509.png" alt="mark"></p><ul><li>回到最初的问题，为什么Redis用了自己新开发的SDS，而不用C语言的字符串？那好我们去看看他们的区别。</li></ul><h3 id="1-1-SDS-和-C字符串的区别"><a href="#1-1-SDS-和-C字符串的区别" class="headerlink" title="1.1 SDS 和 C字符串的区别"></a>1.1 SDS 和 C字符串的区别</h3><ol><li><strong>计数方式不同</strong></li></ol><ul><li>C语言对字符串长度的统计，就完全来自遍历，从头遍历到末尾，直到发现空字符就停止，以此统计出字符串的长度，这样获取长度的时间复杂度来说是0（n），大概就像下面这样</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170018810.gif" alt="mark"></p><ul><li><p>但是这样的计数方式会留下隐患，所以Redis没有采用C的字符串，我后面会提到。</p></li><li><p>而Redis我在上面已经给大家看过结构了，他自己本身就保存了长度的信息，所以我们获取长度的时间复杂度为0（1），是不是发现了Redis快的一点小细节了？还没完，不止这些。</p></li></ul><ol start="2"><li><strong>杜绝缓冲区溢出</strong></li></ol><ul><li>字符串拼接是我们经常做的操作，在C和Redis中一样，也是很常见的操作，但是问题就来了，C是不记录字符串长度的，一旦我们调用了拼接的函数，如果没有提前计算好内存，是会产生缓存区溢出的。</li></ul><p>比如本来字符串长这样：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170206424.png" alt="mark"></p><p>你现在需要在后面拼接 ，但是你没计算好内存，结果就可能这样了：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170225389.png" alt="mark"></p><ul><li>这是你要的结果么？很显然，不是，你的结果意外的被修改了，这要是放在线上的系统，这不是完了？那Redis是怎么避免这样的情况的？</li><li>我们都知道，<strong>他结构存储了当前长度，还有free未使用的长度</strong>，那简单呀，你现在做了拼接操作，我去判断一些是否可以放得下，如果长度够就直接执行，如果不够，那我就进行扩容。</li><li>这些大家在Redis源码里面都是可以看到对应的API的，后面我就不一一贴源码了，有兴趣的可以自己去看一波，需要一点C语言的基础。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170510217.png" alt="mark"></p><ol start="3"><li><strong>减少修改字符串时带来的内存重分配次数</strong></li></ol><ul><li>C语言字符串底层也是一个数组，每次创建的时候就创建一个N+1长度的字符，多的那个1，就是为了保存空字符的，这个空字符也是个坑，但是不是这个环节探讨的内容。</li><li>Redis是个高速缓存数据库，如果我们需要对字符串进行频繁的拼接和截断操作，如果我们写代码忘记了重新分配内存，就可能造成缓冲区溢出，以及内存泄露。</li><li>内存分配算法很耗时，且不说你会不会忘记重新分配内存，就算你全部记得，对于一个高速缓存数据库来说，这样的开销也是我们应该要避免的。</li></ul><p><strong>Redis为了避免C字符串这样的缺陷，就分别采用了两种解决方案，去达到性能最大化，空间利用最大化：</strong></p><ul><li>空间预分配：当我们对SDS进行扩展操作的时候，Redis会为SDS分配好内存，并且根据特定的公式，分配多余的free空间，还有多余的1byte空间（这1byte也是为了存空字符），这样就可以避免我们连续执行字符串添加所带来的内存分配消耗。</li></ul><p>比如现在有这样的一个字符：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170956217.png" alt="mark"></p><p>我们调用了拼接函数，字符串变长了，Redis还会根据算法计算出一个free值给他备用：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171058868.png" alt="mark"></p><p>我们再继续拼接，你会发现，备用的free用上了，省去了这次的内存重分配：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171131120.png" alt="mark"></p><ul><li><strong>惰性空间释放</strong>：刚才提到了会预分配多余的空间，很多小伙伴会担心带来内存的泄露或者浪费，别担心，Redis大佬一样帮我们想到了，当我们执行完一个字符串缩减的操作，redis并不会马上收回我们的空间，因为可以预防你继续添加的操作，这样可以减少分配空间带来的消耗，但是当你再次操作还是没用到多余空间的时候，Redis也还是会收回对于的空间，防止内存的浪费的。</li></ul><p>还是一样的字符串：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171207003.png" alt="mark"></p><p>当我们调用了删减的函数，并不会马上释放掉free空间：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171227873.png" alt="mark"></p><p>如果我们需要继续添加这个空间就能用上了，减少了内存的重分配，如果空间不需要了，调用函数删掉就好了：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171246466.png" alt="mark"></p><ol start="4"><li><strong>二进制安全</strong></li></ol><ul><li>仔细看的仔肯定看到上面我不止一次提到了空字符也就是’\0‘，C语言是判断空字符去判断一个字符的长度的，但是有很多数据结构经常会穿插空字符在中间，比如图片，音频，视频，压缩文件的二进制数据，就比如下面这个单词，他只能识别前面的 不能识别后面的字符，那对于我们开发者而言，这样的结果显然不是我们想要的对不对。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171334719.png" alt="mark"></p><ul><li>Redis就不存在这个问题了，他不是保存了字符串的长度嘛，他不判断空字符，他就判断长度对不对就好了，所以redis也经常被我们拿来保存各种二进制数据，我反正是用的很high，经常用来保存小文件的二进制。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171356886.png" alt="mark"></p><p><strong>总结</strong></p><ul><li>大家是不是发现，一个小小的SDS居然有这么多道理在这？</li><li>以前就知道Redis快，最多说个Redis是单线程的，说个多路IO复用，说个基于内存的操作就完了，现在是不是还可以展开说说了？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-17-动态字符串SDS&quot;&gt;&lt;a href=&quot;#Redis-17-动态字符串SDS&quot; class=&quot;headerlink&quot; title=&quot;Redis-17-动态字符串SDS&quot;&gt;&lt;/a&gt;Redis-17-动态字符串SDS&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;面试场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面试官：Redis有哪些数据类型？&lt;/p&gt;
&lt;p&gt;我：String，List，set，zset，hash&lt;/p&gt;
&lt;p&gt;面试官：没了？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我：哦哦哦，还有HyperLogLog，bitMap，GeoHash，BloomFilter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面试官：就这？回家等通知吧。(GG)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;但是，一场面试少说都是半小时起步上不封顶，你这样一句话就回答了这么重要的五个知识点，这个结果是你想要的么？是面试官想要的么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String在Redis底层是怎么存储的？这些数据类型在Redis中是怎么存放的？Redis快的原因就只有单线程和基于内存么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="SDS" scheme="http://zhuuu.work/tags/SDS/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-异常</title>
    <link href="http://zhuuu.work/2020/09/07/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/"/>
    <id>http://zhuuu.work/2020/09/07/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/</id>
    <published>2020-09-07T09:34:38.000Z</published>
    <updated>2020-09-07T12:11:38.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-异常"><a href="#Java-基础-异常" class="headerlink" title="Java-基础-异常"></a>Java-基础-异常</h1><h2 id="1-什么是异常？"><a href="#1-什么是异常？" class="headerlink" title="1. 什么是异常？"></a>1. 什么是异常？</h2><ul><li><p>事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用<strong>空的引用</strong>、<strong>数组下标越界</strong>、<strong>内存溢出错误</strong>等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。</p></li><li><p><strong>假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果</strong>。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，<strong>通过异常机制来处理程序运行期间出现的错误</strong>。通过异常机制，我们可以更好地提升程序的健壮性。</p></li><li><p>在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。java中的处理就是中断处理。</p></li></ul><p>　<strong>在Java中，异常类的结构层次图如下图所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/145710336.png" alt="mark"></p><a id="more"></a><p><strong>异常的分类：</strong></p><ul><li><p>在Java中异常被当做对象来处理，根类是<code>java.lang.Throwable</code>类，在Java中定义了很多异常类（如<code>OutOfMemoryError、NullPointerException</code>、<code>IndexOutOfBoundsException</code>等），这些异常类分为两大类：<code>Error</code>和<code>Exception</code>。</p></li><li><p><code>Exception</code>类的异常包括<code>checked exception</code>和<code>unchecked exception</code>（<code>unchecked exception</code>也称运行时异常<code>RuntimeException</code>，当然这里的运行时异常并不是前面我所说的运行期间的异常，只是Java中用运行时异常这个术语来表示，Exception类的异常都是在运行期间发生的）。</p><ul><li><code>unchecked exception</code>（非检查异常），也称运行时异常<code>（RuntimeException）</code>，比如常见的<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</li><li><code>checked exception</code>（检查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），<code>java</code>编译器强制程序员必须进行捕获处理，比如常见的<code>IOExeption</code>和<code>SQLException</code>。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过</li></ul></li><li><p>在Java中，所有异常类的父类是<code>Throwable</code>类，</p><ul><li>Error类是error类型异常的父类，</li><li>Exception类是exception类型异常的父类，<ul><li>RuntimeException类是所有运行时异常的父类</li><li>RuntimeException以外的并且继承Exception的类是非运行时异常。</li><li>典型的<code>RuntimeException</code>包括<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> <code>InterrupterException</code>等。</li><li>典型的非<code>RuntimeException</code>包括<code>IOException</code>、<code>SQLException</code>等。</li></ul></li></ul></li></ul><h2 id="2-Java中如何处理异常？"><a href="#2-Java中如何处理异常？" class="headerlink" title="2. Java中如何处理异常？"></a>2. Java中如何处理异常？</h2><ul><li>在Java中如果需要处理异常，必须先对异常进行捕获，然后再对异常情况进行处理。如何对可能发生异常的代码进行异常捕获和处理呢？使用try和catch关键字即可，如下面一段代码所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">  <span class="keyword">if</span>(!file.exists())</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(被try块包围的代码说明这段代码可能会发生异常，一旦发生异常，异常便会被catch捕获到，然后需要在catch块中进行异常处理。)</p><ul><li>在Java中还提供了另一种异常处理方式即抛出异常，顾名思义，也就是说一旦发生异常，我把这个异常抛出去，让调用者去进行处理，自己不进行具体的处理，此时需要用到throw和throws关键字。　</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            createFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><ul><li>这段代码和上面一段代码的区别是，在实际的createFile方法中并没有捕获异常，而是用throws关键字声明抛出异常，</li><li>即告知这个方法的调用者此方法可能会抛出<code>IOException</code>。那么在main方法中调用<code>createFile</code>方法的时候，采用try…catch块进行了异常捕获处理。</li></ul><ul><li>当然还可以采用throw关键字手动来抛出异常对象。下面看一个例子：然后在catch块中进行捕获。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            System.out.println(getDataByIndex(-<span class="number">1</span>,data));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDataByIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组下标越界"</span>);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>也就说在Java中进行异常处理的话，对于可能会发生异常的代码，可以选择三种方法来进行异常处理：<ul><li>对代码块用<code>try..catch</code>进行异常捕获处理；</li><li>在 该代码的方法体外用<strong>throws进行抛出声明</strong>，告知此方法的调用者这段代码可能会出现这些异常，你需要谨慎处理。<ul><li>如果声明抛出的异常是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。</li><li>如果声明抛出的异常是运行时异常，此方法的调用者可以选择地进行异常捕获处理。</li></ul></li><li>在代码块用throw手动抛出一个异常对象，此时也有两种情况，<strong>跟throw中的类似</strong>：<ul><li>如果抛出的异常对象是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。</li><li>如果抛出的异常对象是运行时异常，此方法的调用者可以选择地进行异常捕获处理。</li></ul></li></ul></li></ul><ul><li>如果最终将异常抛给<code>main</code>方法，则相当于交给<code>jvm</code>自动处理，此时<code>jvm</code>会简单地打印异常信息）<strong>同时是中断处理</strong></li></ul><p><strong>未完待续：</strong></p><p><strong>参考博客 ：</strong> <a href="https://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3769804.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-异常&quot;&gt;&lt;a href=&quot;#Java-基础-异常&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-异常&quot;&gt;&lt;/a&gt;Java-基础-异常&lt;/h1&gt;&lt;h2 id=&quot;1-什么是异常？&quot;&gt;&lt;a href=&quot;#1-什么是异常？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是异常？&quot;&gt;&lt;/a&gt;1. 什么是异常？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用&lt;strong&gt;空的引用&lt;/strong&gt;、&lt;strong&gt;数组下标越界&lt;/strong&gt;、&lt;strong&gt;内存溢出错误&lt;/strong&gt;等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果&lt;/strong&gt;。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，&lt;strong&gt;通过异常机制来处理程序运行期间出现的错误&lt;/strong&gt;。通过异常机制，我们可以更好地提升程序的健壮性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。java中的处理就是中断处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　&lt;strong&gt;在Java中，异常类的结构层次图如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/145710336.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="异常总结" scheme="http://zhuuu.work/tags/%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-15-Mysql死锁</title>
    <link href="http://zhuuu.work/2020/09/07/Mysql/Mysql-15-Mysql%E6%AD%BB%E9%94%81/"/>
    <id>http://zhuuu.work/2020/09/07/Mysql/Mysql-15-Mysql%E6%AD%BB%E9%94%81/</id>
    <published>2020-09-07T08:02:27.000Z</published>
    <updated>2020-09-18T11:06:15.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-15-Mysql死锁"><a href="#Mysql-15-Mysql死锁" class="headerlink" title="Mysql-15-Mysql死锁"></a>Mysql-15-Mysql死锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。</p></li><li><p><code>InnoDB</code>引擎提供了行级锁，表锁。<code>MyISAM</code>提供了表锁，如题，MySQL会发生死锁吗？</p></li></ul><a id="more"></a><h2 id="1-案例一"><a href="#1-案例一" class="headerlink" title="1. 案例一"></a>1. 案例一</h2><ul><li>在InnoDB引擎下，<code>RR(REPEATABLE-READ)</code>级别，如果多个事务争抢同一个资源，会发生死锁。在RR级别下，MySQL提供了next-key lock。假如一个索引的行有<code>10,11,13,20</code></li><li>那么可能的<code>next-key lock</code>的包括</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(无穷小, 10]</span><br><span class="line">(10,11]</span><br><span class="line">(11,13]</span><br><span class="line">(13,20]</span><br><span class="line">(20, 无穷大)</span><br></pre></td></tr></table></figure><ul><li>即：当你查询12时，如果数据未查到，那么将对(12,13]范围内的数据进行锁定。<code>next-key lock</code>的定义可以到官方具体查看，这里做个演示。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174336612.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看隔离级别，</span><br><span class="line">show variables like &#39;%tx_isolation%&#39;;</span><br><span class="line">&#x2F;&#x2F; 设置隔离界别</span><br><span class="line">SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br><span class="line">&#x2F;&#x2F; 不设置自动提交</span><br><span class="line">SET autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><ol><li>首先将隔离级别都设置为RR级别的，并且不让事务自动提交</li><li>根据上面的数据，在事务1中查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 得到空结果集，此时锁定的范围是(33,100]</span><br><span class="line">select * FROM user where id&#x3D;33 for update;</span><br></pre></td></tr></table></figure><ol start="3"><li>在事务2中也进行查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询到空的结果，在事务2中锁定的范围是(34,100]</span><br><span class="line">select * FROM user where id&#x3D;34 for update</span><br></pre></td></tr></table></figure><ol start="4"><li>在事务1中插入数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 虽然事务1锁定了范围，事务2也锁定了范围</span><br><span class="line">insert into user values(35,&#39;ac&#39;,10);</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174511421.png" alt="mark"></p><ol start="5"><li>在事务2中也插入数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into user values(34,&#39;ac&#39;,10)</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174533500.png" alt="mark"></p><p><strong>解决方案</strong></p><ol><li><strong>设置死锁的超时时长</strong></li></ol><p><code>innodb_lock_wait_timeout=500</code></p><ol start="2"><li><strong>查询到当前正在锁定的事务线程，将其杀死</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以看到正在运行的事务线程，还有运行状态</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;trx_mysql_thread_id为上一条命令获取的结果，将具体的数字替换一下即可。</span><br><span class="line">kill trx_mysql_thread_id</span><br></pre></td></tr></table></figure><h2 id="2-案例二"><a href="#2-案例二" class="headerlink" title="2. 案例二"></a>2. 案例二</h2><ul><li><strong>索引不当导致全表扫描</strong></li></ul><ol><li>如果在事务中执行了一条不满足条件的语句，执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。</li><li>类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。</li></ol><p><strong>解决方案</strong></p><ul><li>SQL语句中不要使用太复杂的关联多表的查询；</li><li>使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-15-Mysql死锁&quot;&gt;&lt;a href=&quot;#Mysql-15-Mysql死锁&quot; class=&quot;headerlink&quot; title=&quot;Mysql-15-Mysql死锁&quot;&gt;&lt;/a&gt;Mysql-15-Mysql死锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;引擎提供了行级锁，表锁。&lt;code&gt;MyISAM&lt;/code&gt;提供了表锁，如题，MySQL会发生死锁吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis-13-跳表</title>
    <link href="http://zhuuu.work/2020/09/06/Redis/Redis-13-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/09/06/Redis/Redis-13-%E8%B7%B3%E8%A1%A8/</id>
    <published>2020-09-06T10:32:24.000Z</published>
    <updated>2020-09-10T09:23:53.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-13-跳表"><a href="#Redis-13-跳表" class="headerlink" title="Redis-13-跳表"></a>Redis-13-跳表</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先为什么要把mysql索引和redis跳表放在一起讨论呢，因为他们解决的都是同一种问题，用于<strong>解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置（或者对应的value）</strong></li></ul><a id="more"></a><p>现在我们将问题领域边界划分清楚了，就是为了解决数据集合的查找问题。这一块需要考虑哪些问题呢</p><ol><li>需要支持哪些查找方式，单key/多key/范围查找，</li><li>插入/删除效率</li><li>查找效率（即时间复杂度）</li><li>存储大小（空间复杂度）</li></ol><ul><li>我们看下<strong>几种常用的查找结构</strong></li></ul><ol><li><strong>Hash : hash是key,value形式，通过一个散列函数，能够根据key快速找到value</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200807-154119174.png" alt="mark"></p><ol start="2"><li><strong>B+树</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200807-154302337.png" alt="mark"></p><ul><li>B+树首先是有序结构，为了不至于树的高度太高，影响查找效率，在叶子节点上存储的不是单个数据，而是一页数据，提高了查找效率，而为了更好的支持范围查询，B+树在叶子节点冗余了非叶子节点数据，为了支持翻页，叶子节点之间通过指针连接。</li></ul><p><strong>跳表</strong></p><ul><li><strong>跳表是在链表的基础上进行扩展的，为的是实现redis的sorted set数据结构。（Zset）</strong></li><li>level0: 是存储原始数据的，是一个有序链表，每个节点都在链上</li><li>每个节点都在链上 level0+: 通过指针串联起节点，是原始数据的一个子集，level等级越高，串联的数据越少，这样可以显著提高查找效率，</li></ul><p><strong>总结：</strong></p><table><thead><tr><th>数据结构</th><th>实现原理</th><th>key查询方式</th><th>查找效率</th><th>存储大小</th><th>插入、删除效率</th></tr></thead><tbody><tr><td>Hash</td><td>哈希表</td><td>支持单key</td><td>接近O(1)</td><td>小，除了数据没有额外的存储</td><td>O(1)</td></tr><tr><td>B+树</td><td>平衡二叉树扩展而来</td><td>单key,范围，分页</td><td>O(Log(n)</td><td>除了数据，还多了左右指针，以及叶子节点指针</td><td>O(Log(n)，需要调整树的结构，算法比较复杂</td></tr><tr><td>跳表</td><td>有序链表扩展而来</td><td>单key，分页</td><td>O(Log(n)</td><td>除了数据，还多了指针，但是每个节点的指针小于&lt;2,所以比B+树占用空间小</td><td>O(Log(n)，只用处理链表，算法比较简单</td></tr></tbody></table><h2 id="1-Zset-原理分析"><a href="#1-Zset-原理分析" class="headerlink" title="1. Zset 原理分析"></a>1. Zset 原理分析</h2><h3 id="1-1-Zset编码的选择"><a href="#1-1-Zset编码的选择" class="headerlink" title="1.1 Zset编码的选择"></a>1.1 Zset编码的选择</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165054478.png" alt="mark"></p><p><strong>1.有序集合对象的编码可以是<code>ziplist</code>或者<code>skiplist</code>。同时满足以下条件时使用ziplist编码：</strong></p><ul><li><p>元素数量小于128个</p></li><li><p>所有member的长度都小于64字节</p></li><li><p>其他：</p></li><li><ul><li>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改</li><li>对于一个 <code>REDIS_ENCODING_ZIPLIST</code> 编码的 Zset， 只要满足以上任一条件， 则会被转换为 <code>REDIS_ENCODING_SKIPLIST</code> 编码</li></ul></li></ul><p><strong>2.zset操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</span><br><span class="line">zrem(key, member) ：删除名称为key的zset中的元素member</span><br><span class="line">zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</span><br><span class="line">zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</span><br><span class="line">zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</span><br><span class="line">zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</span><br><span class="line">zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素</span><br><span class="line">zrangebyscore(key, min, max)：返回名称为key的zset中score &gt;= min且score &lt;= max的所有元素 zcard(key)：返回名称为key的zset的基数</span><br><span class="line">zscore(key, element)：返回名称为key的zset中元素element的score zremrangebyrank(key, min, max)：删除名称为key的zset中rank &gt;= min且rank &lt;= max的所有元素 zremrangebyscore(key, min, max) ：删除名称为key的zset中score &gt;= min且score &lt;= max的所有元素</span><br></pre></td></tr></table></figure><h2 id="2-ziplist"><a href="#2-ziplist" class="headerlink" title="2. ziplist"></a>2. ziplist</h2><ul><li>ziplist 编码的 Zset 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。</li><li>ziplist 内的集合元素按 score 从小到大排序，其实质是一个双向链表。虽然元素是按 <code>score</code> 有序排序的， 但对 <code>ziplist</code> 的节点指针只能线性地移动，所以在 <code>REDIS_ENCODING_ZIPLIST</code> 编码的 Zset 中， 查找某个给定元素的复杂度为 O(n)</li></ul><p><strong>如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;操作</span><br><span class="line">ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储顺序</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165634662.png" alt="mark"></p><p><strong>3. 从以上的布局中，我们可以看到ziplist内存数据结构，由如下5部分构成：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165706567.png" alt="mark"></p><p>各个部分在内存上是前后相邻的并连续的，每一部分作用如下：</p><ul><li><p>zlbytes： 存储一个无符号整数，固定四个字节长度（32bit），用于存储压缩列表所占用的字节（也包括<zlbytes>本身占用的4个字节），当重新分配内存的时候使用，不需要遍历整个列表来计算内存大小。</p></li><li><p>zltail： 存储一个无符号整数，固定四个字节长度（32bit），表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。<zltail>的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。</p></li><li><p>zllen： 压缩列表包含的节点个数，固定两个字节长度（16bit）， 表示ziplist中数据项（entry）的个数。由于zllen字段只有16bit，所以可以表达的最大值为2^16-1。</p><p>注意点：如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以表示。ziplist是如何做到的？</p><p>如果<zllen>小于等于2^16-2（也就是不等于2^16-1），那么<zllen>就表示ziplist中数据项的个数；否则，也就是<zllen>等于16bit全为1的情况，那么<zllen>就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。</p></li><li><p>entry，表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。</p></li><li><p>zlend， ziplist最后1个字节，值固定等于255，其是一个结束标记。</p></li></ul><h2 id="3-skiplist"><a href="#3-skiplist" class="headerlink" title="3. skiplist"></a>3. skiplist</h2><ul><li><p>skiplist 编码的 Zset 底层为一个被称为 zset 的结构体，这个结构体中包含一个字典和一个跳跃表。跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 </p><p>O(logN)，最坏 O(N)</p></li><li><p><em>字典则保存着从 member 到 score 的映射，这样就可以用 O(1)的复杂度来查找 member 对应的 score 值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。</em></p></li></ul><p><strong>详细解析</strong></p><ul><li>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。</li><li>简单说来<strong>跳表也是链表</strong>的一种，只不过它在<strong>链表的基础上增加了跳跃功能</strong>，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。</li></ul><p>先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170230031.png" alt="mark"></p><p>在这样一个链表中，如果我们要<strong>查找某个数据，那么需要从头开始逐个进行比较**</strong>，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，<strong>时间复杂度为O(n)。</strong>同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170358081.png" alt="mark"></p><ul><li>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。</li><li>现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。</li><li>当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170518070.png" alt="mark"></p><ol><li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li><li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li><li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li></ol><p><strong>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</strong></p><p><strong>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170624567.png" alt="mark"></p><ul><li>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，</li><li>接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。</li><li>可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</li></ul><h3 id="3-1-小结"><a href="#3-1-小结" class="headerlink" title="3.1 小结"></a>3.1 小结</h3><ul><li><code>skiplist</code>正是受这种多层链表的想法的启发而设计出来的。<strong>实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找</strong>，使得查找的时间复杂度可以降低到O(log n)。</li><li>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。</li><li>如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</li></ul><p><strong>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。</strong>比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/171220254.png" alt="mark"></p><ul><li>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。</li><li>因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。</li><li><strong>实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案</strong>。这在后面我们还会提到。</li></ul><p><strong>总结：</strong></p><ul><li><strong>skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。</strong></li><li><strong>这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。</strong></li></ul><h3 id="3-2-举个例子"><a href="#3-2-举个例子" class="headerlink" title="3.2 举个例子"></a>3.2 举个例子</h3><ul><li>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/171415212.png" alt="mark"></p><ul><li><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p></li><li><p>实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key(score)进行排序的，查找过程也是根据key在比较。</p></li></ul><ul><li>执行<strong>插入操作时计算随机数</strong>的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：<ul><li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li><li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li><li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li></ul></li><li>这个随机数伪码如下：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">level := 1</span><br><span class="line">// random()返回一个[0...1)的随机数</span><br><span class="line"><span class="keyword">while</span> random() &lt; p and level &lt; MaxLevel <span class="keyword">do</span></span><br><span class="line">level := level + 1</span><br><span class="line"><span class="built_in">return</span> leve</span><br><span class="line">    </span><br><span class="line"><span class="comment">## randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：  </span></span><br><span class="line">p = 1/4</span><br><span class="line">MaxLevel = 32</span><br></pre></td></tr></table></figure><h2 id="4-skiplist与平衡树、哈希表的比较"><a href="#4-skiplist与平衡树、哈希表的比较" class="headerlink" title="4. skiplist与平衡树、哈希表的比较"></a>4. skiplist与平衡树、哈希表的比较</h2><ul><li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p></li><li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p></li><li><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p></li><li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p></li><li><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p></li><li><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></li></ul><h2 id="5-Redis中skiplist的实现"><a href="#5-Redis中skiplist的实现" class="headerlink" title="5. Redis中skiplist的实现"></a>5. Redis中skiplist的实现</h2><p>skiplist的数据结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">robj *obj;</span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">&#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p> 简单分析一下几个查询命令:</p><ul><li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li><li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li><li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li><li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key，数据相当于value）。</li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li>当数据较少时，sorted set是由一个ziplist来实现的。</li><li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li></ul><p>看一下sorted set与skiplist的关系，：</p><ul><li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。</li><li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。</li><li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li><li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li></ul><p><strong>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</strong></p><ul><li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li><li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li><li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li></ul><h2 id="6-Redis为什么用skiplist而不用平衡树？"><a href="#6-Redis为什么用skiplist而不用平衡树？" class="headerlink" title="6. Redis为什么用skiplist而不用平衡树？"></a>6. Redis为什么用skiplist而不用平衡树？</h2><p><strong>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因。</strong></p><p><strong>原因一</strong></p><p><code>There are a few reasons:</code></p><p>1) <code>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</code><br><strong>1) 也不是非常耗费内存，实际上取决于生成层数函数里的概率 p，取决得当的话其实和平衡树差不多。</strong></p><p><strong>原因二</strong></p><p>2) <code>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</code><br><strong>2) 因为有序集合经常会进行 ZRANGE 或 ZREVRANGE 这样的范围查找操作，跳表里面的双向链表可以十分方便地进行这类操作</strong></p><p><strong>原因三</strong></p><p>3) <code>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</code><br><strong>3) 实现简单，ZRANK 操作还能达到 o(logn)的时间复杂度</strong></p><p><strong>参考博客 : <a href="https://www.cnblogs.com/yuanfang0903/p/12165394.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanfang0903/p/12165394.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-13-跳表&quot;&gt;&lt;a href=&quot;#Redis-13-跳表&quot; class=&quot;headerlink&quot; title=&quot;Redis-13-跳表&quot;&gt;&lt;/a&gt;Redis-13-跳表&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先为什么要把mysql索引和redis跳表放在一起讨论呢，因为他们解决的都是同一种问题，用于&lt;strong&gt;解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置（或者对应的value）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="跳表" scheme="http://zhuuu.work/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://zhuuu.work/2020/09/05/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://zhuuu.work/2020/09/05/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-09-05T00:02:27.000Z</published>
    <updated>2020-09-26T07:00:14.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么要使用分布式锁呢？</p><p>在<code>Nginx</code>实现负载均衡服务器集群时会产生很多问题，在提高并发的同时，服务器也会产生非常多的问题例如，这些问题应该一一的考虑到。</p><ul><li><strong>分布式Session一致性</strong></li><li><strong>分布式全局ID生成方案</strong></li><li>分布式事务解决方案</li><li>分布式任务调度平台</li><li>分布式配置中心</li><li><strong>分布式锁多种实现方案</strong></li><li>分布式日志收集系统</li><li>各种网站跨域请求解决方案</li><li>高并发下服务降级与限流实战</li><li>……</li></ul><p>本次就先以分布式锁来探讨一下分布式场景下的使用与注意事项，和为什么要使用分布式锁。</p><a id="more"></a><ul><li><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。<strong>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）</strong></p></li><li><p><strong>最多只能同时满足两项</strong>。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都<strong>需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</strong></p></li><li><p>在很多场景中，我们为了<strong>保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等</strong>。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行</p></li><li><p>在单机环境中，<code>Java</code>中其实提供了很多并发处理相关的<code>API</code>，但是这些API在分布式场景中就无能为力了。也就是说单纯的<code>Java Api</code>并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案。</p></li></ul><h2 id="为什么要使用分布式锁？"><a href="#为什么要使用分布式锁？" class="headerlink" title="为什么要使用分布式锁？"></a>为什么要使用分布式锁？</h2><ul><li>原因：采用了集群的部署方案</li></ul><p><strong>如何在单台机器上生成唯一的订单号</strong></p><ul><li>UUID、时间戳、redis等。。。</li></ul><p>其实有一种取巧的解决方案，可以适当的避免突然的高并发下的服务宕机（或反应慢）的尴尬场景。</p><ul><li><strong>可以使用<code>redis</code>提前生成150W订单号（假设是在下单场景下）</strong><ul><li>提前生成好150W订单号，存放在<code>redis</code>中，当客户端下单之后，直接到<code>redis</code>中取对应的订单号即可，</li><li>因为<code>redis</code>本身是单线程的，如果<code>redis</code>还只剩下50W个订单号的时候，在继续生产100W个订单号。（这种技巧视业务场景而定，一般我们在面对需求或者发生的问题时，可以从根源下手，这种情况明显就是针对在高并发场景下能一定程度的提高程序的响应速度。提高了整个程序的健壮性。）</li></ul></li></ul><p><strong>那么如果在集群环境下使用<code>UUID</code>的方式安全嘛？</strong></p><ul><li><p>答案是肯定的，<strong>肯定是不安全的</strong>，大概率是会出现重复的<code>ID</code>的。所以<strong>这个时候就提出了分布式锁。</strong></p></li><li><p>可想而知，在多线程下我们可以简单的使用<code>Lock</code>或者<code>synchronized</code>来实现安全性，但是在分布式场景下，这些就显得力不从心了。因为这个时候在微服务场景下，很有可能同一个服务分别安装在不同的服务器上，这样的话，传统的加锁方式根本不可能保证数据的最终一致性。所以分布式锁就诞生了。</p></li></ul><p>针对分布式锁的实现，目前比较常用的有以下几种方案：</p><ul><li><strong>基于数据库实现分布式锁</strong></li><li><strong>基于缓存（redis，memcached，tair）实现分布式锁</strong></li><li><strong>基于Zookeeper实现分布式锁</strong></li></ul><p>在分析这几种实现方案之前我们先来想一下，我们需要的分布式锁应该是怎么样的？（这里以方法锁为例，资源锁同理）</p><ul><li>可以保证在分布式部署的应用集群中，<strong>同一个方法在同一时间只能被一台机器上的一个线程执行</strong>。</li><li>有<strong>高可用的获取锁和释放锁功能</strong></li><li>获取锁和释放锁的性能要好</li><li>这把锁要是一把<strong>可重入锁</strong>（避免死锁）</li><li>这把锁<strong>最好是一把阻塞锁（</strong>根据业务需求考虑要不要这条）</li></ul><h2 id="1-基于数据库实现分布式锁"><a href="#1-基于数据库实现分布式锁" class="headerlink" title="1. 基于数据库实现分布式锁"></a>1. 基于数据库实现分布式锁</h2><h3 id="1-1-基于数据表"><a href="#1-1-基于数据表" class="headerlink" title="1.1 基于数据表"></a>1.1 基于数据表</h3><ul><li>要实现分布式锁，最简单的方式可能就是直接<strong>创建一张锁表</strong>，然后通过操作该表中的数据来实现了。</li><li><strong>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，</strong></li><li><strong>想要释放锁的时候就删除这条记录。</strong></li></ul><p>创建这样一张数据库表：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091537484.png" alt="mark"></p><p>当我们想要锁住某个方法时，执行以下SQL：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091612208.png" alt="mark"></p><p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091905207.png" alt="mark"></p><ul><li><p>上面这种简单的实现有以下几个问题：</p><ul><li>这把锁强<strong>依赖数据库的可用性</strong>，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把<strong>锁没有失效时间</strong>，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把<strong>锁是非重入的</strong>，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li><li>这把锁<strong>只能是非阻塞的</strong>，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li></ul></li><li><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul></li></ul><h3 id="1-2-基于数据库的排他锁"><a href="#1-2-基于数据库的排他锁" class="headerlink" title="1.2 基于数据库的排他锁"></a>1.2 基于数据库的排他锁</h3><ul><li>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</li><li>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于<code>MySql</code>的<code>InnoDB</code>引擎，可以使用以下方法来实现加锁操作：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-092752416.png" alt="mark"></p><ul><li>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁</li><li>这里再多提一句，InnoDB引擎在加锁的时候，<strong>只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁</strong>。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。</li><li>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</li></ul><p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-092938397.png" alt="mark"></p><p>通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p><strong>问题：</strong></p><ul><li>但是还是无法直接解决数据库单点和可重入问题。</li><li>这里还可能存在另外一个问题，虽然我们对<code>method_name</code> 使用了唯一索引，并且显示使用<code>for update</code>来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</li><li>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</li></ul><p><strong>总结</strong>：</p><ul><li>这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</li></ul><h3 id="1-3-乐观锁"><a href="#1-3-乐观锁" class="headerlink" title="1.3 乐观锁"></a>1.3 乐观锁</h3><ul><li>乐观锁假设认为数据一般情况下不会造成冲突，<strong>只有在进行数据的提交更新时</strong>，才会检测数据的冲突情况，如果发现冲突了，则返回错误信息</li></ul><p>实现方式：</p><ul><li><p><strong>时间戳</strong>（timestamp）记录机制实现：<strong>给数据库表增加一个时间戳字段类型的字段</strong>，当读取数据时，将<code>timestamp</code>字段的值一同读出，数据每更新一次，<strong>timestamp也同步更新</strong></p></li><li><p>当对数据做提交更新操作时，检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，若相等，则更新，否则认为是失效数据。</p></li><li><p><strong>同样也可以使用version的方式</strong></p></li></ul><p>性能对比</p><p>（1） 悲观锁实现方式是独占数据，其它线程需要等待，不会出现修改的冲突，能够保证数据的一致性，但是依赖数据库的实现，且在线程较多时出现等待造成效率降低的问题。一般情况下，对于数据很敏感且读取频率较低的场景，可以采用悲观锁的方式</p><p>（2） 乐观锁可以多线程同时读取数据，若出现冲突，也可以依赖上层逻辑修改，能够保证高并发下的读取，适用于读取频率很高而修改频率较少的场景</p><p>（3） 由于库存回写数据属于敏感数据且读取频率适中，所以建议使用悲观锁优化</p><h2 id="2-基于Redis来实现分布式锁"><a href="#2-基于Redis来实现分布式锁" class="headerlink" title="2. 基于Redis来实现分布式锁"></a>2. 基于Redis来实现分布式锁</h2><ul><li>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。</li></ul><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li><strong>互斥性。在任意时刻，只有一个客户端能持有锁。</strong></li><li><strong>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</strong></li><li><strong>具有容错性。只要大部分的<code>redis</code>节点正常运行，客户端就可以加锁和解锁。</strong></li><li><strong>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</strong></li></ol><p>可以看到，我们加锁就一行代码：<strong>jedis.set(String key, String value, String nxxx, String expx, int time)</strong>，这个set()方法一共有五个形参：</p><p>可以看到，我们加锁就一行代码：<strong>jedis.set(String key, String value, String nxxx, String expx, int time)</strong>，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是<code>requestId</code>，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li><li>第三个为<code>nxxx</code>，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为<code>expx</code>，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为<code>time</code>，与第四个参数相呼应，代表key的过期时间。</li></ul><p><strong>总的来说</strong></p><ul><li>执行上面的set() 方法就会导致两种结果<ul><li>当前没有锁（key不存在），那么就进行加锁的操作，并对锁设置有效期，同时<code>value</code>表示加锁的客户端</li><li>已有锁存在，不做任何操作。</li></ul></li></ul><ul><li><strong>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性</strong></li><li><strong>其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</strong></li><li><strong>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</strong></li></ul><p><strong>解锁操作：</strong></p><ul><li>首先获取锁对应的value值，检查是否与<code>requestId</code>相等，如果相等则删除锁（解锁）</li></ul><p><strong>总结：</strong></p><ul><li><p>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，</p></li><li><p>同时，很多缓存服务都是<strong>集群部署</strong>的，可以避免单点问题。</p></li><li><p>并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如<code>redis</code>的<code>setnx</code>方法等。</p></li><li><p>并且，这些缓存服务也都提供了<strong>对数据的过期自动删除的支持</strong>，可以直接设置超时时间来控制锁的释放。</p></li></ul><h2 id="3-基于Zookeeper-实现分布式锁"><a href="#3-基于Zookeeper-实现分布式锁" class="headerlink" title="3. 基于Zookeeper 实现分布式锁"></a>3. 基于Zookeeper 实现分布式锁</h2><ul><li>基于<code>zookeeper</code><strong>临时有序节点</strong>可以实现的分布式锁。</li><li><strong>大致思想</strong><ul><li>每个客户端对某个方法加锁时，在<code>zookeeper</code>上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。</li><li><strong>判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。</strong></li><li><strong>当释放锁的时候，只需将这个瞬时节点删除即可。</strong></li><li>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</li></ul></li></ul><p>来看下Zookeeper能不能解决前面提到的问题。</p><ul><li><p><strong>锁无法释放？</strong>使用<code>Zookeeper</code>可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p></li><li><p><strong>非阻塞锁？</strong>  使用<code>Zookeeper</code>可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，<code>Zookeeper</code>会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p></li><li><p><strong>不可重入？</strong>使用<code>Zookeeper</code>也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p></li><li><p><strong>单点问题？</strong>使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p></li></ul><p>可以直接使用zookeeper第三方库<a href="https://curator.apache.org/" target="_blank" rel="noopener">Curator</a>客户端，这个客户端中封装了一个可重入的锁服务。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-094429707.png" alt="mark"></p><ul><li>Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。</li><li>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。</li><li>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。</li></ul><p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。</p><p>这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p><p><strong>总结</strong></p><ul><li><p>使用Zookeeper实现分布式锁的优点</p></li><li><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p></li><li><p>使用Zookeeper实现分布式锁的缺点</p></li><li><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p></li></ul><h2 id="4-三种方案的比较"><a href="#4-三种方案的比较" class="headerlink" title="4. 三种方案的比较"></a>4. 三种方案的比较</h2><p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><h4 id="从理解的难易程度角度（从低到高）"><a href="#从理解的难易程度角度（从低到高）" class="headerlink" title="从理解的难易程度角度（从低到高）"></a>从理解的难易程度角度（从低到高）</h4><p>数据库 &gt; 缓存 &gt; Zookeeper</p><h4 id="从实现的复杂性角度（从低到高）"><a href="#从实现的复杂性角度（从低到高）" class="headerlink" title="从实现的复杂性角度（从低到高）"></a>从实现的复杂性角度（从低到高）</h4><p>Zookeeper &gt;= 缓存 &gt; 数据库</p><h4 id="从性能角度（从高到低）"><a href="#从性能角度（从高到低）" class="headerlink" title="从性能角度（从高到低）"></a>从性能角度（从高到低）</h4><p>缓存 &gt; Zookeeper &gt;= 数据库</p><h4 id="从可靠性角度（从高到低）"><a href="#从可靠性角度（从高到低）" class="headerlink" title="从可靠性角度（从高到低）"></a>从可靠性角度（从高到低）</h4><p>Zookeeper &gt; 缓存 &gt; 数据库</p><p><strong>参考博客：</strong> <a href="https://www.jianshu.com/p/a44c1c47bcee" target="_blank" rel="noopener">https://www.jianshu.com/p/a44c1c47bcee</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为什么要使用分布式锁呢？&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Nginx&lt;/code&gt;实现负载均衡服务器集群时会产生很多问题，在提高并发的同时，服务器也会产生非常多的问题例如，这些问题应该一一的考虑到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式Session一致性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式全局ID生成方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分布式事务解决方案&lt;/li&gt;
&lt;li&gt;分布式任务调度平台&lt;/li&gt;
&lt;li&gt;分布式配置中心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式锁多种实现方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分布式日志收集系统&lt;/li&gt;
&lt;li&gt;各种网站跨域请求解决方案&lt;/li&gt;
&lt;li&gt;高并发下服务降级与限流实战&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次就先以分布式锁来探讨一下分布式场景下的使用与注意事项，和为什么要使用分布式锁。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-14-MVCC实现</title>
    <link href="http://zhuuu.work/2020/09/04/Mysql/Mysql-14-MVCC%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhuuu.work/2020/09/04/Mysql/Mysql-14-MVCC%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-09-04T08:02:27.000Z</published>
    <updated>2020-09-21T11:02:34.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-14-MVCC实现"><a href="#Mysql-14-MVCC实现" class="headerlink" title="Mysql-14-MVCC实现"></a>Mysql-14-MVCC实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>MVCC (Multiversion Concurrency Control)</code> 中文叫<strong>多版本并发控制</strong>，是现代数据库（包括 <code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code> 等）引擎实现中常用的处理读写冲突的手段，<strong>目的在于提高数据库高并发场景下的吞吐性能</strong>。</li><li>如此一来不同的事务在并发过程中，<code>SELECT</code> 操作可以不加锁而是通过 <code>MVCC</code> 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。</li></ul><p>下面举一个多版本读的例子，例如两个事务 <code>A</code> 和 <code>B</code> 按照如下顺序进行更新和读取操作</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/164638522.png" alt="mark"></p><a id="more"></a><p>在事务 <code>A</code> 提交前后，事务 <code>B</code> 读取到的 <code>x</code> 的值是什么呢？答案是：事务 <code>B</code> 在不同的隔离级别下，读取到的值不一样。</p><ol><li>如果事务 <code>B</code> 的隔离级别是<strong>读未提交（RU）</strong>，那么两次读取均读取到 <code>x</code> 的最新值，即 <code>20</code>。</li><li>如果事务 <code>B</code> 的隔离级别是<strong>读已提交（RC）</strong>，那么第一次读取到旧值 <code>10</code>，第二次因为事务 <code>A</code> 已经提交，则读取到新值 20。</li><li>如果事务 <code>B</code> 的隔离级别是可重复读或者串行（RR，S），则两次均读到旧值 <code>10</code>，不论事务 <code>A</code> 是否已经提交。</li></ol><p>可见在不同的隔离级别下，数据库通过 <code>MVCC</code> 和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性。</p><h2 id="1-为什么需要MVCC"><a href="#1-为什么需要MVCC" class="headerlink" title="1. 为什么需要MVCC ?"></a>1. 为什么需要MVCC ?</h2><ul><li><code>InnoDB</code> 相比 <code>MyISAM</code> 有两大特点，一是支持事务 二是支持行级锁，事务的引入带来了一些新的挑战。相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况：<ul><li><strong>更新丢失（<code>Lost Update</code>）</strong>：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。如何避免这个问题呢，最好在一个事务对数据进行更改但还未提交时，其他事务不能访问修改同一个数据。</li><li><strong>脏读</strong>（<code>Dirty Reads</code>）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些尚未提交的脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做 <strong>“脏读”</strong>。</li><li><strong>不可重复读</strong>（<code>Non-Repeatable Reads</code>）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li><li><strong>幻读（<code>Phantom Reads</code>）</strong>：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为 <strong>“幻读”</strong>。</li></ul></li></ul><p>以上是并发事务过程中会存在的问题，解决更新丢失可以交给应用，但是后三者需要数据库提供事务间的隔离机制来解决。实现隔离机制的方法主要有两种：</p><ol><li><strong>加读写锁</strong></li><li><strong>一致性快照读，即 <code>MVCC</code></strong></li></ol><h2 id="2-InnoDB-中的-MVCC"><a href="#2-InnoDB-中的-MVCC" class="headerlink" title="2. InnoDB 中的 MVCC"></a>2. <strong>InnoDB 中的 MVCC</strong></h2><ul><li>本文聚焦于 <code>MySQL</code> 中的 <code>MVCC</code> 实现，从 <code>《高性能 MySQL》</code>一书中对 <code>MVCC</code> 的介绍可知：<ul><li><code>MySQL</code> 中 <code>InnoDB</code> 引擎支持 <code>MVCC</code></li><li>应对高并发事务, <code>MVCC</code> 比单纯的加行锁更有效, 开销更小</li><li><code>MVCC</code> 在读已提交<code>（Read Committed）</code>和可重复读<code>（Repeatable Read）</code>隔离级别下起作用</li><li><code>MVCC</code> 既可以基于<strong>乐观锁</strong>又可以基于<strong>悲观锁</strong>来实现</li></ul></li></ul><h3 id="2-1-实现原理"><a href="#2-1-实现原理" class="headerlink" title="2.1 实现原理"></a>2.1 实现原理</h3><ul><li><code>InnoDB</code> 中 <code>MVCC</code> 的实现方式为：每一行记录都有两个隐藏列：<code>DATA_TRX_ID</code>、<code>DATA_ROLL_PTR</code>（如果没有主键，则还会多一个隐藏的主键列）。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/165844142.png" alt="mark"></p><ol><li><h3 id="DATA-TRX-ID"><a href="#DATA-TRX-ID" class="headerlink" title="DATA_TRX_ID"></a><strong>DATA_TRX_ID</strong></h3></li></ol><ul><li>记录最近更新这条行记录的<code>事务 ID</code>，大小为 <code>6</code> 个字节</li></ul><ol start="2"><li><h3 id="DATA-ROLL-PTR"><a href="#DATA-ROLL-PTR" class="headerlink" title="DATA_ROLL_PTR"></a><strong>DATA_ROLL_PTR</strong></h3></li></ol><ul><li>表示指向该行回滚段<code>（rollback segment）</code>的指针，大小为 <code>7</code> 个字节</li><li><code>InnoDB</code> 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 <code>undo</code> 中都通过链表的形式组织。</li></ul><ol start="3"><li><h3 id="DB-ROW-ID"><a href="#DB-ROW-ID" class="headerlink" title="DB_ROW_ID"></a><strong>DB_ROW_ID</strong></h3></li></ol><ul><li>行标识（隐藏单调自增 <code>ID</code>），大小为 <code>6</code> 字节，如果表没有主键，<code>InnoDB</code> 会自动生成一个隐藏主键，因此会出现这个列。</li><li>另外，每条记录的头信息（<code>record header</code>）里都有一个专门的 <code>bit</code>（<code>deleted_flag</code>）来表示当前记录是否已经被删除。</li></ul><h3 id="2-2-Undo-Log-链"><a href="#2-2-Undo-Log-链" class="headerlink" title="2.2 Undo Log 链"></a>2.2 Undo Log 链</h3><p><strong>Undo Log 概念</strong></p><ul><li>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。</li></ul><p><strong>Undo log 的用途</strong></p><p>（1）保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p><p>（2）用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p><ul><li>上文提到，在多个事务并行操作某行数据的情况下，不同事务对该行数据的 UPDATE 会产生多个版本，然后通过回滚指针组织成一条 <code>Undo Log</code> 链</li><li>这节我们通过一个简单的例子来看一下 <code>Undo Log</code> 链是如何组织的，<code>DATA_TRX_ID</code> 和 <code>DATA_ROLL_PTR</code> 两个参数在其中又起到什么样的作用。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/170245411.png" alt="mark"></p><p>事务 <code>A</code> 的操作过程为：</p><ul><li>对 <code>DB_ROW_ID = 1</code> 的这行记录加排他锁</li><li>把该行原本的值拷贝到 <code>undo log</code> 中，<code>DB_TRX_ID</code> 和 <code>DB_ROLL_PTR</code> 都不动</li><li>修改该行的值这时产生一个新版本，更新 <code>DATA_TRX_ID</code> 为修改记录的事务 <code>ID</code> ,将 <code>DATA_ROLL_PTR</code> 指向刚刚拷贝到 <code>undo log</code> 链中的旧版本记录，这样就能通过 <code>DB_ROLL_PTR</code> 找到这条记录的历史版本。</li><li>如果对同一行记录执行连续的 <code>UPDATE</code>，<code>Undo Log</code> 会组成一个链表，遍历这个链表可以看到这条记录的变迁</li><li>记录 <code>redo log</code>，包括 <code>undo log</code> 中的修改</li></ul><p>那么 <code>INSERT</code> 和 <code>DELETE</code> 会怎么做呢？</p><ul><li>其实相比 <code>UPDATE</code> 这二者很简单，</li><li><code>INSERT</code> 会产生一条新纪录，它的 <code>DATA_TRX_ID</code> 为当前插入记录的事务 <code>ID</code>；</li><li><code>DELETE</code> 某条记录时可看成是一种特殊的 <code>UPDATE</code>，其实是软删，真正执行删除操作会在 <code>commit</code> 时，<code>DATA_TRX_ID</code> 则记录下删除该记录的事务 <code>ID</code>。</li></ul><h3 id="2-3-一致性读"><a href="#2-3-一致性读" class="headerlink" title="2.3 一致性读"></a>2.3 一致性读</h3><ul><li>在 <code>RU</code> 隔离级别下，直接读取版本的最新记录就 OK，对于 <code>SERIALIZABLE</code> 隔离级别，则是通过加锁互斥来访问数据，因此不需要 <code>MVCC</code> 的帮助。</li><li>因此 <code>MVCC</code> 运行在 <code>RC</code> 和 <code>RR</code> 这两个隔离级别下，当 <code>InnoDB</code> 隔离级别设置为二者其一时，在 <code>SELECT</code> 数据时就会用到版本链</li></ul><blockquote><p>核心问题是版本链中哪些版本对当前事务可见？</p></blockquote><p><code>InnoDB</code> 为了解决这个问题，设计了 <code>ReadView</code>（可读视图）的概念。</p><h4 id="2-3-1-RR-下的-ReadView-生成"><a href="#2-3-1-RR-下的-ReadView-生成" class="headerlink" title="2.3.1 RR 下的 ReadView 生成"></a>2.3.1 <strong>RR 下的 ReadView 生成</strong></h4><ul><li>在 <code>RR</code> 隔离级别下，每个事务 <code>touch first read</code> 时（本质上就是执行第一个 <code>SELECT</code> 语句时，后续所有的 <code>SELECT</code> 都是复用这个 <code>ReadView</code>，其它 <code>update</code>, <code>delete</code>, <code>insert</code> 语句和一致性读 <code>snapshot</code> 的建立没有关系），会将当前系统中的所有的活跃事务拷贝到一个列表生成<code>ReadView</code>。</li><li>下图中事务 <code>A</code> 第一条 <code>SELECT</code> 语句在事务 <code>B</code> 更新数据前，因此生成的 <code>ReadView</code> 在事务 <code>A</code> 过程中不发生变化，即使事务 <code>B</code> 在事务 <code>A</code> 之前提交，但是事务 <code>A</code> 第二条查询语句依旧无法读到事务 <code>B</code> 的修改。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/170739614.png" alt="mark"></p><p>下图中，事务 <code>A</code> 的第一条 <code>SELECT</code> 语句在事务 <code>B</code> 的修改提交之后，因此可以读到事务 <code>B</code> 的修改。<strong>但是注意，如果事务 <code>A</code> 的第一条 <code>SELECT</code> 语句查询时，事务 <code>B</code> 还未提交，那么事务 <code>A</code> 也查不到事务 <code>B</code> 的修改。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/172156851.png" alt="mark"></p><h4 id="2-3-2-RC-下的-ReadView-生成"><a href="#2-3-2-RC-下的-ReadView-生成" class="headerlink" title="2.3.2 RC 下的 ReadView 生成"></a>2.3.2 <strong>RC 下的 ReadView 生成</strong></h4><ul><li>在 <code>RC</code> 隔离级别下，每个 <code>SELECT</code> 语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 <code>ReadView</code>。二者的区别就在于生成 <code>ReadView</code> 的时间点不同，一个是事务之后第一个 <code>SELECT</code> 语句开始、一个是事务中每条 <code>SELECT</code> 语句开始。<ul><li>如果被访问版本的 <code>trx_id</code> 小于 <code>m_ids</code> 中的最小值 <code>up_limit_id</code>，说明生成该版本的事务在 <code>ReadView</code> 生成前就已经提交了，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 <code>trx_id</code> 大于 <code>m_ids</code> 列表中的最大值 <code>low_limit_id</code>，说明生成该版本的事务在生成 <code>ReadView</code> 后才生成，所以该版本不可以被当前事务访问。需要根据 <code>Undo Log</code> 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。</li><li>如果被访问版本的 <code>trx_id</code> 属性值在 <code>m_ids</code> 列表中最大值和最小值之间（包含），那就需要判断一下 <code>trx_id</code> 的值是不是在 <code>m_ids</code> 列表中。如果在，说明创建 <code>ReadView</code> 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 <code>DB_TRX_ID</code> 再从头计算一次可见性；如果不在，说明创建 <code>ReadView</code> 时生成该版本的事务已经被提交，该版本可以被访问。</li><li>此时经过一系列判断我们已经得到了这条记录相对 <code>ReadView</code> 来说的可见结果。此时，如果这条记录的 <code>delete_flag</code> 为 <code>true</code>，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/172304901.png" alt="mark"></p><p><strong>举个例子</strong></p><p><strong>RC 下的 MVCC 判断流程</strong></p><ul><li>我们现在回看刚刚的查询过程，为什么事务 <code>B</code> 在 <code>RC</code> 隔离级别下，两次查询的 <code>x</code> 值不同。<code>RC</code> 下 <code>ReadView</code> 是在语句粒度上生成的。</li><li>当事务 <code>A</code> 未提交时，事务 <code>B</code> 进行查询，假设事务 <code>B</code> 的事务 <code>ID</code> 为 <code>300</code>，此时生成 <code>ReadView</code> 的 <code>m_ids</code> 为 [200，300]，而最新版本的 <code>trx_id</code> 为 <code>200</code>，处于 <code>m_ids</code> 中，则该版本记录不可被访问，查询版本链得到上一条记录的 trx_id 为 <code>100</code>，小于 <code>m_ids</code> 的最小值 <code>200</code>，因此可以被访问，此时事务 <code>B</code> 就查询到值 <code>10</code> 而非 <code>20</code>。</li><li>待事务 <code>A</code> 提交之后，事务 <code>B</code> 进行查询，此时生成的 <code>ReadView</code> 的 <code>m_ids</code> 为 [300]，而最新的版本记录中 <code>trx_id</code> 为 <code>200</code>，小于 <code>m_ids</code> 的最小值 <code>300</code>，因此可以被访问到，此时事务 <code>B</code> 就查询到 <code>20</code>。</li></ul><p><strong>RR 下的 MVCC 判断流程</strong></p><ul><li>如果在 <code>RR</code> 隔离级别下，为什么事务 <code>B</code> 前后两次均查询到 <code>10</code> 呢？</li><li><code>RR</code> 下生成 <code>ReadView</code> 是在事务开始时，m_ids 为 [200,300]，后面不发生变化，</li><li>因此即使事务 <code>A</code> 提交了，<code>trx_id</code> 为 <code>200</code> 的记录依旧处于 <code>m_ids</code> 中，不能被访问，只能访问版本链中的记录 <code>10</code>。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li><code>RC</code>、<code>RR</code> 两种隔离级别的事务在执行普通的读操作时，通过访问版本链的方法，使得事务间的读写操作得以并发执行，从而提升系统性能。</li><li><code>RC</code>、<code>RR</code> 这两个隔离级别的一个很大不同就是生成 <code>ReadView</code> 的时间点不同，<code>RC</code> 在每一次 <code>SELECT</code> 语句前都会生成一个 <code>ReadView</code>，事务期间会更新，因此在其他事务提交前后所得到的 <code>m_ids</code> 列表可能发生变化，使得先前不可见的版本后续又突然可见了。</li><li>而 <code>RR</code> 只在事务的第一个 <code>SELECT</code> 语句时生成一个 <code>ReadView</code>，事务操作期间不更新。</li></ul><p>参考博客 ： <a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52977862</a></p><p>​                 <a href="https://zhuanlan.zhihu.com/p/64576887" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64576887</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-14-MVCC实现&quot;&gt;&lt;a href=&quot;#Mysql-14-MVCC实现&quot; class=&quot;headerlink&quot; title=&quot;Mysql-14-MVCC实现&quot;&gt;&lt;/a&gt;Mysql-14-MVCC实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MVCC (Multiversion Concurrency Control)&lt;/code&gt; 中文叫&lt;strong&gt;多版本并发控制&lt;/strong&gt;，是现代数据库（包括 &lt;code&gt;MySQL&lt;/code&gt;、&lt;code&gt;Oracle&lt;/code&gt;、&lt;code&gt;PostgreSQL&lt;/code&gt; 等）引擎实现中常用的处理读写冲突的手段，&lt;strong&gt;目的在于提高数据库高并发场景下的吞吐性能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如此一来不同的事务在并发过程中，&lt;code&gt;SELECT&lt;/code&gt; 操作可以不加锁而是通过 &lt;code&gt;MVCC&lt;/code&gt; 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面举一个多版本读的例子，例如两个事务 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 按照如下顺序进行更新和读取操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/164638522.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分库分表" scheme="http://zhuuu.work/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-13-分库分表</title>
    <link href="http://zhuuu.work/2020/09/03/Mysql/Mysql-13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/09/03/Mysql/Mysql-13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2020-09-03T08:02:27.000Z</published>
    <updated>2020-09-18T08:30:45.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-13-分库分表"><a href="#Mysql-13-分库分表" class="headerlink" title="Mysql-13-分库分表"></a>Mysql-13-分库分表</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>当一张表的数据达到几千万时，查询一次所花的时间会变长。业界公认MySQL单表容量在 <strong>1千万</strong> 以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。</li><li>数据切分可以分为：<code>垂直切分</code>和<code>水平切分</code>。</li></ul><a id="more"></a><h2 id="1-垂直切分"><a href="#1-垂直切分" class="headerlink" title="1. 垂直切分"></a>1. 垂直切分</h2><ul><li>垂直切分又可以分为: <code>垂直分库</code>和<code>垂直分表</code>。</li></ul><h3 id="1-1-垂直分库"><a href="#1-1-垂直分库" class="headerlink" title="1.1 垂直分库"></a>1.1 垂直分库</h3><p><code>概念</code> 就是<strong>根据业务耦合性，将关联度低的不同表存储在不同的数据库</strong>。<strong>做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与”微服务治理”的做法相似，</strong></p><ul><li>每个微服务使用单独的一个数据库。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/164635785.png" alt="mark"></p><p><strong>说明：</strong></p><p>一开始我们是单体服务，所以只有一个数据库，所有的表都在这个库里。</p><p>后来因为业务需求,单体服务变成微服务治理。所以将之前的一个商品库，拆分成多个数据库。每个微服务对于一个数据库。</p><h3 id="1-2-垂直分表"><a href="#1-2-垂直分表" class="headerlink" title="1.2 垂直分表"></a>1.2 垂直分表</h3><ul><li><code>概念</code> 把一个表的多个字段分别拆成多个表，一般按字段的冷热拆分，热字段一个表，冷字段一个表。从而提升了数据库性能。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/164630656.png" alt="mark"></p><p>说明：</p><p>一开始商品表中包含商品的所有字段，但是我们发现:</p><p><code>1.商品详情和商品属性字段较长</code>。</p><p><code>2.商品列表的时候我们是不需要显示商品详情和商品属性信息，只有在点进商品商品的时候才会展示商品详情信息</code>。</p><p>所以可以考虑把商品详情和商品属性单独切分一张表，提高查询效率。</p><h3 id="1-3-垂直拆分优缺点"><a href="#1-3-垂直拆分优缺点" class="headerlink" title="1.3 垂直拆分优缺点"></a>1.3 垂直拆分优缺点</h3><p><strong>优点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 解决业务系统层面的耦合，业务清晰</span><br><span class="line">- 与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</span><br><span class="line">- 高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 分库后无法Join，只能通过接口聚合方式解决，提升了开发的复杂度</span><br><span class="line">- 分库后分布式事务处理复杂</span><br><span class="line">- 依然存在单表数据量过大的问题（需要水平切分）</span><br></pre></td></tr></table></figure><h2 id="2-水平切分"><a href="#2-水平切分" class="headerlink" title="2. 水平切分"></a>2. 水平切分</h2><p><strong>产生的原因：</strong></p><ul><li>当一个应用难以再细粒度的垂直切分或切分后数据量行数巨大,</li><li>存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。</li></ul><p><strong>这时候需要考虑水平切分了</strong></p><h3 id="2-1-水平切分"><a href="#2-1-水平切分" class="headerlink" title="2.1 水平切分"></a>2.1 水平切分</h3><p>原因： 上面虽然已经把商品库分成3个库，但是随着业务的增加一个订单库也出现QPS过高，数据库响应速度来不及,<strong>一般mysql单机也就1000左右的QPS</strong>，如果超过1000就要考虑分库。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/170142138.png" alt="mark"></p><h3 id="2-2-水平分表"><a href="#2-2-水平分表" class="headerlink" title="2.2 水平分表"></a>2.2 水平分表</h3><ul><li><code>概念</code> <strong>一般我们一张表的数据不要超过1千万,如果表数据超过1千万，并且还在不断增加数据，那就可以考虑分表。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/170553161.png" alt="mark"></p><h3 id="2-3-水平拆分优缺点"><a href="#2-3-水平拆分优缺点" class="headerlink" title="2.3 水平拆分优缺点"></a>2.3 水平拆分优缺点</h3><p><strong>优点</strong></p><ul><li><strong>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</strong></li><li>应用端改造较小，不需要拆分业务模块</li></ul><p><strong>缺点</strong></p><ul><li>跨分片的事务一致性难以保证</li><li>跨库的Join关联查询性能较差</li><li>数据多次扩展难度和维护量极大</li></ul><h2 id="3-数据分片规则"><a href="#3-数据分片规则" class="headerlink" title="3. 数据分片规则"></a>3. 数据分片规则</h2><ul><li>我们我们考虑去水平切分表，将一张表水平切分成多张表，这就涉及到数据分片的规则，比较常见的有：<code>Hash取模分表</code>、<code>数值Range分表</code>、<code>一致性Hash算法分表</code>。</li></ul><h3 id="3-1-hash-取模分表"><a href="#3-1-hash-取模分表" class="headerlink" title="3.1 hash 取模分表"></a>3.1 hash 取模分表</h3><ul><li>一般采用Hash取模的切分方式，例如：假设按goods_id分4张表。（goods_id%4 取整确定表）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/171007587.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line"> - 数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈。</span><br><span class="line">缺点</span><br><span class="line">- 后期分片集群扩容时，需要迁移旧的数据很难。</span><br><span class="line">- 容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带goods_id时,将会导致无法定位数据库,从而需要同时向4个库发起查询，</span><br><span class="line">再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</span><br></pre></td></tr></table></figure><h3 id="3-2-范围-range分表"><a href="#3-2-范围-range分表" class="headerlink" title="3.2 范围 range分表"></a>3.2 范围 range分表</h3><p><code>概念</code> 按照时间区间或ID区间来切分。</p><p>​        例如：将goods_id为1 - 1000的记录分到第一个表，1001–2000的分到第二个表，以此类推。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/171123540.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">- 单表大小可控</span><br><span class="line">- 天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</span><br><span class="line">- 使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</span><br><span class="line">缺点</span><br><span class="line">- 热点数据成为性能瓶颈。</span><br><span class="line">例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询</span><br></pre></td></tr></table></figure><h3 id="3-3-一致性-hash-算法"><a href="#3-3-一致性-hash-算法" class="headerlink" title="3.3 一致性 hash 算法"></a>3.3 一致性 hash 算法</h3><ul><li>一致性Hash算法能很好的<code>解决因为Hash取模而产生的分片集群扩容时，需要迁移旧的数据的难题</code>。至于具体原理这里就不详细说，</li></ul><h2 id="4-分库分表带来的问题"><a href="#4-分库分表带来的问题" class="headerlink" title="4. 分库分表带来的问题"></a>4. 分库分表带来的问题</h2><p>任何事情都有两面性，分库分表也不例外，如果采用分库分表，会引入新的的问题</p><h4 id="1、分布式事务问题"><a href="#1、分布式事务问题" class="headerlink" title="1、分布式事务问题"></a>1、分布式事务问题</h4><p>使用分布式事务中间件解决，具体是通过<strong>最终一致性还是强一致性分布式事务</strong>，看业务需求，这里就不多说。</p><h4 id="2、跨节点关联查询-Join-问题"><a href="#2、跨节点关联查询-Join-问题" class="headerlink" title="2、跨节点关联查询 Join 问题"></a>2、跨节点关联查询 Join 问题</h4><p>切分之前，我们可以通过Join来完成。而切分之后，数据可能分布在不同的节点上，此时Join带来的问题就比较麻烦了，考虑到性能，尽量避免使用Join查询。</p><p>解决这个问题的一些方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全局表</span><br></pre></td></tr></table></figure><p>全局表，也可看做是 “<strong>数据字典表</strong>“，就是系统中所有模块都可能依赖的一些表，为了避免跨库Join查询，可以将 <strong>这类表在每个数据库中都保存一份</strong>。这些数据通常</p><p>很少会进行修改，所以也不担心一致性的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段冗余</span><br></pre></td></tr></table></figure><p><strong>利用空间换时间，为了性能而避免join查询</strong>。例：订单表保存userId时候,也将userName冗余保存一份，这样查询订单详情时就不需要再去查询”买家user表”了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据组装</span><br></pre></td></tr></table></figure><p><strong>在系统层面，分两次查询</strong>。第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</p><h4 id="3、跨节点分页、排序、函数问题"><a href="#3、跨节点分页、排序、函数问题" class="headerlink" title="3、跨节点分页、排序、函数问题"></a>3、跨节点分页、排序、函数问题</h4><ul><li>跨节点多库进行查询时，会出现Limit分页、Order by排序等问题。分页需要按照指定字段进行排序，<strong>当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；</strong></li><li><strong>当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。</strong></li></ul><h4 id="4、全局主键避重问题"><a href="#4、全局主键避重问题" class="headerlink" title="4、全局主键避重问题"></a>4、全局主键避重问题</h4><p>如果都用<code>主键自增</code>肯定不合理，如果用<code>UUID</code>那么无法做到根据主键排序，所以我们可以考虑通过<code>雪花ID</code>来作为数据库的主键，</p><p>有关雪花ID可以参考博客：<a href="https://www.cnblogs.com/qdhxhz/p/11372658.html" target="_blank" rel="noopener">静态内部类单例模式实现雪花算法</a></p><h4 id="5、数据迁移问题"><a href="#5、数据迁移问题" class="headerlink" title="5、数据迁移问题"></a>5、数据迁移问题</h4><ul><li>采用<code>双写的方式</code>，修改代码，所有涉及到分库分表的表的增、删、改的代码，都要对新库进行增删改。同时，再有一个数据抽取服务，不断地从老库抽数据，往新库写，</li><li>边写边按时间比较数据是不是最新的。</li></ul><p><strong>参考博客 ：</strong> <a href="https://www.cnblogs.com/qdhxhz/p/11608222.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/11608222.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-13-分库分表&quot;&gt;&lt;a href=&quot;#Mysql-13-分库分表&quot; class=&quot;headerlink&quot; title=&quot;Mysql-13-分库分表&quot;&gt;&lt;/a&gt;Mysql-13-分库分表&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当一张表的数据达到几千万时，查询一次所花的时间会变长。业界公认MySQL单表容量在 &lt;strong&gt;1千万&lt;/strong&gt; 以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。&lt;/li&gt;
&lt;li&gt;数据切分可以分为：&lt;code&gt;垂直切分&lt;/code&gt;和&lt;code&gt;水平切分&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分库分表" scheme="http://zhuuu.work/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-ClassLoader详解</title>
    <link href="http://zhuuu.work/2020/09/01/JavaInterview/Java-%E5%9F%BA%E7%A1%80-ClassLoader%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/09/01/JavaInterview/Java-%E5%9F%BA%E7%A1%80-ClassLoader%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-09-01T06:34:38.000Z</published>
    <updated>2020-09-26T01:20:10.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-ClassLoader详解"><a href="#Java-基础-ClassLoader详解" class="headerlink" title="Java-基础-ClassLoader详解"></a>Java-基础-ClassLoader详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p><code>ClassLoader</code>翻译过来就是类加载器，普通的java开发者其实用到的不多，但对于某些框架开发者来说却非常常见。</p></li><li><p>理解<code>ClassLoader</code>的加载机制，也有利于我们编写出更高效的代码。</p></li><li><p><code>ClassLoader</code>的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，<code>jvm</code>启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。</p></li><li><p>想想也是的，一次性加载那么多jar包那么多class，那内存不崩溃。本文的目的也是学习<code>ClassLoader</code>这种加载机制。</p></li></ul><a id="more"></a><h2 id="1-Class-文件"><a href="#1-Class-文件" class="headerlink" title="1. Class 文件"></a>1. Class 文件</h2><ul><li>我们都知道在Java中程序是运行在虚拟机中，我们平常用文本编辑器或者是IDE编写的程序都是.java格式的文件，这是最基础的源码，但这类文件是不能直接运行的。如我们编写一个简单的程序<code>HelloWorld.java</code></li></ul><p>如图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200923/211656521.png" alt="mark"></p><ul><li>然后，我们需要在命令行中进行java文件的编译</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200923/211710053.png" alt="mark"></p><p>可以看到目录下生成了.class文件</p><p>我们再从命令行中执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200923/212008863.png" alt="mark"></p><ul><li>上面是基本代码示例，是所有入门JAVA语言时都学过的东西，这里重新拿出来是想让大家将焦点回到class文件上，class文件是字节码格式文件，java虚拟机并不能直接识别我们平常编写的.java源文件，所以需要javac这个命令转换成.class文件。</li><li>另外，如果用C或者PYTHON编写的程序正确转换成.class文件后，java虚拟机也是可以识别运行的。更多信息大家可以参考<a href="http://blog.csdn.net/zhangjg_blog/article/details/21486985" target="_blank" rel="noopener">这篇</a>。</li></ul><h2 id="2-java环境变量"><a href="#2-java环境变量" class="headerlink" title="2. java环境变量"></a>2. java环境变量</h2><ul><li>初学java的时候，最害怕的就是下载JDK后要配置环境变量了，关键是当时不理解，所以战战兢兢地照着书籍上或者是网络上的介绍进行操作。然后下次再弄的时候，又忘记了而且是必忘。当时，心里的想法很气愤的，想着是–这东西一点也不人性化，为什么非要自己配置环境变量呢？太不照顾菜鸟和新手了，很多菜鸟就是因为卡在环境变量的配置上，遭受了太多的挫败感。</li><li>因为我是在Windows下编程的，所以只讲Window平台上的环境变量，主要有3个：<strong>JAVA_HOME</strong>、<strong>PATH</strong>、<strong>CLASSPATH</strong>。</li></ul><h3 id="2-1-JAVA-HOME"><a href="#2-1-JAVA-HOME" class="headerlink" title="2.1 JAVA_HOME"></a>2.1 JAVA_HOME</h3><ul><li>指的是你JDK安装的位置，一般默认安装在C盘，如</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_91</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-PATH"><a href="#2-2-PATH" class="headerlink" title="2.2 PATH"></a>2.2 PATH</h3><ul><li>将程序路径包含在PATH当中后，在命令行窗口就可以直接键入它的名字了，而不再需要键入它的全路径,比如上面代码中我用的到<code>javac</code>和<code>java</code>两个命令。</li><li>一般的</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PATH</span>=<span class="variable">%JAVA_HOME%</span>\bin;<span class="variable">%JAVA_HOME%</span>\jre\bin;<span class="variable">%PATH%</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-CLASSPATH"><a href="#2-3-CLASSPATH" class="headerlink" title="2.3 CLASSPATH"></a>2.3 CLASSPATH</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH=.;<span class="variable">%JAVA_HOME%</span>\lib;<span class="variable">%JAVA_HOME%</span>\lib\tools.jar</span><br></pre></td></tr></table></figure><ul><li>一看就是指向jar包路径。<br>需要注意的是前面的<code>.;</code>，<code>.</code>代表当前目录。</li></ul><p>好了，扯远了，知道了环境变量，特别是CLASSPATH时，我们进入今天的主题Classloader.</p><h2 id="3-类加载的流程"><a href="#3-类加载的流程" class="headerlink" title="3. 类加载的流程"></a>3. 类加载的流程</h2><h3 id="3-1-双亲委派类加载器"><a href="#3-1-双亲委派类加载器" class="headerlink" title="3.1 双亲委派类加载器"></a>3.1 双亲委派类加载器</h3><ul><li><strong>Bootstrap ClassLoader</strong> 最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如<code>java -Xbootclasspath/a:path</code>被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。</li><li><strong>Extention ClassLoader</strong> 扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载<code>-D java.ext.dirs</code>选项指定的目录。</li><li><strong>Appclass Loader也称为SystemAppClass</strong> 加载当前应用的classpath的所有类。</li></ul><p>我们看到了系统的3个类加载器，但我们可能不知道具体哪个先行呢？<br>我可以先告诉你答案</p><ol><li><code>Bootstrap CLassloder</code></li><li><code>Extention ClassLoader</code></li><li><code>AppClassLoader</code></li></ol><p>为了更好的理解，我们可以查看源码。<br>看<a href="http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java" target="_blank" rel="noopener">sun.misc.Launcher</a>,它是一个java虚拟机的入口应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath =</span><br><span class="line">        System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create extension class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create application class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Returns the class loader used to launch the main application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">     * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>源码有精简，我们可以得到相关的信息。</p><ol><li><code>Launcher</code>初始化了<code>ExtClassLoader</code>和<code>AppClassLoader</code>。</li><li>Launcher中并没有看见<code>BootstrapClassLoader</code>，但通过<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>得到了字符串<code>bootClassPath</code>,这个应该就是<code>BootstrapClassLoader</code>加载的jar包路径。</li></ol><p>得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\resources.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\rt.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\sunrsasign.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jsse.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jce.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\charsets.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jfr.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\classes</span><br></pre></td></tr></table></figure><p>可以看到，这些全是JRE目录下的jar包或者是class文件。</p><h3 id="3-2-ExtClassLoader-源码"><a href="#3-2-ExtClassLoader-源码" class="headerlink" title="3.2 ExtClassLoader 源码"></a>3.2 ExtClassLoader 源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            ClassLoader.registerAsParallelCapable();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * create an ExtClassLoader. The ExtClassLoader is created</span></span><br><span class="line"><span class="comment">         * within a context that limits which files it can read</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> File[] dirs = getExtDirs();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Prior implementations of this doPrivileged() block supplied</span></span><br><span class="line">                <span class="comment">// aa synthesized ACC via a call to the private method</span></span><br><span class="line">                <span class="comment">// ExtClassLoader.getContext().</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                            <span class="keyword">int</span> len = dirs.length;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                                MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">            String s = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">            File[] dirs;</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">                StringTokenizer st =</span><br><span class="line">                    <span class="keyword">new</span> StringTokenizer(s, File.pathSeparator);</span><br><span class="line">                <span class="keyword">int</span> count = st.countTokens();</span><br><span class="line">                dirs = <span class="keyword">new</span> File[count];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    dirs[i] = <span class="keyword">new</span> File(st.nextToken());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dirs = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dirs;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>我们先前的内容有说过，可以指定<code>-D java.ext.dirs</code>参数来添加和改变ExtClassLoader的加载路径。这里我们通过可以编写测试代码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure><h3 id="3-3-AppClassLoader-源码"><a href="#3-3-AppClassLoader-源码" class="headerlink" title="3.3 AppClassLoader 源码"></a>3.3 AppClassLoader 源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">     * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> String s = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] path = (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> File[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    URL[] urls =</span><br><span class="line">                        (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> URL[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> AppClassLoader(urls, extcl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到AppClassLoader加载的就是<code>java.class.path</code>下的路径。我们同样打印它的值。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\ClassLoaderDemo\bin</span><br></pre></td></tr></table></figure><p>这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。</p><p>好了，自此我们已经知道了<code>BootstrapClassLoader、ExtClassLoader、AppClassLoader</code>实际是查阅相应的环境属性<code>sun.boot.class.path</code>、<code>java.ext.dirs</code>和<code>java.class.path</code>来加载资源文件的。</p><h3 id="3-4-加载顺序"><a href="#3-4-加载顺序" class="headerlink" title="3.4 加载顺序"></a>3.4 加载顺序</h3><ul><li>接下来我们探讨它们的加载顺序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后，编写一个ClassLoaderTest.java文件。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">ClassLoader cl = Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们获取到了Test.class文件的类加载器，然后打印出来。结果是：</span></span><br><span class="line"><span class="comment">// ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93</span></span><br></pre></td></tr></table></figure><p>也就是说明Test.class文件是由AppClassLoader加载的。</p><ul><li>这个Test类是我们自己编写的，那么int.class或者是String.class的加载是由谁完成的呢？<br>我们可以在代码中尝试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">ClassLoader cl = Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line"></span><br><span class="line">cl = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，却报错了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader is:sun.misc.Launcher<span class="variable">$AppClassLoader</span>@73d16e93</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">at ClassLoaderTest.main(ClassLoaderTest.java:15)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示的是空指针，意思是int.class这类基础类没有类加载器加载？</span><br><span class="line"></span><br><span class="line">当然不是！</span><br><span class="line">int.class是由Bootstrap ClassLoader加载的。要想弄明白这些，我们首先得知道一个前提。</span><br></pre></td></tr></table></figure><ul><li><strong>每个类加载其都有一个父类加载器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个类加载器都有一个父加载器，比如加载Test.class是由AppClassLoader完成，那么AppClassLoader也有一个父加载器，怎么样获取呢？很简单，通过getParent方法。比如代码可以这样编写：</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line">System.out.println(<span class="string">"ClassLoader\'s parent is:"</span>+cl.getParent().toString());</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader is:sun.misc.Launcher$AppClassLoader@<span class="number">73</span>d16e93</span><br><span class="line">ClassLoader<span class="string">'s parent is:sun.misc.Launcher$ExtClassLoader@15db9742</span></span><br></pre></td></tr></table></figure><p>这个说明，AppClassLoader的父加载器是ExtClassLoader。那么ExtClassLoader的父加载器又是谁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line">System.out.println(<span class="string">"ClassLoader\'s parent is:"</span>+cl.getParent().toString());</span><br><span class="line">System.out.println(<span class="string">"ClassLoader\'s grand father is:"</span>+cl.getParent().getParent().toString());</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>运行如果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">Exception in thread &quot;main&quot; ClassLoader&#39;s parent is:sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">at ClassLoaderTest.main(ClassLoaderTest.java:13)</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>又是一个空指针异常，这表明ExtClassLoader也没有父加载器。那么，为什么标题又是每一个加载器都有一个父加载器呢？这不矛盾吗？为了解释这一点，我们还需要看下面的一个基础前提。</p><ul><li><strong>父类加载器不是父类</strong></li></ul><p>我们先前已经粘贴了ExtClassLoader和AppClassLoader的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看见<code>ExtClassLoader</code>和<code>AppClassLoader</code>同样继承自<code>URLClassLoader</code>，但上面一小节代码中，为什么调用AppClassLoader的<code>getParent()</code>代码会得到ExtClassLoader的实例呢？先从URLClassLoader说起，这个类又是什么？</p><ul><li><code>URLClassLoader</code>的源码中并没有找到<code>getParent()</code>方法。这个方法在<code>ClassLoader.java</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The parent class loader for delegation</span></span><br><span class="line"><span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line"><span class="comment">// must be added *after* it.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"><span class="comment">// The class loader for the system</span></span><br><span class="line">    <span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader scl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recursive invocation"</span>);</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//通过Launcher获取ClassLoader</span></span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                scl = AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oops != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) oops;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// wrap the exception</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>getParent()</code>实际上返回的就是一个<code>ClassLoader</code>对象<code>parent</code>，parent的赋值是在ClassLoader对象的构造方法中，它有两个情况：</p><ol><li>由外部类创建<code>ClassLoader</code>时直接指定一个<code>ClassLoader</code>为parent。</li><li>由<code>getSystemClassLoader()</code>方法生成，也就是在<code>sun.misc.Laucher</code>通过<code>getClassLoader()</code>获取，也就是<code>AppClassLoader</code>。直白的说，一个<code>ClassLoader</code>创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。</li></ol><ul><li>我们主要研究的是ExtClassLoader与AppClassLoader的parent的来源，正好它们与Launcher类有关，我们上面已经粘贴过Launcher的部分代码。</li></ul><p>我们需要注意的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader extcl;</span><br><span class="line">        </span><br><span class="line">extcl &#x3D; ExtClassLoader.getExtClassLoader();</span><br><span class="line"></span><br><span class="line">loader &#x3D; AppClassLoader.getAppClassLoader(extcl);</span><br></pre></td></tr></table></figure><p>代码已经说明了问题AppClassLoader的parent是一个ExtClassLoader实例。</p><p>ExtClassLoader并没有直接找到对parent的赋值。它调用了它的父类也就是URLClassLoder的构造方法并传递了3个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] dirs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(getExtURLs(dirs), <span class="keyword">null</span>, factory);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                          URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案已经很明了了，ExtClassLoader的parent为null。</strong></p><p>上面张贴这么多代码也是为了说明<code>AppClassLoader</code>的parent是<code>ExtClassLoader</code>，<code>ExtClassLoader</code>的<code>parent</code>是<code>null</code>。这符合我们之前编写的测试代码。</p><p>不过，细心的同学发现，还是有疑问的我们只看到<code>ExtClassLoader</code>和<code>AppClassLoader</code>的创建，那么<code>BootstrapClassLoader</code>呢？</p><p>还有，<code>ExtClassLoader</code>的父加载器为null,但是<code>Bootstrap CLassLoader</code>却可以当成它的父加载器这又是为何呢？</p><ul><li>BootStrap ClassLoader 是由 C++编写的<ul><li><code>Bootstrap ClassLoader</code>是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在<code>java</code>代码中获取它的引用，JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件，之前的<code>int.class,String.class</code>都是由它加载。</li><li>然后呢，我们前面已经分析了，JVM初始化<code>sun.misc.Launcher</code>并创建Extension <code>ClassLoader``AppClassLoader</code>实例。并将<code>ExtClassLoader</code>设置为<code>AppClassLoader</code>的父加载器。Bootstrap没有父加载器，但是它却可以作用一个<code>ClassLoader</code>的父加载器。比如<code>ExtClassLoader</code>。这也可以解释之前通过<code>ExtClassLoader</code>的getParent方法获取为Null的现象。具体是什么原因，很快就知道答案了。</li></ul></li></ul><h2 id="4-双亲委派"><a href="#4-双亲委派" class="headerlink" title="4. 双亲委派"></a>4. 双亲委派</h2><ul><li>一个类加载器查找class和resource时，是通过“委托模式”进行的<ul><li>它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到<code>Bootstrap ClassLoader</code></li><li>如果<code>Bootstrap classloader</code>找到了，直接返回</li><li>如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</li></ul></li></ul><p>具体流程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。</span><br><span class="line">递归，重复第1部的操作。</span><br><span class="line">2. 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。</span><br><span class="line">3. Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。</span><br><span class="line">4. ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。</span><br></pre></td></tr></table></figure><p><strong>我们可以发现委托是从下向上，然后具体查找过程却是自上至下。</strong></p><h2 id="5-重要的方法"><a href="#5-重要的方法" class="headerlink" title="5. 重要的方法"></a>5. 重要的方法</h2><h3 id="5-1-loadClass"><a href="#5-1-loadClass" class="headerlink" title="5.1 loadClass()"></a>5.1 loadClass()</h3><ul><li>JDK文档中是这样写的，通过指定的全限定类名加载class，它通过同名的<code>loadClass(String,boolean)</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name,</span><br><span class="line">                             <span class="keyword">boolean</span> resolve)</span><br><span class="line">                      <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure><p>上面是<strong>方法原型(说明我们可以打破双亲委派)</strong>，一般实现这个方法的步骤是</p><ol><li>执行<code>findLoadedClass(String)</code>去检测这个<code>class</code>是不是已经加载过了。</li><li>执行父加载器的<code>loadClass</code>方法。如果父加载器为<code>null</code>，则<code>jvm</code>内置的加载器去替代，也就是<code>Bootstrap ClassLoader</code>。这也解释了<code>ExtClassLoader</code>的<code>parent</code>为null,但仍然说<code>Bootstrap ClassLoader</code>是它的父加载器。</li><li>如果向上委托父加载器没有加载成功，则通过<code>findClass(String)</code>查找。</li></ol><ul><li>如果class在上面的步骤中找到了，参数resolve又是true的话，那么<code>loadClass()</code>又会调用<code>resolveClass(Class)</code>这个方法来生成最终的Class对象。 我们可以从源代码看出这个步骤。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//父加载器没有找到，则调用findclass</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>另外，要注意的是如果要编写一个classLoader的子类，也就是自定义一个classloader，建议覆盖<code>findClass()</code>方法，而不要直接改写<code>loadClass()</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">    c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-自定义ClassLoader"><a href="#6-自定义ClassLoader" class="headerlink" title="6. 自定义ClassLoader"></a>6. 自定义ClassLoader</h2><p>不知道大家有没有发现，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？</p><p>如果要这样做的话，需要我们自定义一个classloader。</p><p><strong>步骤</strong></p><ol><li>编写一个类继承自<code>ClassLoader</code>抽象类。</li><li>复写它的<code>findClass()</code>方法。</li><li>在<code>findClass()</code>方法中调用<code>defineClass()</code>。</li></ol><p>defineClass() 方法 ： 这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常。</p><h3 id="6-1-自定义DiskClassLoader"><a href="#6-1-自定义DiskClassLoader" class="headerlink" title="6.1 自定义DiskClassLoader"></a>6.1 自定义DiskClassLoader</h3><p>假设我们需要一个自定义的classloader,默认加载路径为<code>D:\lib</code>下的jar包和资源。</p><p>我们写编写一个测试用的类文件，Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frank.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Say Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后将它编译过class文件Test.class放到<code>D:\lib</code>这个路径下。</li></ul><p><code>DiskClassLoader</code> 编写如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String mLibPath;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">mLibPath = path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">String fileName = getFileName(name);</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(mLibPath,fileName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileInputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] data = bos.toByteArray();</span><br><span class="line">        is.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取要加载 的class文件名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFileName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> index = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line"><span class="keyword">if</span>(index == -<span class="number">1</span>)&#123; </span><br><span class="line"><span class="keyword">return</span> name+<span class="string">".class"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> name.substring(index+<span class="number">1</span>)+<span class="string">".class"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们在<code>findClass()</code>方法中定义了查找class的方法，然后数据通过<code>defineClass()</code>生成了Class对象。</li></ul><p>现在我们要编写测试代码。我们知道如果调用一个Test对象的say方法，它会输出”Say Hello”这条字符串。但现在是我们把Test.class放置在应用工程所有的目录之外，我们需要加载它，然后执行它的方法。具体效果如何呢？我们编写的DiskClassLoader能不能顺利完成任务呢？我们拭目以待。</p><p><strong>测试代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建自定义classloader对象。</span></span><br><span class="line">DiskClassLoader diskLoader = <span class="keyword">new</span> DiskClassLoader(<span class="string">"D:\\lib"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//加载class文件</span></span><br><span class="line">Class c = diskLoader.loadClass(<span class="string">"com.frank.test.Test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object obj = c.newInstance();</span><br><span class="line">Method method = c.getDeclaredMethod(<span class="string">"say"</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//通过反射调用Test类的say方法</span></span><br><span class="line">method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException </span><br><span class="line">| NoSuchMethodException</span><br><span class="line">| SecurityException | </span><br><span class="line">IllegalArgumentException | </span><br><span class="line">InvocationTargetException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考博客</strong> : <a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-ClassLoader详解&quot;&gt;&lt;a href=&quot;#Java-基础-ClassLoader详解&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-ClassLoader详解&quot;&gt;&lt;/a&gt;Java-基础-ClassLoader详解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ClassLoader&lt;/code&gt;翻译过来就是类加载器，普通的java开发者其实用到的不多，但对于某些框架开发者来说却非常常见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解&lt;code&gt;ClassLoader&lt;/code&gt;的加载机制，也有利于我们编写出更高效的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ClassLoader&lt;/code&gt;的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，&lt;code&gt;jvm&lt;/code&gt;启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;想想也是的，一次性加载那么多jar包那么多class，那内存不崩溃。本文的目的也是学习&lt;code&gt;ClassLoader&lt;/code&gt;这种加载机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JVM" scheme="http://zhuuu.work/tags/JVM/"/>
    
      <category term="ClassLoader" scheme="http://zhuuu.work/tags/ClassLoader/"/>
    
      <category term="双亲委派" scheme="http://zhuuu.work/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>JUC-20-ThreadPoolExecutor</title>
    <link href="http://zhuuu.work/2020/08/31/JUC/JUC-20-ThreadPoolExecutor/"/>
    <id>http://zhuuu.work/2020/08/31/JUC/JUC-20-ThreadPoolExecutor/</id>
    <published>2020-08-31T08:02:24.000Z</published>
    <updated>2020-09-20T01:32:27.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUC-20-ThreadPoolExecutor"><a href="#JUC-20-ThreadPoolExecutor" class="headerlink" title="JUC-20-ThreadPoolExecutor"></a>JUC-20-ThreadPoolExecutor</h2><h2 id="1-submit-和-execute"><a href="#1-submit-和-execute" class="headerlink" title="1. submit 和 execute"></a>1. submit 和 execute</h2><ol><li><strong>execute</strong></li></ol><ul><li>这个方法是在<code>Executor</code>接口中定义的，不会返回执行结果，在<code>ThreadPoolExecutor</code> 类中有具体的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>submit方法</strong></li></ol><ul><li>这个方法是在<code>ExecutorService</code> 接口中定义的，在<code>AbstractExecutorService</code> 类中有具体的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个Callable</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交一个Runnable</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交一个Runnable并默认值result，在任务执行完毕以后，调用&#123;Future.get()&#125;方法会返回这个默认值</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><strong>其实最终调用的方法，都是execute方法</strong></li><li><strong>sumbit方法相当于把任务包装了一下，返回的是一个Future句柄，这个句柄其实就是FutureTask对象</strong></li></ul><p><strong>区别</strong></p><ul><li><strong>接收的参数不一样</strong></li><li><strong>submit有返回值，而execute没有</strong></li><li><strong>submit方便Exception处理</strong><ul><li>意思就是如果你在你的task里会抛出<code>checked</code>或者<code>unchecked exception</code>，而你又希望外面的调用者能够感知这些<code>exception</code>并做出及时的处理</li><li>那么就需要用到<code>submit</code>，通过捕获<code>Future.get</code>抛出的异常。</li></ul></li></ul><a id="more"></a><h2 id="2-Callable-和-Runnable"><a href="#2-Callable-和-Runnable" class="headerlink" title="2 . Callable 和 Runnable"></a>2 . Callable 和 Runnable</h2><h3 id="2-1-Runnable"><a href="#2-1-Runnable" class="headerlink" title="2.1 Runnable"></a>2.1 Runnable</h3><ul><li>先说一下<code>java.lang.Runnable</code>吧，它是一个接口，在它里面只声明了一个run()方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>由于run()方法返回值为void类型</strong>，所以在执行完任务之后无法返回任何结果。</li></ul><h3 id="2-2-Callable"><a href="#2-2-Callable" class="headerlink" title="2.2 Callable"></a>2.2 Callable</h3><ul><li><code>Callable</code>位于<code>java.util.concurrent</code>包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做<code>call()：</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到，这是一个<strong>泛型接口</strong>，该接口声明了一个名称为call()的方法，同时这个方法可以有返回值V，也可以抛出异常。call()方法返回的类型就是传递进来的V类型。</li></ul><ul><li><strong>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的</strong>，在ExecutorService接口中声明了若干个submit方法的重载版本：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个方法：submit提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个方法：submit提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个方法：submit提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此我们只要创建好我们的线程对象（实现Callable接口或者Runnable接口），然后通过上面3个方法提交给线程池去执行即可。</span></span><br></pre></td></tr></table></figure><h2 id="3-Future"><a href="#3-Future" class="headerlink" title="3. Future"></a>3. Future</h2><ul><li><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</li><li><code>Future&lt;V&gt;</code>接口是用来<strong>获取异步计算结果</strong>的，说白了就是对具体的<code>Runnable</code>或者<code>Callable</code>对象任务执行的结果进行获取(get())，取消(<code>cancel()</code>)，判断是否完成等操作。我们看看Future接口的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在<strong>Future接口中声明了5个方法</strong>，下面依次解释每个方法的作用：</p><ul><li><p><strong>cancel方法</strong>用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p></li><li><p><strong>isCancelled方法</strong>表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</p></li><li><p><strong>isDone方法</strong>表示任务是否已经完成，若任务完成，则返回true；</p></li><li><p><strong>get()方法</strong>用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</p></li><li><p><strong>get(long timeout, TimeUnit unit)</strong>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</p></li></ul></li></ul><ul><li>也就是说<strong>Future提供了三种功能：</strong></li></ul><p>1）判断任务是否完成；</p><p>2）能够中断任务；</p><p>3）能够获取任务执行结果。</p><p><strong>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</strong></p><h2 id="4-FutureTask"><a href="#4-FutureTask" class="headerlink" title="4. FutureTask"></a>4. FutureTask</h2><h3 id="4-1-FutureTask-的-状态"><a href="#4-1-FutureTask-的-状态" class="headerlink" title="4.1 FutureTask 的 状态"></a>4.1 FutureTask 的 状态</h3><ul><li>我们先来看一下FutureTask的实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure><ul><li><code>FutureTask</code>类实现了<code>RunnableFuture</code>接口，我们看一下<code>RunnableFuture</code>接口的实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出<code>RunnableFuture</code>继承了Runnable接口和Future接口，<ul><li>而FutureTask实现了RunnableFuture接口。所以它<strong>既可以作为Runnable被线程执行，</strong></li><li><strong>又可以作为Future得到Callable的返回值。</strong></li></ul></li></ul><p><strong>分析：</strong></p><ul><li>FutureTask除了实现了Future接口外还实现了Runnable接口，因此FutureTask也可以直接提交给Executor执行。 当然也可以调用线程直接执行（FutureTask.run()）。接下来我们根据FutureTask.run()的执行时机来分析其所处的3种状态：<ul><li><strong>未启动（NEW），</strong>FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，而且没有执行FutureTask.run()方法前，这个FutureTask也处于未启动状态。</li><li><strong>已启动(Completing)</strong>，<code>FutureTask.run()</code>被执行的过程中，<code>FutureTask</code>处于已启动状态。</li><li><strong>已完成(Normal)，</strong><code>FutureTask.run()</code>方法执行完正常结束，或者被取消或者抛出异常而结束，FutureTask都处于完成状态。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200915/103146074.png" alt="mark"></p><ul><li>下面我们再来看看<code>FutureTask</code>的方法执行示意图（方法和Future接口基本是一样的，这里就不过多描述了）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200915/103203544.png" alt="mark"></p><p><strong>分析</strong></p><p><strong>get()逻辑</strong></p><ul><li>当FutureTask处于未启动或已启动状态时，如果此时我们执行FutureTask.get()方法将导致调用线程阻塞；</li><li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。</li></ul><p><strong>cancel()逻辑</strong></p><ul><li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会执行。</li><li>当FutureTask处于已启动状态时，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果任务取消成功，cancel(…)返回true；但如果执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时cancel(…)返回false</li><li>当任务已经完成，执行cancel(…)方法将返回false。</li></ul><p><strong>最后我们给出FutureTask的两种构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-FutureTask的使用"><a href="#4-2-FutureTask的使用" class="headerlink" title="4.2 FutureTask的使用"></a>4.2 FutureTask的使用</h3><ul><li><p>通过上面的介绍，我们对Callable，Future，FutureTask都有了比较清晰的了解了，那么它们到底有什么用呢？我们前面说过通过这样的方式去创建线程的话，<strong>最大的好处就是能够返回结果</strong></p></li><li><p>加入有这样的场景，我们现在需要计算一个数据，而这个数据的计算比较耗时，而我们后面的程序也要用到这个数据结果，那么这个时Callable岂不是最好的选择？</p></li><li><p>我们可以开设一个线程去执行计算，而主线程继续做其他事，而后面需要使用到这个数据时，我们再使用Future获取不就可以了吗？下面我们就来编写一个这样的实例。</p></li></ul><p><strong>1、使用Callable+Future获取执行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建Callable对象任务  </span></span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        <span class="comment">//提交任务并获取执行结果  </span></span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        <span class="comment">//关闭线程池  </span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.get()!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">"task运行结果"</span>+result.get());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"未获取到结果"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子线程在进行计算</span><br><span class="line">主线程在执行任务</span><br><span class="line">task运行结果<span class="number">4950</span></span><br><span class="line">所有任务执行完毕</span><br></pre></td></tr></table></figure><p><strong>2、使用Callable+FutureTask获取执行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line"><span class="comment">//        Task task = new Task();</span></span><br><span class="line"><span class="comment">//        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(futureTask);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(futureTask.get()!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"future.get()未获取到结果"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上。</p><h3 id="4-3-补充"><a href="#4-3-补充" class="headerlink" title="4.3 补充"></a>4.3 补充</h3><ul><li>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的。</li><li>Callable规定的方法是call(),Runnable规定的方法是run()。</li><li><strong>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)。</strong></li><li><strong>call方法可以抛出异常，run方法不可以。</strong></li><li>运行Callable的 任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</li><li><strong>加入线程池运行，Runnable使用Executor的execute方法，Callable使用submit方法。</strong></li></ul><p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></p><p><strong>参考博客</strong> : <a href="https://blog.csdn.net/leilifengxingmw/article/details/79533006" target="_blank" rel="noopener">https://blog.csdn.net/leilifengxingmw/article/details/79533006</a></p><p>​                    <a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></p><p>​                    <a href="https://www.cnblogs.com/xiaoxi/p/8303574.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/8303574.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JUC-20-ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#JUC-20-ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;JUC-20-ThreadPoolExecutor&quot;&gt;&lt;/a&gt;JUC-20-ThreadPoolExecutor&lt;/h2&gt;&lt;h2 id=&quot;1-submit-和-execute&quot;&gt;&lt;a href=&quot;#1-submit-和-execute&quot; class=&quot;headerlink&quot; title=&quot;1. submit 和 execute&quot;&gt;&lt;/a&gt;1. submit 和 execute&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;execute&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这个方法是在&lt;code&gt;Executor&lt;/code&gt;接口中定义的，不会返回执行结果，在&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 类中有具体的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Executor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable command)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;submit方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这个方法是在&lt;code&gt;ExecutorService&lt;/code&gt; 接口中定义的，在&lt;code&gt;AbstractExecutorService&lt;/code&gt; 类中有具体的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Callable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Callable&amp;lt;T&amp;gt; task)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Runnable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Future&amp;lt;?&amp;gt; submit(Runnable task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Runnable并默认值result，在任务执行完毕以后，调用&amp;#123;Future.get()&amp;#125;方法会返回这个默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable task, T result)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;其实最终调用的方法，都是execute方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sumbit方法相当于把任务包装了一下，返回的是一个Future句柄，这个句柄其实就是FutureTask对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;接收的参数不一样&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;submit有返回值，而execute没有&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;submit方便Exception处理&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;意思就是如果你在你的task里会抛出&lt;code&gt;checked&lt;/code&gt;或者&lt;code&gt;unchecked exception&lt;/code&gt;，而你又希望外面的调用者能够感知这些&lt;code&gt;exception&lt;/code&gt;并做出及时的处理&lt;/li&gt;
&lt;li&gt;那么就需要用到&lt;code&gt;submit&lt;/code&gt;，通过捕获&lt;code&gt;Future.get&lt;/code&gt;抛出的异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-HTTPS点开网页原理</title>
    <link href="http://zhuuu.work/2020/08/31/NetworkCoding/HTTP-HTTPS%E7%82%B9%E5%BC%80%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/08/31/NetworkCoding/HTTP-HTTPS%E7%82%B9%E5%BC%80%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-31T03:02:24.000Z</published>
    <updated>2020-09-21T01:01:17.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-HTTPS区别"><a href="#HTTP-HTTPS区别" class="headerlink" title="HTTP-HTTPS区别"></a>HTTP-HTTPS区别</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议</p></li><li><p>申请证书上，HTTPS需要使用ca申请证书</p></li><li><p>对于抓包而言 ，HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议</p></li><li><p>连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443</p></li></ul><p><strong>HTTP通信过程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/100535634.png" alt="mark"></p><a id="more"></a><h2 id="2-HTTPS的通信过程"><a href="#2-HTTPS的通信过程" class="headerlink" title="2. HTTPS的通信过程"></a>2. HTTPS的通信过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-105034140.png" alt="mark"></p><p>https通信时，首先建立ssl层的连接，客户端将ssl版本号和加密组件发到服务器端，服务器端收到后对ssl版本号和加密组件进行匹配，同时将CA证书及密钥发送到客户端。客户端对证书进行验证，验证通过后使用非对称加密对数据通信时的密钥进行协商。协商后得到一致的获得一致的对称加密密钥。然后使用对称加密算法进行TCP连接，后续的过程跟http的过程一致。三次握手，数据交换，四次挥手，通信结束。</p><p>过程如下 ：</p><ol><li>客户端和服务器端通过TCP建立连接。</li><li>客户端向服务器发送HTTPS请求。</li><li>服务器响应请求，并将数字证书发送给客户端，数字证书包括公共秘钥、域名、申请证书的公司。</li><li>客户端收到服务器端的数字证书之后，会验证数字证书的合法性。</li><li>如果公钥合格，那么客户端会生成一个用于进行对称加密的密钥client key，并用服务器的公钥对客户端密钥进行非对称加密。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用私钥对其进行非对称解密，得到客户端秘钥。并使用客户端秘钥进行对称加密，生成密文并发送。</li><li>客户端收到密文，并使用客户端秘钥进行解密，渲染网页。</li></ol><h2 id="3-HTTP的工作过程详解"><a href="#3-HTTP的工作过程详解" class="headerlink" title="3. HTTP的工作过程详解"></a>3. HTTP的工作过程详解</h2><p><strong>总结</strong></p><p>HTTP由请求和响应构成，是一个标准的客户端服务器模型（C/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。</p><ol><li>地址解析。域名系统DNS解析域名得到主机的IP地址</li><li>封装HTTP请求数据包。封装的内容有以上部分结合本机自己的信息。</li><li>封装成TCP包，建立TCP连接（TCP的三次握手）</li><li>客户机发送请求命令。 建立连接后，客户机向服务器发送一个请求</li><li>服务器响应。服务器接到请求后，给予相应的响应信息</li><li>服务器关闭TCP连接。一般Web服务器向浏览器发送了请求数据，它要关闭TCP连接</li><li>客户端解析报文，解析HTML代码，并渲染</li></ol><h3 id="3-1-DNS过程（应用层）"><a href="#3-1-DNS过程（应用层）" class="headerlink" title="3.1 DNS过程（应用层）"></a>3.1 DNS过程（应用层）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">其实我们在浏览器中输入URL的时候，浏览器就会开始智能的匹配可能URL，浏览器会从历史记录，书签等地方，找到你已经输入的字符串可能对应的URL，然后给出智能提示</span><br><span class="line"></span><br><span class="line">在输好URL后我们会按下Enter键，浏览器会发起请求，如果URL是域名而不是IP地址，将进行域名解析，所谓域名解析是指什么呢？</span><br><span class="line"></span><br><span class="line">IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址，域名解析就是域名到IP地址的转换过程。</span><br><span class="line">域名解析按下面的步骤进行（部分内容涉及到计算机网络知识）：</span><br><span class="line"></span><br><span class="line">我们本地硬盘下有一个hosts(windows下路径为C:\Windows\System32\drivers\etc)文件，作用是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”。一般来说，系统会首先自动从hosts文件中寻找对应的IP地址，如果有的话就直接使用hosts文件里面的IP地址，然后直接进行端口确认</span><br><span class="line">如果上一步没有找到，浏览器将调用解析程序，并成为DNS服务器的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报的方式发给本地DNS服务器</span><br><span class="line">如果本地DNS服务器查找到相应的域名的IP地址，就把对应的IP地址放在回答报文中返回</span><br><span class="line">如果上一步没有找到，即本地DNS服务器不知道被查询域名的IP地址，由于主机向本地DNS服务器的查询是递归查询，所以此时，本地DNS服务器就会以DNS客户的身份向其他根DNS服务器继续发出查询请求报文。本地DNS服务器向根DNS服务器的查询是迭代查询，当找到相应域名的IP地址后，就会把这个结果返回给最初发起查询请求的浏览器</span><br><span class="line"></span><br><span class="line">递归查询：在该模式下DNS服务器接收到客户机请求，必须返回一个准确的查询结果给客户机。如果该DNS服务器本地没有存储被查询的DNS信息，那么该服务器会（替客户机）询问其他服务器，并将返回的查询结果再返回给客户机。</span><br><span class="line">迭代查询：在该模式下DNS服务器接收到客户机请求，如果该DNS服务器本地没有存储被查询的DNS信息，DNS服务器会向客户机提供其他能够解析查询请求的DNS服务器地址，让客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。</span><br><span class="line">经过上面的步骤后，浏览器已经获得输入域名的IP地址，可以进行下一步了。</span><br></pre></td></tr></table></figure><h3 id="3-2-发起请求建立连接-传输层"><a href="#3-2-发起请求建立连接-传输层" class="headerlink" title="3.2 发起请求建立连接(传输层)"></a>3.2 发起请求建立连接(传输层)</h3><ul><li>浏览器得到<code>IP</code>地址并确认端口后，会向目标服务器发起<code>HTTP</code>请求，<code>HTTP</code>请求是通过<code>TCP</code>连接来发送的(如果是<code>HTTPS</code>则需要先建立SSL连接，再是<code>TCP</code>连接，下面的讨论基于<code>HTTP</code>)，具体如下<ul><li><strong>浏览器会生成目标服务器的<code>HTTP</code>请求报文</strong>，<strong>请求报文一般包含请求方法、请求<code>URI</code>、协议版本、请求首部字段等内容，<code>HTTP</code>请求准备好后，<code>HTTP</code>请求报文从应用层传到传输层后会被分割为报文段，并会发起一条到达目标服务器的<code>TCP</code>连接，开始<code>TCP</code>三次握手</strong>，过程如图所示：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/101827387.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通俗的可以理解为：</span><br><span class="line"></span><br><span class="line">A主动向B打电话：嗨，能听到吗（SYN&#x3D;1，seq&#x3D;x），然后A就开始等待B的回答（SYN-SENT状态），此时A不知道B能不能听到</span><br><span class="line">B听到A的话之后，可以确认它能听到A，但是它还要确认一下A能不能听到他自己的声音，于是B说：我能听到你的声音（ACK&#x3D;1，ack&#x3D;x+1），你能听到我的声音吗（SYN&#x3D;1,seq&#x3D;y），然后B开始等待A的恢复（SYN-RECD状态）</span><br><span class="line">A听到B的话之后，A可以确认两件事，一是B能听到它说话，二是它也能听到B说话，A已经可以随时说话和倾听了（ESTABLISHED状态）。但是此时的B还在等待中，并不知道A能不能听到，所以此时A需要再回复B说：我可以听到你的声音（ACK&#x3D;1，ack&#x3D;y+1）,开始愉快的聊天吧~（seq&#x3D;x+1），B听到这句话后便也可以随时说话和倾听了（ESTABLISHED状态）</span><br><span class="line">之后两个人就可以balabalabala....</span><br></pre></td></tr></table></figure><ul><li><code>HTTP</code>请求的请求报文是直接附在第三次握手的消息中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">穿插补充小知识，为什么是三次握手，而不是两次四次？</span><br><span class="line"></span><br><span class="line">在《计算机网络》一书中也有讲过这个问题，给出的解释是：三次握手是为了防止失效的连接请求报文段被服务端接收，从而产生错误。具体例子如下所述：</span><br><span class="line">client发出的一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</span><br><span class="line">假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。但是由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。而server却以为新的连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</span><br><span class="line">采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接</span><br></pre></td></tr></table></figure><h3 id="3-3-封装成IP数据包（网络层）"><a href="#3-3-封装成IP数据包（网络层）" class="headerlink" title="3.3 封装成IP数据包（网络层）"></a>3.3 封装成IP数据包（网络层）</h3><ul><li>连接建立之后，开始进行数据传输，虽然浏览器知道目标服务器的<code>IP</code>和端口，但是数据总不可能飞过去吧？<code>HTTP</code>请求报文段会从传输层传到网络层，在网络层被封装成<code>IP</code>数据包，网络层规定了通过怎样的路径（所谓的传输路线）到达目标服务器，并把数据包传送给对方。</li></ul><h3 id="3-4-封装成帧-（数据链路层）"><a href="#3-4-封装成帧-（数据链路层）" class="headerlink" title="3.4 封装成帧 （数据链路层）"></a>3.4 封装成帧 （数据链路层）</h3><ul><li>网络层封装好的<code>IP</code>数据包会进一步传到下一层 — 数据链路层，然后会再次被封装到<code>MAC</code>数据帧结构中</li><li>由于<code>IP</code>地址间的通信依赖于<code>MAC</code>地址（网卡所属的固定地址），所以<code>MAC</code>数据帧结构中会有经过<code>ARP</code>协议解析后的<code>MAC</code>地址（不一定是目标服务器的<code>MAC</code>地址，因为实际上通信的双方在同一局域网（LAN）内的情况是很少的，一般都会经过路由中转）。</li></ul><h3 id="3-5-传输比特流-（物理层）"><a href="#3-5-传输比特流-（物理层）" class="headerlink" title="3.5 传输比特流 （物理层）"></a>3.5 传输比特流 （物理层）</h3><ul><li>数据链路层的<code>MAC</code>数据帧再向下传，便会到达物理层，这里要注意<strong><em>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体\</em></strong>。 物理层需要确保原始的数据可在各种物理媒体上传输，它规定了传输媒体的机械特性、电气特性、功能特性、过程特性</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/103108545.png" alt="mark"></p><ul><li>常见的传输媒体有双绞线、电缆、光缆、无线信道等，物理层的任务就是要让数据在这些传输媒体上都能能进行传输</li></ul><h3 id="3-6-服务端的逆操作"><a href="#3-6-服务端的逆操作" class="headerlink" title="3.6 服务端的逆操作"></a>3.6 服务端的逆操作</h3><ul><li><p>通过<code>MAC</code>地址匹配，数据通过传输媒体到达目标服务器的物理层，物理层接收数据比特流然后向上传送到服务器的数据链路层，在数据链路层<code>MAC</code>数据帧将进行封装的逆操作，还原成<code>IP</code>数据包之后向上传送到网络层，网络层也进行封装的逆操作还原成<code>HTTP</code>请求报文段（分割后的一小段一小段的），然后这些报文段向上传到传输层，在传输层按原来的序号重新组装成完整的<code>HTTP</code>请求报文，再向上传到应用层，应用层的<code>HTTP</code>协议便会开始对请求进行处理</p></li><li><p>这个处理可能是直接返回静态的资源，也可能经过<code>PHP</code>、<code>JAVA</code>等语言进行处理等，等处理完成后，会返回一个<code>HTTP</code>响应，它生成一个<code>HTTP</code>响应报文，与<code>HTTP</code>请求报文结构类似，然后这个响应报文会“走过”请求报文来时的路到达浏览器</p></li></ul><h3 id="3-7-客户端的释放链接"><a href="#3-7-客户端的释放链接" class="headerlink" title="3.7 客户端的释放链接"></a>3.7 客户端的释放链接</h3><ul><li>浏览器接收<code>HTTP</code>响应，<strong>然后有可能释放<code>TCP</code>连接，也有可能重新使用这个<code>TCP</code>连接发送新的请求（持久连接）</strong>，此处了解一下<code>TCP</code>连接的释放，不同于<code>TCP</code>连接建立的三次握手，<code>TCP</code>连接的释放是四次挥手，客户端和服务器端都可以发起关闭请求，也存在两者同时发起关闭请求的情况，图中为客户端A主动发起关闭请求：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/103323033.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">同样通俗的解释一波：</span><br><span class="line"></span><br><span class="line">A对B要传的文件已经传完了，于是他对B说：我要传的文件已经传完了，我要准备下线了（seq&#x3D;u，FIN&#x3D;1）。然后A就等待B的回复（FIN-WAIT-1状态）</span><br><span class="line"></span><br><span class="line">B看到A的消息后，回复A说：知道了，但是我还有文件给你（ACK&#x3D;1,ack&#x3D;u+1,seq&#x3D;v）。B进入等他文件传完的状态（CLOSE-WAIT状态）。</span><br><span class="line">A收到B的回复之后，下线不了了，于是继续等待着B的文件传完（FIN-WAIT-2状态）</span><br><span class="line"></span><br><span class="line">几分钟后，B的文件传完了，此时他对A说：我的文件传完了，我也要下线了（seq&#x3D;w,FIN&#x3D;1,ACK&#x3D;1,ack&#x3D;u+1），然后B等待A的回复来确认真的可以下线了（LAST-ACK状态）</span><br><span class="line"></span><br><span class="line">A收到B的回复后，便对A说：好的，那你下线吧（ACK&#x3D;1，seq&#x3D;u+1,ack&#x3D;w+1）。此时A会等待一段时间（2MSL，TIME-WAIT状态），B收到后就直接下线了（CLOSE状态），然后2MSL时间到了之后，A也下线（CLOSE状态）</span><br></pre></td></tr></table></figure><p><strong>几个小问题</strong></p><ul><li><strong>为什么服务器B在接到A的断开请求时不立即同意断开？</strong><ul><li>当服务器B收到断开连接的请求时，服务器可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开</li></ul></li></ul><ul><li><strong>为什么是四次挥手，而不是像建立连接一样的三次</strong><ul><li>因为<code>TCP</code>连接是全双工模式，服务器B收到A的断开请求时，仅仅表明A没有东西传给服务器B了，但此时服务器B可能向A的传输还没结束，所以服务器B要先给A一个确认收到A的断开请求的<code>ACK</code>报文，然后继续向A把信息传完，等传完之后服务器B再向A发送断开请求的报文段，等A收到并回复<code>ACK</code>报文后再释放连接。</li><li>也就是说对于A来说他要发送请求给B并等待B确认，对于B来说也要发送请求给A并等待A确认，两者都经过这两个过程才能完全释放<code>TCP</code>连接，而非单方面的释放。<br>建立连接只需要建立，没有<strong>数据</strong>的影响，而释放连接还要考虑数据是否传输完，所以建立连接的时候B确认收到A的建立请求与B发送建立请求这一步可以合成一步成为<code>TCP</code>建立连接的第二次握手，而释放连接时却必须分开。</li></ul></li></ul><ul><li><strong>最后一次握手后A为什么要等<code>2MSL</code>？</strong><br><strong>首先解释一下<code>MSL</code>，<code>MSL</code>是指最长报文段寿命</strong>，RFC793建议为两分钟，但实际上可据实际情况而定，也就是说一个报文段最久可存在的时间是<code>MSL</code></li></ul><ol><li>这是为了保证A发送的最后一个<code>ACK</code>报文能够到达服务器B，如果这个<code>ACK</code>报文丢失了，服务器B没有收到，B会超时重传第三次握手的<code>FIN+ACK</code>报文给A，这个时候处于等待的A就可以收到这个重传的<code>FIN+ACK</code>报文，并再次发送<code>ACK</code>报文给服务器B，并且重新启动2MSL计时器，最终结果是A和B都正常进入CLOSE状态。如果A发完<code>ACK</code>报文后就直接释放了A–&gt;B的连接，那么A就收不到B重传的<code>FIN+ACK</code>报文，也不能重新发送ACK`报文，那么B就无法按正常步骤释放B–&gt;A的连接</li><li>防止“已失效的连接请求报文”出现在下一个新的连接中，因为一个报文段的寿命是<code>MSL</code>，所以A在发送完最后一个<code>ACK</code>报文段之后，再经过时间2<code>MSL</code>，本连接持续的时间内所产生的所有报文段都将在网络中消失，这样这些旧的报文段便不会出现在下一个新的连接中</li></ol><h3 id="3-8-浏览器的加载过程"><a href="#3-8-浏览器的加载过程" class="headerlink" title="3.8 浏览器的加载过程"></a>3.8 浏览器的加载过程</h3><p>浏览器之后会检查<code>HTTP</code>的响应状态，主要通过响应码来判断</p><blockquote><p>1xx: 表示通知信息的，比如请求收到了或正在处理<br>2xx：表示成功，操作被成功接收并处理<br>3xx：表示重定向，一般完成请求还必须采取进一步的行动<br>4xx：表示客户端的差错<br>5xx：表示服务器的差错</p></blockquote><ul><li><p>如果响应可缓存，浏览器将把响应存入缓存</p></li><li><p>浏览器根据<code>HTTP</code>报头信息解码响应，决定如何处理这些响应，并展现响应，以响应为一个<code>HTML</code>为例</p></li><li><p>浏览器开始自上而下，自左而右的加载<code>HTML</code>文档，最开始会遇到<code>&lt;!DOCTYPE&gt;</code>声明，然后根据<code>&lt;!DOCTYPE&gt;</code>声明浏览器就知道该用哪种规范来解析这个文档</p></li><li><p>再继续边加载边解析，边生成<code>DOM</code>树，加载过程中遇到外部<code>CSS</code>文件，浏览器便会另外发出一个请求，来获取<code>CSS</code>文件（过程和上面说的一样），获取<code>CSS</code>后会生成<code>CSS Rule</code>树。<code>DOM</code>树和<code>CSS Rule</code>树生成<code>Render</code>树，页面可以开始边加载边渲染了</p><ul><li>渲染树和<code>DOM</code>树的关系：那些不可见的<code>DOM</code>元素（如<code>&lt;head&gt;…&lt;/head&gt;</code>，<code>display=none</code>的元素）不会被插入渲染树中；还有像一些节点是绝对定位或浮动，这些节点会在文本流之外，因此他们会在渲染树和<code>DOM</code>树的不同位置，渲染树标识出真实的位置，并用一个占位结构标识出他们原来的位置，而<code>DOM</code>树上是他们原来的位置</li><li>渲染包含”布局”（<code>layout</code>）和”绘制”（<code>paint</code>）这两个步骤，所谓”布局”是指给出每个<code>DOM</code>节点在浏览器窗口中的准确位置，”绘制”是指遍历<code>Render</code>树将布局好的<code>DOM</code>节点绘制在屏幕上。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/105633907.png" alt="mark"></p><ul><li><p>浏览器继续加载渲染，如果遇到<code>＜script＞</code>标签，浏览器会立即执行（暂不考虑<code>defer</code>及<code>async</code>属性），此时会出现页面阻塞，不仅要等待文档中<code>JS</code>文件下载加载完毕，还要等待<code>JS</code>解析执行完毕，才可以恢复<code>HTML</code>文档的加载解析。</p><ul><li>这是浏览器为了防止出现<code>JS</code>修改<code>DOM</code>树，需要重新构建<code>DOM</code>树的情况，<code>DOM</code>树改变浏览器需要回过头来重新渲染这部分代码，所以浏览器希望通过阻塞其他内容的下载和呈现，来避免出现更多的不必要的<code>Reflow</code>（称为回流或者重排）</li><li>如果<code>&lt;script&gt;</code>放在的<code>&lt;head&gt;</code>中，则<code>&lt;body&gt;</code>标签无法被加载，那么页面自然就无法渲染了,因此这将导致在该<code>JS</code>代码完全执行完之前，页面都是一片空白，用户体验非常不好，一般我看到长时间的空白页面，我都非常想直接关闭它。因此会推荐将所有<code>&lt;script&gt;</code>标签尽可能放到<code>&lt;body&gt;</code>标签的底部，以尽量减少对整个页面下载的影响，此时虽然还会存在一个脚本阻塞另一个脚本的问题，但是用户体验比上面的好很多，因为用户看到了大部分内容，而不是空白</li><li><code>defer</code>属性相当于告诉浏览器立即下载，延迟执行。它使得加载后续文档元素的过程将和<code>JS</code>文件的<strong>加载</strong>并行进行（异步），但是<code>JS</code>文件的<strong>执行</strong>要在整个页面解析完成之后，<code>DOMContentLoaded</code>事件触发之前完成，执行顺序为出现的先后顺序。（高程中指出现实中不一定会按照顺序执行，也不一定会在<code>DOMContentLoaded</code>事件触发之前完成，因此最好只包含一个延迟脚本，这可能是与浏览器的实现有关，具体什么情况下会出现我还不知道？？？）</li><li><code>async</code>属性相当于告诉浏览器立即下载执行，并且页面的加载渲染不需要等待该脚本加载和执行，它们两者会异步进行。标记为<code>async</code>的脚本不会按照它们出现的先后顺序执行，而是谁先下载完了谁就先执行，它们一定会在页面的<code>load</code>事件触发之前执行，但可能会在<code>DOMContentLoaded</code>事件触发之前或之后执行。基于前面所说的一点原因，异步脚本最好不要修改<code>DOM</code>，如果由多个异步脚本，它们之间最好没有依赖关系</li></ul></li><li><p>浏览器继续加载渲染，如果遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源，这是异步请求，所以不会等到图片下载完，而是继续渲染后面的<code>HTML</code>文档。</p></li><li><p>等到服务器返回图片文件，如果先前并没有为这个图片设定宽高，那么由于图片占用了一定面积，影响了后面段落的排布，浏览器会进行<code>Reflow</code></p></li><li><p>然后然后终于和<code>＜/html＞</code>碰面了，此次的页面加载渲染过程完成，浏览器也是很累了，然后会立即触发<code>DOMContentLoaded</code>事件，该事件是在形成完整的<code>DOM</code>树之后就会触发，而不会理会图像、<code>JS</code>文件、<code>CSS</code>文件或其他资源是否已经下载完毕</p></li><li><p>当页面完全加载后，也就是所有图像、<code>JS</code>文件、<code>CSS</code>文件等外部资源都加载完成后会触发<code>load</code>事件</p></li><li><p>用户在页面上进行交互时，可能会导致页面进行<code>Repaint</code>或<code>Reflow</code></p><ul><li><code>Repaint</code>：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的<code>Repaint</code>，重绘某一部分</li><li><code>Reflow</code>：如果某个部分发生了的变化影响了布局，那浏览器就需要倒回去重新渲染，每次<code>Reflow</code>必然会导致<code>Repaint</code></li></ul></li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>看似简单的操作背后藏着数不清的小动作，文中也只是涉及了一部分，还有很多相关的过程没有涉及到，但是能力有限，还是慢慢来，暂时就先告一段落</li></ul><p><strong>参考博客 ：</strong> </p><p><a href="https://segmentfault.com/a/1190000014620172" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014620172</a></p><p><a href="https://www.cnblogs.com/chengxs/p/11039155.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxs/p/11039155.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-HTTPS区别&quot;&gt;&lt;a href=&quot;#HTTP-HTTPS区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP-HTTPS区别&quot;&gt;&lt;/a&gt;HTTP-HTTPS区别&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;申请证书上，HTTPS需要使用ca申请证书&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于抓包而言 ，HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTP通信过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/100535634.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络编程" scheme="http://zhuuu.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网页原理" scheme="http://zhuuu.work/tags/%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/"/>
    
      <category term="HTTP" scheme="http://zhuuu.work/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-347-前K个高频元素</title>
    <link href="http://zhuuu.work/2020/08/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2020/08/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2020-08-29T07:51:53.000Z</published>
    <updated>2020-09-26T08:29:18.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-347-Top-K-Frequent-Elements"><a href="#Leecode-347-Top-K-Frequent-Elements" class="headerlink" title="Leecode-347-Top K Frequent Elements"></a>Leecode-347-<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Top K Frequent Elements</a></h1><h2 id="思路：堆"><a href="#思路：堆" class="headerlink" title="思路：堆"></a>思路：堆</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong>高的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>这里题目描述中对时间复杂度做出了要求 ，需要在 O(n log n)的限制。</li></ul><p><strong>Solution : 粗暴排序法</strong></p><ul><li>最简单粗暴的思路就是 <strong>使用排序算法对元素按照频率由高到低进行排序</strong>，然后再取前 k 个元素。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/150737778.png" alt="mark"></p><ul><li>可以发现，使用常规的诸如冒泡，选择，甚至快速排序都不满足要求，它们的时间复杂度要求必须优于O(nlogn)</li></ul><ul><li><p><strong>时间复杂度：O(nlogn)</strong>，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，排序算法时间复杂度为 O(nlogn)；因此整体时间复杂度为 O(nlogn)。</p></li><li><p><strong>空间复杂度：O（n）</strong> ，需要Map来存储n个键值对</p></li></ul><p><strong>接下来我们介绍遇到TopK问题最常用的方法：最大堆或者最小堆</strong></p><p><strong>本题使用的是最小堆</strong></p><p><strong>Solution : 最小堆</strong></p><ul><li>题目最终需要返回的是前k个频率最大的元素。可以想到借助堆这种数据结构，对于k频率之后的元素不用再去处理，进一步优化时间复杂度</li><li>举个例子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/151221418.png" alt="mark"></p><p>具体的操作流程为：</p><ul><li><p>借助<strong>哈希表</strong>来建立数字和其出现次数之间的映射，遍历一遍数组统计元素的频率</p></li><li><p>维护一个元素数目是 k 的最小堆</p></li><li><p>每次都将新的元素和堆顶元素（堆中频率最小的元素）进行比较</p></li><li><p>如果新的元素频率比堆顶的元素大，则弹出堆顶的元素，将新的元素添加进堆中</p></li><li><p>最终，堆中的K个元素就是前 k 个高频元素。</p></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(a) - map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次将新的元素和堆顶元素（堆中频率最小的元素）进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; map.get(pq.peek()))&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出最小堆中的元素</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            res.add(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简便写法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 1. 统计每个元素出现的次数，元素作为key，元素出现的次数作为值</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 构造一个k个元素的小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; map.get(a) - map.get(b));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.每次将新的元素和堆顶的元素比较（堆中频率最小的元素进行比较）</span></span><br><span class="line">        <span class="keyword">for</span>(Integer key:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.offer(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(key) &gt; map.get(pq.peek()))&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.offer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 取出最小堆的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            res[index++] = pq.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(nlogk)</strong>，n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，遍历用于存储元素频率的 map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这里维护堆的数目是 k，所以这一系列操作的时间复杂度是O(nlogk) 的；因此，总的时间复杂度是 O(nlog⁡k)。</li><li><strong>空间复杂度：O(n)</strong>，最坏情况下（每个元素都不同），map 需要存储 n 个键值对，优先队列需要存储 k 个元素，因此，空间复杂度是 O(n)。</li></ul><p><strong>手动使用小顶堆实现TopK</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        buildHeap(tree, n);<span class="comment">//第一步是将得到的数组构建成小顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            swap(tree, i, <span class="number">0</span>);<span class="comment">//第一次构建完小顶堆之后，要进行第一个数和最后一个树的交换</span></span><br><span class="line">            <span class="comment">//交换完之后，最上面的数就不是最小数了，因此只需要对最上面的数，进行一个树的调整即可</span></span><br><span class="line">            <span class="comment">//所以，我们使用的时adjustTree而不是buildHeap</span></span><br><span class="line">            adjustTree(tree, i, <span class="number">0</span>);<span class="comment">//这里解释一下，这参数的含义：之所以将i当做数组的长度，</span></span><br><span class="line">            <span class="comment">//是因为我们将第一个数和最后一个数交换之后，就已经把最小的数放在了数组最后，进行</span></span><br><span class="line">            <span class="comment">//树调整的时候，就不需要管最后一个数字了。而0就是因为交换之后需要进行节点调节的那个节点</span></span><br><span class="line">            <span class="comment">//换到了第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这个函数写完之后，就可以将任意一个数组，构建成小顶堆了，构建完小顶堆之后，就要进行堆排序了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (n-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="comment">//i从最后一个子节点的父节点开始，所以i = (n-1)/2</span></span><br><span class="line">            adjustTree(tree, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用adjustTree和swap两个函数，可以针对某一个父节点，进行调节。接下来，解决当整个树是</span></span><br><span class="line">    <span class="comment">//乱序的，将一个树构建成一个小顶堆。思路是这样的：从最后一个子节点的父节点开始调节，往上走。</span></span><br><span class="line">    <span class="comment">//不断重复，每往上一个父节点，父节点的下标就减一，可以将adjustTree和swap函数放进一个for循环</span></span><br><span class="line">    <span class="comment">//就是上面的for循环</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 表示从某一个节点开始，调整一次树，使之成为堆，其中i表示某一个节点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustTree</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n) &#123;<span class="comment">//这是递归头。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先确定i节点的左右两个孩子的下标</span></span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c2 = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//接下来，在这三个值中，找出最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = i;<span class="comment">//先假设最小值为这个父节点</span></span><br><span class="line">        <span class="keyword">if</span>(c1&lt;n &amp;&amp; tree[c1]&gt;tree[max]) &#123;<span class="comment">//要保证c1不会出界</span></span><br><span class="line">            max = c1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c2&lt;n &amp;&amp; tree[c2]&gt;tree[max]) &#123;<span class="comment">//保证c2不会出界  c2&lt;n</span></span><br><span class="line">            max = c2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的条件判断，就可以将最小值的下标保存到max中了，如果最小值max就是i，也就是</span></span><br><span class="line">        <span class="comment">//父节点最小，就不用调整，但是如果父节点不是最小，就要进行交换了</span></span><br><span class="line">        <span class="keyword">if</span>(max!=i) &#123;</span><br><span class="line">            swap(tree,max,i);</span><br><span class="line">            adjustTree(tree,n,max);<span class="comment">//交换之后，将父节点下放一级，就有可能会破坏下一层结构，</span></span><br><span class="line">            <span class="comment">//所以，递归调用adjustTree.使用递归之后，就要添加递归头了</span></span><br><span class="line">        &#125;              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] tree, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = tree[i];</span><br><span class="line">        tree[i] = tree[j];</span><br><span class="line">        tree[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">32</span>, <span class="number">56</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">32</span>&#125;;<span class="comment">//原始数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] topk = topK(data, <span class="number">5</span>);<span class="comment">//调用topK方法，返回前k大的数组，返回的数组并不是有序的，而是一个小顶堆，如果想返回一个有序的，可以调用上面HeapSort类中的heapSort方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; topk.length; i++) &#123;<span class="comment">//循环输出小顶堆</span></span><br><span class="line">            System.out.println(topk[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topK(<span class="keyword">int</span>[] data, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] topk = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//根据传进来的K创建长度为k的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            topk[i] = data[i];<span class="comment">//先将源数据的前k个的数赋值给topK数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeapSort.buildHeap(topk, k);<span class="comment">//对这个topK数组进行一次最小堆的构建。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; data.length; i++) &#123;<span class="comment">//从源数据的第K个数开始循环，如果循环的数比堆顶元素还小，直接pass，</span></span><br><span class="line">            <span class="comment">// 如果比堆顶元素要大，就将此数放在堆顶，同时进行一次以它为起始点的树的调整。</span></span><br><span class="line">            <span class="keyword">int</span> temp = data[i];</span><br><span class="line">            <span class="keyword">if</span> (topk[<span class="number">0</span>] &lt; temp) &#123;</span><br><span class="line">                topk[<span class="number">0</span>] = temp;</span><br><span class="line">                HeapSort.adjustTree(topk, k, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-347-Top-K-Frequent-Elements&quot;&gt;&lt;a href=&quot;#Leecode-347-Top-K-Frequent-Elements&quot; class=&quot;headerlink&quot; title=&quot;Leecode-347-Top K Frequent Elements&quot;&gt;&lt;/a&gt;Leecode-347-&lt;a href=&quot;https://leetcode-cn.com/problems/top-k-frequent-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Top K Frequent Elements&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：堆&quot;&gt;&lt;a href=&quot;#思路：堆&quot; class=&quot;headerlink&quot; title=&quot;思路：堆&quot;&gt;&lt;/a&gt;思路：堆&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;k&lt;/strong&gt;高的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1,1,1,2,2,3], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。&lt;/li&gt;
&lt;li&gt;你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。&lt;/li&gt;
&lt;li&gt;你可以按任意顺序返回答案。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="TopK算法题" scheme="http://zhuuu.work/tags/TopK%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux-11-磁盘调度算法</title>
    <link href="http://zhuuu.work/2020/08/29/Linux/Linux-11-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/08/29/Linux/Linux-11-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-29T03:22:53.000Z</published>
    <updated>2020-09-26T06:54:55.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-11-磁盘调度算法"><a href="#Linux-11-磁盘调度算法" class="headerlink" title="Linux-11-磁盘调度算法"></a>Linux-11-磁盘调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png" alt="mark"></p><a id="more"></a><h2 id="1-磁盘结构"><a href="#1-磁盘结构" class="headerlink" title="1. 磁盘结构"></a>1. 磁盘结构</h2><ul><li>常见的机械磁盘是上图左边的样子，中间圆的部分是磁盘的盘片，一般会有多个盘片，每个盘面都有自己的磁头。</li><li>右边的图就是一个盘片的结构，盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是 <code>512</code> 字节。</li><li>那么，多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面，如上图里中间的样子。</li></ul><p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。</p><p>寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设有下面一个请求序列，每个数字代表磁道的位置：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">初始磁头当前的位置是在第 &#96;53&#96; 磁道。</span><br></pre></td></tr></table></figure><p>接下来，分别对以上的序列，作为每个调度算法的例子，那常见的磁盘调度算法有：</p><ul><li>先来先服务算法</li><li>最短寻道时间优先算法</li><li>扫描算法算法</li><li>循环扫描算法</li><li>LOOK 与 C-LOOK 算法</li></ul><h2 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2. 磁盘调度算法"></a>2. 磁盘调度算法</h2><h3 id="2-1-先来先服务"><a href="#2-1-先来先服务" class="headerlink" title="2.1 先来先服务"></a>2.1 先来先服务</h3><ul><li><p>先来先服务（<em>First-Come，First-Served，FCFS</em>），顾名思义，先到来的请求，先被服务。</p></li><li><p>那按照这个序列的话：</p><p><code>98，183，37，122，14，124，65，67</code></p><p>那么，磁盘的写入顺序是从左到右，如下图：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144809106.png" alt="mark"></p><ul><li>先来先服务算法总共移动了 <code>640</code> 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</li></ul><h3 id="2-2-最短寻道时间优先"><a href="#2-2-最短寻道时间优先" class="headerlink" title="2.2 最短寻道时间优先"></a>2.2 最短寻道时间优先</h3><ul><li>最短寻道时间优先（<em>Shortest Seek First，SSF</em>）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</li></ul><p><code>98，183，37，122，14，124，65，67</code></p><ul><li>那么，那么根据距离磁头（ 53 位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：</li></ul><p><code>65，67，37，14，98，122，124，183</code></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144946962.png" alt="mark"></p><ul><li>磁头移动的总距离是 <code>236</code> 磁道，相比先来先服务性能提高了不少。<ul><li>但这个算法可能存在某些请求的<strong>饥饿</strong>，因为本次例子我们是静态的序列，看不出问题，</li><li>假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里<strong>产生饥饿的原因是磁头在一小块区域来回移动</strong>。</li></ul></li></ul><h3 id="2-3-扫描算法"><a href="#2-3-扫描算法" class="headerlink" title="2.3 扫描算法"></a>2.3 扫描算法</h3><ul><li>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</li><li>为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（*Scan*）算法</strong>。</li><li>这种算法也叫做电梯算法，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">37，14，0，65，67，98，122，124，183</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145111421.png" alt="mark"></p><ul><li>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</li><li>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题<ul><li>中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。</li></ul></li></ul><h3 id="2-4-循环扫描算法"><a href="#2-4-循环扫描算法" class="headerlink" title="2.4 循环扫描算法"></a>2.4 循环扫描算法</h3><ul><li><p>扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</p></li><li><p>循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">65，67，98，122，124，183，199，0，14，37</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145234782.png" alt="mark"></p><ul><li>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</li><li>循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。</li></ul><h3 id="2-5-LOOK-与-C-LOOK算法"><a href="#2-5-LOOK-与-C-LOOK算法" class="headerlink" title="2.5 LOOK 与 C-LOOK算法"></a>2.5 LOOK 与 C-LOOK算法</h3><ul><li>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</li><li>那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></li><li>那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145437467.png" alt="mark"></p><ul><li>而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145453441.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-11-磁盘调度算法&quot;&gt;&lt;a href=&quot;#Linux-11-磁盘调度算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-11-磁盘调度算法&quot;&gt;&lt;/a&gt;Linux-11-磁盘调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="磁盘调度算法" scheme="http://zhuuu.work/tags/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-try-catch</title>
    <link href="http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-try-catch/"/>
    <id>http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-try-catch/</id>
    <published>2020-08-28T08:39:38.000Z</published>
    <updated>2020-09-18T06:12:19.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-try-catch"><a href="#Java-基础-try-catch" class="headerlink" title="Java-基础-try-catch"></a>Java-基础-try-catch</h1><h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p><strong>绕口令开始</strong></p><p><strong>1、不管有没有异常，<code>finally</code>中的代码都会执行</strong><br><strong>2、当<code>try、catch</code>中有<code>return</code>时，<code>finally</code>中的代码依然会继续执行</strong><br><strong>3、<code>finally</code>是在<code>return</code>后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。</strong><br><strong>4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</strong><br><strong>5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 先执行try中的语句，包括return后面的表达式，</span><br><span class="line">2. 有异常时,先执行catch中的语句，包括return后面的表达式,</span><br><span class="line">3. 然后执行finally中的语句,如果finally里面有return语句，会提前退出，</span><br><span class="line">最后执行try中的return，有异常时执行catch中的return。</span><br><span class="line"></span><br><span class="line">4. 在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的。编译器把finally中的return语句标识为一个warning.</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-举例分析"><a href="#2-举例分析" class="headerlink" title="2. 举例分析"></a>2. 举例分析</h2><ol><li>案例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 try</span><br><span class="line">执行 finally</span><br><span class="line">主方法返回 ：try</span><br></pre></td></tr></table></figure><p><strong>结论：执行try 到了return的时候会去检测finally。finally块存在会先执行finally块的内容，再return。</strong></p><p><strong>案例二：假设finally里面也有return呢？执行的是哪个return？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 <span class="keyword">try</span></span><br><span class="line">执行<span class="keyword">finally</span></span><br><span class="line">主方法返回 ：<span class="keyword">finally</span></span><br></pre></td></tr></table></figure><p><strong>结论：如果finally里面存在return，将直接返回。不再跳回try块的return。</strong></p><p><strong>案例三：catch也是一样的道理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行 <span class="keyword">try</span></span><br><span class="line">执行 <span class="keyword">catch</span></span><br><span class="line">执行<span class="keyword">finally</span></span><br><span class="line">主方法返回 ：<span class="keyword">finally</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-try-catch&quot;&gt;&lt;a href=&quot;#Java-基础-try-catch&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-try-catch&quot;&gt;&lt;/a&gt;Java-基础-try-catch&lt;/h1&gt;&lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;绕口令开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、不管有没有异常，&lt;code&gt;finally&lt;/code&gt;中的代码都会执行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2、当&lt;code&gt;try、catch&lt;/code&gt;中有&lt;code&gt;return&lt;/code&gt;时，&lt;code&gt;finally&lt;/code&gt;中的代码依然会继续执行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;3、&lt;code&gt;finally&lt;/code&gt;是在&lt;code&gt;return&lt;/code&gt;后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 先执行try中的语句，包括return后面的表达式，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 有异常时,先执行catch中的语句，包括return后面的表达式,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 然后执行finally中的语句,如果finally里面有return语句，会提前退出，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	最后执行try中的return，有异常时执行catch中的return。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的。编译器把finally中的return语句标识为一个warning.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="try-catch-finally" scheme="http://zhuuu.work/tags/try-catch-finally/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-线程中断</title>
    <link href="http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</id>
    <published>2020-08-28T08:38:38.000Z</published>
    <updated>2020-08-28T14:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-线程中断"><a href="#Java-基础-线程中断" class="headerlink" title="Java-基础-线程中断"></a>Java-基础-线程中断</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Thread提供了interrupt方法，中断线程的执行：</p><ul><li>如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出<code>InterruptedException</code>,同时清除线程的中断状态;</li><li>如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；</li><li>如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心 interrupt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">         checkAccess();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这个方法不会清除中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-源码实现"><a href="#2-源码实现" class="headerlink" title="2. 源码实现"></a>2. 源码实现</h2><ul><li>之前在分析Thread.start的时候曾经提到，JavaThread有三个成员变量:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于synchronized同步块和Object.wait() </span></span><br><span class="line">ParkEvent * _ParkEvent ; </span><br><span class="line"><span class="comment">//用于Thread.sleep() </span></span><br><span class="line">ParkEvent * _SleepEvent ; </span><br><span class="line"><span class="comment">//用于unsafe.park()/unpark(),供java.util.concurrent.locks.LockSupport调用， </span></span><br><span class="line"><span class="comment">//因此它支持了java.util.concurrent的各种锁、条件变量等线程同步操作,是concurrent的实现基础 </span></span><br><span class="line">Parker* _parker;</span><br></pre></td></tr></table></figure><ul><li>初步猜测interrupt实现应该与此有关系；<br>interrupt方法的源码也在jvm.cpp文件:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Interrupt"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before we operate</span></span><br><span class="line">  oop java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;threadObj()</span> </span>== java_thread ? NULL : Threads_lock);</span><br><span class="line">  <span class="comment">// We need to re-resolve the java_thread, since a GC might have happened during the</span></span><br><span class="line">  <span class="comment">// acquire of the lock</span></span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != NULL) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><ul><li>JVM_Interrupt对参数进行了校验，然后直接调用Thread::interrupt:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  trace(<span class="string">"interrupt"</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Thread::interrupt调用os::interrupt方法实现,os::interrupt方法定义在os_linux.cpp:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取系统native线程对象</span></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">    osthread-&gt;set_interrupted(<span class="literal">true</span>);</span><br><span class="line">   <span class="comment">//内存屏障，使osthread的interrupted状态对其它线程立即可见</span></span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    <span class="comment">//前文说过，_SleepEvent用于Thread.sleep,线程调用了sleep方法，则通过unpark唤醒</span></span><br><span class="line">    ParkEvent * <span class="keyword">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">    <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;unpark() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//_parker用于concurrent相关的锁，此处同样通过unpark唤醒</span></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">  <span class="comment">//synchronized同步块和Object.wait() 唤醒</span></span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由此可见，interrupt其实就是通过ParkEvent的unpark方法唤醒对象；另外要注意：</strong></p><ul><li>object.wait、Thread.sleep和Thread.join会抛出InterruptedException并清除中断状态；</li><li>Lock.lock()方法不会响应中断，Lock.lockInterruptibly()方法则会响应中断并抛出异常，区别在于park()等待被唤醒时lock会继续执行park()来等待锁，而 lockInterruptibly会抛出异常；</li><li>synchronized被唤醒后会尝试获取锁，失败则会通过循环继续park()等待，因此实际上是不会被interrupt()中断的;</li><li>一般情况下，抛出异常时，会清空Thread的interrupt状态，在编程时需要注意；</li></ul><h2 id="3-网络中断相关"><a href="#3-网络中断相关" class="headerlink" title="3. 网络中断相关"></a>3. 网络中断相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>其中blocker是Thread的成员变量,Thread提供了blockedOn方法可以设置blocker:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">           blocker = b;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>如果一个nio通道实现了InterruptibleChannel接口，就可以响应interrupt()中断，其原理就在InterruptibleChannel接口的抽象实现类AbstractInterruptibleChannel的方法begin()中:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread target)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (!open)</span><br><span class="line">                               <span class="keyword">return</span>;</span><br><span class="line">                           open = <span class="keyword">false</span>;</span><br><span class="line">                           interrupted = target;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               AbstractInterruptibleChannel.<span class="keyword">this</span>.implCloseChannel();</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       blockedOn(interruptor);<span class="comment">//设置当前线程的blocker为interruptor</span></span><br><span class="line">       Thread me = Thread.currentThread();</span><br><span class="line">       <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">           interruptor.interrupt(me);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> AsynchronousCloseException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       blockedOn(<span class="keyword">null</span>);<span class="comment">//设置当前线程的blocker为null</span></span><br><span class="line">       Thread interrupted = <span class="keyword">this</span>.interrupted;</span><br><span class="line">      <span class="comment">//如果发生中断，Thread.interrupt方法会调用Interruptible的interrupt方法，</span></span><br><span class="line">     <span class="comment">//设置this.interrupted为当前线程</span></span><br><span class="line">       <span class="keyword">if</span> (interrupted != <span class="keyword">null</span> &amp;&amp; interrupted == Thread.currentThread()) &#123;</span><br><span class="line">           interrupted = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ClosedByInterruptException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!completed &amp;&amp; !open)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AsynchronousCloseException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class java.nio.channels.Channels.WritableByteChannelImpl</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            out.write(buf, <span class="number">0</span>, bytesToWrite);</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(bytesToWrite &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class java.nio.channels.Channels.ReadableByteChannelImpl</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            bytesRead = in.read(buf, <span class="number">0</span>, bytesToRead);</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(bytesRead &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>以上述代码为例，nio通道的ReadableByteChannel每次执行阻塞方法read()前，都会执行begin()，把Interruptible回调接口注册到当前线程上。当线程中断时，Thread.interrupt()触发回调接口Interruptible关闭io通道,导致read方法返回，最后在finally块中执行end()方法检查中断标记，抛出ClosedByInterruptException;</li></ul><p><strong>Selector的实现类似：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread ignore)</span> </span>&#123;</span><br><span class="line">                        AbstractSelector.<span class="keyword">this</span>.wakeup();</span><br><span class="line">                    &#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        AbstractInterruptibleChannel.blockedOn(interruptor);</span><br><span class="line">        Thread me = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">            interruptor.interrupt(me);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractInterruptibleChannel.blockedOn(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.class EPollSelectorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            pollWrapper.poll(timeout);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            end();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到当发生中断时会调用wakeup方法唤醒poll方法，但并不会抛出中断异常；</p><h2 id="4-通过interrupted-关闭线程"><a href="#4-通过interrupted-关闭线程" class="headerlink" title="4. 通过interrupted()关闭线程"></a>4. 通过interrupted()关闭线程</h2><ul><li>总所周知，<code>Thread.stop, Thread.suspend, Thread.resume</code> 都已经被废弃了。因为它们太暴力了，是不安全的，这种暴力中断线程是一种不安全的操作，举个栗子来说明其可能造成的问题：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopThread thread = <span class="keyword">new</span> StopThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 休眠1秒，确保线程进入运行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 暂停线程</span></span><br><span class="line">        thread.stop();</span><br><span class="line"><span class="comment">//      thread.interrupt();</span></span><br><span class="line">        <span class="comment">// 确保线程已经销毁</span></span><br><span class="line">        <span class="keyword">while</span> (thread.isAlive()) &#123; &#125;</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        thread.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这是一个同步原子操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ++x;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 休眠3秒,模拟耗时操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"x="</span> + x + <span class="string">" y="</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，run方法里是一个同步的原子操作，x和y必须要共同增加，然而这里如果调用thread.stop()方法强制中断线程，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">0</span></span><br></pre></td></tr></table></figure><p> 没有异常，也破坏了我们的预期。如果这种问题出现在我们的程序中，会引发难以预期的异常。因此这种不安全的方式很早就被废弃了。取而代之的是interrupt()，上述代码如果采用thread.interrupt()方法，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">1</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ThreadTest$StopThread.run(ThreadTest.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure><p> <strong>x=1,y=1 这个结果是符合我们的预期，同时还抛出了个异常，这个异常下文详说。</strong></p><p><strong>interrupt() 它基于「一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。」思想，是一个比较温柔的做法，它更类似一个标志位。其实作用不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</strong></p><p><strong>interrupt() 并不能真正的中断线程，这点要谨记。需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就需要这样做：</strong></p><ol><li>在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。</li><li>在调用阻塞方法时正确处理InterruptedException异常。（例如：catch异常后就结束线程。）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心 interrupt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">         checkAccess();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这个方法不会清除中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>首先讲 interrupt() 方法：</strong></p><ol><li>interrupt 中断操作时，非自身打断需要先检测是否有中断权限，这由jvm的安全机制配置；</li><li>如果线程处于<code>sleep, wait, join</code>等状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常；</li><li>如果线程处于I/O阻塞状态，将会抛出ClosedByInterruptException（IOException的子类）异常；</li><li>如果线程在Selector上被阻塞，select方法将立即返回；</li><li>如果非以上情况，将直接标记 interrupt 状态；</li></ol><p><strong>注意：interrupt 操作不会打断所有阻塞，只有上述阻塞情况才在jvm的打断范围内，如处于锁阻塞的线程，不会受 interrupt 中断；</strong></p><p><strong>等待情况下中断，抛出异常后线程恢复非中断状态，即 interrupted = false</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"1"</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread has been interrupt!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"isInterrupted: "</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread has been interrupt!</span><br><span class="line">isInterrupted: <span class="keyword">false</span></span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure><p><strong>调用Thread.interrupted() 方法后线程恢复非中断状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"1"</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"first :"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"second:"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first :<span class="keyword">true</span></span><br><span class="line">second:<span class="keyword">false</span></span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure><p><strong>上述两种隐含的状态恢复操作，是符合常理的，因为线程标记为中断后，用户没有真正中断线程，必然将其恢复为false。理论上Thread.interrupted()调用后，如果已中断，应该执行退出操作，不会重复调用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-线程中断&quot;&gt;&lt;a href=&quot;#Java-基础-线程中断&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-线程中断&quot;&gt;&lt;/a&gt;Java-基础-线程中断&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Thread提供了interrupt方法，中断线程的执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出&lt;code&gt;InterruptedException&lt;/code&gt;,同时清除线程的中断状态;&lt;/li&gt;
&lt;li&gt;如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；&lt;/li&gt;
&lt;li&gt;如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 核心 interrupt 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; != Thread.currentThread()) &lt;span class=&quot;comment&quot;&gt;// 非本线程，需要检查权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         checkAccess();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (blockerLock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         Interruptible b = blocker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (b != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             interrupt0();           &lt;span class=&quot;comment&quot;&gt;// 仅仅设置interrupt标志位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             b.interrupt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);    &lt;span class=&quot;comment&quot;&gt;// 调用如 I/O 操作定义的中断方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     interrupt0();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; currentThread().isInterrupted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 这个方法不会清除中断状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isInterrupted(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; ClearInterrupted)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="线程中断" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--41-数据流中的中位数</title>
    <link href="http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2020-08-26T07:15:53.000Z</published>
    <updated>2020-09-09T04:23:13.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–41-数据流中的中位数"><a href="#剑指offer–41-数据流中的中位数" class="headerlink" title="剑指offer–41-数据流中的中位数"></a>剑指offer–41-<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-两个堆"><a href="#思路-两个堆" class="headerlink" title="思路 : 两个堆"></a><strong>思路 : 两个堆</strong></h2><p><strong>待优化的思路1：快排</strong></p><ul><li>其中位数的计算方法：首先对数组执行排序（使用O<em>(</em>N<em>log</em>N) 时间），然后返回中间元素即可（使用 O(1)时间）。</li><li>针对本题，根据以上思路，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。此方法的时间复杂度为 O(N)，其中包括： 查找元素插入位置O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。</li></ul><p><strong>思路2： 两个堆</strong></p><ul><li>事实上，我们只关心在中间的那两个数（或者一个数），其它数没有必要进行 “比较” 和 “交换” 的操作。</li><li>在我们学习过的数据结构里，堆就有类似的性质，每次都从堆里得到一个 “最值” 而其它元素无需排序，这样就可以以O(logN) 的复杂度每次都从堆中取出最值。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111604101.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111617276.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111821068.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-112110039.png" alt="mark"></p><p><strong>总结：</strong></p><ul><li><strong>为了找到添加新数据以后，数据流的中位数，我们让这个新数据在大顶堆和小顶堆中都走了一遍。而为了让大顶堆的元素多 1 个，我们让从小顶堆中又拿出一个元素“送回”给大顶堆；</strong></li><li>将元素放入优先队列以后，优先队列会以对数时间复杂度自行调整，把“最优值”放入堆顶，这是使用优先队列解决这个问题的原因。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前大顶堆和小顶堆的元素个数之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxheap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minheap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">        minheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        maxheap.offer(num);</span><br><span class="line">        minheap.add(maxheap.poll());</span><br><span class="line">        <span class="comment">// 如果两个堆合起来的元素个数是奇数，小顶堆要拿出堆顶元素给大顶堆</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            maxheap.add(minheap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (maxheap.peek() + minheap.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) maxheap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度：</strong>O(logN) 优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的，综上时间复杂度是 O(logN) 级别的。</li><li><strong>空间复杂度：</strong>O(N) 占用堆的大小</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;a href=&quot;#剑指offer–41-数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;/a&gt;剑指offer–41-&lt;a href=&quot;https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据流中的中位数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;[2,3,4] 的中位数是 3&lt;/p&gt;
&lt;p&gt;[2,3] 的中位数是 (2 + 3) / 2 = 2.5&lt;/p&gt;
&lt;p&gt;设计一个支持以下两种操作的数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void addNum(int num) - 从数据流中添加一个整数到数据结构中。&lt;/li&gt;
&lt;li&gt;double findMedian() - 返回目前所有元素的中位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[1],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,null,1.50000,null,2.00000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,2.00000,null,2.50000]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--52-两个链表的第一个公共节点</title>
    <link href="http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--56-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--56-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2020-08-26T07:12:53.000Z</published>
    <updated>2020-08-26T11:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–52-两个链表的第一个公共节点"><a href="#剑指offer–52-两个链表的第一个公共节点" class="headerlink" title="剑指offer–52-两个链表的第一个公共节点"></a>剑指offer–52-<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191825466.png" alt="mark"></p><p>在节点 c1 开始相交。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191838788.png" alt="mark"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-192018933.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-192115537.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路：</p><ul><li><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p></li><li><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = headA;</span><br><span class="line">        ListNode l2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            <span class="comment">// 我走过你走的路</span></span><br><span class="line">            l1 = l1 == <span class="keyword">null</span>? headB:l1.next;</span><br><span class="line">           <span class="comment">//  你走过我走的路</span></span><br><span class="line">            l2 = l2 == <span class="keyword">null</span>? headA:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 所以我们才能相遇</span></span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O（n + m）</strong></li><li><strong>空间复杂度:O(1)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–52-两个链表的第一个公共节点&quot;&gt;&lt;a href=&quot;#剑指offer–52-两个链表的第一个公共节点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–52-两个链表的第一个公共节点&quot;&gt;&lt;/a&gt;剑指offer–52-&lt;a href=&quot;https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个链表的第一个公共节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入两个链表，找出它们的第一个公共节点。&lt;/p&gt;
&lt;p&gt;如下面的两个链表&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191825466.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在节点 c1 开始相交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191838788.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID</title>
    <link href="http://zhuuu.work/2020/08/25/distributed/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <id>http://zhuuu.work/2020/08/25/distributed/%E5%88%86%E5%B8%83%E5%BC%8FID/</id>
    <published>2020-08-25T09:38:38.000Z</published>
    <updated>2020-09-20T06:15:49.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>在说分布式ID的具体实现之前，我们来简单分析一下为什么用分布式ID？分布式ID应该满足哪些特征？</li></ul><p><strong>1、什么是分布式ID？</strong></p><p>拿MySQL数据库举个栗子：</p><ul><li>在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。</li><li>但随着数据日渐增长，主从同步也扛不住了，就需要<strong>对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据</strong>，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有<code>唯一ID</code>做标识。此时一个能够生成<code>全局唯一ID</code>的系统是非常必要的。那么这个<code>全局唯一ID</code>就叫<code>分布式ID</code>。</li></ul><p><strong>2、那么分布式ID需要满足那些条件？</strong></p><ul><li>全局唯一：必须保证ID是全局性唯一的，基本要求</li><li>高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈</li><li>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性</li><li>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单</li><li>趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求</li></ul><a id="more"></a><h2 id="一-九种生成方案"><a href="#一-九种生成方案" class="headerlink" title="一. 九种生成方案"></a>一. 九种生成方案</h2><p>今天主要分析一下以下9种，分布式ID生成器方式以及优缺点：</p><ul><li>UUID</li><li>数据库自增ID</li><li>数据库多主模式</li><li>号段模式</li><li>Redis</li><li>雪花算法（SnowFlake）</li><li>滴滴出品（TinyID）</li><li>百度 （Uidgenerator）</li><li>美团（Leaf）</li></ul><p>那么它们都是如何实现？以及各自有什么优缺点？我们往下看</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224053071.png" alt="mark"></p><p><strong>1、基于UUID</strong></p><p>在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是UUID，毕竟它有着全球唯一的特性。那么UUID可以做分布式ID吗？答案是可以的，但是并不推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">       String uuid &#x3D; UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);</span><br><span class="line">       System.out.println(uuid);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>UUID</code>的生成简单到只有一行代码，输出结果 <code>c2b8c2b9e46c47e3b30dca3b0d447718</code>，但UUID却并不适用于实际的业务需求。像用作订单号<code>UUID</code>这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务<code>主键ID</code>，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作<code>分布式ID</code>。</p><p><strong>优点：</strong></p><ul><li>生成足够简单，本地生成无网络消耗，具有唯一性</li></ul><p><strong>缺点：</strong></p><ul><li>无序的字符串，不具备趋势自增特性</li><li>没有具体的业务含义</li><li>长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 <code>UUID</code> 的无序性会导致数据位置频繁变动，严重影响性能。</li></ul><p><strong>2、基于数据库自增ID</strong></p><p>基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224302161.png" alt="mark"></p><p>当我们需要一个ID的时候，向表中插入一条记录返回<code>主键ID</code>，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</p><p><strong>优点：</strong></p><ul><li>实现简单，ID单调自增，数值类型查询速度快</li></ul><p><strong>缺点：</strong></p><ul><li>DB单点存在宕机风险，无法扛住高并发场景</li></ul><p><strong>3、基于数据库集群模式</strong></p><ul><li>前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。</li><li>那这样还会有个问题，两个MySQL实例的自增ID都从1开始，<strong>会生成重复的ID怎么办？</strong></li></ul><p><strong>解决方案</strong>：设置<code>起始值</code>和<code>自增步长</code></p><p>MySQL_1 配置：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224410327.png" alt="mark"></p><p>MySQL_2 配置：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224414705.png" alt="mark"></p><p>这样两个MySQL实例的自增ID分别就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、3、5、7、9</span><br><span class="line">2、4、6、8、10</span><br></pre></td></tr></table></figure><p>那如果集群后的性能还是扛不住高并发咋办？就要进行MySQL扩容增加节点，这是一个比较麻烦的事。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224448462.png" alt="mark"></p><p><strong>缺点：</strong></p><ul><li>增加第三台<code>MySQL</code>实例需要人工修改一、二两台<code>MySQL实例</code>的起始值和步长，把<code>第三台机器的ID</code>起始生成位置设定在比现有<code>最大自增ID</code>的位置远一些，但必须在一、二两台<code>MySQL实例</code>ID还没有增长到<code>第三台MySQL实例</code>的<code>起始ID</code>值的时候，否则<code>自增ID</code>就要出现重复了，<strong>必要时可能还需要停机修改</strong>。</li></ul><p><strong>优点：</strong></p><ul><li>解决DB单点问题</li></ul><p><strong>4、基于数据库的号段模式</strong></p><ul><li>号段模式是当下<strong>分布式ID生成器的主流实现方式之一</strong>，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围</li><li>例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE id_generator (</span><br><span class="line">  id int(10) NOT NULL,</span><br><span class="line">  max_id bigint(20) NOT NULL COMMENT &#39;当前最大id&#39;,</span><br><span class="line">  step int(20) NOT NULL COMMENT &#39;号段的布长&#39;,</span><br><span class="line">  biz_type    int(20) NOT NULL COMMENT &#39;业务类型&#39;,</span><br><span class="line">  version int(20) NOT NULL COMMENT &#39;版本号&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>biz_type ：代表不同业务类型</p><p>max_id ：当前最大的可用id</p><p>step ：代表号段的长度</p><p>version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224734804.png" alt="mark"></p><ul><li>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update id_generator set max_id &#x3D; #&#123;max_id+step&#125;, version &#x3D; version + 1 where version &#x3D; # &#123;version&#125; and biz_type &#x3D; XXX</span><br></pre></td></tr></table></figure><ul><li>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</li></ul><p><strong>5、基于Redis模式</strong></p><p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224902154.png" alt="mark"></p><p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p><ul><li><strong><code>RDB</code>会定时打一个快照进行持久化</strong>，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li><li><strong><code>AOF</code>会对每条写命令进行持久化</strong>，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li></ul><p><strong>6、基于雪花算法（Snowflake）模式</strong></p><ul><li>雪花算法（<code>Snowflake</code>）是<code>twitter</code>公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/161626004.png" alt="mark"></p><ul><li><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。<ul><li><code>Snowflake</code> ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</span><br><span class="line">时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) &#x2F; (1000L * 60 * 60 * 24 * 365) &#x3D; 69年</span><br><span class="line">工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。</span><br><span class="line">序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</span><br></pre></td></tr></table></figure><ul><li>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://github.com/beyondfengyu/SnowFlake</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlakeShortUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_TIMESTAMP = <span class="number">1480166465631L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>;   <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">5</span>;     <span class="comment">//机器标识占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_BIT = <span class="number">5</span>; <span class="comment">//数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_DATA_CENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATA_CENTER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> dataCenterId;  <span class="comment">//数据中心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> machineId;     <span class="comment">//机器标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimeStamp = -<span class="number">1L</span>;  <span class="comment">//上一次时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mill = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastTimeStamp) &#123;</span><br><span class="line">            mill = getNewTimeStamp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataCenterId 数据中心ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> machineId    机器标志ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlakeShortUrl</span><span class="params">(<span class="keyword">long</span> dataCenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"DtaCenterId can't be greater than MAX_DATA_CENTER_NUM or less than 0！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"MachineId can't be greater than MAX_MACHINE_NUM or less than 0！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currTimeStamp = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Clock moved backwards.  Refusing to generate id"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp == lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">//相同毫秒内，序列号自增</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                currTimeStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不同毫秒内，序列号置为0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastTimeStamp = currTimeStamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class="comment">//时间戳部分</span></span><br><span class="line">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       <span class="comment">//数据中心部分</span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             <span class="comment">//机器标识部分</span></span><br><span class="line">                | sequence;                             <span class="comment">//序列号部分</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SnowFlakeShortUrl snowFlake = <span class="keyword">new</span> SnowFlakeShortUrl(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); i++) &#123;</span><br><span class="line">            <span class="comment">//10进制</span></span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、百度（uid-generator）</strong></p><ul><li><code>uid-generator</code>是由百度技术部开发，项目GitHub地址 </li><li><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的<code>snowflake</code>算法不同在于，<code>uid-generator</code>支持自<code>定义时间戳</code>、<code>工作机器ID</code>和 <code>序列号</code> 等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略。</li><li><code>uid-generator</code>需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的<code>workId</code>数据由host，port组成。</li></ul><p><strong>对于<code>uid-generator</code> ID组成结构</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;workId&#96;，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，</span><br><span class="line">需要注意的是，和原始的&#96;snowflake&#96;不太一样，时间的单位是秒，而不是毫秒，</span><br><span class="line">&#96;workId&#96;也不一样，而且同一应用每次重启就会消费一个&#96;workId&#96;</span><br></pre></td></tr></table></figure><p><strong>8、美团（Leaf）</strong></p><p><code>Leaf</code>由美团开发，github地址：<a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fgithub.com%2FMeituan-Dianping%2FLeaf">https://github.com/Meituan-Dianping/Leaf</a><br><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用。</p><p><strong>号段模式</strong></p><ul><li>先导入源码 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fgithub.com%2FMeituan-Dianping%2FLeaf">https://github.com/Meituan-Dianping/Leaf</a> ，在建一张表<code>leaf_alloc</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;leaf_alloc&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;leaf_alloc&#96; (</span><br><span class="line">  &#96;biz_tag&#96; varchar(128)  NOT NULL DEFAULT &#39;&#39; COMMENT &#39;业务key&#39;,</span><br><span class="line">  &#96;max_id&#96; bigint(20) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;当前已经分配了的最大id&#39;,</span><br><span class="line">  &#96;step&#96; int(11) NOT NULL COMMENT &#39;初始步长，也是动态调整的最小步长&#39;,</span><br><span class="line">  &#96;description&#96; varchar(256)  DEFAULT NULL COMMENT &#39;业务key的描述&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;数据库维护的更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;biz_tag&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><ul><li>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leaf.name&#x3D;com.sankuai.leaf.opensource.test</span><br><span class="line">leaf.segment.enable&#x3D;true</span><br><span class="line">leaf.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;leaf_test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;characterSetResults&#x3D;utf8</span><br><span class="line">leaf.jdbc.username&#x3D;root</span><br><span class="line">leaf.jdbc.password&#x3D;root</span><br><span class="line"></span><br><span class="line">leaf.snowflake.enable&#x3D;false</span><br><span class="line">#leaf.snowflake.zk.address&#x3D;</span><br><span class="line">#leaf.snowflake.port&#x3D;</span><br></pre></td></tr></table></figure><ul><li>启动<code>leaf-server</code> 模块的 <code>LeafServerApplication</code>项目就跑起来了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">号段模式获取分布式自增ID的测试url ：http：&#x2F;&#x2F;localhost：8080&#x2F;api&#x2F;segment&#x2F;get&#x2F;leaf-segment-test</span><br><span class="line"></span><br><span class="line">监控号段模式：http:&#x2F;&#x2F;localhost:8080&#x2F;cache</span><br></pre></td></tr></table></figure><p><strong>snowflake模式</strong></p><ul><li><code>Leaf</code>的<code>snowflake</code>模式依赖于<code>ZooKeeper</code>，<strong>不同于<code>原始snowflake</code>算法也主要是在<code>workId</code>的生成上</strong></li><li><code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序Id来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code>。</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163411884.png" alt="mark" style="zoom:200%;" /><ul><li>snowflake模式获取分布式自增ID的测试url：[<a href="http://localhost:8080/api/snowflake/get/test]" target="_blank" rel="noopener">http://localhost:8080/api/snowflake/get/test]</a></li></ul><p><strong>9、滴滴（Tinyid）</strong></p><p><code>Tinyid</code>由滴滴开发，Github地址：<a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fgithub.com%2Fdidi%2Ftinyid">https://github.com/didi/tinyid</a>。</p><p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163635480.png" alt="mark"></p><p><strong>Http方式接入</strong></p><p>（1）导入Tinyid源码：<br>git clone <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fgithub.com%2Fdidi%2Ftinyid.git">https://github.com/didi/tinyid.git</a></p><p>（2）创建数据表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tiny_id_info&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span><br><span class="line">  &#96;biz_type&#96; varchar(63) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;业务类型，唯一&#39;,</span><br><span class="line">  &#96;begin_id&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#39;,</span><br><span class="line">  &#96;max_id&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;当前最大id&#39;,</span><br><span class="line">  &#96;step&#96; int(11) DEFAULT &#39;0&#39; COMMENT &#39;步长&#39;,</span><br><span class="line">  &#96;delta&#96; int(11) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;每次id增量&#39;,</span><br><span class="line">  &#96;remainder&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;余数&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NOT NULL DEFAULT &#39;2010-01-01 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT &#39;2010-01-01 00:00:00&#39; COMMENT &#39;更新时间&#39;,</span><br><span class="line">  &#96;version&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;版本号&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uniq_biz_type&#96; (&#96;biz_type&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8 COMMENT &#39;id信息表&#39;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;tiny_id_token&#96; (</span><br><span class="line">  &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增id&#39;,</span><br><span class="line">  &#96;token&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;token&#39;,</span><br><span class="line">  &#96;biz_type&#96; varchar(63) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;此token可访问的业务类型标识&#39;,</span><br><span class="line">  &#96;remark&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;备注&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NOT NULL DEFAULT &#39;2010-01-01 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT &#39;2010-01-01 00:00:00&#39; COMMENT &#39;更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8 COMMENT &#39;token信息表&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;tiny_id_info&#96; (&#96;id&#96;, &#96;biz_type&#96;, &#96;begin_id&#96;, &#96;max_id&#96;, &#96;step&#96;, &#96;delta&#96;, &#96;remainder&#96;, &#96;create_time&#96;, &#96;update_time&#96;, &#96;version&#96;)</span><br><span class="line">VALUES</span><br><span class="line">    (1, &#39;test&#39;, 1, 1, 100000, 1, 0, &#39;2018-07-21 23:52:58&#39;, &#39;2018-07-22 23:19:27&#39;, 1);</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;tiny_id_info&#96; (&#96;id&#96;, &#96;biz_type&#96;, &#96;begin_id&#96;, &#96;max_id&#96;, &#96;step&#96;, &#96;delta&#96;, &#96;remainder&#96;, &#96;create_time&#96;, &#96;update_time&#96;, &#96;version&#96;)</span><br><span class="line">VALUES</span><br><span class="line">    (2, &#39;test_odd&#39;, 1, 1, 100000, 2, 1, &#39;2018-07-21 23:52:58&#39;, &#39;2018-07-23 00:39:24&#39;, 3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;tiny_id_token&#96; (&#96;id&#96;, &#96;token&#96;, &#96;biz_type&#96;, &#96;remark&#96;, &#96;create_time&#96;, &#96;update_time&#96;)</span><br><span class="line">VALUES</span><br><span class="line">    (1, &#39;0f673adf80504e2eaa552f5d791b644c&#39;, &#39;test&#39;, &#39;1&#39;, &#39;2017-12-14 16:36:46&#39;, &#39;2017-12-14 16:36:48&#39;);</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;tiny_id_token&#96; (&#96;id&#96;, &#96;token&#96;, &#96;biz_type&#96;, &#96;remark&#96;, &#96;create_time&#96;, &#96;update_time&#96;)</span><br><span class="line">VALUES</span><br><span class="line">    (2, &#39;0f673adf80504e2eaa552f5d791b644c&#39;, &#39;test_odd&#39;, &#39;1&#39;, &#39;2017-12-14 16:36:46&#39;, &#39;2017-12-14 16:36:48&#39;);</span><br></pre></td></tr></table></figure><p>（3）配置数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">datasource.tinyid.names&#x3D;primary</span><br><span class="line">datasource.tinyid.primary.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">datasource.tinyid.primary.url&#x3D;jdbc:mysql:&#x2F;&#x2F;ip:port&#x2F;databaseName?autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8</span><br><span class="line">datasource.tinyid.primary.username&#x3D;root</span><br><span class="line">datasource.tinyid.primary.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>（4）启动<code>tinyid-server</code>后测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取分布式自增ID: http:&#x2F;&#x2F;localhost:9999&#x2F;tinyid&#x2F;id&#x2F;nextIdSimple?bizType&#x3D;test&amp;token&#x3D;0f673adf80504e2eaa552f5d791b644c&#39;</span><br><span class="line">返回结果: 3</span><br><span class="line"></span><br><span class="line">批量获取分布式自增ID:</span><br><span class="line">http:&#x2F;&#x2F;localhost:9999&#x2F;tinyid&#x2F;id&#x2F;nextIdSimple?bizType&#x3D;test&amp;token&#x3D;0f673adf80504e2eaa552f5d791b644c&amp;batchSize&#x3D;10&#39;</span><br><span class="line">返回结果:  4,5,6,7,8,9,10,11,12,13</span><br></pre></td></tr></table></figure><p><strong>Java客户端方式接入</strong></p><ul><li>重复Http方式的（2）（3）操作</li><li>引入依赖</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163740832.png" alt="mark"></p><ul><li>配置文件</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163753437.png" alt="mark"></p><ul><li><code>test</code> 、<code>tinyid.token</code>是在数据库表中预先插入的数据，<code>test</code> 是具体业务类型，<code>tinyid.token</code>表示可访问的业务类型</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163811537.png" alt="mark"></p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二. 总结"></a><strong>二. 总结</strong></h2><ul><li>本文只是简单介绍一下每种分布式ID生成器，旨在给大家一个详细学习的方向，每种生成方式都有它自己的优缺点，具体如何使用还要看具体的业务需求。</li></ul><p><strong>参考博客 ：</strong> <a href="https://zhuanlan.zhihu.com/p/152179727?utm_source" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/152179727?utm_source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式ID&quot;&gt;&lt;a href=&quot;#分布式ID&quot; class=&quot;headerlink&quot; title=&quot;分布式ID&quot;&gt;&lt;/a&gt;分布式ID&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在说分布式ID的具体实现之前，我们来简单分析一下为什么用分布式ID？分布式ID应该满足哪些特征？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1、什么是分布式ID？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿MySQL数据库举个栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。&lt;/li&gt;
&lt;li&gt;但随着数据日渐增长，主从同步也扛不住了，就需要&lt;strong&gt;对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据&lt;/strong&gt;，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有&lt;code&gt;唯一ID&lt;/code&gt;做标识。此时一个能够生成&lt;code&gt;全局唯一ID&lt;/code&gt;的系统是非常必要的。那么这个&lt;code&gt;全局唯一ID&lt;/code&gt;就叫&lt;code&gt;分布式ID&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2、那么分布式ID需要满足那些条件？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局唯一：必须保证ID是全局性唯一的，基本要求&lt;/li&gt;
&lt;li&gt;高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈&lt;/li&gt;
&lt;li&gt;高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性&lt;/li&gt;
&lt;li&gt;好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单&lt;/li&gt;
&lt;li&gt;趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="雪花算法" scheme="http://zhuuu.work/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux-03-PV</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-03-PV/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-03-PV/</id>
    <published>2020-08-25T08:52:53.000Z</published>
    <updated>2020-09-14T12:05:37.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-03-PV"><a href="#Linux-03-PV" class="headerlink" title="Linux-03-PV"></a>Linux-03-PV</h1><h2 id="1-疑惑解答"><a href="#1-疑惑解答" class="headerlink" title="1. 疑惑解答"></a>1. 疑惑解答</h2><ul><li>进程通常分为<strong>就绪、运行和阻塞</strong>三个工作状态。三种状态在某些条件下可以转换，三者之间的转换关系如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-131907370.png" alt="mark"></p><p>进程三个状态之间的转换就是靠PV操作来控制的。</p><p><strong>PV操作主要就是P操作、V操作和信号量。其中信号量起到了至关重要的作用。</strong></p><a id="more"></a><p><strong>信号量</strong></p><p>信号量是最早出现的用来解决<strong>进程同步与互斥问题</strong>的机制。　</p><ul><li>信号量由一个值和一个指针组成，指针指向等待该信号量的进程。信号量的值表示相应资源的使用情况。</li><li>信号量<code>S&gt;=0</code>时，S表示可用资源的数量。<strong>执行一次P操作意味着请求分配一个资源，因此S的值减1；</strong></li><li>当<code>S&lt;0</code>时，表示已经没有可用资源，S的绝对值表示当前等待该资源的进程数。请求者必须等待其他进程释放该类资源，才能继续运行。而执行<strong>一个V操作意味着释放一个资源，因此S的值加1；</strong></li><li>若S&lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。</li></ul><p>注意，信号量的值只能由PV操作来改变。</p><p><strong><em>\</em>关于PV操作容易产生的一些疑问：**</strong></p><p><strong>1，S大于0那就表示有临界资源可供使用，为什么不唤醒进程？</strong></p><ul><li>S大于0的确表示有临界资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒。</li></ul><p><strong>2，S小于0应该是说没有临界资源可供使用，为什么还要唤醒进程？</strong></p><ul><li>V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S&lt;0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。</li><li>比如，有两个某类资源，四个进程A、B、C、D要用该类资源，最开始S=2，当A进入，S=1，当B进入S=0，表明该类资源刚好用完， 当C进入时S=-1，表明有一个进程被阻塞了，D进入，S=-2。当A用完该类资源时，进行V操作，S=-1，释放该类资源，因为S&lt;0，表明有进程阻塞在该类资源上，于是唤醒一个。</li></ul><p><strong>3，如果是互斥信号量的话，应该设置信号量S=1，但是当有5个进程都访问的话，最后在该信号量的链表里会有4个在等待，也是说S=-4，那么第一个进程执行了V操作使S加1，释放了资源，下一个应该能够执行，但唤醒的这个进程在执行P操作时因S&lt;0，也还是执行不了，这是怎么回事呢？</strong></p><ul><li>当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区，并不需要执行P操作了，当执行完了临界区的程序后，就执行V操作。</li></ul><p><strong>4，S的绝对值表示等待的进程数，同时又表示临界资源，这到底是怎么回事？</strong></p><ul><li>当信号量S小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目</li><li>S大于0时表示可用的临界资源数。注意在不同情况下所表达的含义不一样。当等于0时，表示刚好用完。</li></ul><h2 id="2-临界区和临界资源"><a href="#2-临界区和临界资源" class="headerlink" title="2. 临界区和临界资源"></a>2. 临界区和临界资源</h2><ol><li><strong>临界区</strong></li></ol><ul><li>每个进程中访问临界资源的那段<strong>程序代码称为临界区</strong></li><li>每次只准许一个进程进入临界区，进入后不允许其他进程进入。</li></ul><ol start="2"><li><strong>临界资源</strong></li></ol><ul><li>临界资源是一次<strong>仅允许一个进程使用的共享资源</strong></li></ul><ol start="3"><li><strong>进程进入临界区的调度原则是：</strong></li></ol><ul><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区</li><li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ul><h2 id="3-PV操作"><a href="#3-PV操作" class="headerlink" title="3. PV操作"></a>3. PV操作</h2><p><strong>临界区：</strong>我们把并发进程中与共享变量有关的<strong>程序段称为临界区。</strong></p><p><strong>信号量S</strong>：</p><ul><li>信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；</li><li>当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</li></ul><p>​    <strong>P操作P（S）</strong>：将信号量S减去1，若结果小于0，则把调用P（S）的进程置成等待信号量S的状态。即为请求资源。</p><p>​    <strong>V操作V（S）</strong>：将信号量S加上1，若结果不大于0，则释放一个等待信号量S的进程。即为释放资源。</p><p>正如老师上课时所举的父亲给孩子吃苹果的例子一样，假如一个盘子只能放一个苹果，父亲往盘子里放了一个苹果。如果儿子吃了（<strong>V操作</strong>），父亲才可以接着放（<strong>P操作</strong>）；如果儿子不吃，那父亲就不能放苹果，只能等着。</p><p><strong>伪代码如下</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Procedure P (Var S：Semaphore)</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">S：=S - 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> S&lt;0 <span class="keyword">then</span> W(S) </span><br><span class="line"></span><br><span class="line">end; &#123; P &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Procedure V (Var S：Semaphore)</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">S：=S + 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> S&lt; = 0 <span class="keyword">then</span> R(S) </span><br><span class="line"></span><br><span class="line">end; &#123; V &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#       W(S)：表示把调用P（S）的进程置成等待信号量S的状态。</span></span><br><span class="line"><span class="comment">#R(S)：表示释放一个等待信号量S的进程。</span></span><br></pre></td></tr></table></figure><h3 id="3-1-进程互斥"><a href="#3-1-进程互斥" class="headerlink" title="3.1 进程互斥"></a>3.1 进程互斥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    利用信号量和PV操作实现进程互斥的一般模型是：</span><br><span class="line">进程P1              进程P2           ……          进程Pn</span><br><span class="line">……                  ……                           ……</span><br><span class="line">P（S）；              P（S）；                         P（S）；</span><br><span class="line">临界区；             临界区；                        临界区；</span><br><span class="line">V（S）；              V（S）；                        V（S）；</span><br><span class="line">……                  ……            ……           ……</span><br></pre></td></tr></table></figure><pre><code>其中信号量S用于互斥，初值为1。使用PV操作实现进程互斥时应该注意的是：（1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。（2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。（3）互斥信号量的初值一般为1。</code></pre><h3 id="3-2-进程同步"><a href="#3-2-进程同步" class="headerlink" title="3.2 进程同步"></a>3.2 进程同步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">利用信号量和PV操作实现进程同步</span><br><span class="line">PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。</span><br><span class="line"></span><br><span class="line">    使用PV操作实现进程同步时应该注意的是：</span><br><span class="line"></span><br><span class="line">    （1）分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。</span><br><span class="line">    （2）信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。</span><br><span class="line">    （3）同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-03-PV&quot;&gt;&lt;a href=&quot;#Linux-03-PV&quot; class=&quot;headerlink&quot; title=&quot;Linux-03-PV&quot;&gt;&lt;/a&gt;Linux-03-PV&lt;/h1&gt;&lt;h2 id=&quot;1-疑惑解答&quot;&gt;&lt;a href=&quot;#1-疑惑解答&quot; class=&quot;headerlink&quot; title=&quot;1. 疑惑解答&quot;&gt;&lt;/a&gt;1. 疑惑解答&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程通常分为&lt;strong&gt;就绪、运行和阻塞&lt;/strong&gt;三个工作状态。三种状态在某些条件下可以转换，三者之间的转换关系如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-131907370.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程三个状态之间的转换就是靠PV操作来控制的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PV操作主要就是P操作、V操作和信号量。其中信号量起到了至关重要的作用。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程通信方式" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-04-僵尸进程,孤儿进程</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-04-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B,%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-04-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B,%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-08-25T08:52:53.000Z</published>
    <updated>2020-09-03T01:19:12.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-04-僵尸进程-孤儿进程"><a href="#Linux-04-僵尸进程-孤儿进程" class="headerlink" title="Linux-04-僵尸进程,孤儿进程"></a>Linux-04-僵尸进程,孤儿进程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用<code>wait()</code>或者<code>waitpid()</code>系统调用取得子进程的终止状态</li></ul><p>　　<strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p>　　<strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><a id="more"></a><h2 id="1-问题和危害"><a href="#1-问题和危害" class="headerlink" title="1. 问题和危害"></a>1. 问题和危害</h2><p><strong>僵尸进程的危害</strong></p><ul><li><p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号<code>the process ID</code>,退出状态<code>the termination status of the process</code>,运行时间<code>the amount of CPU time taken by the process</code>等)。直到父进程通过<code>wait / waitpid</code>来取时才释放。 </p></li><li><p><strong>如果进程不调用wait / waitpid的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p></li></ul><p><strong>孤儿进程的危害</strong></p><ul><li><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，<code>init</code>进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地<code>wait()</code>它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，<code>init</code>进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></li></ul><p><strong>僵尸进程危害的场景</strong></p><ul><li><p>例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短</p></li><li><p>但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵尸进程，倘若用<code>ps</code>命令查看的话，就会看到很多状态为Z的进程。</p></li><li><p>严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）</p></li><li><p>枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被<code>init</code>进程接管，<code>init</code>进程会<code>wait()</code>这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。</p></li></ul><h2 id="2-问题演示"><a href="#2-问题演示" class="headerlink" title="2. 问题演示"></a>2. 问题演示</h2><p>孤儿进程测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="comment">//创建一个进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am the child process.\n"</span>);</span><br><span class="line">        <span class="comment">//输出进程ID和父进程ID</span></span><br><span class="line">        printf(<span class="string">"pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        printf(<span class="string">"I will sleep five seconds.\n"</span>);</span><br><span class="line">        <span class="comment">//睡眠5s，保证父进程先退出</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        printf(<span class="string">"pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        printf(<span class="string">"child process is exited.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am father process.\n"</span>);</span><br><span class="line">        <span class="comment">//父进程睡眠1s，保证子进程输出进程id</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        printf(<span class="string">"father process is  exited.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/090940937.png" alt="mark"></p><p>僵尸进程测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am child process.I am exiting.\n"</span>);</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"I am father process.I will sleep two seconds\n"</span>);</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//输出进程信息</span></span><br><span class="line">    system(<span class="string">"ps -o pid,ppid,state,tty,command"</span>);</span><br><span class="line">    printf(<span class="string">"father process is exiting.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091128821.png" alt="mark"></p><p>僵尸进程测试2：父进程循环创建子进程，子进程退出，造成多个僵尸进程，程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    <span class="comment">//循环创建子进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork error:"</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"I am a child process.\nI am exiting.\n"</span>);</span><br><span class="line">            <span class="comment">//子进程退出，成为僵尸进程</span></span><br><span class="line">            exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//父进程休眠20s继续创建子进程</span></span><br><span class="line">            sleep(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091246352.png" alt="mark"></p><h2 id="3-问题的解决方法"><a href="#3-问题的解决方法" class="headerlink" title="3. 问题的解决方法"></a>3. 问题的解决方法</h2><p><strong>（1）通过信号机制</strong></p><p>　　子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="comment">//创建捕捉子进程退出信号</span></span><br><span class="line">    signal(SIGCHLD,sig_child);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am child process,pid id %d.I am exiting.\n"</span>,getpid());</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"I am father process.I will sleep two seconds\n"</span>);</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//输出进程信息</span></span><br><span class="line">    system(<span class="string">"ps -o pid,ppid,state,tty,command"</span>);</span><br><span class="line">    printf(<span class="string">"father process is exiting.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     pid_t        pid;</span><br><span class="line">     <span class="keyword">int</span>        stat;</span><br><span class="line">     <span class="comment">//处理僵尸进程</span></span><br><span class="line">     <span class="keyword">while</span> ((pid = waitpid(-<span class="number">1</span>, &amp;stat, WNOHANG)) &gt;<span class="number">0</span>)</span><br><span class="line">            printf(<span class="string">"child %d terminated.\n"</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091458045.png" alt="mark"></p><p><strong>（2）fork两次</strong><br>　　《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    <span class="comment">//创建第一个子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一个子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程再创建子进程</span></span><br><span class="line">        printf(<span class="string">"I am the first child process.pid:%d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork error:"</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个子进程退出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"first procee is exited.\n"</span>);</span><br><span class="line">            exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二个子进程</span></span><br><span class="line">        <span class="comment">//睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        printf(<span class="string">"I am the second child process.pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程处理第一个子进程退出</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, NULL, <span class="number">0</span>) != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"waitepid error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091537084.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-04-僵尸进程-孤儿进程&quot;&gt;&lt;a href=&quot;#Linux-04-僵尸进程-孤儿进程&quot; class=&quot;headerlink&quot; title=&quot;Linux-04-僵尸进程,孤儿进程&quot;&gt;&lt;/a&gt;Linux-04-僵尸进程,孤儿进程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用&lt;code&gt;wait()&lt;/code&gt;或者&lt;code&gt;waitpid()&lt;/code&gt;系统调用取得子进程的终止状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;strong&gt;孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="僵尸进程" scheme="http://zhuuu.work/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="孤儿进程" scheme="http://zhuuu.work/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-459-重复的子字符串</title>
    <link href="http://zhuuu.work/2020/08/25/Leetcode/Leetcode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/08/25/Leetcode/Leetcode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-25T08:35:53.000Z</published>
    <updated>2020-08-25T08:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-459-重复的子字符串"><a href="#Leecode-459-重复的子字符串" class="headerlink" title="Leecode-459. 重复的子字符串"></a>Leecode-<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果您的字符串 S 包含一个重复的子字符串，那么这意味着您可以多次 “移位和换行”`您的字符串，并使其与原始字符串匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：abcabc</span><br><span class="line"></span><br><span class="line">移位一次：cabcab</span><br><span class="line">移位两次：bcabca</span><br><span class="line">移位三次：abcabc</span><br></pre></td></tr></table></figure><p>现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串。</p><p>基于这个思想，可以每次移动k个字符，直到匹配移动 length - 1 次。但是这样对于重复字符串很长的字符串，效率会非常低。在 LeetCode 中执行时间超时了。</p><p>为了避免这种无用的环绕，可以创建一个新的字符串 str，它等于原来的字符串 S 再加上 S 自身，这样其实就包含了所有移动的字符串。</p><p><strong>比如字符串：S = acd，那么 str = S + S = acdacd</strong></p><p><strong>acd 移动的可能：dac、cda。其实都包含在了 str 中了。就像一个滑动窗口</strong></p><p><strong>一开始 acd (acd) ，移动一次 ac(dac)d，移动两次 a(cda)cd。循环结束</strong></p><p><strong>所以可以直接判断 str 中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String str = s + s;</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).contains(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leecode-459-重复的子字符串&quot;&gt;&lt;a href=&quot;#Leecode-459-重复的子字符串&quot; class=&quot;headerlink&quot; title=&quot;Leecode-459. 重复的子字符串&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://lee
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux-02-进程通信方式</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-02-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-02-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2020-08-25T07:52:53.000Z</published>
    <updated>2020-10-04T06:14:48.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-02-进程通信方式"><a href="#Linux-02-进程通信方式" class="headerlink" title="Linux-02-进程通信方式"></a>Linux-02-进程通信方式</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200927/102456602.png" alt="mark"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200927/102542062.png" alt="mark"></p><ul><li>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？</li></ul><h2 id="一、管道"><a href="#一、管道" class="headerlink" title="一、管道"></a>一、管道</h2><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p><h3 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</li><li>它只能用于具有<strong>亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</strong>。</li><li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的<code>read、write</code> 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li></ol><p>如果你学过 Linux 命令，那你肯定很熟悉「<code>|</code>」这个竖线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps auxf | grep mysql</span><br></pre></td></tr></table></figure><p>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p>同时，我们得知上面这种管道是没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</p><ul><li>匿名管道的创建，需要通过下面这个系统调用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2])</span><br></pre></td></tr></table></figure><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符<code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p><h3 id="2、原型"><a href="#2、原型" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 #include &lt;unistd.h&gt;</span><br><span class="line">2 int pipe(int fd[2]);    &#x2F;&#x2F; 返回值：若成功返回0，失败返回-1</span><br></pre></td></tr></table></figure><p><strong>当一个管道建立时，它会创建两个文件描述符</strong>：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200927/103118008.png" alt="mark"></p><p>要关闭管道只需将这两个文件描述符关闭即可。</p><p>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li></ul><h3 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-094212697.png" alt="mark"></p><p>若要数据流从父进程流向子进程，则关闭父进程的读端（<code>fd[0]</code>）与子进程的写端（<code>fd[1]</code>）；反之，则可以使数据流从子进程流向父进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];  <span class="comment">// 两个文件描述符</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)  <span class="comment">// 创建管道</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create Pipe Error!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)  <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        read(fd[<span class="number">0</span>], buff, <span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、FIFO"><a href="#二、FIFO" class="headerlink" title="二、FIFO"></a>二、FIFO</h2><p>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p><p>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo myPipe</span><br></pre></td></tr></table></figure><ul><li>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure><ul><li>接下来，我们往 myPipe 这个管道写入数据：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello&quot; &gt; myPipe  &#x2F;&#x2F; 将数据写进管道</span><br><span class="line">                         &#x2F;&#x2F; 停住了 ...</span><br></pre></td></tr></table></figure><ul><li><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p></li><li><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; myPipe  &#x2F;&#x2F; 读取管道里的数据</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p></li><li><p>我们可以看出，<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p></li></ul><h3 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><strong>FIFO可以在无关的进程之间交换数据，与无名管道不同。</strong></li><li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li></ol><h3 id="2、原型-1"><a href="#2、原型-1" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 #include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">2 &#x2F;&#x2F; 返回值：成功返回0，出错返回-1</span><br><span class="line">3 int mkfifo(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure><p>其中的 mode 参数与<code>open</code>函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p><p>当 open 一个FIFO时，是否设置非阻塞标志（<code>O_NONBLOCK</code>）的区别：</p><ul><li>若没有指定<code>O_NONBLOCK</code>（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</li><li>若指定了<code>O_NONBLOCK</code>，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</li></ul><h3 id="3、例子-1"><a href="#3、例子-1" class="headerlink" title="3、例子"></a>3、例子</h3><ul><li><strong>FIFO的通信方式类似于在进程中使用文件来传输数据</strong>，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：</li></ul><p><strong>write_fifo.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;   // exit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;    // O_WRONLY</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;     // time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">time_t</span> tp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">        n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">        <span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>read_fifo.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line">        perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">// 以读打开FIFO</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两个终端里用 gcc 分别编译运行上面两个文件，可以看到输出结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">2</span> I am <span class="number">5954</span> process.</span><br><span class="line"> <span class="number">3</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">4</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">5</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">6</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">7</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">8</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">9</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line"><span class="number">10</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line"><span class="number">11</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line"><span class="number">12</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">2</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">3</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">4</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">5</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">6</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">7</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">8</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">9</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line"><span class="number">10</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line"><span class="number">11</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure><p>上述例子可以扩展成 客户进程—服务器进程 通信的实例，<code>write_fifo</code>的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，<code>read_fifo</code>类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-100921142.png" alt="mark"></p><h2 id="三、消息队列"><a href="#三、消息队列" class="headerlink" title="三、消息队列"></a>三、消息队列</h2><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><h3 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li><li><strong>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</strong></li><li><strong>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</strong></li></ol><h3 id="2、原型-2"><a href="#2、原型-2" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：</p><ul><li>如果没有与键值key相对应的消息队列，并且flag中包含了<code>IPC_CREAT</code>标志位。</li><li>key参数为<code>IPC_PRIVATE</code>。</li></ul><p>函数<code>msgrcv</code>在读取消息队列时，type参数有下面几种情况：</p><ul><li><code>type == 0</code>，返回队列中的第一个消息；</li><li><code>type &gt; 0</code>，返回队列中消息类型为 type 的第一个消息；</li><li><code>type &lt; 0</code>，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li></ul><p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）</p><h3 id="3、例子-2"><a href="#3、例子-2" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p><p><strong>msg_server.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取消息</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">        msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">        <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">        msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>msg_client.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加消息，类型为888</span></span><br><span class="line">    msg.mtype = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">    msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取类型为777的消息</span></span><br><span class="line">    msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li></li></ul><h3 id="3、例子-3"><a href="#3、例子-3" class="headerlink" title="3、例子"></a>3、例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//    若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//    若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//    释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//    如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id;  <span class="comment">// 信号量集ID</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量集，其中只有一个信号量</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化：初值设为0资源被占用</span></span><br><span class="line">    init_sem(sem_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"Fork Error"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Process child: pid=%d\n"</span>, getpid());</span><br><span class="line">        sem_v(sem_id);  <span class="comment">/*释放资源*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/*父进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(sem_id);   <span class="comment">/*等待资源*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Process father: pid=%d\n"</span>, getpid());</span><br><span class="line">        sem_v(sem_id);   <span class="comment">/*释放资源*/</span></span><br><span class="line">        del_sem(sem_id); <span class="comment">/*删除信号量集*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子如果不加信号量，则父进程会先执行完毕。这里加了信号量让父进程等待子进程执行完以后再执行。</p><h2 id="四、共享内存"><a href="#四、共享内存" class="headerlink" title="四、共享内存"></a>四、共享内存</h2><ul><li>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</li><li>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</li><li><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200927/104938057.png" alt="mark"></p><h3 id="1、特点-3"><a href="#1、特点-3" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li><li>因为多个进程可以同时操作，所以需要进行同步。</li><li><strong>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</strong></li></ol><h3 id="2、原型-3"><a href="#2、原型-3" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>当用<code>shmget</code>函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p><p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code>shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p><p><code>shmdt</code>函数是用来断开<code>shmat</code>建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p><p><code>shmctl</code>函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是<code>IPC_RMID</code>（从系统中删除该共享内存）。</p><h3 id="3、例子-4"><a href="#3、例子-4" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面这个例子，使用了【共享内存+信号量+消息队列】的组合来实现服务器进程与客户进程间的通信。</p><ul><li>共享内存用来传递数据；</li><li>信号量用来同步；</li><li>消息队列用来 在客户端修改了共享内存后 通知服务器读取。</li></ul><p><strong>server.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;  // shared memory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;  // semaphore</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;  // message queue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;   // memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(<span class="keyword">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    init_sem(sem_id, <span class="number">1</span>);  <span class="comment">/*初值设为1资源未占用*/</span></span><br><span class="line">    <span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">    <span class="keyword">char</span> *shm;</span><br><span class="line">    <span class="keyword">char</span> data[] = <span class="string">"this is server"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">buf1</span>;</span>  <span class="comment">/*用于删除共享内存*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">buf2</span>;</span>  <span class="comment">/*用于删除消息队列*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span>  <span class="comment">/*消息队列用于通知对方更新了共享内存*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存</span></span><br><span class="line">    <span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Create Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">int</span>)shm == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量</span></span><br><span class="line">    semid = creat_sem(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msgrcv(msqid, &amp;msg, <span class="number">1</span>, <span class="number">888</span>, <span class="number">0</span>); <span class="comment">/*读取类型为888的消息*/</span></span><br><span class="line">        <span class="keyword">if</span>(msg.mtext == <span class="string">'q'</span>)  <span class="comment">/*quit - 跳出循环*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(msg.mtext == <span class="string">'r'</span>)  <span class="comment">/*read - 读共享内存*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            sem_p(semid);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,shm);</span><br><span class="line">            sem_v(semid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除共享内存、消息队列、信号量*/</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, &amp;buf1);</span><br><span class="line">    msgctl(msqid, IPC_RMID, &amp;buf2);</span><br><span class="line">    del_sem(semid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>client.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;  // shared memory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;  // semaphore</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;  // message queue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;   // memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">    <span class="keyword">char</span> *shm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">/*while循环条件*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取共享内存</span></span><br><span class="line">    <span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">int</span>)shm == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取信号量</span></span><br><span class="line">    <span class="keyword">if</span>((semid = semget(key, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*                 IPC                 *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*    Input r to send data to server.  *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*    Input q to quit.                 *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please input command: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Data to send: "</span>);</span><br><span class="line">                sem_p(semid);  <span class="comment">/*访问资源*/</span></span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm);</span><br><span class="line">                sem_v(semid);  <span class="comment">/*释放资源*/</span></span><br><span class="line">                <span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">                <span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">                msg.mtype = <span class="number">888</span>;</span><br><span class="line">                msg.mtext = <span class="string">'r'</span>;  <span class="comment">/*发送消息通知服务器读数据*/</span></span><br><span class="line">                msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">                msg.mtype = <span class="number">888</span>;</span><br><span class="line">                msg.mtext = <span class="string">'q'</span>;</span><br><span class="line">                msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Wrong input!\n"</span>);</span><br><span class="line">                <span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">                <span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当<code>scanf()</code>输入字符或字符串时，缓冲区中遗留下了<code>\n</code>，所以每次输入操作后都需要清空标准输入的缓冲区。但是由于 gcc 编译器不支持<code>fflush(stdin)</code>（它只是标准C的扩展），所以我们使用了替代方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 while((c&#x3D;getchar())!&#x3D;&#39;\n&#39; &amp;&amp; c!&#x3D;EOF);</span><br></pre></td></tr></table></figure><h2 id="五、信号量"><a href="#五、信号量" class="headerlink" title="五、信号量"></a>五、信号量</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ul><li>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</li><li>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</li></ul><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><h3 id="2-PV操作"><a href="#2-PV操作" class="headerlink" title="2. PV操作"></a>2. PV操作</h3><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li><p>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</p></li><li><p>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</p></li><li><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p></li></ul><h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h3><p>接下来，举个例子，如果要使得两个<strong>进程互斥访问共享内存</strong>，我们可<strong>以初始化信号量为 <code>1</code></strong>。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200927/105626287.png" alt="mark"></p><p>具体的过程如下：</p><ul><li><p>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</p></li><li><p>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</p></li><li><p>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</p></li><li><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p></li></ul><p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p><ul><li>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</li><li>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为<code>0</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200927/105738863.png" alt="mark"></p><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><h2 id="六-信号"><a href="#六-信号" class="headerlink" title="六. 信号"></a>六. 信号</h2><h3 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1. 特点"></a>1. 特点</h3><ul><li><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p></li><li><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p></li><li><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p><strong>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</strong></p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><ul><li><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</li><li><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</li><li><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</li></ul><h2 id="五种通讯方式总结"><a href="#五种通讯方式总结" class="headerlink" title="五种通讯方式总结"></a>五种通讯方式总结</h2><p>1.管道：速度慢，容量有限，只有父子进程能通讯</p><p>2.FIFO：任何进程间都能通讯，但速度慢   </p><p>3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   </p><p>4.信号量：不能传递复杂消息，只能用来同步   </p><p>5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p><p><strong>参考博客</strong> ： <a href="https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-02-进程通信方式&quot;&gt;&lt;a href=&quot;#Linux-02-进程通信方式&quot; class=&quot;headerlink&quot; title=&quot;Linux-02-进程通信方式&quot;&gt;&lt;/a&gt;Linux-02-进程通信方式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200927/102456602.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程通信方式" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-12-一对多,多对一，多对多问题</title>
    <link href="http://zhuuu.work/2020/08/25/Mysql/Mysql-12-%E4%B8%80%E5%AF%B9%E5%A4%9A,%E5%A4%9A%E5%AF%B9%E4%B8%80%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/08/25/Mysql/Mysql-12-%E4%B8%80%E5%AF%B9%E5%A4%9A,%E5%A4%9A%E5%AF%B9%E4%B8%80%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-25T06:28:27.000Z</published>
    <updated>2020-08-25T06:50:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-12-一对多-多对一，多对多问题"><a href="#Mysql-12-一对多-多对一，多对多问题" class="headerlink" title="Mysql-12-一对多,多对一，多对多问题"></a>Mysql-12-一对多,多对一，多对多问题</h1><h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p>​    一对一关系示例：</p><ul><li><ul><li>一个学生对应一个学生档案材料，或者每个人都有唯一的身份证编号。</li></ul></li></ul><p>​    一对多关系示例：</p><ul><li><ul><li>一个学生只属于一个班，但是一个班级有多名学生。</li></ul></li></ul><p>​    多对多关系示例：</p><ul><li><ul><li>一个学生可以选择多门课，一门课也有多名学生。</li></ul></li></ul><a id="more"></a><h2 id="2-数据库建表注意"><a href="#2-数据库建表注意" class="headerlink" title="2. 数据库建表注意"></a>2. 数据库建表注意</h2><p><strong>1.一对多关系处理：</strong></p><p>​    <strong>通过学生和班级问题了解一对多：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143534668.png" alt="mark"></p><p><strong>解决方案：</strong></p><ul><li>班级是1端，学生是多端，结合面向对象的思想，1端是父亲，多端是儿子，所以多端具有1端的属性，也就是说多端里面应该放置1端的主键，那么<strong>学生表里面应该放置班级表里面的主键</strong></li></ul><p><strong>2.多对多关系处理：</strong></p><p>  <strong>通过学生选课了解多对多问题的处理：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143627192.png" alt="mark"></p><p><strong>解决方案：</strong></p><ul><li><strong>在多对多中在一个表中添加一个字段就行不通了，所以处理多对多表问题时，就要考虑建立关系表了</strong></li></ul><p><strong>学生表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143739422.png" alt="mark"></p><p><strong>课程表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143932875.png" alt="mark"></p><p><strong>关系表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143947893.png" alt="mark"></p><p>注：所以对于多对多表，通过关系表就建立起了两张表的联系！多对多表时建立主外键后，要先删除约束表内容再删除主表内容</p><p>对于<strong>多对多关系，需要转换成1对多关系</strong>，那么就需要一张中间表来转换，这张中间表里面<strong>需要存放学生表里面的主键和课程表里面的主键</strong>，此时学生与中间表示1对多关系，课程与中间表是1对多关系，学生与课程是多对多关系</p><h2 id="3-解决方案总结"><a href="#3-解决方案总结" class="headerlink" title="3. 解决方案总结"></a>3. 解决方案总结</h2><ol><li><strong>一对一的解决方案</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一对一</span><br><span class="line">一张表的一条记录一定只能与另外一张表的一条记录进行对应，反之亦然。</span><br><span class="line"></span><br><span class="line">学生表：姓名，性别，年龄，身高，体重，籍贯，家庭住址，紧急联系人</span><br><span class="line">其中姓名、性别、年龄、身高，体重属于常用数据，但是籍贯、住址和联系人为不常用数据</span><br><span class="line">如果每次查询都是查询所有数据，不常用的数据就会影响效率，实际又不用</span><br><span class="line"></span><br><span class="line">常用信息表：ID(P)，姓名，性别，年龄，身高，体重</span><br><span class="line">不常用信息表：ID(P)，籍贯，家庭住址，紧急联系人</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">将常用的和不常用的信息分享存储，分成两张表</span><br><span class="line">不常用信息表和常用信息表，保证不常用信息表与常用信息表能够对应上：找一个具有唯一性的</span><br><span class="line">字段来共同连接两张表。</span><br><span class="line">一个常用表中的一条记录永远只能在一张不常用表中匹配一条记录，反之亦然。</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>一对多</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一对多</span><br><span class="line">一张表中有一条记录可以对应另外一张表中的多条记录；但是反过来，另外一张表的一条记录</span><br><span class="line">只能对应第一张表的一条记录，这种关系就是一对多或多对一</span><br><span class="line">母亲与孩子的关系：母亲，孩子两个实体</span><br><span class="line">母亲表：ID(P),名字，年龄，性别</span><br><span class="line">孩子表：ID(P),名字，年龄，性别</span><br><span class="line">以上关系：一个妈妈可以在孩子表中找到多条记录（也可能是一条），但是一个孩子只能找到一个妈妈</span><br><span class="line">是一种典型的一对多的关系。</span><br><span class="line"></span><br><span class="line">但是以上设计：解决了实体的设计表问题，但是没有解决关系问题，孩子找不到母亲，母亲也找不到孩子</span><br><span class="line"></span><br><span class="line">解决方案：在某一张表中增加一个字段，能够找到另外一张表中的记录:在孩子表中增加一个字段</span><br><span class="line">指向母亲表，因为孩子表的记录只能匹配到一条母亲表的记录。</span><br><span class="line">母亲表：ID(P),名字，年龄，性别</span><br><span class="line">孩子表：ID(P),名字，年龄，性别，母亲表ID（母亲表主键）</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>多对多</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">多对多</span><br><span class="line">一对表中（A）的一条记录能够对应另外一张表（B）中的多条记录；同时B表中的一条记录</span><br><span class="line">也能对应A表中的多条记录</span><br><span class="line"></span><br><span class="line">老师和学生</span><br><span class="line">老师表 T_ID(P),姓名，性别</span><br><span class="line">学生表 S_ID(P),姓名，性别</span><br><span class="line">以上设计方案：实现了实体的设计，但是没有维护实体的关系</span><br><span class="line">一个老师教过多个学生，一个学生也被多个老师教过</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决方案：增加一张中间关系表</span><br><span class="line">老师与学生的关系表：ID(P),T_ID,S_ID </span><br><span class="line">老师表与中间表形成一对多的关系，而中间表是多表；维护了能够唯一找到一表的关系；</span><br><span class="line">同样的学生表与中间表也是一个一对多的关系; </span><br><span class="line">学生找老师：找出学生ID---&gt;中间表寻找匹配记录（多条）---&gt;老师表匹配（一条）</span><br><span class="line">老师找学生：找出老师ID---&gt;中间表寻找匹配记录（多条）---&gt;学生表匹配（一条）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-12-一对多-多对一，多对多问题&quot;&gt;&lt;a href=&quot;#Mysql-12-一对多-多对一，多对多问题&quot; class=&quot;headerlink&quot; title=&quot;Mysql-12-一对多,多对一，多对多问题&quot;&gt;&lt;/a&gt;Mysql-12-一对多,多对一，多对多问题&lt;/h1&gt;&lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;​    一对一关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生对应一个学生档案材料，或者每个人都有唯一的身份证编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    一对多关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生只属于一个班，但是一个班级有多名学生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    多对多关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生可以选择多门课，一门课也有多名学生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库建表关系" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-Integer和int</title>
    <link href="http://zhuuu.work/2020/08/23/JavaInterview/Java-%E5%9F%BA%E7%A1%80-Integer%E5%92%8Cint/"/>
    <id>http://zhuuu.work/2020/08/23/JavaInterview/Java-%E5%9F%BA%E7%A1%80-Integer%E5%92%8Cint/</id>
    <published>2020-08-23T09:38:38.000Z</published>
    <updated>2020-09-12T09:02:45.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-Integer和int"><a href="#Java-基础-Integer和int" class="headerlink" title="Java-基础-Integer和int"></a>Java-基础-Integer和int</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>int和Integer的区别</strong></p><ul><li><p>Integer的默认值是null，int的默认值是0</p></li><li><p>Integer是int的包装类(引用数据类型 )，int则是java的一种基本数据类型 </p></li><li><p>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </p></li><li><p>Integer变量必须实例化后才能使用，而int变量不需要 </p></li></ul><h2 id="衍生"><a href="#衍生" class="headerlink" title="衍生"></a>衍生</h2><p>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; new Integer(100);</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，<strong>java会自动拆包装为int</strong>，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">int j &#x3D; 100；</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>3、<strong>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false</strong>。（因为 ①当变量值在-128<del>127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②**当变量值在-128</del>127之间时**，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>4、<strong>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false（运用到的设计模式：享元模式 对象池连接的思想）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 100;</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br><span class="line">Integer i &#x3D; 128;</span><br><span class="line">Integer j &#x3D; 128;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>对于第4条的原因：<br>java在编译Integer i = 100 ;时，会翻译成为<code>Integer i = Integer.valueOf(100)</code>；，而java API中对Integer类型的valueOf的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)&#123;</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p><p>如果有错误的地方，还请指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-基础-Integer和int&quot;&gt;&lt;a href=&quot;#Java-基础-Integer和int&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-Integer和int&quot;&gt;&lt;/a&gt;Java-基础-Integer和int&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
    
      <category term="Integer" scheme="http://zhuuu.work/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>Linux-10-内存页面置换算法</title>
    <link href="http://zhuuu.work/2020/08/23/Linux/Linux-10-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/08/23/Linux/Linux-10-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-23T03:22:53.000Z</published>
    <updated>2020-09-26T06:42:44.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-10-内存页面置换算法"><a href="#Linux-10-内存页面置换算法" class="headerlink" title="Linux-10-内存页面置换算法"></a>Linux-10-内存页面置换算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><a id="more"></a><h2 id="1-缺页异常"><a href="#1-缺页异常" class="headerlink" title="1. 缺页异常"></a>1. 缺页异常</h2><p>在了解内存页面置换算法前，我们得先谈一下<strong>缺页异常（缺页中断）</strong>。</p><p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p><ul><li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li><li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li></ul><p>我们来看一下缺页中断的处理流程，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142400418.png" alt="mark"></p><ol><li>在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。</li><li>如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。</li><li>操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。</li><li>找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。</li><li>页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。</li><li>最后，CPU 重新执行导致缺页异常的指令。</li></ol><p>上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p><ul><li>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页<ul><li>如果该物理页有被修改过（脏页），则把它换出到磁盘</li><li>然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。</li></ul></li></ul><p>这里提一下，页表项通常有如下图的字段：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142756318.png" alt="mark"></p><ul><li><em>状态位</em>：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。</li><li><em>访问字段</em>：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。</li><li><em>修改位</em>：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。</li><li><em>硬盘地址</em>：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li></ul><h2 id="2-虚拟内存管理"><a href="#2-虚拟内存管理" class="headerlink" title="2. 虚拟内存管理"></a>2. 虚拟内存管理</h2><p>这里整理了虚拟内存的管理整个流程，你可以从下面这张图看到：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142914008.jpg" alt="mark"></p><ul><li><p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong></p></li><li><p>也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。</p></li></ul><h2 id="3-常见的页面置换算法"><a href="#3-常见的页面置换算法" class="headerlink" title="3. 常见的页面置换算法"></a>3. 常见的页面置换算法</h2><p>那其算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种：</p><ul><li>最佳页面置换算法（<em>OPT</em>）</li><li>先进先出置换算法（<em>FIFO</em>）</li><li>最近最久未使用的置换算法（<em>LRU</em>）</li><li>时钟页面置换算法（<em>Lock</em>）</li><li>最不常用置换算法（<em>LFU</em>）</li></ul><h3 id="3-1-最佳页面置换算法"><a href="#3-1-最佳页面置换算法" class="headerlink" title="3.1 最佳页面置换算法"></a>3.1 最佳页面置换算法</h3><ul><li>最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</li><li>所以，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。</li><li>我们举个例子，假设一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143450166.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>7</code> 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 <code>4</code> 次。</li><li>这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。</li><li>所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。</li></ul><h3 id="3-2-先进先出置换算法"><a href="#3-2-先进先出置换算法" class="headerlink" title="3.2 先进先出置换算法"></a>3.2 先进先出置换算法</h3><ul><li>既然我们无法预知页面在下一次访问前所需的等待时间，那我们可以<strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</li><li>还是以前面的请求的页面序列作为例子，假设使用先进先出置换算法，则过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143610965.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>10</code> 次，页面置换共发生了 <code>7</code> 次，跟最佳页面置换算法比较起来，性能明显差了很多。</li></ul><h3 id="3-3-最近最久未使用置换算法（LRU）"><a href="#3-3-最近最久未使用置换算法（LRU）" class="headerlink" title="3.3 最近最久未使用置换算法（LRU）"></a>3.3 最近最久未使用置换算法（LRU）</h3><ul><li><p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p></li><li><p>这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。</p></li><li><p>还是以前面的请求的页面序列作为例子，假设使用最近最久未使用的置换算法，则过程如下图：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143749910.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>9</code> 次，页面置换共发生了 <code>6</code> 次，跟先进先出置换算法比较起来，性能提高了一些。</li><li>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。</li><li>困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</li><li>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</li></ul><h3 id="3-4-时钟页面置换算法"><a href="#3-4-时钟页面置换算法" class="headerlink" title="3.4 时钟页面置换算法"></a>3.4 时钟页面置换算法</h3><ul><li><p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p></li><li><p>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</p></li></ul><p>该算法的思路是，<strong>把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</strong></p><ul><li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144000359.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144016734.png" alt="mark"></p><p>了解了这个算法的工作方式，就明白为什么它被称为时钟（<em>Clock</em>）算法了</p><h3 id="3-5-最不常用算法（LFU）"><a href="#3-5-最不常用算法（LFU）" class="headerlink" title="3.5 最不常用算法（LFU）"></a>3.5 最不常用算法（LFU）</h3><ul><li>最不常用（<em>LFU</em>）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是<strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</li><li>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</li></ul><p><strong>缺点</strong></p><ul><li>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</li><li>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果<strong>链表长度很大，是非常耗时</strong>的，效率不高。</li><li>LFU 算法<strong>只考虑了频率问题，没考虑时间的问题</strong>，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。<ul><li>那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2</li><li>也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-10-内存页面置换算法&quot;&gt;&lt;a href=&quot;#Linux-10-内存页面置换算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-10-内存页面置换算法&quot;&gt;&lt;/a&gt;Linux-10-内存页面置换算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="内存页面置换" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Redis-15-mysql和redis缓存不一致</title>
    <link href="http://zhuuu.work/2020/08/22/Redis/Redis-15-mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>http://zhuuu.work/2020/08/22/Redis/Redis-15-mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/</id>
    <published>2020-08-22T10:32:24.000Z</published>
    <updated>2020-09-09T14:38:36.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-15-mysql和redis缓存不一致"><a href="#Redis-15-mysql和redis缓存不一致" class="headerlink" title="Redis-15-mysql和redis缓存不一致"></a>Redis-15-mysql和redis缓存不一致</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>这实际上是个“如果要做的足够精致是非常难的“问题。缓存失效被称为计算机科学里最难的两个问题之一（另外一个是起名字）。</p></li><li><p>先对本题一致性做个说明。这里的不一致是指：假如一个数据访问者同时读取Redis和DB，他能在一段时间里发现二者不一样。</p></li><li><p><strong>不错，如果一份数据放在DB，然后copy到Redis，然后改DB，那么Redis是不会自己魔幻般同步变更的。</strong></p></li><li><p><strong>必须有某种机制告诉Redis该变了。这些机制包括（但不仅仅限于）：</strong></p></li></ul><a id="more"></a><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><ul><li><p>Redis里的数据不立刻更新，等redis里数据自然过期。然后去DB里取，顺带重新set redis。</p></li><li><p>这种用法被称作“Cache Aside”。好处是代码比较简单，坏处是会有一段时间DB和Redis里的数据不一致。</p></li><li><p><strong>这个不一致的时间取决于redis里数据设定的有效期，比如10min。但如果Redis里数据没设置有效期，这招就不灵了。</strong></p></li></ul><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><ul><li>更新DB时总是不直接触碰DB，而是通过代码。而代码做的显式更新DB，然后马上del掉redis里的数据。</li><li>在下次取数据时，模式就恢复到了上一条说的方式。这也算是一种Cache Aside的变体。</li><li>这要做的好处是，数据的一致性会比较好，一般正常情况下，数据不一致的时间会在1s以下，对于绝大部分的场景是足够了。但是有极少几率，由于更新时序，下Redis数据会和DB不一致（这个有文章解释，这里不展开）。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/221825945.png" alt="mark"></p><ul><li><strong>方案1和方案2的做法常规上被称为“Cache“</strong>。</li><li>而且因为1有更新不及时的问题，2有极端情况下数据会不一致的问题，所以常规Cache代码会把1+2组合起来，要求Redis里的数据必须有过期时间，并且不能太长，</li><li>这样即便是不一致也能混过去。同时如果是主动对数据进行更新，Cache的数据更新也会比较及时。</li></ul><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><ul><li><p>并且2并不一定总是行得通。比如OLTP的服务在前面是Cache+DB的模式，而数据是由后台管理系统来更新的，总是不会触碰OLTP服务，更不会动Cache。这时将Redis看作是存储也算是一种方案。就是：</p></li><li><p><strong>Redis里的数据总是不过期，但是有个背景更新任务（“定时执行的代码” 或者 “被队列驱动的代码）读取db，把最新的数据塞给Redis。</strong></p></li><li><p><strong>这种做法将Redis看作是“存储”。</strong>访问者不知道背后的实际数据源，只知道Redis是唯一可以取的数据的地方。当实际数据源更新时，背景更新任务来将数据更新到Redis。这时还是会存在Redis和实际数据源不一致的问题。</p><ul><li>如果是<strong>定时任务</strong>，最长的不一致时长就是更新任务的执行间隔；</li><li>如果是用<strong>类似于队列的方式来更新</strong>，那么不一致时间取决于队列产生和消费的延迟。<ul><li>常用的队列（或等价物）有Redis（怎么还是Redis），Kafka，AMQ，RMQ，binglog，log文件，阿里的canal等。</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/223311394.png" alt="mark"></p><ul><li><strong>这种做法还有一种变体Write Through，写入时直接写DB，DB把数据更新Cache，而读取时读Cache。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/223403561.png" alt="mark"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>以上方式无论如何都会有一段时间Redis和DB会不一致</strong>。实践上，这个不一致时间短则几十ms，长可以到几十分钟。<strong>这种程度的一致性对于很多业务场景都已经足够了</strong></li><li>很多时候，用户无法区分自己读取的是Redis还是DB，只能读取到其中的一个。这时数据看起来直觉上是没问题的就可以接受了。只要不出现，用户先看见了数据是A，然后看到数据是B，之后一刷新，又看到A的尴尬场景就行了。</li><li>但对于有些业务，比如协作文档编辑，电商秒杀的扣库存，银行转账等，以上的做法就不够用了。</li></ul><p><strong>第一种方法</strong></p><ul><li>第一种是不要用Redis，只用DB。或者更直接点说是“只要一个单点的数据源”。这样肯定就没有一致性问题</li><li>代价就是CAP中因为CP被满足，因此A被牺牲掉。这就是为啥银行一系统升级就要停服务的原因。</li></ul><p><strong>第二种方法</strong></p><ul><li>另外一种保证一致性的做法就是用某种分布式协议一致性来做，大致可以归结到<ul><li>SAGA或者TCC - 这两种需要业务代码的大量配合。通过业务代码来补偿一致性。</li><li>2PC, 3PC - 现实当中有XA协议。比如Ehcache是支持XA协议的。但是性能表现不佳，运维也麻烦，我比较少见到实际这么干的。</li><li>基于Paxos或者Raft的分布式锁，然后对Redis和DB进行双写，但是除非客户端和服务器么次都去访问分布式锁，也会有一点点不一致的问题。这实际上相当于将多个地方的一致性控制交给了分布式锁的集中维护。</li></ul></li></ul><p>综上，除了单点DB存储之外的方案，其一致性面临的窘境是</p><ul><li><strong>要么，接受“最终一致”</strong>，但到底多久之后一致，不一致时表现怎么样，有很多种做法。分布式一致性有各种各样的模型，比如线性一致性、顺序一致性等。他们都是在“不一致”和“强一致”之间提供某种折衷。这些折衷大量应用于我们常见的诸多业务之中、如社交、IM、电商不触及钱的地方等</li><li><strong>要么，要求必须强一致。</strong>那么在分布式条件下就要牺牲A。比如访问一个Cache，Cache知道自己的数据不是最新的，就要和DB去Sync，Sync的过程中DB的数据还不能改。期间访问者要不收到一个错误“数据不同步，不能访问”，要不就卡在那里等着同步完成。个人以为，这还不如干脆就不要Cache，在维护强一致的同时，用其他方式来优化访问性能。</li></ul><p><strong>参考博客</strong> ：<a href="https://www.zhihu.com/question/319817091/answer/653985863" target="_blank" rel="noopener">https://www.zhihu.com/question/319817091/answer/653985863</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-15-mysql和redis缓存不一致&quot;&gt;&lt;a href=&quot;#Redis-15-mysql和redis缓存不一致&quot; class=&quot;headerlink&quot; title=&quot;Redis-15-mysql和redis缓存不一致&quot;&gt;&lt;/a&gt;Redis-15-mysql和redis缓存不一致&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这实际上是个“如果要做的足够精致是非常难的“问题。缓存失效被称为计算机科学里最难的两个问题之一（另外一个是起名字）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先对本题一致性做个说明。这里的不一致是指：假如一个数据访问者同时读取Redis和DB，他能在一段时间里发现二者不一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不错，如果一份数据放在DB，然后copy到Redis，然后改DB，那么Redis是不会自己魔幻般同步变更的。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;必须有某种机制告诉Redis该变了。这些机制包括（但不仅仅限于）：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="mysql和redis缓存不一致" scheme="http://zhuuu.work/tags/mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    
      <category term="mysql" scheme="http://zhuuu.work/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis-16-Redis分布式</title>
    <link href="http://zhuuu.work/2020/08/22/Redis/Redis-16-Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/08/22/Redis/Redis-16-Redis%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2020-08-22T10:32:24.000Z</published>
    <updated>2020-09-17T07:29:21.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-16-Redis分布式"><a href="#Redis-16-Redis分布式" class="headerlink" title="Redis-16-Redis分布式"></a>Redis-16-Redis分布式</h1><h2 id="1-为什么用Redis"><a href="#1-为什么用Redis" class="headerlink" title="1. 为什么用Redis?"></a>1. 为什么用Redis?</h2><ol><li>单线程的redis为什么这么快??</li></ol><p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。</p><p><strong>回答</strong>:主要是以下三点<br>(一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞<strong>I/O多路复用机制</strong></p><p><strong>关于Redis的 I/O多路复用：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-154227633.png" alt="mark"></p><ul><li>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</li><li>需要说明的是，这个I/O多路复用机制，redis还提供了<code>select、epoll、evport、kqueue</code>等多路复用函数库</li></ul><a id="more"></a><h2 id="2-Redis数据结构应用场景"><a href="#2-Redis数据结构应用场景" class="headerlink" title="2. Redis数据结构应用场景"></a>2. Redis数据结构应用场景</h2><p><strong>redis的数据类型，以及每种数据类型的使用场景</strong></p><p><strong>回答</strong>：一共五种</p><p>(一)String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong>（以及分布式锁）</p><p>(二)hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。就是用这种数据结构存储用户信息，以<code>cookieId</code>作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p><p>(三)list<br>使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</p><p>(四)set<br>因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p><p>另外，就是利用<strong>交集、并集、差集</strong>等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</p><p>(五)<code>sorted set</code><br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>。sorted set可以用来做<strong>延时任务</strong>。最后一个应用就是可以做<strong>范围查找</strong>。</p><h2 id="3-Redis过期策略和内存淘汰机制"><a href="#3-Redis过期策略和内存淘汰机制" class="headerlink" title="3. Redis过期策略和内存淘汰机制"></a>3. Redis过期策略和内存淘汰机制</h2><ul><li>redis的<strong>过期策略以及内存淘汰机制</strong></li></ul><p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p><p><strong>回答</strong>:</p><ul><li>redis采用的是<strong>定期删除+惰性删除策略。</strong></li></ul><p><strong>为什么不用定时删除策略?</strong></p><ul><li>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</li></ul><p><strong>定期删除+惰性删除是如何工作的呢?</strong></p><ul><li><p>定期删除，redis默认每个<code>100ms</code>检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</p></li><li><p>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p></li></ul><p><strong>采用定期删除+惰性删除就没其他问题了么?</strong></p><ul><li>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。</li></ul><p><strong>在redis.conf中有一行配置</strong></p><p><code># maxmemory-policy volatile-lru</code></p><p><strong>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**应该没人用吧。**</span><br><span class="line">2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。**推荐使用，目前项目在用这种。**</span><br><span class="line">3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。**应该也没人用吧，你不删最少使用Key,去随机删。**</span><br><span class="line">4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。**这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐**</span><br><span class="line">5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。**依然不推荐**</span><br><span class="line">6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。**不推荐**</span><br></pre></td></tr></table></figure><p><strong>ps：如果没有设置 <code>expire</code> 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</strong></p><h2 id="4-双写一致性问题"><a href="#4-双写一致性问题" class="headerlink" title="4. 双写一致性问题"></a>4. 双写一致性问题</h2><p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为<strong>最终一致性</strong>和<strong>强一致性</strong>。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p><p><strong>回答</strong>:</p><ul><li>首先，采取正确更新策略，<ul><li>先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li></ul></li></ul><h2 id="5-并发竞争key的问题"><a href="#5-并发竞争key的问题" class="headerlink" title="5. 并发竞争key的问题"></a>5. 并发竞争key的问题</h2><ul><li><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></li></ul><ul><li><strong>回答:</strong>如下所示<br>(1)如果对这个key操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，<strong>要求顺序</strong><br>假设有一个<code>key1</code>,系统A需要将<code>key1</code>设置为<code>valueA</code>,系统B需要将<code>key1</code>设置为<code>valueB</code>,系统C需要将<code>key1</code>设置为<code>valueC</code>.<br>期望按照key1的value值按照 <code>valueA--&gt;valueB--&gt;valueC</code>的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br><span class="line"></span><br><span class="line">那么，假设这会系统B先抢到锁，将key1设置为&#123;valueB 3:05&#125;。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做<span class="built_in">set</span>操作了。以此类推。</span><br><span class="line"></span><br><span class="line">其他方法，比如利用队列，将<span class="built_in">set</span>方法变成串行访问也可以。总之，灵活变通。</span><br></pre></td></tr></table></figure><p><strong>参考博客 ：</strong> <a href="https://blog.csdn.net/tmeng521/article/details/91039391" target="_blank" rel="noopener">https://blog.csdn.net/tmeng521/article/details/91039391</a></p><p>​                    <a href="https://www.cnblogs.com/bigben0123/p/9115597.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigben0123/p/9115597.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-16-Redis分布式&quot;&gt;&lt;a href=&quot;#Redis-16-Redis分布式&quot; class=&quot;headerlink&quot; title=&quot;Redis-16-Redis分布式&quot;&gt;&lt;/a&gt;Redis-16-Redis分布式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么用Redis&quot;&gt;&lt;a href=&quot;#1-为什么用Redis&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么用Redis?&quot;&gt;&lt;/a&gt;1. 为什么用Redis?&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;单线程的redis为什么这么快??&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;:这个问题其实是对redis内部机制的一个考察。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答&lt;/strong&gt;:主要是以下三点&lt;br&gt;(一)纯内存操作&lt;br&gt;(二)单线程操作，避免了频繁的上下文切换&lt;br&gt;(三)采用了非阻塞&lt;strong&gt;I/O多路复用机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Redis的 I/O多路复用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-154227633.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。&lt;/li&gt;
&lt;li&gt;需要说明的是，这个I/O多路复用机制，redis还提供了&lt;code&gt;select、epoll、evport、kqueue&lt;/code&gt;等多路复用函数库&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="Redis分布式" scheme="http://zhuuu.work/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo-01-调用过程</title>
    <link href="http://zhuuu.work/2020/08/20/Dubbo/Dubbo-01-%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/08/20/Dubbo/Dubbo-01-%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-08-20T12:32:24.000Z</published>
    <updated>2020-09-26T03:36:48.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo-01-调用过程"><a href="#Dubbo-01-调用过程" class="headerlink" title="Dubbo-01-调用过程"></a>Dubbo-01-调用过程</h1><ul><li>微服务的普及化以及重要性，服务化场景下随之而来的就是服务之间的通信问题，那服务间的通信脑海中想到的就是 RPC，说到 RPC 就离不开咱们的 Dubbo。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/105245606.jpg" alt="mark"></p><p><strong>本文流程：</strong></p><p><strong>Dubbo 的简介、总体分层、核心组件以及大致调用流程</strong>。</p><p>我们先来谈一谈什么叫 RPC ，我发现有很多同学不太了解这个概念，还有人把 RPC 和 HTTP 来进行对比。所以咱们先来说说什么是 RPC。</p><a id="more"></a><h2 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1. RPC"></a>1. RPC</h2><ul><li><p>RPC，<code>Remote Procedure Call</code>即远程过程调用，远程过程调用其实对标的是本地过程调用，本地过程调用你熟悉吧？</p><ul><li>想想那青葱岁月，你在大学赶着期末大作业，正在攻克图书管理系统，你奋笔疾书疯狂地敲击键盘，实现了图书借阅、图书归还等等模块，你实现的一个个方法之间的调用就叫本地过程调用。</li></ul></li><li><p>你要是和我说你实现图书馆里系统已经用了服务化，搞了远程调用了，我只能和你说你有点东西。</p></li></ul><ul><li>简单的说本机上内部的方法调用都可以称为本地过程调用，而远程过程调用实际上就指的是你本地调用了远程机子上的某个方法，这就是远程过程调用。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/105520106.jpg" alt="mark"></p><ul><li><p>所以说 RPC 对标的是本地过程调用，至于 RPC 要如何调用远程的方法可以走 HTTP、也可以是基于 TCP 自定义协议。</p></li><li><p>所以说你讨论 RPC 和 HTTP 就不是一个层级的东西。</p></li><li><p>而 <strong>RPC 框架就是要实现像那小助手一样的东西，目的就是让我们使用远程调用像本地调用一样简单方便，并且解决一些远程调用会发生的一些问题</strong>，使用户用的无感知、舒心、放心、顺心，它好我也好，快乐没烦恼。</p></li></ul><h3 id="1-1-如何设计一个RPC框架"><a href="#1-1-如何设计一个RPC框架" class="headerlink" title="1.1 如何设计一个RPC框架"></a>1.1 如何设计一个RPC框架</h3><ul><li>在明确了什么是 RPC，以及 RPC 框架的目的之后，咱们想想如果让你做一款 RPC 框架你该如何设计？</li></ul><p><strong>服务消费者</strong></p><ul><li><p>首先消费者面向接口编程，所以需要得知有哪些接口可以调用，可以通过<strong>公用 jar 包</strong>的方式来维护接口。</p></li><li><p>现在知道有哪些接口可以调用了，但是只有接口啊，具体的实现怎么来？这事必须框架给处理了！所以还<strong>需要来个代理类</strong>，让消费者只管调，啥事都别管了，我<strong>代理帮你搞定</strong>。</p></li><li><p>虽说代理帮你搞定但是代理也需要知道它到底要调哪个机子上的远程方法，所以<strong>需要有个注册中心</strong>，这样调用方从注册中心可以知晓可以调用哪些服务提供方，一般而言提供方不止一个，毕竟只有一个挂了那不就没了。</p></li><li><p>所以提供方一般都是集群部署，那调用方需要通过<strong>负载均衡</strong>来选择一个调用，可以通过<strong>某些策略</strong>例如同机房优先调用啊啥的。</p></li><li><p>当然还需要有<strong>容错机制</strong>，毕竟这是远程调用，网络是不可靠的，所以可能需要重试什么的。</p></li><li><p>还要和服务提供方<strong>约定一个协议</strong>，例如我们就用 HTTP 来通信就好啦，也就是大家要讲一样的话，不然可能听不懂了。</p></li><li><p>当然序列化必不可少，毕竟我们本地的结构是“立体”的，需要序列化之后才能传输，因此还需要<strong>约定序列化格式</strong>。</p></li><li><p>并且这过程中间可能还需要掺入一些 Filter，来作一波统一的处理，例如调用计数啊等等。</p></li></ul><p><strong>这些都是框架需要做的，让消费者像在调用本地方法一样，无感知。</strong></p><p><strong>服务提供者</strong></p><ul><li>服务提供者肯定要<strong>实现对应的接口</strong>这是毋庸置疑的。</li><li>然后需要把自己的接口暴露出去，向<strong>注册中心注册自己</strong>，暴露自己所能提供的服务。</li><li>然后有消费者请求过来需要处理，提供者需要用和消费者<strong>协商好的协议</strong>来处理这个请求，然后做<strong>反序列化</strong>。</li><li>序列化完的请求应该<strong>扔到线程池里面做处理</strong>，某个线程接受到这个请求之后找到对应的实现调用，然后再<strong>将结果原路返回</strong>。</li></ul><p><strong>注册中心</strong></p><ul><li>上面其实我们都提到了注册中心，这东西就相当于一个平台，大家在上面暴露自己的服务，也在上面得知自己能调用哪些服务。</li><li>当然还能做配置中心，将配置集中化处理，动态变更通知订阅者。</li></ul><p><strong>监控运维</strong></p><ul><li>面对众多的服务，精细化的监控和方便的运维必不可少。</li><li>这点很多开发者在开发的时候察觉不到，到你真正上线开始运行维护的时候，如果没有良好的监控措施，快速的运维手段，到时候就是睁眼瞎！手足无措，等着挨批把！</li></ul><p><strong>小结：</strong></p><ul><li>让我们小结一下，大致上一个 RPC 框架需要做的就是<ul><li>约定要通信协议</li><li>序列化的格式</li><li>一些容错机制</li><li>负载均衡策略</li><li>监控运维</li><li>一个注册中心</li></ul></li></ul><h3 id="1-2-简单实现一个RPC框架"><a href="#1-2-简单实现一个RPC框架" class="headerlink" title="1.2 简单实现一个RPC框架"></a>1.2 简单实现一个RPC框架</h3><ul><li>没错就是简单的实现，上面我们在思考如何设计一个 RPC 框架的时候想了很多，那算是生产环境使用级别的功能需求了，我们这是 Demo，目的是突出 RPC框架重点功能 - <strong>实现远程调用</strong>。</li></ul><ul><li>首先我们定义一个接口和一个简单实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AobingService</span> </span>&#123;  </span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AobingServiceImpl</span> <span class="keyword">implements</span> <span class="title">AobingService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Yo man Hello，I am"</span> + name;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后我们再来实现服务提供者暴露服务的功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AobingRpcFramework</span> </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">          ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">          <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">              Socket socket = server.accept();</span><br><span class="line">              <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                  <span class="comment">//反序列化</span></span><br><span class="line">                  ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream()); </span><br><span class="line">                  String methodName = input.read(); <span class="comment">//读取方法名</span></span><br><span class="line">                  Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject(); <span class="comment">//参数类型</span></span><br><span class="line">                  Object[] arguments = (Object[]) input.readObject(); <span class="comment">//参数</span></span><br><span class="line">                  Method method = service.getClass().getMethod(methodName, parameterTypes);  <span class="comment">//找到方法</span></span><br><span class="line">                  Object result = method.invoke(service, arguments); <span class="comment">//调用方法</span></span><br><span class="line">                  <span class="comment">// 返回结果</span></span><br><span class="line">                  ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                  output.writeObject(result);</span><br><span class="line">              &#125;).start();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">refer</span> <span class="params">(Class&lt;T&gt; interfaceClass, String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123;interfaceClass&#125;, </span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">                    Socket socket = <span class="keyword">new</span> Socket(host, port);  <span class="comment">//指定 provider 的 ip 和端口</span></span><br><span class="line">                    ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream()); </span><br><span class="line">                    output.write(method.getName());  <span class="comment">//传方法名</span></span><br><span class="line">                    output.writeObject(method.getParameterTypes());  <span class="comment">//传参数类型</span></span><br><span class="line">                    output.writeObject(arguments);  <span class="comment">//传参数值</span></span><br><span class="line">                    ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                    Object result = input.readObject();  <span class="comment">//读取结果</span></span><br><span class="line">                    <span class="keyword">return</span> result;  </span><br><span class="line">               &#125;</span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这个 RPC 框架就这样好了，是不是很简单？就是<strong>调用者传递了方法名、参数类型和参数值，提供者接收到这样参数之后调用对于的方法返回结果就好了</strong>！这就是远程过程调用。</p><ul><li>我们来看看如何使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//服务提供者只需要暴露出接口</span></span><br><span class="line">AobingService service = <span class="keyword">new</span> AobingServiceImpl ();  </span><br><span class="line">AobingRpcFramework.export(service, <span class="number">2333</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//服务调用者只需要设置依赖</span></span><br><span class="line">AobingService service = AobingRpcFramework.refer(AobingService.class, "127.0.0.1", 2333);  </span><br><span class="line">service.hello();</span><br></pre></td></tr></table></figure><p>看起来好像好不错哟，不过这很是简陋，用作 demo 有助理解还是极好的！</p><p>接下来就来看看 Dubbo 吧！上正菜！</p><h2 id="2-Dubbo简介"><a href="#2-Dubbo简介" class="headerlink" title="2. Dubbo简介"></a>2. Dubbo简介</h2><ul><li>Dubbo 是阿里巴巴 2011年开源的一个基于 Java 的 RPC 框架，中间沉寂了一段时间，不过其他一些企业还在用 Dubbo 并自己做了扩展，比如当当网的 Dubbox，还有网易考拉的 Dubbok。</li><li>但是在 2017 年阿里巴巴又重启了对 Dubbo 维护。在 2017 年荣获了开源中国 2017 最受欢迎的中国开源软件 Top 3。</li><li>在 2018 年和 Dubbox 进行了合并，并且进入 Apache 孵化器，在 2019 年毕业正式成为 Apache 顶级项目。</li><li>目前 Dubbo 社区主力维护的是 2.6.x 和 2.7.x 两大版本，2.6.x 版本主要是 bug 修复和少量功能增强为准，是稳定版本。</li><li>而 2.7.x 是主要开发版本，更新和新增新的 feature 和优化，并且 2.7.5 版本的发布被 Dubbo 认为是里程碑式的版本发布，之后我们再做分析。</li><li>它实现了面向接口的代理 RPC 调用，并且可以配合 ZooKeeper 等组件实现服务注册和发现功能，并且拥有负载均衡、容错机制等。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/110621676.png" alt="mark"></p><table><thead><tr><th align="left">节点</th><th align="left">角色说明</th></tr></thead><tbody><tr><td align="left">Consumer</td><td align="left">需要调用远程服务的服务消费方</td></tr><tr><td align="left">Registry</td><td align="left">注册中心</td></tr><tr><td align="left">Provider</td><td align="left">服务提供方</td></tr><tr><td align="left">Container</td><td align="left">服务运行的容器</td></tr><tr><td align="left">Monitor</td><td align="left">监控中心</td></tr></tbody></table><p><strong>再来说一下整体的流程</strong></p><ul><li><p>首先服务提供者 <strong>Provider 启动然后向注册中心注册</strong>自己所能提供的服务。</p></li><li><p>服务消费者 <strong>Consumer 启动向注册中心订阅</strong>自己所需的服务。</p></li><li><p>然后注册中心将提供者元信息通知给 Consumer， 之后 Consumer 因为已经从注册中心获取提供者的地址，因此可以<strong>通过负载均衡选择一个 Provider 直接调用</strong> 。</p></li><li><p>之后服务提供方元数据变更的话<strong>注册中心会把变更推送给服务消费者</strong>。</p></li><li><p>服务提供者和消费者都会在内存中记录着调用的次数和时间，然后<strong>定时的发送统计数据到监控中心</strong>。</p></li></ul><p><strong>注意点：</strong></p><ul><li>首先<strong>注册中心和监控中心是可选的</strong>，你可以不要监控，也不要注册中心，直接在配置文件里面写然后提供方和消费方直连。</li><li>然后注册中心、提供方和消费方之间都是长连接，和监控方不是长连接，并且<strong>消费方是直接调用提供方，不经过注册中心</strong>。</li><li>就算<strong>注册中心和监控中心宕机了也不会影响到已经正常运行的提供者和消费者</strong>，因为消费者有本地缓存提供者的信息。</li></ul><h2 id="3-Dubbo分层架构"><a href="#3-Dubbo分层架构" class="headerlink" title="3. Dubbo分层架构"></a>3. Dubbo分层架构</h2><ul><li>总的而言 Dubbo 分为三层，如果每一层再细分下去，一共有十层。别怕也就十层</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/112908886.jpg" alt="mark"></p><ul><li>大的三层分别为 Business（业务层）、RPC 层、Remoting，并且还分为 API 层和 SPI 层。</li><li>分为大三层其实就是和我们知道的网络分层一样的意思，<strong>只有层次分明，职责边界清晰才能更好的扩展</strong>。</li><li>而分 API 层和 SPI 层这是 Dubbo 成功的一点，<strong>采用微内核设计+SPI扩展</strong>，使得有特殊需求的接入方可以自定义扩展，做定制的二次开发。</li></ul><p>接下来咱们再来看看每一层都是干嘛的。</p><ul><li>Service，业务层，就是咱们开发的业务逻辑层。</li><li>Config，配置层，主要围绕 ServiceConfig 和 ReferenceConfig，初始化配置信息。</li><li>Proxy，代理层，服务提供者还是消费者都会生成一个代理类，使得服务接口透明化，代理层做远程调用和返回结果。</li><li>Register，注册层，封装了服务注册和发现。</li><li>Cluster，路由和集群容错层，负责选取具体调用的节点，处理特殊的调用要求和负责远程调用失败的容错措施。</li><li>Monitor，监控层，负责监控统计调用时间和次数。</li><li>Portocol，远程调用层，主要是封装 RPC 调用，主要负责管理 Invoker，Invoker代表一个抽象封装了的执行体，之后再做详解。</li><li>Exchange，信息交换层，用来封装请求响应模型，同步转异步。</li><li>Transport，网络传输层，抽象了网络传输的统一接口，这样用户想用 Netty 就用 Netty，想用 Mina 就用 Mina。</li><li>Serialize，序列化层，将数据序列化成二进制流，当然也做反序列化。</li></ul><h3 id="3-1-SPI"><a href="#3-1-SPI" class="headerlink" title="3.1 SPI"></a>3.1 SPI</h3><ul><li>我再稍微提一下 SPI（Service Provider Interface），是 JDK 内置的一个服务发现机制，<strong>它使得接口和具体实现完全解耦</strong>。我们只声明接口，具体的实现类在配置中选择。</li><li>具体的就是你定义了一个接口，然后在<code>META-INF/services</code>目录下<strong>放置一个与接口同名的文本文件</strong>，文件的内容为<strong>接口的实现类</strong>，多个实现类用换行符分隔。</li><li>这样就通过配置来决定具体用哪个实现！</li><li>而 Dubbo SPI 还做了一些改进，篇幅有限留在之后再谈。</li></ul><h2 id="4-Dubbo的调用过程"><a href="#4-Dubbo的调用过程" class="headerlink" title="4. Dubbo的调用过程"></a>4. Dubbo的调用过程</h2><ul><li>上面我已经介绍了每个层到底是干嘛的，我们现在再来串起来走一遍调用的过程，加深你对 Dubbo 的理解，让知识点串起来，由点及面来一波连连看。</li></ul><p><strong>先从服务提供者开始，看看它是如何工作的。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/113239679.jpg" alt="mark"></p><p><strong>服务暴露过程</strong></p><ul><li>首先 Provider 启动，通过 Proxy 组件根据具体的协议 Protocol 将需要暴露出去的接口封装成 Invoker，Invoker 是 Dubbo 一个很核心的组件，代表一个可执行体。</li><li>然后再通过 Exporter 包装一下，这是为了在注册中心暴露自己套的一层，然后将 Exporter 通过 Registry 注册到注册中心。这就是整体服务暴露过程。</li></ul><p><strong>消费过程</strong></p><ul><li>接着我们来看消费者调用流程（把服务者暴露的过程也在图里展示出来了，这个图其实算一个挺完整的流程图了）。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/113428361.jpg" alt="mark"></p><ul><li>首先消费者启动会向注册中心拉取服务提供者的元信息，然后调用流程也是从 Proxy 开始，毕竟都需要代理才能无感知。</li><li>Proxy 持有一个 Invoker 对象，调用 invoke 之后需要通过 Cluster 先从 Directory 获取所有可调用的远程服务的 Invoker 列表，如果配置了某些路由规则，比如某个接口只能调用某个节点的那就再过滤一遍 Invoker 列表。</li><li>剩下的 Invoker 再通过 LoadBalance 做负载均衡选取一个。然后再经过 Filter 做一些统计什么的，再通过 Client 做数据传输，比如用 Netty 来传输。</li><li>传输需要经过 Codec 接口做协议构造，再序列化。最终发往对应的服务提供者。</li><li>服务提供者接收到之后也会进行 Codec 协议处理，然后反序列化后将请求扔到线程池处理。某个线程会根据请求找到对应的 Exporter ，而找到 Exporter 其实就是找到了 Invoker，但是还会有一层层 Filter，经过一层层过滤链之后最终调用实现类然后原路返回结果。</li></ul><p><strong>完成整个调用过程！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dubbo-01-调用过程&quot;&gt;&lt;a href=&quot;#Dubbo-01-调用过程&quot; class=&quot;headerlink&quot; title=&quot;Dubbo-01-调用过程&quot;&gt;&lt;/a&gt;Dubbo-01-调用过程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;微服务的普及化以及重要性，服务化场景下随之而来的就是服务之间的通信问题，那服务间的通信脑海中想到的就是 RPC，说到 RPC 就离不开咱们的 Dubbo。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/105245606.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文流程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dubbo 的简介、总体分层、核心组件以及大致调用流程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们先来谈一谈什么叫 RPC ，我发现有很多同学不太了解这个概念，还有人把 RPC 和 HTTP 来进行对比。所以咱们先来说说什么是 RPC。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Dubbo" scheme="http://zhuuu.work/tags/Dubbo/"/>
    
      <category term="RPC" scheme="http://zhuuu.work/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-014-最长公共前缀</title>
    <link href="http://zhuuu.work/2020/08/20/Leetcode/Leetcode-014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://zhuuu.work/2020/08/20/Leetcode/Leetcode-014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</id>
    <published>2020-08-20T11:52:53.000Z</published>
    <updated>2020-08-20T05:56:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-014-最长公共前缀"><a href="#Leetcode-014-最长公共前缀" class="headerlink" title="Leetcode-014-最长公共前缀"></a>Leetcode-014-<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">最长公共前缀</a></h1><h2 id="思路：遍历"><a href="#思路：遍历" class="headerlink" title="思路：遍历"></a>思路：遍历</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 横向扫描</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到字符串数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="comment">// 拿到第一个字符串</span></span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两比较，找出最长公共前缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            prefix = longestPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  两两比较，找出最长公共前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longestPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(),str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index))&#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截取字符串</span></span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-014-最长公共前缀&quot;&gt;&lt;a href=&quot;#Leetcode-014-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-014-最长公共前缀&quot;&gt;&lt;/a&gt;Leetcode-014-&lt;a href=&quot;https:/
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-03-红黑树</title>
    <link href="http://zhuuu.work/2020/08/19/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/08/19/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03-%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-08-19T10:32:24.000Z</published>
    <updated>2020-08-19T07:23:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-03-红黑树"><a href="#数据结构-03-红黑树" class="headerlink" title="数据结构-03-红黑树"></a>数据结构-03-红黑树</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p>数据结构在线生成工具 ： <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><strong>二叉排序树</strong>（Binary Sort Tree）或者是一棵空树；或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点 </li></ol><p><strong>关于红黑树</strong></p><ul><li><p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p></li><li><p>因为一棵由n个结点随机构造的二叉查找树的高度为lgn，所以顺理成章，二叉查找树的一般操作的执行时间为O(lgn)。但二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。</p></li><li><p><strong>红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)，为了保证这个性质，所以红黑树有以下几个特性：</strong></p></li></ul><ol><li><strong>一个节点要么是红的要么就是黑的</strong></li><li><strong>根节点一定是黑色的</strong></li><li><strong>从叶子节点到根节点 黑色节点一定是一致的（黑高）</strong></li><li><strong>不能有两个红色节点相连（叶子节点一定是黑色的）</strong></li><li><strong>一般采用红插法，这样可以保证树不会失衡</strong></li></ol><h2 id="2-红黑树的旋转"><a href="#2-红黑树的旋转" class="headerlink" title="2. 红黑树的旋转"></a>2. 红黑树的旋转</h2><p>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。旋转包括两种：左旋和右旋。如下图所示：</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-03-红黑树&quot;&gt;&lt;a href=&quot;#数据结构-03-红黑树&quot; class=&quot;headerlink&quot; title=&quot;数据结构-03-红黑树&quot;&gt;&lt;/a&gt;数据结构-03-红黑树&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据结构在线生成工具 ： &lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="http://zhuuu.work/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis-14-key有效时间设置</title>
    <link href="http://zhuuu.work/2020/08/19/Redis/Redis-14-key%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <id>http://zhuuu.work/2020/08/19/Redis/Redis-14-key%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/</id>
    <published>2020-08-19T10:32:24.000Z</published>
    <updated>2020-08-19T09:14:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-14-key有效时间设置"><a href="#Redis-14-key有效时间设置" class="headerlink" title="Redis-14-key有效时间设置"></a>Redis-14-key有效时间设置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文对redis的过期处理机制做个简单的概述，让大家有个基本的认识。</li><li><strong>Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的</strong>。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</li></ul><a id="more"></a><h2 id="1-有效时间设置"><a href="#1-有效时间设置" class="headerlink" title="1. 有效时间设置"></a>1. 有效时间设置</h2><p>redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。Expires字典保存了所有键的过期时间，Expires也被称为过期字段。<br>四种处理策略</p><ol><li>EXPIRE 将key的生存时间设置为ttl秒</li><li>PEXPIRE 将key的生成时间设置为ttl毫秒</li><li>EXPIREAT 将key的过期时间设置为timestamp所代表的的秒数的时间戳</li><li>PEXPIREAT 将key的过期时间设置为timestamp所代表的的毫秒数的时间戳</li></ol><p>其实以上几种处理方式都是根据PEXPIREAT来实现的，设置生存时间的时候是redis内部计算好时间之后在内存处理的，最终的处理都会转向PEXPIREAT。<br>1、2两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到redis中。<br>3、4两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。</p><h2 id="2-过期键的删除策略"><a href="#2-过期键的删除策略" class="headerlink" title="2. 过期键的删除策略"></a>2. 过期键的删除策略</h2><p>如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢？？如果不是，那过期后到底什么时候被删除呢？？</p><p>其实有三种不同的删除策略：<br>（1）立即删除。在设置键的过期时间时，创建一个回调事件，当过期时间达到时，由时间处理器自动执行键的删除操作。<br>（2）惰性删除。键过期了就过期了，不管。每次从dict字典中按key取值时，先检查此key是否已经过期，如果过期了就删除它，并返回nil，如果没过期，就返回键值。<br>（3）定时删除。每隔一段时间，对expires字典进行检查，删除里面的过期键。<br>可以看到，第二种为被动删除，第一种和第三种为主动删除，且第一种实时性更高。下面对这三种删除策略进行具体分析。</p><h3 id="2-1-立即删除"><a href="#2-1-立即删除" class="headerlink" title="2.1 立即删除"></a>2.1 立即删除</h3><ul><li><p>立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是<strong>立即删除对cpu是最不友好的</strong>。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力。</p></li><li><p>而且目前redis事件处理器对时间事件的处理方式–无序链表，查找一个key的时间复杂度为O(n),所以并不适合用来处理大量的时间事件。</p></li></ul><h3 id="2-2-惰性删除"><a href="#2-2-惰性删除" class="headerlink" title="2.2 惰性删除"></a>2.2 惰性删除</h3><ul><li><p>惰性删除是指，某个键值过期后，此键值不会马上被删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。所以惰性删除的缺点很明显:<strong>浪费内存</strong>。dict字典和expires字典都要保存这个键值的信息。</p></li><li><p>举个例子，对于一些按时间点来更新的数据，比如log日志，过期后在很长的一段时间内可能都得不到访问，这样在这段时间内就要拜拜浪费这么多内存来存log。<strong>这对于性能非常依赖于内存大小的redis来说，是比较致命的</strong>。</p></li></ul><h3 id="2-3-定时删除"><a href="#2-3-定时删除" class="headerlink" title="2.3 定时删除"></a>2.3 定时删除</h3><ul><li>从上面分析来看，立即删除会短时间内占用大量cpu，惰性删除会在一段时间内浪费内存，所以定时删除是一个折中的办法。</li><li>定时删除是：每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对cpu的影响。另一方面定时删除也有效的减少了因惰性删除带来的内存浪费。</li></ul><p><strong>redis使用的过期键值删除策略是：惰性删除加上定期删除，两者配合使用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-14-key有效时间设置&quot;&gt;&lt;a href=&quot;#Redis-14-key有效时间设置&quot; class=&quot;headerlink&quot; title=&quot;Redis-14-key有效时间设置&quot;&gt;&lt;/a&gt;Redis-14-key有效时间设置&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文对redis的过期处理机制做个简单的概述，让大家有个基本的认识。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的&lt;/strong&gt;。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux-08-netstat详解</title>
    <link href="http://zhuuu.work/2020/08/19/Linux/Linux-08-netstat%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/08/19/Linux/Linux-08-netstat%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-08-19T03:44:53.000Z</published>
    <updated>2020-09-23T02:08:12.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-08-netstat详解"><a href="#Linux-08-netstat详解" class="headerlink" title="Linux-08-netstat详解"></a>Linux-08-netstat详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>Netstat</code> 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (<code>Interface Statistics</code>)，<code>masquerade</code> 连接，多播成员 (<code>Multicast Memberships</code>) 等等。</li></ul><p><strong>输出信息含义</strong></p><ul><li>执行<code>netstat</code>后，其输出结果为</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED</span><br><span class="line">tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED</span><br><span class="line">tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED</span><br><span class="line">tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED</span><br><span class="line">tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE</span><br><span class="line"></span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags Type State I-Node Path</span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16178 @000000dd</span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16176 @000000dc</span><br><span class="line">unix 9 [ ] DGRAM 5292 /dev/<span class="built_in">log</span></span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16182 @000000df</span><br></pre></td></tr></table></figure><p>从整体上看，<code>netstat</code>的输出结果可以分为两个部分：</p><ul><li><p>一个是<code>Active Internet connections</code>，称为有源<code>TCP</code>连接，其中”<code>Recv-Q</code>“和”<code>Send-Q</code>“指<code>%0A</code>的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。</p></li><li><p>另一个是<code>Active UNIX domain sockets</code>，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p></li><li><p>其中 ： <code>Proto</code>显示连接使用的协议,<code>RefCnt</code>表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。</p></li></ul><a id="more"></a><h2 id="1-常见参数"><a href="#1-常见参数" class="headerlink" title="1. 常见参数"></a>1. 常见参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-a (all)显示所有选项，默认不显示LISTEN相关</span><br><span class="line">-t (tcp)仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化成数字。</span><br><span class="line">-l 仅列出有在 Listen (监听) 的服務状态</span><br><span class="line"></span><br><span class="line">-p 显示建立相关链接的程序名</span><br><span class="line">-r 显示路由信息，路由表</span><br><span class="line">-e 显示扩展信息，例如uid等</span><br><span class="line">-s 按各个协议进行统计</span><br><span class="line">-c 每隔一个固定时间，执行该netstat命令。</span><br></pre></td></tr></table></figure><ul><li>提示：<code>LISTEN</code>和<code>LISTENING</code>的状态只有用-a或者-l才能看到</li></ul><h2 id="2-使用命令实例"><a href="#2-使用命令实例" class="headerlink" title="2. 使用命令实例"></a>2. 使用命令实例</h2><h3 id="2-1-列出所有端口-包括监听和未监听的"><a href="#2-1-列出所有端口-包括监听和未监听的" class="headerlink" title="2.1 列出所有端口(包括监听和未监听的)"></a>2.1 列出所有端口<strong>(包括监听和未监听的)</strong></h3><p> <strong>列出所有端口 netstat -a</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># netstat -a | more</span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> udp        0      0 *:bootpc                *:*</span><br><span class="line"> </span><br><span class="line">Active UNIX domain sockets (servers and established)</span><br><span class="line"> Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6135     &#x2F;tmp&#x2F;.X11-unix&#x2F;X0</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     5140     &#x2F;var&#x2F;run&#x2F;acpid.socket</span><br></pre></td></tr></table></figure><p> <strong>列出所有 tcp 端口 netstat -at</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># netstat -at</span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> tcp        0      0 localhost:ipp           *:*                     LISTEN</span><br><span class="line"> tcp        0      0 *:smtp                  *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br></pre></td></tr></table></figure><p> <strong>列出所有 udp 端口 netstat -au</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -au</span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> udp        0      0 *:bootpc                *:*</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br><span class="line"> udp        0      0 *:mdns                  *:*</span><br></pre></td></tr></table></figure><h3 id="2-2-列出所有处于监听状态的-Sockets"><a href="#2-2-列出所有处于监听状态的-Sockets" class="headerlink" title="2.2 列出所有处于监听状态的 Sockets"></a>2.2 列出所有处于监听状态的 Sockets</h3><p> <strong>只显示监听端口 netstat -l</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -l</span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:ipp           *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br></pre></td></tr></table></figure><p> <strong>只列出所有监听 tcp 端口 netstat -lt</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -lt</span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> tcp        0      0 *:smtp                  *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br></pre></td></tr></table></figure><p> <strong>只列出所有监听 udp 端口 netstat -lu</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># netstat -lu</span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br><span class="line"> udp        0      0 *:mdns                  *:*</span><br></pre></td></tr></table></figure><p> <strong>只列出所有监听 UNIX 端口 netstat -lx</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># netstat -lx</span><br><span class="line"> Active UNIX domain sockets (only servers)</span><br><span class="line"> Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6294     private&#x2F;maildrop</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6203     public&#x2F;cleanup</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6302     private&#x2F;ifmail</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6306     private&#x2F;bsmtp</span><br></pre></td></tr></table></figure><h3 id="2-3-显示每个协议的统计信息"><a href="#2-3-显示每个协议的统计信息" class="headerlink" title="2.3 显示每个协议的统计信息"></a>2.3 显示每个协议的统计信息</h3><p> <strong>显示所有端口的统计信息 netstat -s</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># netstat -s</span><br><span class="line"> Ip:</span><br><span class="line"> 11150 total packets received</span><br><span class="line"> 1 with invalid addresses</span><br><span class="line"> 0 forwarded</span><br><span class="line"> 0 incoming packets discarded</span><br><span class="line"> 11149 incoming packets delivered</span><br><span class="line"> 11635 requests sent out</span><br><span class="line"> Icmp:</span><br><span class="line"> 0 ICMP messages received</span><br><span class="line"> 0 input ICMP message failed.</span><br><span class="line"> Tcp:</span><br><span class="line"> 582 active connections openings</span><br><span class="line"> 2 failed connection attempts</span><br><span class="line"> 25 connection resets received</span><br><span class="line"> Udp:</span><br><span class="line"> 1183 packets received</span><br><span class="line"> 4 packets to unknown port received.</span><br><span class="line"> .....</span><br></pre></td></tr></table></figure><p> <strong>显示 TCP 或 UDP 端口的统计信息 netstat -st 或 -su</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># netstat -st </span><br><span class="line"># netstat -su</span><br></pre></td></tr></table></figure><h3 id="2-4-在输出中显示PID和进程名称"><a href="#2-4-在输出中显示PID和进程名称" class="headerlink" title="2.4 在输出中显示PID和进程名称"></a>2.4 在输出中显示PID和进程名称</h3><p><code>netstat -p</code> 可以与其它开关一起使用，就可以添加 “PID/进程名称” 到 netstat 输出中，这样 <code>debugging</code> 的时候可以很方便的发现特定端口运行的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># netstat -pt</span><br><span class="line"> Active Internet connections (w&#x2F;o servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line"> tcp        1      0 ramesh-laptop.loc:47212 192.168.185.75:www        CLOSE_WAIT  2109&#x2F;firefox</span><br><span class="line"> tcp        0      0 ramesh-laptop.loc:52750 lax:www ESTABLISHED 2109&#x2F;firefox</span><br></pre></td></tr></table></figure><h3 id="2-5-在输出中不显示主机，端口和用户名-host-port-or-user"><a href="#2-5-在输出中不显示主机，端口和用户名-host-port-or-user" class="headerlink" title="2.5 在输出中不显示主机，端口和用户名(host,port or user)"></a>2.5 在输出中不显示主机，端口和用户名(host,port or user)</h3><p>当你不想让主机，端口和用户名显示，使用 netstat -n。将会使用数字代替那些名称。</p><p>同样可以加速输出，因为不用进行比对查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -an</span><br></pre></td></tr></table></figure><p>如果只是不想让这三个名称中的一个被显示，使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># netsat -a --numeric-ports</span><br><span class="line"># netsat -a --numeric-hosts</span><br><span class="line"># netsat -a --numeric-users</span><br></pre></td></tr></table></figure><h3 id="2-6-持续输出netstat信息"><a href="#2-6-持续输出netstat信息" class="headerlink" title="2.6 持续输出netstat信息"></a>2.6 持续输出netstat信息</h3><ul><li><code>netstat</code> 将每隔一秒输出网络信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># netstat -c</span><br><span class="line"> Active Internet connections (w&#x2F;o servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 ramesh-laptop.loc:36130 101-101-181-225.ama:www ESTABLISHED</span><br><span class="line"> tcp        1      1 ramesh-laptop.loc:52564 101.11.169.230:www      CLOSING</span><br><span class="line"> tcp        0      0 ramesh-laptop.loc:43758 server-101-101-43-2:www ESTABLISHED</span><br><span class="line"> tcp        1      1 ramesh-laptop.loc:42367 101.101.34.101:www      CLOSING</span><br><span class="line"> ^C</span><br></pre></td></tr></table></figure><h3 id="2-7-显示系统不支持的地址族（Address-Families）"><a href="#2-7-显示系统不支持的地址族（Address-Families）" class="headerlink" title="2.7 显示系统不支持的地址族（Address Families）"></a>2.7 显示系统不支持的地址族（<strong>Address Families</strong>）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat --verbose</span><br></pre></td></tr></table></figure><p>在输出的末尾，会有如下的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat: no support for &#96;AF IPX&#39; on this system.</span><br><span class="line">netstat: no support for &#96;AF AX25&#39; on this system.</span><br><span class="line">netstat: no support for &#96;AF X25&#39; on this system.</span><br><span class="line">netstat: no support for &#96;AF NETROM&#39; on this system.</span><br></pre></td></tr></table></figure><h3 id="2-8-显示核心路由信息"><a href="#2-8-显示核心路由信息" class="headerlink" title="2.8 显示核心路由信息"></a>2.8 显示核心路由信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -r</span><br><span class="line"> Kernel IP routing table</span><br><span class="line"> Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line"> 192.168.1.0     *               255.255.255.0   U         0 0          0 eth2</span><br><span class="line"> link-local      *               255.255.0.0     U         0 0          0 eth2</span><br><span class="line"> default         192.168.1.1     0.0.0.0         UG        0 0          0 eth2</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 使用 <code>netstat -rn</code> 显示数字格式，不查询主机名称。</p><h3 id="2-9-找出程序运行的端口"><a href="#2-9-找出程序运行的端口" class="headerlink" title="2.9 找出程序运行的端口"></a>2.9 找出程序运行的端口</h3><ul><li>并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># netstat -ap | grep ssh</span><br><span class="line"> tcp        1      0 dev-db:ssh           101.174.100.22:39213        CLOSE_WAIT  -</span><br><span class="line"> tcp        1      0 dev-db:ssh           101.174.100.22:57643        CLOSE_WAIT  -</span><br></pre></td></tr></table></figure><ul><li><strong>找出运行在指定端口的进程</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -an | grep &#39;:80&#39;</span><br></pre></td></tr></table></figure><h3 id="2-10-显示网络接口列表"><a href="#2-10-显示网络接口列表" class="headerlink" title="2.10 显示网络接口列表"></a>2.10 显示网络接口列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -i</span><br><span class="line"> Kernel Interface table</span><br><span class="line"> Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line"> eth0       1500 0         0      0      0 0             0      0      0      0 BMU</span><br><span class="line"> eth2       1500 0     26196      0      0 0         26883      6      0      0 BMRU</span><br><span class="line"> lo        16436 0         4      0      0 0             4      0      0      0 LRU</span><br></pre></td></tr></table></figure><ul><li>显示详细信息，像是 <code>ifconfig</code> 使用 <code>netstat -ie</code>:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># netstat -ie</span><br><span class="line"> Kernel Interface table</span><br><span class="line"> eth0      Link encap:Ethernet  HWaddr 00:10:40:11:11:11</span><br><span class="line"> UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line"> RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line"> TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line"> collisions:0 txqueuelen:1000</span><br><span class="line"> RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"> Memory:f6ae0000-f6b00000</span><br></pre></td></tr></table></figure><h3 id="2-11-IP和TCP分析"><a href="#2-11-IP和TCP分析" class="headerlink" title="2.11 IP和TCP分析"></a>2.11 IP和TCP分析</h3><p><strong>查看连接某服务端口最多的的IP地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wss8848@ubuntu:~$ netstat -nat | grep &quot;192.168.1.15:22&quot; |awk &#39;&#123;print $5&#125;&#39;|awk -F: &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -20</span><br><span class="line">18 221.136.168.36</span><br><span class="line">3 154.74.45.242</span><br><span class="line">2 78.173.31.236</span><br><span class="line">2 62.183.207.98</span><br><span class="line">2 192.168.1.14</span><br><span class="line">2 182.48.111.215</span><br><span class="line">2 124.193.219.34</span><br><span class="line">2 119.145.41.2</span><br><span class="line">2 114.255.41.30</span><br><span class="line">1 75.102.11.99</span><br></pre></td></tr></table></figure><p> <strong>TCP各种状态列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wss8848@ubuntu:~$ netstat -nat |awk &#39;&#123;print $6&#125;&#39;</span><br><span class="line">established)</span><br><span class="line">Foreign</span><br><span class="line">LISTEN</span><br><span class="line">TIME_WAIT</span><br><span class="line">ESTABLISHED</span><br><span class="line">TIME_WAIT</span><br><span class="line">SYN_SENT</span><br></pre></td></tr></table></figure><ul><li>先把状态全都取出来,然后使用<code>uniq -c</code>统计，之后再进行排序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wss8848@ubuntu:~$ netstat -nat |awk &#39;&#123;print $6&#125;&#39;|sort|uniq -c</span><br><span class="line">143 ESTABLISHED</span><br><span class="line">1 FIN_WAIT1</span><br><span class="line">1 Foreign</span><br><span class="line">1 LAST_ACK</span><br><span class="line">36 LISTEN</span><br><span class="line">6 SYN_SENT</span><br><span class="line">113 TIME_WAIT</span><br><span class="line">1 established)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  最后的命令如下:</span><br><span class="line">netstat -nat |awk &#39;&#123;print $6&#125;&#39;|sort|uniq -c|sort -rn</span><br><span class="line">分析access.log获得访问前10位的ip地址</span><br><span class="line">awk &#39;&#123;print $1&#125;&#39; access.log |sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-08-netstat详解&quot;&gt;&lt;a href=&quot;#Linux-08-netstat详解&quot; class=&quot;headerlink&quot; title=&quot;Linux-08-netstat详解&quot;&gt;&lt;/a&gt;Linux-08-netstat详解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Netstat&lt;/code&gt; 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (&lt;code&gt;Interface Statistics&lt;/code&gt;)，&lt;code&gt;masquerade&lt;/code&gt; 连接，多播成员 (&lt;code&gt;Multicast Memberships&lt;/code&gt;) 等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;输出信息含义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行&lt;code&gt;netstat&lt;/code&gt;后，其输出结果为&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Active Internet connections (w/o servers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Proto Recv-Q Send-Q Local Address Foreign Address State&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Active UNIX domain sockets (w/o servers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Proto RefCnt Flags Type State I-Node Path&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unix 1 [ ] STREAM CONNECTED 16178 @000000dd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unix 1 [ ] STREAM CONNECTED 16176 @000000dc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unix 9 [ ] DGRAM 5292 /dev/&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unix 1 [ ] STREAM CONNECTED 16182 @000000df&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;从整体上看，&lt;code&gt;netstat&lt;/code&gt;的输出结果可以分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个是&lt;code&gt;Active Internet connections&lt;/code&gt;，称为有源&lt;code&gt;TCP&lt;/code&gt;连接，其中”&lt;code&gt;Recv-Q&lt;/code&gt;“和”&lt;code&gt;Send-Q&lt;/code&gt;“指&lt;code&gt;%0A&lt;/code&gt;的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另一个是&lt;code&gt;Active UNIX domain sockets&lt;/code&gt;，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其中 ： &lt;code&gt;Proto&lt;/code&gt;显示连接使用的协议,&lt;code&gt;RefCnt&lt;/code&gt;表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Linux网络管理" scheme="http://zhuuu.work/tags/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux-01-网络IO</title>
    <link href="http://zhuuu.work/2020/08/18/Linux/Linux-01-%E7%BD%91%E7%BB%9CIO/"/>
    <id>http://zhuuu.work/2020/08/18/Linux/Linux-01-%E7%BD%91%E7%BB%9CIO/</id>
    <published>2020-08-18T07:52:53.000Z</published>
    <updated>2020-09-13T11:01:55.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-01-网络IO"><a href="#Linux-01-网络IO" class="headerlink" title="Linux-01-网络IO"></a>Linux-01-网络IO</h1><p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1-用户空间与内核空间"><a href="#1-用户空间与内核空间" class="headerlink" title="1. 用户空间与内核空间"></a>1. 用户空间与内核空间</h3><ul><li>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，<strong>它的寻址空间（虚拟存储空间）为4G（2的32次方）</strong>。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</li><li><strong>针对linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），供内核使用，称为内核空间，</strong></li><li><strong>而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间。</strong></li></ul><h3 id="2-进程切换"><a href="#2-进程切换" class="headerlink" title="2. 进程切换"></a>2. 进程切换</h3><ul><li><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol></li></ul><h3 id="3-进程阻塞"><a href="#3-进程阻塞" class="headerlink" title="3. 进程阻塞"></a>3. 进程阻塞</h3><ul><li>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</li></ul><h3 id="4-文件描述符fd"><a href="#4-文件描述符fd" class="headerlink" title="4. 文件描述符fd"></a>4. 文件描述符fd</h3><ul><li>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</li><li><strong>文件描述符在形式上是一个非负整数。实际上，它是一个索引值</strong>，指向<strong>内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</li></ul><h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><ul><li><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<br><strong>1. 等待数据准备 (Waiting for the data to be ready)</strong><br><strong>2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</strong></p></li><li><p><strong>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</strong><br><strong>- 阻塞 I/O（blocking IO）</strong><br><strong>- 非阻塞 I/O（nonblocking IO）</strong><br><strong>- I/O 多路复用（ IO multiplexing）</strong><br><strong>- 信号驱动 I/O（ signal driven IO）</strong><br><strong>- 异步 I/O（asynchronous IO）</strong></p></li></ul><p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><h3 id="1-阻塞-I-O（blocking-IO）"><a href="#1-阻塞-I-O（blocking-IO）" class="headerlink" title="1. 阻塞 I/O（blocking IO）"></a>1. 阻塞 I/O（blocking IO）</h3><ul><li>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-162629646.png" alt="mark"></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。</p><p>这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h3 id="2-非阻塞-I-O（nonblocking-IO）"><a href="#2-非阻塞-I-O（nonblocking-IO）" class="headerlink" title="2. 非阻塞 I/O（nonblocking IO）"></a>2. 非阻塞 I/O（nonblocking IO）</h3><ul><li>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-163037584.png" alt="mark"></p><ul><li>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。</li><li>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。</li><li>用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</li></ul><blockquote><p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p></blockquote><h3 id="3-异步-I-O（asynchronous-IO）"><a href="#3-异步-I-O（asynchronous-IO）" class="headerlink" title="3. 异步 I/O（asynchronous IO）"></a>3. 异步 I/O（asynchronous IO）</h3><ul><li>Linux下的asynchronous IO其实用得很少。先看一下它的流程：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-164148525.png" alt="mark"></p><h3 id="4-I-O-多路复用（-IO-multiplexing）"><a href="#4-I-O-多路复用（-IO-multiplexing）" class="headerlink" title="4. I/O 多路复用（ IO multiplexing）"></a>4. I/O 多路复用（ IO multiplexing）</h3><ul><li><code>IO multiplexing</code>就是我们说的<code>select，poll，epoll</code>，有些地方也称这种IO方式为<code>event driven IO select/epoll</code>的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是<code>select，poll，epoll</code>这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-165609923.png" alt="mark"></p><ul><li><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</li></ul><ul><li><p>所以，I/O 多路复用的特点是<strong>通过一种机制一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p></li><li><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p></li><li><p>在IO multiplexing Model中，实际中，对于每一个<code>socket</code>，一般都设置成为<code>non-blocking</code>，但是，如上图所示，整个用户的<code>process</code>其实是一直被<code>block</code>的。只不过<code>process</code>是被<code>select</code>这个函数<code>block</code>，而不是被<code>socket IO</code>给<code>block</code>。</p></li></ul><h2 id="select-poll-epoll-详解"><a href="#select-poll-epoll-详解" class="headerlink" title="select poll epoll 详解"></a>select poll epoll 详解</h2><p><strong>总结的不错的博客:</strong> <a href="https://blog.csdn.net/jiange_zh/article/details/50811553" target="_blank" rel="noopener">https://blog.csdn.net/jiange_zh/article/details/50811553</a></p><p>(1)select==&gt;时间复杂度O(n)</p><ul><li>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200830/142733029.png" alt="mark"></p><p>(2)poll==&gt;时间复杂度O(n)</p><ul><li>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</li></ul><p>(3)epoll==&gt;时间复杂度O(1)</p><ul><li><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200830/142834510.png" alt="mark"></p><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 </p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><p><strong>epoll的工作方式</strong></p><p>epoll的两种工作方式：<strong>1.水平触发（LT）2.边缘触发（ET）</strong> </p><p><strong>LT模式：</strong></p><ul><li>若就绪的事件一次没有处理完要做的事件，就会一直去处理。</li><li>即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 </li></ul><p><strong>ET模式：</strong></p><ul><li>就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。</li><li>而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。 </li></ul><p>由此可见：ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。<br>注意：ET模式只支持非阻塞的读写：为了保证数据的完整性。</p><p><strong>总结：</strong></p><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-blocking和non-blocking的区别"><a href="#1-blocking和non-blocking的区别" class="headerlink" title="1. blocking和non-blocking的区别"></a>1. blocking和non-blocking的区别</h3><ul><li>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</li></ul><h3 id="2-synchronous-IO和asynchronous-IO的区别"><a href="#2-synchronous-IO和asynchronous-IO的区别" class="headerlink" title="2. synchronous IO和asynchronous IO的区别"></a>2. synchronous IO和asynchronous IO的区别</h3><ul><li>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</li></ul><p><strong>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</strong></p><ul><li><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。<strong>但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</strong></p></li><li><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-01-网络IO&quot;&gt;&lt;a href=&quot;#Linux-01-网络IO&quot; class=&quot;headerlink&quot; title=&quot;Linux-01-网络IO&quot;&gt;&lt;/a&gt;Linux-01-网络IO&lt;/h1&gt;&lt;p&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="多路复用" scheme="http://zhuuu.work/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux-07-内存管理</title>
    <link href="http://zhuuu.work/2020/08/18/Linux/Linux-07-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/08/18/Linux/Linux-07-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-18T03:52:53.000Z</published>
    <updated>2020-09-21T14:36:28.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-07-内存管理"><a href="#Linux-07-内存管理" class="headerlink" title="Linux-07-内存管理"></a>Linux-07-内存管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>操作系统内存管理：</strong>总的来说，操作系统内存管理包括<strong>物理内存管理</strong>和<strong>虚拟内存管理</strong>。</li></ul><p><strong>物理内存管理：</strong></p><ul><li>包括程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式（分页、分段、段页式）。</li></ul><p><strong>虚拟内存管理：</strong></p><ul><li>虚拟内存管理包括虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。</li></ul><a id="more"></a><h2 id="1-计算机存储体系"><a href="#1-计算机存储体系" class="headerlink" title="1. 计算机存储体系"></a>1. 计算机存储体系</h2><ul><li>内存是计算机很重要的一个资源，因为<strong>程序只有被加载到内存中才可以运行</strong>；此外，CPU所需要的指令与数据也都是来自内存的。可以说，内存是影响计算机性能的一个很重要的因素。</li></ul><h3 id="1-1-分层存储器体系"><a href="#1-1-分层存储器体系" class="headerlink" title="1.1 分层存储器体系"></a>1.1 分层存储器体系</h3><ul><li><p>在介绍内存管理的细节前，先要了解一下分层存储器体系：</p><ul><li>大部分的计算机都有一个存储器层次结构，即少量的非常快速、昂贵、易变的高速缓存(cache)；若干兆字节的中等速度、中等价格、易变的主存储器(RAM)；数百兆或数千兆的低速、廉价、不易变的磁盘。这些资源的合理使用与否直接关系着系统的效率。<ul><li>CPU缓存（Cache Memory）：是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。缓存的出现主要是为了解决CPU运算速度与内存 读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据到来或把数据写入内存。</li></ul></li></ul></li><li><p>计算机是一种数据处理设备，它由CPU和内存以及外部设备组成。CPU负责数据处理，内存负责存储，外部设备负责数据的输入和输出，它们之间通过总线连接在一起。</p></li><li><p>CPU内部主要由控制器、运算器和寄存器组成。控制器负责指令的读取和调度，运算器负责指令的运算执行，寄存器负责数据的存储，它们之间通过CPU内的总线连接在一起。</p></li><li><p>每个外部设备(例如：显示器、硬盘、键盘、鼠标、网卡等等)则是由外设控制器、I/O端口、和输入输出硬件组成。</p><ul><li>外设控制器负责设备的控制和操作，I/O端口负责数据的临时存储，输入输出硬件则负责具体的输入输出，它们间也通过外部设备内的总线连接在一起。</li></ul></li></ul><p><strong>在这套设计思想(冯.诺依曼体系架构)里面: 总是有一部分负责控制、一部分负责执行、一部分则负责存储，它之间进行交互以及接口通信则总是通过总线来完成。</strong></p><ul><li>这种设计思路一样的可以应用在我们的软件设计体系里面：组件和组件之间通信通过事件的方式来进行解耦处理，而一个组件内部同样也需要明确好各个部分的职责(一部分负责调度控制、一部分负责执行实现、一部分负责数据存储)。</li></ul><h3 id="1-2-计算存储的层次结构"><a href="#1-2-计算存储的层次结构" class="headerlink" title="1.2 计算存储的层次结构"></a>1.2 计算存储的层次结构</h3><ul><li>当前技术没有能够提供这样的存储器，因此大部分的计算机都有一个存储器层次结构:<ul><li>高速缓存(cache): 少量的非常快速、昂贵、易变的高速缓存(cache)；</li><li>主存储器(RAM): 若干兆字节的中等速度、中等价格、易变的主存储器(RAM)；</li><li>磁盘: 数百兆或数千兆的低速、廉价、不易变的磁盘。</li></ul></li></ul><p>这些资源的合理使用与否直接关系着系统的效率。</p><h2 id="2-内存使用的演化"><a href="#2-内存使用的演化" class="headerlink" title="2. 内存使用的演化"></a>2. 内存使用的演化</h2><h3 id="2-1-没有内存的年代"><a href="#2-1-没有内存的年代" class="headerlink" title="2.1 没有内存的年代"></a>2.1 没有内存的年代</h3><ul><li>在早些的操作系统中，并没有引入内存抽象的概念。<strong>程序直接访问和操作的都是物理内存</strong>，内存的管理也非常简单，除去操作系统所用的内存之外，全部给用户程序使用，想怎么折腾都行，只要别超出最大的容量。比如当执行如下指令时：</li></ul><p><code>mov reg1,1000</code></p><p><strong>1、无内存抽象存在的问题：</strong></p><p>这条指令会毫无想象力的将物理地址1000中的内容赋值给寄存器。不难想象，这种内存操作方式使得操作系统中存在多进程变得完全不可能，比如MS-DOS，你必须执行完一条指令后才能接着执行下一条。如果是多进程的话，由于直接操作物理内存地址，当一个进程给内存地址1000赋值后，另一个进程也同样给内存地址赋值，那么第二个进程对内存的赋值会覆盖第一个进程所赋的值，这回造成两条进程同时崩溃。</p><p><strong>带来两个问题：</strong></p><ol><li>用户程序可以访问任意内存，容易破坏操作系统，造成崩溃</li><li>同时运行多个程序特别困难</li></ol><p>随着计算机技术发展，要求操作系统支持多进程的需求，所谓多进程，并不需要同时运行这些进程，只要它们都处于 ready 状态，操作系统快速地在它们之间切换，就能达到同时运行的假象。每个进程都需要内存，Context Switch 时，之前内存里的内容怎么办？简单粗暴的方式就是先 dump 到磁盘上，然后再从磁盘上 restore 之前 dump 的内容（如果有的话），但效果并不好，太慢了！</p><h3 id="2-2-内存抽象：地址空间"><a href="#2-2-内存抽象：地址空间" class="headerlink" title="2.2 内存抽象：地址空间"></a>2.2 内存抽象：地址空间</h3><ul><li>那怎么才能不慢呢？把进程对应的内存依旧留在物理内存中，需要的时候就切换到特定的区域。这就涉及到了内存的保护机制，毕竟进程之间可以随意读取、写入内容就乱套了，非常不安全。因此操作系统需要对物理内存做一层抽象，也就是「地址空间」(Address Space)，一个进程的地址空间包含了该进程所有相关内存，比如 code / stack / heap。一个 16 KB 的地址空间可能长这样：</li></ul><p>当程序运行时，heap 和 stack 共用中间 free 的区域，当然这只是 OS 层面的抽象。比如下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line"> </span><br><span class="line">x &#x3D; x + 3; &#x2F;&#x2F; this is the line of code we are interested in</span><br></pre></td></tr></table></figure><p>变成汇编指令后，大概是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">128: movl 0x0(%ebx), %eax  ;load 0+ebx into eax</span><br><span class="line">132: addl $0x03, %eax ;add 3 to eax register</span><br><span class="line">135: movl %eax, 0x0(%ebx) ;store eax back to mem</span><br></pre></td></tr></table></figure><ul><li>最前面的是 PC (Program Counter)，用来表示当前 code 的索引，比如 CPU 执行到 128 时，进行了 Context Switch（上下文切换），那么在 Switch 回来后，还可以接着从 132 开始执行（当然需要先把 PC 存起来）。之后的就是汇编代码，告诉 CPU 该如何操作。</li></ul><ul><li><p><strong>基址寄存器与界限寄存器可以简单的动态重定位：</strong>每个内存地址送到内存之前，都会自动加上基址寄存器的内容.</p><ul><li><p>从 32KB 处作为开始，48KB 作为结束。那 32 / 48 可不可以动态设置呢，只要在 CPU 上整两个寄存器，<strong>基址寄存器</strong>base 和 <strong>界限寄存器</strong>bounds 就可以了，base 指明从哪里开始，bounds 指定哪里是边界。 因此真实物理地址和虚拟地址之间的关系是：</p></li><li><pre><code>physical address = virtual address + base</code></pre></li><li><p>有时，CPU 上用来做内存地址翻译的也会被叫做「内存管理单元 MMU」(Memory Management Unit)，随着功能越来越强大，MMU 也会变得越来越复杂。</p></li><li><p>base and bounds 这种做法最大的问题在于空间浪费，Stack 和 Heap 中间有一块 free space，即使没有用，也被占着，那如何才能解放这块区域呢，进入虚拟内存。</p></li></ul></li></ul><h2 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3. 虚拟内存"></a>3. 虚拟内存</h2><ul><li>虚拟内存是现代操作系统普遍使用的一种技术。前面所讲的<strong>抽象满足了多进程的要求，但很多情况下，现有内存无法满足仅仅一个大进程的内存要求</strong>。物理内存不够用的情况下，如何解决呢？<ul><li><strong>覆盖overlays：</strong>在早期的操作系统曾使用覆盖技术来解决这个问题，将一个程序分为多个块，基本思想是先将块0加入内存，块0执行完后，将块1加入内存。依次往复，这个解决方案最大的问题是需要程序员去程序进行分块，这是一个费时费力让人痛苦不堪的过程。后来这个解决方案的修正版就是虚拟内存。</li><li><strong>交换swapping：</strong>可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），或读人保存在外存中而处于就绪状态的程序。</li><li><strong>虚拟内存：</strong>虚拟内存的基本思想是，每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为<strong>页</strong>(Page).每个页都是一段连续的地址。对于进程来看,逻辑上貌似有很多内存空间，其中<strong>一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)</strong>，还有一些没加载在内存中的对应在硬盘上。</li></ul></li></ul><h2 id="4-物理内存：连续分配存储管理方式"><a href="#4-物理内存：连续分配存储管理方式" class="headerlink" title="4. 物理内存：连续分配存储管理方式"></a>4. 物理内存：连续分配存储管理方式</h2><ul><li>连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式。</li></ul><h3 id="4-1-单一连续存储管理"><a href="#4-1-单一连续存储管理" class="headerlink" title="4.1 单一连续存储管理"></a>4.1 单一连续存储管理</h3><ul><li>在这种管理方式中，内存被分为两个区域：系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。其特点是，最简单，适用于单用户、单任务的操作系统。CP／M和 DOS 2．0以下就是采用此种方式。这种方式的最大优点就是易于管理。但也存在着一些问题和不足之处，例如对要求内存空间少的程序，造成内存浪费；程序全部装入，使得很少使用的程序部分也占用—定数量的内存。</li></ul><h3 id="4-2-分区式存储管理"><a href="#4-2-分区式存储管理" class="headerlink" title="4.2 分区式存储管理"></a>4.2 分区式存储管理</h3><ul><li><p>为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。</p></li><li><p>分区式存储管理引人了两个新的问题：内碎片和外碎片。</p></li><li><p>内碎片是占用分区内未被利用的空间，外碎片是占用分区之间难以利用的空闲分区(通常是小空闲分区)。</p></li><li><p>为实现分区式存储管理，操作系统应维护的数据结构为分区表或分区链表。表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。</p></li><li><p>分区式存储管理常采用的一项技术就是<strong><em>\</em>内存紧缩(compaction)。**</strong></p></li></ul><p><a href="https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param</a></p><p>未完待续</p><p><strong>参考博客 ：</strong> <a href="https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-07-内存管理&quot;&gt;&lt;a href=&quot;#Linux-07-内存管理&quot; class=&quot;headerlink&quot; title=&quot;Linux-07-内存管理&quot;&gt;&lt;/a&gt;Linux-07-内存管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作系统内存管理：&lt;/strong&gt;总的来说，操作系统内存管理包括&lt;strong&gt;物理内存管理&lt;/strong&gt;和&lt;strong&gt;虚拟内存管理&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;物理内存管理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包括程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式（分页、分段、段页式）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存管理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟内存管理包括虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper-01-脑裂问题</title>
    <link href="http://zhuuu.work/2020/08/17/Zookeeper/ZooKeeper-01-%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/08/17/Zookeeper/ZooKeeper-01-%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-17T09:38:38.000Z</published>
    <updated>2020-09-25T07:08:03.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZooKeeper-01-脑裂问题"><a href="#ZooKeeper-01-脑裂问题" class="headerlink" title="ZooKeeper-01-脑裂问题"></a>ZooKeeper-01-脑裂问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是分布式系统中一个很实际的问题，书上说的不是很详细，整理总结一下。</li></ul><h2 id="1-脑裂和假死"><a href="#1-脑裂和假死" class="headerlink" title="1. 脑裂和假死"></a>1. 脑裂和假死</h2><h3 id="1-1-脑裂"><a href="#1-1-脑裂" class="headerlink" title="1.1 脑裂"></a>1.1 脑裂</h3><ul><li>官方定义：当一个集群的不同部分在同一时间都认为自己是活动的时候，我们就可以将这个现象称为脑裂症状。</li><li>通俗的说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。<strong>那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。</strong></li><li>但是<strong>如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。</strong>于是 cluster 里面就会有两个 master。</li></ul><p><strong>举例：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/223556058.png" alt="mark"></p><a id="more"></a><ul><li><p>UserA和UserB分别将自己的信息注册在RouterA和RouterB中。RouterA和RouterB使用数据同步（2PC），来同步信息。那么当UserA想要向UserB发送一个消息的时候，需要现在RouterA中查询出UserA到UserB的消息路由路径，然后再交付给相应的路径进行路由。</p></li><li><p>当脑裂发生的时候，相当RouterA和RouterB直接的联系丢失了，RouterA认为整个系统中只有它一个Router，RouterB也是这样认为的。那么相当于RouterA中没有UserB的信息，RouterB中没有UserA的信息了，此时UserA再发送消息给UserB的时候，RouterA会认为UserB已经离线了，然后将该信息进行离线持久化，这样整个网络的路由是不是就乱掉了。</p></li><li><p><strong>对于Zookeeper来说有一个很重要的问题，就是到底是根据一个什么样的情况来判断一个节点死亡down掉了。</strong></p><ul><li>在分布式系统中这些都是有监控者来判断的，但是监控者也很难判定其他的节点的状态</li><li><strong>唯一一个可靠的途径就是心跳</strong></li><li><strong>Zookeeper也是使用心跳来判断客户端是否仍然活着</strong>，但是使用心跳机制来判断节点的存活状态也带来了假死问题。</li></ul></li></ul><h3 id="1-2-假死"><a href="#1-2-假死" class="headerlink" title="1.2 假死"></a>1.2 假死</h3><ul><li><p><code>ZooKeeper</code>每个节点都尝试注册一个象征master的临时节点，其他没有注册成功的则成为slaver，并且通过watch机制监控着master所创建的临时节点，<code>Zookeeper</code>通过内部心跳机制来确定master的状态，一旦<code>master</code>出现意外<code>Zookeeper</code>能很快获悉并且通知其他的slaver，其他<code>slaver</code>在之后作出相关反应。这样就完成了一个切换。</p></li><li><p>这种模式也是比较通用的模式，基本大部分都是这样实现的，但是这里面有个很严重的问题，如果注意不到会导致短暂的时间内系统出现脑裂，因为心跳出现超时可能是master挂了，但是也可能是master，zookeeper之间网络出现了问题，也同样可能导致。</p></li><li><p>这种情况就是假死，master并未死掉，但是与ZooKeeper之间的网络出现问题导致Zookeeper认为其挂掉了然后通知其他节点进行切换，这样slaver中就有一个成为了master，但是原本的master并未死掉，这时候client也获得master切换的消息，但是仍然会有一些延时</p></li><li><p>zookeeper需要通讯需要一个一个通知，这时候整个系统就很混乱可能有一部分client已经通知到了连接到新的master上去了，有的client仍然连接在老的master上如果同时有两个client需要对master的同一个数据更新并且刚好这两个client此刻分别连接在新老的master上，就会出现很严重问题。</p></li></ul><h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><ul><li><strong>假死：</strong>由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着。</li><li><strong>脑裂：</strong>由于假死会发起新的master选举，选举出一个新的master，但旧的master网络又通了，导致出现了两个master ，有的客户端连接到老的master 有的客户端链接到新的master。</li></ul><h2 id="2-Zookeeper-解决方案"><a href="#2-Zookeeper-解决方案" class="headerlink" title="2. Zookeeper 解决方案"></a>2. Zookeeper 解决方案</h2><ul><li>要解决Split-Brain的问题，一般有3种方式:<ul><li>Quorums（ˈkwôrəm 法定人数） ：比如3个节点的集群，Quorums = 2, 也就是说集群可以容忍1个节点失效，这时候还能选举出1个lead，集群还可用。比如4个节点的集群，它的Quorums = 3，Quorums要超过3，相当于集群的容忍度还是1，如果2个节点失效，那么整个集群还是无效的</li><li>Redundant communications：<strong>冗余通信的方式</strong>，集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。</li><li>Fencing, <strong>共享资源的方式</strong>：比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是Leader，看不到共享资源的，就不在集群中。</li></ul></li></ul><p><strong>ZooKeeper默认采用了Quorums这种方式</strong>，即只有集群中超过半数节点投票才能选举出Leader。这样的方式可以确保leader的唯一性,要么选出唯一的一个leader,要么选举失败。在ZooKeeper中Quorums有2个作用：</p><ul><li>集群中最少的节点数用来<strong>选举Leader保证集群可用</strong>：通知客户端数据已经安全保存前集群中最少数量的节点数已经保存了该数据。一旦这些节点保存了该数据，客户端将被通知已经安全保存了，可以继续其他任务。而集群中剩余的节点将会最终也保存了该数据。</li><li>假设某个leader假死，其余的followers选举出了一个新的leader。这时，旧的leader复活并且仍然认为自己是leader，这个时候它向其他followers发出写请求也是会被拒绝的。因为每当新leader产生时，会生成一个epoch，这个epoch是递增的，followers如果确认了新的leader存在，知道其epoch，就会拒绝epoch小于现任leader epoch的所有请求。那有没有follower不知道新的leader存在呢，有可能，但肯定不是大多数，否则新leader无法产生。Zookeeper的写也遵循quorum机制，因此，得不到大多数支持的写是无效的，旧leader即使各种认为自己是leader，依然没有什么作用。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>总结一下就是，通过Quorums机制来防止脑裂和假死</li><li>当leader挂掉之后，可以重新选举出新的leader节点使整个集群达成一致</li><li>当出现假死现象时，通过epoch大小来拒绝旧的leader发起的请求</li><li>在前面也已经讲到过，这个时候，重新恢复通信的老的leader节点会进入恢复模式，与新的leader节点做数据同步，perfect。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ZooKeeper-01-脑裂问题&quot;&gt;&lt;a href=&quot;#ZooKeeper-01-脑裂问题&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper-01-脑裂问题&quot;&gt;&lt;/a&gt;ZooKeeper-01-脑裂问题&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这是分布式系统中一个很实际的问题，书上说的不是很详细，整理总结一下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-脑裂和假死&quot;&gt;&lt;a href=&quot;#1-脑裂和假死&quot; class=&quot;headerlink&quot; title=&quot;1. 脑裂和假死&quot;&gt;&lt;/a&gt;1. 脑裂和假死&lt;/h2&gt;&lt;h3 id=&quot;1-1-脑裂&quot;&gt;&lt;a href=&quot;#1-1-脑裂&quot; class=&quot;headerlink&quot; title=&quot;1.1 脑裂&quot;&gt;&lt;/a&gt;1.1 脑裂&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;官方定义：当一个集群的不同部分在同一时间都认为自己是活动的时候，我们就可以将这个现象称为脑裂症状。&lt;/li&gt;
&lt;li&gt;通俗的说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。&lt;strong&gt;那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;但是&lt;strong&gt;如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。&lt;/strong&gt;于是 cluster 里面就会有两个 master。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;举例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/223556058.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Zookeeper" scheme="http://zhuuu.work/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式-脑裂问题</title>
    <link href="http://zhuuu.work/2020/08/17/distributed/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/08/17/distributed/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-17T09:38:38.000Z</published>
    <updated>2020-09-25T07:08:20.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式-脑裂问题"><a href="#分布式-脑裂问题" class="headerlink" title="分布式-脑裂问题"></a>分布式-脑裂问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是分布式系统中一个很实际的问题，书上说的不是很详细，整理总结一下。</li></ul><h2 id="1-脑裂和假死"><a href="#1-脑裂和假死" class="headerlink" title="1. 脑裂和假死"></a>1. 脑裂和假死</h2><h3 id="1-1-脑裂"><a href="#1-1-脑裂" class="headerlink" title="1.1 脑裂"></a>1.1 脑裂</h3><ul><li>官方定义：当一个集群的不同部分在同一时间都认为自己是活动的时候，我们就可以将这个现象称为脑裂症状。</li><li>通俗的说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。</li><li>但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</li></ul><p><strong>举例：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/223556058.png" alt="mark"></p><a id="more"></a><ul><li><p>UserA和UserB分别将自己的信息注册在RouterA和RouterB中。RouterA和RouterB使用数据同步（2PC），来同步信息。那么当UserA想要向UserB发送一个消息的时候，需要现在RouterA中查询出UserA到UserB的消息路由路径，然后再交付给相应的路径进行路由。</p></li><li><p>当脑裂发生的时候，相当RouterA和RouterB直接的联系丢失了，RouterA认为整个系统中只有它一个Router，RouterB也是这样认为的。那么相当于RouterA中没有UserB的信息，RouterB中没有UserA的信息了，此时UserA再发送消息给UserB的时候，RouterA会认为UserB已经离线了，然后将该信息进行离线持久化，这样整个网络的路由是不是就乱掉了。</p></li><li><p><strong>对于Zookeeper来说有一个很重要的问题，就是到底是根据一个什么样的情况来判断一个节点死亡down掉了。</strong></p><ul><li>在分布式系统中这些都是有监控者来判断的，但是监控者也很难判定其他的节点的状态</li><li><strong>唯一一个可靠的途径就是心跳</strong></li><li><strong>Zookeeper也是使用心跳来判断客户端是否仍然活着</strong>，但是使用心跳机制来判断节点的存活状态也带来了假死问题。</li></ul></li></ul><h3 id="1-2-假死"><a href="#1-2-假死" class="headerlink" title="1.2 假死"></a>1.2 假死</h3><ul><li><p><code>ZooKeeper</code>每个节点都尝试注册一个象征master的临时节点，其他没有注册成功的则成为slaver，并且通过watch机制监控着master所创建的临时节点，<code>Zookeeper</code>通过内部心跳机制来确定master的状态，一旦<code>master</code>出现意外<code>Zookeeper</code>能很快获悉并且通知其他的slaver，其他<code>slaver</code>在之后作出相关反应。这样就完成了一个切换。</p></li><li><p>这种模式也是比较通用的模式，基本大部分都是这样实现的，但是这里面有个很严重的问题，如果注意不到会导致短暂的时间内系统出现脑裂，因为心跳出现超时可能是master挂了，但是也可能是master，zookeeper之间网络出现了问题，也同样可能导致。</p></li><li><p>种情况就是假死，master并未死掉，但是与ZooKeeper之间的网络出现问题导致Zookeeper认为其挂掉了然后通知其他节点进行切换，这样slaver中就有一个成为了master，但是原本的master并未死掉，这时候client也获得master切换的消息，但是仍然会有一些延时</p></li><li><p>zookeeper需要通讯需要一个一个通知，这时候整个系统就很混乱可能有一部分client已经通知到了连接到新的master上去了，有的client仍然连接在老的master上如果同时有两个client需要对master的同一个数据更新并且刚好这两个client此刻分别连接在新老的master上，就会出现很严重问题。</p></li></ul><h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><ul><li><strong>假死：</strong>由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着。</li><li><strong>脑裂：</strong>由于假死会发起新的master选举，选举出一个新的master，但旧的master网络又通了，导致出现了两个master ，有的客户端连接到老的master 有的客户端链接到新的master。</li></ul><h2 id="2-Zookeeper-解决方案"><a href="#2-Zookeeper-解决方案" class="headerlink" title="2. Zookeeper 解决方案"></a>2. Zookeeper 解决方案</h2><ul><li>要解决Split-Brain的问题，一般有3种方式:<ul><li>Quorums（ˈkwôrəm 法定人数） ：比如3个节点的集群，Quorums = 2, 也就是说集群可以容忍1个节点失效，这时候还能选举出1个lead，集群还可用。比如4个节点的集群，它的Quorums = 3，Quorums要超过3，相当于集群的容忍度还是1，如果2个节点失效，那么整个集群还是无效的</li><li>Redundant communications：<strong>冗余通信的方式</strong>，集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。</li><li>Fencing, <strong>共享资源的方式</strong>：比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是Leader，看不到共享资源的，就不在集群中。</li></ul></li></ul><p><strong>ZooKeeper默认采用了Quorums这种方式</strong>，即只有集群中超过半数节点投票才能选举出Leader。这样的方式可以确保leader的唯一性,要么选出唯一的一个leader,要么选举失败。在ZooKeeper中Quorums有2个作用：</p><ul><li>集群中最少的节点数用来<strong>选举Leader保证集群可用</strong>：通知客户端数据已经安全保存前集群中最少数量的节点数已经保存了该数据。一旦这些节点保存了该数据，客户端将被通知已经安全保存了，可以继续其他任务。而集群中剩余的节点将会最终也保存了该数据。</li><li>假设某个leader假死，其余的followers选举出了一个新的leader。这时，旧的leader复活并且仍然认为自己是leader，这个时候它向其他followers发出写请求也是会被拒绝的。因为每当新leader产生时，会生成一个epoch，这个epoch是递增的，followers如果确认了新的leader存在，知道其epoch，就会拒绝epoch小于现任leader epoch的所有请求。那有没有follower不知道新的leader存在呢，有可能，但肯定不是大多数，否则新leader无法产生。Zookeeper的写也遵循quorum机制，因此，得不到大多数支持的写是无效的，旧leader即使各种认为自己是leader，依然没有什么作用。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>总结一下就是，通过Quorums机制来防止脑裂和假死</li><li>当leader挂掉之后，可以重新选举出新的leader节点使整个集群达成一致</li><li>当出现假死现象时，通过epoch大小来拒绝旧的leader发起的请求</li><li>在前面也已经讲到过，这个时候，重新恢复通信的老的leader节点会进入恢复模式，与新的leader节点做数据同步，perfect。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式-脑裂问题&quot;&gt;&lt;a href=&quot;#分布式-脑裂问题&quot; class=&quot;headerlink&quot; title=&quot;分布式-脑裂问题&quot;&gt;&lt;/a&gt;分布式-脑裂问题&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这是分布式系统中一个很实际的问题，书上说的不是很详细，整理总结一下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-脑裂和假死&quot;&gt;&lt;a href=&quot;#1-脑裂和假死&quot; class=&quot;headerlink&quot; title=&quot;1. 脑裂和假死&quot;&gt;&lt;/a&gt;1. 脑裂和假死&lt;/h2&gt;&lt;h3 id=&quot;1-1-脑裂&quot;&gt;&lt;a href=&quot;#1-1-脑裂&quot; class=&quot;headerlink&quot; title=&quot;1.1 脑裂&quot;&gt;&lt;/a&gt;1.1 脑裂&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;官方定义：当一个集群的不同部分在同一时间都认为自己是活动的时候，我们就可以将这个现象称为脑裂症状。&lt;/li&gt;
&lt;li&gt;通俗的说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。&lt;/li&gt;
&lt;li&gt;但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;举例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/223556058.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Zookeeper" scheme="http://zhuuu.work/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-XX-Mysql面试总结</title>
    <link href="http://zhuuu.work/2020/08/17/Mysql/Mysql-XX-Mysql%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://zhuuu.work/2020/08/17/Mysql/Mysql-XX-Mysql%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-17T08:02:27.000Z</published>
    <updated>2020-08-17T01:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-XX-Mysql面试总结"><a href="#Mysql-XX-Mysql面试总结" class="headerlink" title="Mysql-XX-Mysql面试总结"></a>Mysql-XX-Mysql面试总结</h1><p><a href="https://www.jianshu.com/p/c189439fb32e" target="_blank" rel="noopener">https://www.jianshu.com/p/c189439fb32e</a> <strong>一定要看</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql-XX-Mysql面试总结&quot;&gt;&lt;a href=&quot;#Mysql-XX-Mysql面试总结&quot; class=&quot;headerlink&quot; title=&quot;Mysql-XX-Mysql面试总结&quot;&gt;&lt;/a&gt;Mysql-XX-Mysql面试总结&lt;/h1&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux-06-多路复用</title>
    <link href="http://zhuuu.work/2020/08/17/Linux/Linux-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://zhuuu.work/2020/08/17/Linux/Linux-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2020-08-17T03:52:53.000Z</published>
    <updated>2020-09-26T10:59:26.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-06-多路复用"><a href="#Linux-06-多路复用" class="headerlink" title="Linux-06-多路复用"></a>Linux-06-多路复用</h1><h2 id="1-BIO-的缺陷"><a href="#1-BIO-的缺陷" class="headerlink" title="1. BIO 的缺陷"></a>1. BIO 的缺陷</h2><ul><li>BIO中的B 是 <code>Blocking</code> 的阻塞的意思</li><li>作为<strong>服务端开发</strong>，使用<code>ServerSocket</code> 绑定端口号之后会监听该端口,等待<code>accept</code>事件，<code>accept</code>是会阻塞当前线程</li><li>当我们收到<code>accept</code>事件的时候，程序就会拿到客户端与当前服务端连接的<code>Socket</code></li><li>针对这个<code>socket</code>我们可以进行读写，但是呢，这个<code>socket</code>读写都是会阻塞当前线程的。</li><li>一般我们会有使用<strong>多线程方式进行c/s交互，但是这样很难做到C10K</strong>（比如说：1W个客户端就需要和服务端用1W个线程支持，这样的话CPU肯定就爆炸了，同时线程上下文切换也会把机器负载给拉飞。）</li></ul><a id="more"></a><h2 id="2-NIO-解决C10K问题"><a href="#2-NIO-解决C10K问题" class="headerlink" title="2. NIO 解决C10K问题"></a>2. NIO 解决C10K问题</h2><h3 id="2-1-Java角度"><a href="#2-1-Java角度" class="headerlink" title="2.1 Java角度"></a>2.1 Java角度</h3><ul><li>站在java 角度去看，NIO包提供了一套非阻塞的接口，这样就<strong>不需要我们为每一个c/s长连接保留一个单独的处理线程了。</strong></li><li>这个<strong>阻塞BIO之所以需要给每个socket长连接指定一个线程，就是因为它阻塞</strong>嘛</li><li>现在这个NIO API具有非阻塞的特性了，就可以<strong>用1个线程去检查n个socket</strong></li><li>在 java 层面，nio 提供了一个这样的选择器<code>selector</code></li><li>然后我们<strong>需要把需要检查的socket注册到这个<code>selector</code>中</strong>，然后主线程阻塞在<code>selector</code>的<code>select</code>方法中。</li><li>当选择器发现<code>socket</code>就绪了，某个socket就绪了。就会唤醒主线程，</li><li>然后咱们可以通过<code>selector</code> 获取就绪状态的<code>socket</code> 进行相应的处理。</li></ul><p><strong>其实这里selector 里面是native api ,底层Jvm调用SystemCall kernel去实现的</strong></p><h2 id="3-select-…-实现原理"><a href="#3-select-…-实现原理" class="headerlink" title="3. select(…) 实现原理"></a>3. select(…) 实现原理</h2><ul><li><strong>每次调用<code>kernel</code> 的 select函数，都会涉及到用户态/内核态的切换</strong>，<strong>还需要传递需要检查的socket集合</strong>，其实就是需要检查的<code>fd</code>(文件描述符)集合<ul><li>因为咱的程序都是运行在linux或者unix操作系统上，这种操作系统，一切皆文件，<code>socket</code>也不例外，这里传递的fd其实就是文件系统中对应socket生成的文件描述符</li></ul></li><li><strong>操作系统 这个<code>select</code>函数被调用以后，</strong><ul><li><strong>首先会去fd集合中去检查内存中<code>socket</code>套接字的状态，这个时间复杂度是<code>O(N)</code>的</strong>，然后检查完一遍之后，如果有就绪状态的<code>socket</code>,那么就会直接返回，不会阻塞当前线程。</li><li>否则的话，那个就说明当前指定<code>fd</code>集合对应的<code>socket</code>没有就绪状态，那么就需要阻塞当前调用线程了，直到有某个<code>socket</code>有数据之后，才唤醒线程。</li></ul></li></ul><p><strong>select(…) 对监听socket有1024的大小限制</strong></p><ul><li>这个是因为<code>fd</code>集合这个结构是一个<strong><code>bitmap</code>位图的结构</strong>，这个位图结构就是一个长的二进制数,类似<code>0101</code>这种<ul><li>这个<code>bitmap</code>默认长度是<code>1024个bit</code>,想要修改长度非常麻烦，需要<strong>重新编译操作系统内核</strong></li></ul></li><li>处于某种性能考虑,<code>select</code>函数做了两件事<ul><li><strong>第一件事</strong>，跑到就绪状态的<code>socket</code>对应的fd文件中设置一个标记mask,表示这个fd对应的<code>socket</code>就绪了</li><li><strong>第二件事</strong>，返回<code>select</code>函数，对应的也就是唤醒java线程，站在java层面，<strong>他会收到一个int结果值，表示有几个socket处于就绪状态</strong><ul><li>但是具体是哪个<code>socket</code>就绪，<code>java</code>是不知道的，所以接下来会是一个<code>O(N)</code>的系统调用，检查fd集合中每一个socket的就绪状态，其实就是检查文件系统中指定<code>socket</code>的文件描述符的状态，<strong>涉及到用户态和内核态的来回切换，如果<code>bitmap</code>再大，就非常耗费性能</strong></li><li>还有就是<strong>系统调用涉及到参数的数据拷贝</strong>，如果数据太庞大，他也不利于系统的调用速度</li></ul></li></ul></li></ul><h2 id="4-select-深入问题"><a href="#4-select-深入问题" class="headerlink" title="4. select(..) 深入问题"></a>4. select(..) 深入问题</h2><p><strong>问题：select (…) 第一遍 O(N) 去检查未发现就绪的socket ，后续某个socket就绪后，select(…)是如何感知道的？是不断的轮询吗？</strong></p><p><strong>铺垫知识</strong></p><ol><li><strong>操作系统调度</strong></li></ol><ul><li>cpu同一时刻，它只能运行一个进程，操作系统做主要的任务就是系统调度，就是有n个进程，然后让这n个进程在cpu上切换进行</li><li><strong>未挂起的进程都在工作队列内</strong>，都有机会获取到cpu的执行权</li><li><strong>挂起的进程就会从这个工作队列里移除出去</strong>，反映到咱们java层面就是线程阻塞了</li><li>linux系统线程其实就是轻量级进程</li></ul><ol start="2"><li><strong>操作系统中断</strong></li></ol><ul><li><p>比如说，咱们用键盘打字，如果cpu正执行其他程序，一直不释放，那咱这个打字就也没法打了</p></li><li><p>咱们都知道，不是这样的情况，因为就是有系统中断的存在，当按下一个键以后会给主板发送一个电流信号，主板感知到以后，它就会触发这个cpu中断、</p></li><li><p><strong>所以中断 其实就是让cpu给正在执行的进程先保留程序上下文，然后避让出cpu，给中断程序绕道</strong></p></li><li><p><strong>中断程序就会拿到cpu的执行权限</strong>，进行相应代码的执行，比如说键盘的中断程序，就会执行输出的逻辑</p></li></ul><p><strong>回到最开始的问题</strong></p><ul><li>这个<code>select</code>函数，它第一遍轮询，没有发现就绪状态的socket的话，它就会把当前进程保留给需要检查的socket等待队列中</li><li><code>socket</code> 结构 有三块核心区域，分别就是<strong>读缓存，写缓存还有这个等待队列</strong></li><li>这个 <code>select</code> 函数，它会把当前进程保留到每个需要检查的socket 的等待队列中，就会把当前进程从工作队列里面移除了，移除了之后其实就是挂起了当前线程，然后这个select 函数也就不会再运行了</li><li><strong>下一个阶段，假设我们客户端往当前服务器发送了数据</strong>，数据通过网线到网卡，网卡再到DMA硬件的这种方式直接将数据写到内存里面，然后整个过程，CPU是不参与的</li><li>当传输完成以后，它就会触发网络数据传输完毕的中断程序，这个中断程序它会把cpu正在执行的进程给顶掉，然后<strong>cpu就会执行咱这个中断程序的逻辑</strong><ul><li>对应的逻辑是：根据内存中的数据包，然后分析出来数据包是哪个socket的数据，</li><li>同时tcp/ip它又是保证传输的时候是有端口号的，然后根据端口号就能找到对用的socket实例，找到socket实例以后，就会<strong>把数据导入到socket读缓冲里面</strong></li><li><strong>导入完成以后，它就开始去检查socket等待队列</strong>，看是不是有等待者，如果有等待者的话，就会把等待者移动到工作队列里面去，中断程序到这一步就执行完了</li><li>这样咱们的进程就又回到了工作队列，又有机会获取到cpu时间片了</li></ul></li><li>然后当前进程执行的<code>select</code>函数再次检查，就会发现这个就绪的<code>socket了</code>,就会给就绪的<code>socket</code>的<code>fd</code>文件描述符打标记，然后<code>select</code>函数就执行完了，返回到java层面就涉及到内核态和用户态的转换，<strong>后面的事情就是轮询检查</strong>每一个socket的fd是否被打了标记，然后就是处理被打了标记的socket就ok了</li></ul><h2 id="5-poll-和-select-区别"><a href="#5-poll-和-select-区别" class="headerlink" title="5. poll() 和 select()区别"></a>5. poll() 和 select()区别</h2><ul><li><strong>传参不一样</strong> <ul><li><strong>select 用的是bitmap ，</strong>它表示需要检查的socket集合</li><li><strong>poll 使用的是 链表结构，</strong>表示需要检查的socket集合（主要是为了解决socket监听长度超过1024的<code>socket</code>的限制）</li></ul></li></ul><h2 id="6-epoll-的-产生背景"><a href="#6-epoll-的-产生背景" class="headerlink" title="6. epoll 的 产生背景"></a>6. epoll 的 产生背景</h2><ul><li><strong>select 和 poll 的共有缺陷</strong><ul><li><strong>第一个缺陷：</strong> <code>select</code> 和 <code>poll</code> 函数，<strong>这两系统函数每次调用都需要我们提供给它所有的需要监听的socket文件描述符集合，而且主线程是死循环调用<code>select/poll</code>函数的,这里面涉及到用户空间数据到内核空间拷贝的过程</strong><ul><li>咱们需要监听的socket集合，<strong>数据变化非常小</strong></li><li><strong>每次就一到两个socket_fd需要更改，但是没有办法，因为select和poll函数，只是一个很单纯的函数</strong></li><li><strong>它在kernel层面，不会保留任何的数据信息，所以说每次调用都进行了数据拷贝</strong></li></ul></li><li><strong>第二个缺陷：</strong> select 和 poll 函数它的返回值都是int整型值，只能代表有几个socket就绪或者有错误了，它没办法表示具体是哪个socket就绪了<ul><li>这就<strong>导致了程序被唤醒以后，还需要新的一轮系统调用去检查哪个socket是就绪状态的</strong>，然后再进行socket数据处理逻辑，这里走了不少弯路（同时还存在用户态和内核态的切换，这样缺陷就更严重了）</li></ul></li></ul></li></ul><p><strong>epoll 就是为了解决这两个问题</strong></p><h2 id="7-epoll-…-实现原理"><a href="#7-epoll-…-实现原理" class="headerlink" title="7. epoll (…) 实现原理"></a>7. epoll (…) 实现原理</h2><ul><li>epoll 函数<strong>在内核空间内，它有一个对应的数据结构去存储一些数据，这个数据结构其实就是eventpoll对象</strong><ul><li>这个<code>eventpoll</code> 可以通过一个系统函数<code>epoll_create()</code>函数去创建的</li></ul></li><li>创建完成之后，系统函数返回一个<code>eventpoll</code>对象的id，相当于我们在内核空间开辟了一小块空间，并且我们也知道这块空间的位置</li></ul><p><strong>先说下eventpoll 的数据结构：三块重要的区域</strong></p><ul><li>一块是存放<strong>需要监听的socket_fd描述符列表</strong></li><li>另一块就是<strong>就绪列表，存放就绪状态的socket信息</strong></li><li>eventpoll 还有一块空间是<code>eventpoll</code> 的<strong>等待队列，这个等待队列保存的就是调用<code>epoll_wait</code>的进程</strong></li><li><strong>另外呢还提供了两个函数，一个是<code>epoll_ctl</code>函数，一个是<code>epoll_wait</code>函数</strong></li><li><strong>其中存放的socket集合信息采用的是红黑树的数据结构</strong>，socket集合信息经常用增删改查的，这种红黑树再适合不过了，保持了时间复杂度为O(logN)</li></ul><p><strong>epoll_ctl()</strong> </p><ul><li>它可以根据<code>eventpoll-id</code>去增删改内核空间上<code>eventpoll</code> 对象的检查列表（socket信息）</li></ul><p>*<em>epoll_wait() *</em></p><ul><li>它主要的参数是<code>eventpoll-id</code> 表示此次系统调用需要检测的<code>socket_fd</code>集合，是<code>eventpoll</code> 中已经指定好的那些<code>socket</code>信息</li><li><code>epoll_wait</code> <strong>默认情况下会阻塞系统的调用线程</strong>，直到<code>eventpoll</code> 对象中关联的某个或者某些个socket就绪以后，<code>epoll_wait</code>函数才会返回</li><li>返回值是<code>Int</code>类型的<ul><li>返回0，表示没有就绪的socket</li><li>返回大于0，表示有几个就绪的socket</li><li>返回-1表示异常</li></ul></li></ul><h2 id="8-eventpoll-对象就绪列表的维护"><a href="#8-eventpoll-对象就绪列表的维护" class="headerlink" title="8. eventpoll 对象就绪列表的维护"></a>8. eventpoll 对象就绪列表的维护</h2><p><strong>select函数调用的流程：</strong></p><ul><li>socket对象有三块区域<ul><li>读缓冲区</li><li>写缓冲区</li><li>等待队列</li></ul></li><li>select函数调用的时候会把当前进程从工作队列里面拿出来</li><li><strong>然后把进程引用追加到当前进程关注的每一个socket对象的等待队列中</strong></li><li>然后当socket连接的客户端发送完数据之后，数据还是通过硬件DMA的方式把数据写入到内存，然后相应的硬件向CPU发出中断信号,CPU就会让出当前进程位置去执行网络数据就绪的中断程序，</li><li><strong>这个中断程序就会把内存中的网络数据写入到对应的socket读缓冲区里面，之后把这个socket等待队列中的进程全部移动到工作队列中，再然后select函数返回</strong></li></ul><p><strong>epoll函数流程非常相似</strong></p><ul><li><p>当我们调用系统函数<code>epoll_ ctl</code>时候，比如我们新添加一个需要关注的socket,其实<strong>内核程序会把当前的<code>eventpoll</code>对象追加到这个<code>socket</code>的等待队列里头</strong></p></li><li><p>然后当<code>socket</code>连接的客户端发送完数据之后，数据还是通过硬件DMA的方式把数据写入到内存，然后相应的硬件向CPU发出中断信号,CPU就会让出当前进程位置去执行网络数据就绪的中断程序，</p></li><li><p><strong>这个中断程序就会把内存中的网络数据写入到对应的<code>socket</code>读缓冲区里面，然后它发现这个<code>socket</code>的等待队列里头不是进程，而是一个<code>eventpoll</code>对象的引用</strong></p></li><li><p><strong>这个时候呢，他就会根据这个<code>eventpoll</code>对象的引用，将当前<code>socket</code>的引用追加到eventpoll的就绪链表的末尾</strong>（<code>eventpoll</code> 还有一块空间是<code>eventpoll</code> 的等待队列，这个等待队列保存的就是调用<code>epoll_wait</code>的进程）</p></li><li><p>然后，当中断程序把<code>socket</code>的引用追加到就绪列表的末尾之后，就继续检查<code>eventpoll</code>对象的等待队列，如果有进程，就会把进程转移到工作队列中</p></li><li><p>转移完毕之后，进程就有获取到CPU执行的时间片了，然后就是调用<code>epoll_wait</code> 函数，他这个函数就返回到java层面了</p></li></ul><p><strong>总结：</strong></p><ul><li><strong>eventpoll对象等待队列里面，它有调用epoll_wait(,,,)函数进去的进程</strong></li><li><strong>然后再把这个进程，从这个eventpoll的等待队列里面迁移到工作队列里面</strong></li></ul><h2 id="9-epoll-wait-获取就绪的socket"><a href="#9-epoll-wait-获取就绪的socket" class="headerlink" title="9. epoll_wait() 获取就绪的socket"></a>9. epoll_wait() 获取就绪的socket</h2><p><strong>epoll_wait() 返回值是Int类型的</strong></p><ul><li>返回0，表示没有就绪的socket</li><li>返回大于0，表示有几个就绪的socket</li><li>返回-1表示异常</li></ul><p><strong>那么获取就绪的socket是怎么实现的呢？</strong></p><ul><li><code>epoll_wait</code> 函数，<strong>调用的时候</strong>会传入一个<code>epoll_event</code>事件数组指针</li><li><code>epoll_wait</code> <strong>函数正常返回之前</strong>，会把就绪的socket事件信息拷贝到这个数组指针里头</li><li>这样返回到上层程序，就能通过这个数组拿到就绪列表</li></ul><h2 id="10-epoll-wait-可不可以设置成非阻塞的"><a href="#10-epoll-wait-可不可以设置成非阻塞的" class="headerlink" title="10. epoll_wait 可不可以设置成非阻塞的"></a>10. epoll_wait 可不可以设置成非阻塞的</h2><ul><li>默认<code>epoll_wait</code> 是阻塞的</li><li>它有一个参数，表示阻塞时间的长度，如果<strong>这个参数设置为0</strong>，表示这个<code>epoll_wait</code> 是一个非阻塞调用的</li><li><strong>每次调用都会去检查就绪列表</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-06-多路复用&quot;&gt;&lt;a href=&quot;#Linux-06-多路复用&quot; class=&quot;headerlink&quot; title=&quot;Linux-06-多路复用&quot;&gt;&lt;/a&gt;Linux-06-多路复用&lt;/h1&gt;&lt;h2 id=&quot;1-BIO-的缺陷&quot;&gt;&lt;a href=&quot;#1-BIO-的缺陷&quot; class=&quot;headerlink&quot; title=&quot;1. BIO 的缺陷&quot;&gt;&lt;/a&gt;1. BIO 的缺陷&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;BIO中的B 是 &lt;code&gt;Blocking&lt;/code&gt; 的阻塞的意思&lt;/li&gt;
&lt;li&gt;作为&lt;strong&gt;服务端开发&lt;/strong&gt;，使用&lt;code&gt;ServerSocket&lt;/code&gt; 绑定端口号之后会监听该端口,等待&lt;code&gt;accept&lt;/code&gt;事件，&lt;code&gt;accept&lt;/code&gt;是会阻塞当前线程&lt;/li&gt;
&lt;li&gt;当我们收到&lt;code&gt;accept&lt;/code&gt;事件的时候，程序就会拿到客户端与当前服务端连接的&lt;code&gt;Socket&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;针对这个&lt;code&gt;socket&lt;/code&gt;我们可以进行读写，但是呢，这个&lt;code&gt;socket&lt;/code&gt;读写都是会阻塞当前线程的。&lt;/li&gt;
&lt;li&gt;一般我们会有使用&lt;strong&gt;多线程方式进行c/s交互，但是这样很难做到C10K&lt;/strong&gt;（比如说：1W个客户端就需要和服务端用1W个线程支持，这样的话CPU肯定就爆炸了，同时线程上下文切换也会把机器负载给拉飞。）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="多路复用" scheme="http://zhuuu.work/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-interrupt()</title>
    <link href="http://zhuuu.work/2020/08/17/JavaInterview/Java-%E5%9F%BA%E7%A1%80-interrupt()/"/>
    <id>http://zhuuu.work/2020/08/17/JavaInterview/Java-%E5%9F%BA%E7%A1%80-interrupt()/</id>
    <published>2020-08-17T03:38:38.000Z</published>
    <updated>2020-09-10T12:47:07.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-interrupt"><a href="#Java-基础-interrupt" class="headerlink" title="Java-基础-interrupt()"></a>Java-基础-interrupt()</h1><h2 id="1-InterruptedException"><a href="#1-InterruptedException" class="headerlink" title="1. InterruptedException"></a>1. InterruptedException</h2><ul><li>当一个方法后面声明可能会抛出<code>InterruptedException</code>异常时，说明该方法是可能会花一点时间，但是可以取消的方法。</li></ul><ul><li>抛<code>InterruptedException</code>的代表方法有：<ul><li><code>java.lang.Object</code> 类的 wait 方法</li><li><code>java.lang.Thread</code> 类的 sleep 方法</li><li><code>java.lang.Thread</code> 类的 join 方法</li></ul></li></ul><a id="more"></a><p>– 需要花点时间的方法</p><ul><li><p>执行<code>wait</code>方法的线程，会进入等待区等待被<code>notify/notify All</code>。在等待期间，线程不会活动。</p></li><li><p>执行<code>sleep</code>方法的线程，会暂停执行参数内所设置的时间。</p></li><li><p>执行<code>join</code>方法的线程，会等待到指定的线程结束为止。</p></li></ul><p>因此，上面的方法都是需要花点时间的方法。</p><p>– 可以取消的方法</p><ul><li>因为需要花时间的操作会降低程序的响应性，所以可能会取消/中途放弃执行这个方法。</li><li>这里主要是通过<code>interrupt</code>方法来取消。</li></ul><ol><li><strong>sleep方法与interrupt方法</strong></li></ol><ul><li>interrupt方法是Thread类的实例方法，在执行的时候并不需要获取Thread实例的锁定，任何线程在任何时刻，都可以通过线程实例来调用其他线程的interrupt方法。</li><li>当在sleep中的线程被调用interrupt方法时，就会放弃暂停的状态，并抛出<code>InterruptedException</code>异常，这样一来，线程的控制权就交给了捕捉这个异常的catch块了。</li></ul><ol start="2"><li><strong>wait方法和interrupt方法</strong></li></ol><ul><li>当线程调用<code>wait</code>方法后，<strong>线程在进入等待区时，会把锁定解除</strong>。</li><li>当对wait中的线程调用<code>interrupt</code>方法时，<strong>会先重新获取锁定</strong>，再抛出<code>InterruptedException</code>异常，获取锁定之前，无法抛出<code>InterruptedException</code>异常。</li></ul><ol start="3"><li><strong>join方法和interrupt方法</strong></li></ol><ul><li>当线程以join方法等待其他线程结束时，一样可以使用interrupt方法取消。因为join方法不需要获取锁定，故而与sleep一样，会马上跳到catch程序块</li></ul><p><strong>线程中断</strong></p><ul><li>每一个线程都有一个boolean类型的标志，此标志意思是当前的请求是否请求中断，默认为false。</li><li>当一个线程A调用了线程B的interrupt方法时，那么线程B的是否请求的中断标志变为true。而线程B可以调用方法检测到此标志的变化。</li></ul><ol><li><strong>对于阻塞方法（join,sleep,wait）</strong></li></ol><ul><li>如果线程B调用了阻塞方法，如果是否请求中断标志变为了true，那么它会抛出InterruptedException异常。<strong>抛出异常的同时它会将线程B的是否请求中断标志置为false</strong></li></ul><ol start="2"><li><strong>对于非阻塞方法</strong></li></ol><ul><li>可以通过线程B的<code>isInterrupted</code>方法进行检测是否请求中断标志为true还是false</li><li>另外还有一个静态的方法<code>interrupted</code>方法也可以检测标志。但是静态方法它检测完以后会自动的将是否请求中断标志位置为false</li></ul><p><strong>讲下列三个方法的时候先给出总结：</strong></p><ul><li><strong>调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真正的停止线程</strong></li><li><strong>interrupted()测试当前线程是否已经是中断状态，执行后具有清除中断状态flag的功能</strong></li><li><strong>isInterrupted()测试线程Thread对象是否已经是中断状态，但不清除中断状态flag</strong></li></ul><h2 id="2-interrupt-方法"><a href="#2-interrupt-方法" class="headerlink" title="2. interrupt()方法"></a>2. interrupt()方法</h2><ul><li><strong>interrupt方法其实只是改变了中断状态而已。</strong></li><li><strong>而sleep、wait和join这些方法的内部会不断的检查中断状态的值，从而自己抛出InterruptEdException。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，如果在线程进行其他处理时，调用了它的interrupt方法，线程也不会抛出InterruptedException的，只有当线程走到了sleep, wait, join这些方法的时候，才会抛出InterruptedException。若是没有调用sleep, wait, join这些方法，或者没有在线程里自己检查中断状态，自己抛出InterruptedException，那InterruptedException是不会抛出来的。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/204151515.png" alt="mark"></p><h2 id="3-isInterrupted-方法"><a href="#3-isInterrupted-方法" class="headerlink" title="3. isInterrupted() 方法"></a>3. isInterrupted() 方法</h2><ul><li>可以用来检查中断状态，并且不会清除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" i = "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main thread interrupt</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.getName() + <span class="string">":"</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">":"</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + Thread.currentThread().isInterrupted());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thread interrupt</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.getName() + <span class="string">":"</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">":"</span> + thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/204610315.png" alt="mark"></p><h2 id="4-interrupted（）-方法"><a href="#4-interrupted（）-方法" class="headerlink" title="4. interrupted（） 方法"></a>4. interrupted（） 方法</h2><ul><li>可以用来检查并清除中断状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" i = "</span> + i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"interrupted 1: "</span> + Thread.interrupted());</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"interrupted 2: "</span> + Thread.interrupted());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/204321165.png" alt="mark"></p><ul><li>控制台第一次打印的结果是true，第二次为false；</li><li>Java Doc中给出的解释是：测试当前线程是否已经中断，线程的中断状态由该方法清除。即如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除flag后以及第二次调用检查中断状态之前，当前线程再次中断的情况除外）</li><li>所以，interrupted()方法具有清除状态flag的功能 </li></ul><h2 id="5-InterruptedException-的处理"><a href="#5-InterruptedException-的处理" class="headerlink" title="5. InterruptedException 的处理"></a>5. InterruptedException 的处理</h2><ul><li>现在知道线程可以检测到自身的标志位的变化，但是他只是一个标志，<strong>如果线程本身不处理的话，那么程序还是会执行下去</strong>，就好比，老师在学校叮嘱要好好学习，具体什么时候，如何好好学习还是看自身。</li><li><strong>因此<code>interrupt()</code> 方法并不能立即中断线程，该方法仅仅告诉线程外部已经有中断请求，至于是否中断还取决于线程自己</strong></li></ul><p>简单的了解了什么是阻塞和中断以后，我们就该了解碰到<code>InterruptedException</code>异常该如何处理了。</p><p><strong>一句话：不要不管不顾</strong></p><ul><li><strong>有时候阻塞的方法抛出<code>InterruptedException</code>异常并不合适</strong>，例如在<code>Runnable</code>中调用了可中断的方法，因为你的程序是实现了<code>Runnable</code>接口，然后在重写<code>Runnable</code>接口的<code>run</code>方法的时候，那么子类抛出的异常要小于等于父类的异常。而在<code>Runnable</code>中<code>run</code>方法是没有抛异常的。<strong>所以此时是不能抛出InterruptedException异常</strong>。</li><li>如果<strong>此时你只是记录日志的话</strong>，那么就是一个<strong>不负责任的做法</strong>，<strong>因为在捕获<code>InterruptedException</code>异常的时候自动的将 是否请求中断标志置为了false。</strong></li><li><strong>至少在捕获了<code>InterruptedException</code>异常之后，如果你什么也不想做，那么就将标志重新置为<code>true</code></strong>，<strong>以便栈中更高层的代码能知道中断，并且对中断作出响应。</strong></li></ul><p><strong>捕获到InterruptedException异常后恢复中断状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.queue = queue; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                 Task task = queue.take(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                 task.execute();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">             <span class="comment">// Restore the interrupted status</span></span><br><span class="line">             <span class="comment">// 向上保存中断的状态</span></span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-interrupt&quot;&gt;&lt;a href=&quot;#Java-基础-interrupt&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-interrupt()&quot;&gt;&lt;/a&gt;Java-基础-interrupt()&lt;/h1&gt;&lt;h2 id=&quot;1-InterruptedException&quot;&gt;&lt;a href=&quot;#1-InterruptedException&quot; class=&quot;headerlink&quot; title=&quot;1. InterruptedException&quot;&gt;&lt;/a&gt;1. InterruptedException&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当一个方法后面声明可能会抛出&lt;code&gt;InterruptedException&lt;/code&gt;异常时，说明该方法是可能会花一点时间，但是可以取消的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;抛&lt;code&gt;InterruptedException&lt;/code&gt;的代表方法有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java.lang.Object&lt;/code&gt; 类的 wait 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt; 类的 sleep 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt; 类的 join 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="打断" scheme="http://zhuuu.work/tags/%E6%89%93%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码-01-DI注入</title>
    <link href="http://zhuuu.work/2020/08/16/Spring/Spring%E6%BA%90%E7%A0%81-01-DI%E6%B3%A8%E5%85%A5/"/>
    <id>http://zhuuu.work/2020/08/16/Spring/Spring%E6%BA%90%E7%A0%81-01-DI%E6%B3%A8%E5%85%A5/</id>
    <published>2020-08-16T07:02:24.000Z</published>
    <updated>2020-08-16T08:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码-01-DI注入"><a href="#Spring源码-01-DI注入" class="headerlink" title="Spring源码-01-DI注入"></a>Spring源码-01-DI注入</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>比如提到spring的自动注入作为一个java程序员肯定自信无比了解；但是笔者要说的自动注入可能会和你理解有很大出入。</li><li>自动注入需要相对于手动装配来说；在spring应用程序当中假设你的A类依赖了B类，需要在A类当中提供一个B类的属性，再加上setter，继而在xml当中配置、描述一下这两个类之间的依赖关系。如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；</li><li>这种由程序员自己配置、描述好依赖关系的写法叫做手动装配；看个例子吧；</li></ul><a id="more"></a><h2 id="1-DI装配方式"><a href="#1-DI装配方式" class="headerlink" title="1. DI装配方式"></a>1. DI装配方式</h2><h3 id="1-1-手动装配"><a href="#1-1-手动装配" class="headerlink" title="1.1 手动装配"></a>1.1 手动装配</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.luban.app;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">B b;</span><br><span class="line">public void setB(B b) &#123;</span><br><span class="line">this.b = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.luban.app;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.luban.app.A"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 由程序员手动指定的依赖关系 称为手动装配--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"b"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span>  <span class="attr">class</span>=<span class="string">"com.luban.app.B"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>但是实际开发中手动装配的场景比较少(比如在缺少源码的情况下可能会使用这种手动装配情况)；<br>关于依赖注入的资料可以参考官网</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies</a></li><li>这一章节提到了一个非常重要的知识点，<strong>也是一个常见的spring面试题目。spring有几种依赖注入方式？那么这个问题应该怎么回答呢？</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200816-162155273.png" alt="mark"></p><h3 id="1-2-DI注入两种方式"><a href="#1-2-DI注入两种方式" class="headerlink" title="1.2 DI注入两种方式"></a>1.2 DI注入两种方式</h3><ul><li><p>官网的意思是DI(依赖注入)一共有两种主要的变体（注意会考），分别是基于构造方法的依赖注入和基于setter（setXxxx(…)）的依赖注入</p></li><li><p>不管是手动装配还是自动装配都是基于这两种方式或者变体方式来的；但是这里一定要回答到主要和变体两个名词，因为有的注入方式就不是这两种，而是这两种其中一种的变体方式；比如在一个类的属性上面加@Autowired，这种方式注入属性的方式就是利用了java的反射知识，</p></li><li><p><code>field.set(value,targetObject)</code>;关于这个我在后面的文章中对spring源码解析的时候会说明<code>@Autowired</code>的原理；所以<code>@Autowired</code>这种注入的方式是setter注入方式的一种变体</p></li><li><p>但是这里需要说明的是所谓的setter其实和属性无关，什么意思呢？一般的setter方法会对应一个属性，但是spring的基于setter的注入方式是不需要属性的，仅仅只需要一个setter方法，下面这个例子来说明这个问题.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring源码-01-DI注入&quot;&gt;&lt;a href=&quot;#Spring源码-01-DI注入&quot; class=&quot;headerlink&quot; title=&quot;Spring源码-01-DI注入&quot;&gt;&lt;/a&gt;Spring源码-01-DI注入&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;比如提到spring的自动注入作为一个java程序员肯定自信无比了解；但是笔者要说的自动注入可能会和你理解有很大出入。&lt;/li&gt;
&lt;li&gt;自动注入需要相对于手动装配来说；在spring应用程序当中假设你的A类依赖了B类，需要在A类当中提供一个B类的属性，再加上setter，继而在xml当中配置、描述一下这两个类之间的依赖关系。如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；&lt;/li&gt;
&lt;li&gt;这种由程序员自己配置、描述好依赖关系的写法叫做手动装配；看个例子吧；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
      <category term="Spring源码学习" scheme="http://zhuuu.work/tags/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-344-反转字符串</title>
    <link href="http://zhuuu.work/2020/08/15/Leetcode/Leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/08/15/Leetcode/Leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-15T04:22:53.000Z</published>
    <updated>2020-10-08T01:22:49.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-344-反转字符串"><a href="#Leetcode-344-反转字符串" class="headerlink" title="Leetcode-344-反转字符串"></a>Leetcode-344-<a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">反转字符串</a></h1><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a> 码表中的可打印字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-双指针"><a href="#方法-双指针" class="headerlink" title="方法 : 双指针"></a>方法 : 双指针</h2><ul><li>对于长度为 N 的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为 <code>s[0] s[1] s[2] ... s[N - 1]</code>，那么反转后字符数组为<code>s[N - 1] s[N - 2] ... s[0]</code>。比较反转前后下标变化很容易得出 <code>s[i]</code> 的字符与<code>s[N - 1 - i]</code>的字符发生了交换的规律，因此我们可以得出如下双指针的解法：</li></ul><ul><li>将 <code>left</code>指向字符数组首元素，<code>right</code> 指向字符数组尾元素。<br>当 <code>left &lt; right：</code><br>交换<code>s[left]</code>和<code>s[right]；</code><br><code>left</code>指针右移一位，即<code>left = left + 1；</code><br><code>right</code>指针左移一位，即 <code>right = right - 1。</code></li></ul><ul><li>当 <code>left &gt;= right</code>，反转结束，返回字符数组即可。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/092158630.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义双指针</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">// 相遇即退出循环</span></span><br><span class="line">            <span class="keyword">char</span> temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// left向前走一步</span></span><br><span class="line">            <span class="comment">// right向后走一步</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，其中 N<em>N</em> 为字符数组的长度。一共执行了 N/2次的交换。</li><li><strong>空间复杂度</strong>：O(1)。只使用了常数空间来存放若干变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-344-反转字符串&quot;&gt;&lt;a href=&quot;#Leetcode-344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-344-反转字符串&quot;&gt;&lt;/a&gt;Leetcode-344-&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;反转字符串&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：双指针&quot;&gt;&lt;a href=&quot;#思路：双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：双指针&quot;&gt;&lt;/a&gt;思路：双指针&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 &lt;code&gt;char[]&lt;/code&gt; 的形式给出。&lt;/p&gt;
&lt;p&gt;不要给另外的数组分配额外的空间，你必须&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;修改输入数组&lt;/strong&gt;、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;
&lt;p&gt;你可以假设数组中的所有字符都是 &lt;a href=&quot;https://baike.baidu.com/item/ASCII&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ASCII&lt;/a&gt; 码表中的可打印字符。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://zhuuu.work/2020/08/14/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://zhuuu.work/2020/08/14/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-08-14T09:38:38.000Z</published>
    <updated>2020-09-26T11:43:02.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>事务想必大家并不陌生，至于什么是 ACID，也是老生常谈了。</li><li>还是得先说说 ACID，然后再来介绍下什么是分布式事务和常见的分布式事务包括 2PC、3PC、TCC、本地消息表、消息事务、最大努力通知。</li></ul><a id="more"></a><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><ul><li>原子性（Atomicity），可以理解为一个事务内的所有操作要么都执行，要么都不执行。</li><li>一致性（Consistency），可以理解为数据是满足完整性约束的，也就是不会存在中间状态的数据，比如你账上有400，我账上有100，你给我打200块，此时你账上的钱应该是200，我账上的钱应该是300，不会存在我账上钱加了，你账上钱没扣的<strong>中间状态</strong>。</li><li>隔离性（Isolation），指的是多个事务并发执行的时候不会互相干扰，即一个事务内部的数据对于其他事务来说是隔离的。</li><li>持久性（Durability），指的是一个事务完成了之后数据就被永远保存下来，之后的其他操作或故障都不会对事务的结果产生影响。</li></ul><p>而通俗意义上事务就是为了使得一些更新操作要么都成功，要么都失败。</p><p>说到这里可能有人会说，<strong>不对啊 Redis 的事务不能保证所有操作要么都执行要么都不执行，为什么它也叫事务啊？</strong></p><p>首先你要知晓一般的中间件都会夸大其效果，人家团队也是想更出名，吸引更多的人来使用他们的产品，所以我们得以辩证的角度来看待。</p><p>一般而言他们既然敢说出他们实现了什么什么，要么是真的实现了，要么是在某种特殊、定制或者极端的条件下才能满足功能。</p><ul><li>来看看 Redis 怎么说的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/191135006.png" alt="mark"></p><p>这句话就是告诉大家事务中的某个命令失败了，之后的命令还是会被处理，Redis  不会停止命令，意味着也不会回滚。</p><p>你说这不是扯嘛？这都偏离事务最核心的本意了啊。</p><p>别急，咱们来看看 Redis 怎么解释的。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/191241255.png" alt="mark"></p><ul><li><p>Redis 官网解释了为什么不支持回滚，他们说首先如果命令出错那都是语法使用错误，<strong>是你们自己编程出错</strong>，而且这种情况应该在开发的时候就被检测出来，不应在生产环境中出现。</p></li><li><p>然后 Redis 就是为了快！不需要提供回滚。</p></li><li><p>下面还有一段话我就不截图了，就是说就算提供回滚也没用，你这代码都写错了，<strong>回滚并不能使你免于编程错误</strong>。而且一般这种错也不可能进入到生产环境，所以选择更加简单、快速的方法，我们不支持回滚。</p></li><li><p>你看看这说的好像很有道理，我们不提供回滚，因为我们不需要为你的编程错误买单！</p></li></ul><h2 id="2-分布式事务"><a href="#2-分布式事务" class="headerlink" title="2. 分布式事务"></a>2. 分布式事务</h2><h3 id="2-1-2PC"><a href="#2-1-2PC" class="headerlink" title="2.1 2PC"></a>2.1 2PC</h3><ul><li><p><code>2PC（Two-phase commit protocol）</code>，中文叫二阶段提交。<strong>二阶段提交是一种强一致性设计</strong>，2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。</p></li><li><p>注意这只是协议或者说是理论指导，只阐述了大方向，具体落地还是有会有差异的。</p></li></ul><p>让我们来看下两个阶段的具体流程。</p><ul><li><strong>准备阶段</strong>协调者会给各参与者发送准备命令，你可以把准备命令理解成除了提交事务之外啥事都做完了。</li><li>同步等待所有资源的响应之后就进入第二阶段即提交阶段（注意提交阶段不一定是提交事务，也可能是回滚事务）。</li><li>假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/191719154.png" alt="mark"></p><ul><li>假如在第一阶段有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式事务执行失败。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/191747805.png" alt="mark"></p><p><strong>那可能就有人问了，那第二阶段提交失败的话呢？</strong></p><ul><li>这里有两种情况。<ul><li>第一种是<strong>第二阶段执行的是回滚事务操作</strong>，那么答案是不断重试，直到所有参与者都回滚了，不然那些在第一阶段准备成功的参与者会一直阻塞着。</li><li>第二种是<strong>第二阶段执行的是提交事务操作</strong>，那么答案也是不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功，到最后真的不行只能人工介入处理。</li></ul></li></ul><p>大体上二阶段提交的流程就是这样，<strong>我们再来看看细节</strong>。</p><ul><li>首先 2PC 是一个<strong>同步阻塞协议</strong>，像第一阶段协调者会等待所有参与者响应才会进行下一步操作</li><li>当然第一阶段的<strong>协调者有超时机制</strong>，假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令。</li><li>在第二阶段协调者的没法超时，因为按照我们上面分析只能不断重试！</li></ul><p><strong>协调者是一个单点，存在单点故障问题</strong>。</p><ul><li><p>假设协调者在<strong>发送准备命令之前</strong>挂了，还行等于事务还没开始。</p></li><li><p>假设协调者在<strong>发送准备命令之后</strong>挂了，这就不太行了，有些参与者等于都执行了处于事务资源锁定的状态。不仅事务执行不下去，还会因为锁定了一些公共资源而阻塞系统其它操作。</p></li><li><p>假设协调者在<strong>发送回滚事务命令之前</strong>挂了，那么事务也是执行不下去，且在第一阶段那些准备成功参与者都阻塞着。</p></li><li><p>假设协调者在<strong>发送回滚事务命令之后</strong>挂了，这个还行，至少命令发出去了，很大的概率都会回滚成功，资源都会释放。但是如果出现网络分区问题，某些参与者将因为收不到命令而阻塞着。</p></li><li><p>假设协调者在<strong>发送提交事务命令之前</strong>挂了，这个不行，傻了！这下是所有资源都阻塞着。</p></li><li><p>假设协调者在<strong>发送提交事务命令之后</strong>挂了，这个还行，也是至少命令发出去了，很大概率都会提交成功，然后释放资源，但是如果出现网络分区问题某些参与者将因为收不到命令而阻塞着。</p></li></ul><p><strong>协调者故障，通过选举得到新的协调者</strong></p><ul><li>因为协调者单点问题，因此我们可以通过选举等操作选出一个新协调者来顶替。</li><li>如果处于第一阶段，其实影响不大都回滚好了，在第一阶段事务肯定还没提交。</li><li>如果处于第二阶段，假设参与者都没挂，此时新协调者可以向所有参与者确认它们自身情况来推断下一步的操作。</li><li>假设有个别参与者挂了！这就有点僵硬了，比如协调者发送了回滚命令，此时第一个参与者收到了并执行，然后协调者和第一个参与者都挂了。</li><li>此时其他参与者都没收到请求，然后新协调者来了，它询问其他参与者都说OK，但它不知道挂了的那个参与者到底O不OK，所以它傻了。</li><li>问题其实就出在<strong>每个参与者自身的状态只有自己和协调者知道</strong>，因此新协调者无法通过在场的参与者的状态推断出挂了的参与者是什么情况。</li><li>虽然协议上没说，不过在实现的时候我们可以灵活的让协调者将自己发过的请求在哪个地方记一下，也就是日志记录，这样新协调者来的时候不就知道此时该不该发了？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/192613256.png" alt="mark"></p><ul><li>但是就算协调者知道自己该发提交请求，那么在参与者也一起挂了的情况下没用，因为你不知道参与者在挂之前有没有提交事务。</li><li>如果参与者在挂之前事务提交成功，新协调者确定存活着的参与者都没问题，那肯定得向其他参与者发送提交事务命令才能保证数据一致。</li><li>如果参与者在挂之前事务还未提交成功，参与者恢复了之后数据是回滚的，此时协调者必须是向其他参与者发送回滚事务命令才能保持事务的一致。</li></ul><p><strong>所以说极端情况下还是无法避免数据不一致问题。</strong></p><p><code>talk is cheap</code> 让我们再来看下代码，可能更加的清晰。以下代码取自 &lt;&gt;。</p><p>这个代码就是实现了 2PC，但是相比于2PC增加了写日志的动作、参与者之间还会互相通知、参与者也实现了超时。这里要注意，一般所说的2PC，不含上述功能，这都是实现的时候添加的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">协调者:</span><br><span class="line">    write START_2PC to local log; <span class="comment">//开始事务</span></span><br><span class="line">    multicast VOTE_REQUEST to all participants; <span class="comment">//广播通知参与者投票</span></span><br><span class="line">    <span class="keyword">while</span> not all votes have been collected &#123;</span><br><span class="line">        wait <span class="keyword">for</span> any incoming vote;</span><br><span class="line">        <span class="keyword">if</span> timeout &#123; <span class="comment">//协调者超时</span></span><br><span class="line">            write GLOBAL_ABORT to local log; <span class="comment">//写日志</span></span><br><span class="line">            multicast GLOBAL_ABORT to all participants; <span class="comment">//通知事务中断</span></span><br><span class="line">            exit;</span><br><span class="line">        &#125;</span><br><span class="line">        record vote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果所有参与者都ok</span></span><br><span class="line">    <span class="keyword">if</span> all participants sent VOTE_COMMIT and coordinator votes COMMIT &#123;</span><br><span class="line">        write GLOBAL_COMMIT to local log;</span><br><span class="line">        multicast GLOBAL_COMMIT to all participants;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write GLOBAL_ABORT to local log;</span><br><span class="line">        multicast GLOBAL_ABORT to all participants;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">参与者:</span><br><span class="line"></span><br><span class="line">    write INIT to local log; <span class="comment">//写日志</span></span><br><span class="line">    wait <span class="keyword">for</span> VOTE_REQUEST from coordinator;</span><br><span class="line">    <span class="keyword">if</span> timeout &#123; <span class="comment">//等待超时</span></span><br><span class="line">        write VOTE_ABORT to local log;</span><br><span class="line">        exit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> participant votes COMMIT &#123;</span><br><span class="line">        write VOTE_COMMIT to local log; <span class="comment">//记录自己的决策</span></span><br><span class="line">        send VOTE_COMMIT to coordinator;</span><br><span class="line">        wait <span class="keyword">for</span> DECISION from coordinator;</span><br><span class="line">        <span class="keyword">if</span> timeout &#123;</span><br><span class="line">            multicast DECISION_REQUEST to other participants; <span class="comment">//超时通知</span></span><br><span class="line">            wait until DECISION is received;  <span class="comment">/* remain blocked*/</span></span><br><span class="line">            write DECISION to local log;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> DECISION == GLOBAL_COMMIT</span><br><span class="line">            write GLOBAL_COMMIT to local log;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> DECISION == GLOBAL_ABORT</span><br><span class="line">            write GLOBAL_ABORT to local log;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write VOTE_ABORT to local log;</span><br><span class="line">        send VOTE_ABORT to coordinator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">每个参与者维护一个线程处理其它参与者的DECISION_REQUEST请求：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">true</span> &#123;</span><br><span class="line">        wait until any incoming DECISION_REQUEST is received;</span><br><span class="line">        read most recently recorded STATE from the local log;</span><br><span class="line">        <span class="keyword">if</span> STATE == GLOBAL_COMMIT</span><br><span class="line">            send GLOBAL_COMMIT to requesting participant;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> STATE == INIT or STATE == GLOBAL_ABORT;</span><br><span class="line">            send GLOBAL_ABORT to requesting participant;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            skip;  <span class="comment">/* participant remains blocked */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>至此我们已经详细的分析的 2PC 的各种细节，我们来总结一下！</strong></p><ul><li><p>2PC 是一种<strong>尽量保证强一致性</strong>的分布式事务，因此它是<strong>同步阻塞</strong>的，而同步阻塞就导致长久的资源锁定问题，<strong>总体而言效率低</strong></p></li><li><p>并且存在<strong>单点故障</strong>问题，在极端条件下存在<strong>数据不一致</strong>的风险。</p></li><li><p>当然具体的实现可以变形，而且 2PC 也有变种，例如 <code>Tree 2PC</code>、<code>Dynamic 2PC</code>。</p></li><li><p>还有一点不知道你们看出来没，2PC 适用于<strong>数据库层面的分布式事务场景</strong>，而我们业务需求有时候不仅仅关乎数据库，也有可能是上传一张图片或者发送一条短信。</p><ul><li>而且像 Java 中的 JTA 只能解决一个应用下多数据库的分布式事务问题，跨服务了就不能用了。</li></ul></li><li><p>简单说下 Java 中 JTA，它是基于XA规范实现的事务接口，这里的 XA 你可以简单理解为基于数据库的 XA 规范来实现的 2PC。（至于XA规范到底是啥，篇幅有限，下次有机会再说）</p></li></ul><p><strong>接下来我们再来看看 3PC。</strong></p><h3 id="2-2-3PC"><a href="#2-2-3PC" class="headerlink" title="2.2 3PC"></a>2.2 3PC</h3><ul><li>3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在<strong>参与者中也引入了超时机制</strong>，并且<strong>新增了一个阶段</strong>使得参与者可以利用这一个阶段统一各自的状态。</li></ul><p><strong>让我们来详细看一下。</strong></p><ul><li><p>3PC 包含了三个阶段，分别是<strong>准备阶段、预提交阶段和提交阶段</strong>，对应的英文就是：<code>CanCommit、PreCommit 和 DoCommit</code>。</p></li><li><p>看起来是<strong>把 2PC 的提交阶段变成了预提交阶段和提交阶段</strong>，但是 3PC 的准备阶段协调者只是询问参与者的自身状况，比如你现在还好吗？负载重不重？这类的。</p></li><li><p>而预提交阶段就是和 2PC 的准备阶段一样，除了事务的提交该做的都做了。</p></li></ul><p>提交阶段和 2PC 的一样，让我们来看一下图。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/193308241.png" alt="mark"></p><p>我们先来看一下 3PC 的阶段变更有什么影响。</p><ul><li>首先<strong>准备阶段的变更成不会直接执行事务</strong>，而是会先去询问此时的参与者是否有条件接这个事务，因此<strong>不会一来就干活直接锁资源</strong>，使得在某些资源不可用的情况下所有参与者都阻塞着。</li><li>而<strong>预提交阶段的引入起到了一个统一状态的作用</strong>，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。<ul><li>假如你是一位参与者，你知道自己进入了预提交状态那你就可以推断出来其他参与者也都进入了预提交状态。</li></ul></li><li>但是多引入一个阶段也多一个交互，因此<strong>性能会差一些</strong>，而且<strong>绝大部分的情况下资源应该都是可用的</strong>，这样等于每次明知可用执行还得询问一次。</li></ul><p>我们再来看下参与者超时能带来什么样的影响。</p><ul><li>我们知道 2PC 是同步阻塞的，上面我们已经分析了协调者挂在了提交请求还未发出去的时候是最伤的，所有参与者都已经锁定资源并且阻塞等待着。</li><li>那么引入了超时机制，参与者就不会傻等了，<strong>如果是等待提交命令超时，那么参与者就会提交事务了</strong>，因为都到了这一阶段了大概率是提交的，<strong>如果是等待预提交命令超时，那该干啥就干啥了，反正本来啥也没干</strong>。</li><li>然而超时机制也会带来数据不一致的问题，比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是<strong>有可能执行的是回滚操作，这样一来数据就不一致了</strong>。</li></ul><p>从维基百科上看，3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题。</p><ul><li>新协调者来的时候发现有一个参与者处于预提交或者提交阶段，那么表明已经经过了所有参与者的确认了，所以此时执行的就是提交命令。</li><li>所以说 3PC 就是通过引入预提交阶段来使得参与者之间的状态得到统一，也就是留了一个阶段让大家同步一下。</li><li>但是这也只能让协调者知道该如果做，但不能保证这样做一定对，这其实和上面 2PC 分析一致，因为挂了的参与者到底有没有执行事务无法断定。</li><li>所以说 3PC 通过预提交阶段可以减少故障恢复时候的复杂性，但是不能保证数据一致，除非挂了的那个参与者恢复。</li></ul><p><strong>小结:</strong></p><ul><li>3PC 相对于 2PC 做了一定的改进：引入了参与者超时机制，并且增加了预提交阶段使得故障恢复之后协调者的决策复杂度降低，但整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。</li><li>所以 2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制。</li><li>我再说下 3PC 我没有找到具体的实现，所以我认为 3PC 只是纯的理论上的东西，而且可以看到相比于 2PC 它是做了一些努力但是效果甚微，所以只做了解即可。</li></ul><h3 id="2-3-TCC"><a href="#2-3-TCC" class="headerlink" title="2.3 TCC"></a>2.3 TCC</h3><ul><li><strong>2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务</strong>，就像我前面说的分布式事务不仅仅包括数据库的操作，还包括发送短信等，这时候 TCC 就派上用场了！</li></ul><p><strong>TCC</strong> 指的是<code>Try - Confirm - Cancel</code>。</p><ul><li>Try 指的是预留，即资源的预留和锁定，<strong>注意是预留</strong>。</li><li>Confirm 指的是确认操作，这一步其实就是真正的执行了。</li><li>Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。</li></ul><ul><li>其实从思想上看和 2PC 差不多，都是先试探性的执行，如果都可以那就真正的执行，如果不行就回滚。</li><li>比如说一个事务要执行A、B、C三个操作，那么先对三个操作执行预留动作。如果都预留成功了那么就执行确认操作，如果有一个预留失败那就都执行撤销动作。</li></ul><p>我们来看下流程，TCC模型还有个事务管理者的角色，用来记录TCC全局事务状态并提交或者回滚事务。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/193720663.png" alt="mark"></p><ul><li><p>可以看到流程还是很简单的，难点在于业务上的定义，对于每一个操作你都需要定义三个动作分别对应<code>Try - Confirm - Cancel</code>。</p></li><li><p>因此 <strong>TCC 对业务的侵入较大和业务紧耦合</strong>，需要根据特定的场景和业务逻辑来设计相应的操作。</p></li><li><p>还有一点要注意，撤销和确认操作的执行可能需要重试，因此还需要保证<strong>操作的幂等</strong>。</p></li></ul><p><strong>小结</strong></p><ul><li>相对于 2PC、3PC ，TCC 适用的范围更大，但是开发量也更大，毕竟都在业务上实现，而且有时候你会发现这三个方法还真不好写</li><li>不过也因为是在业务上实现的，所以<strong>TCC可以跨数据库、跨不同的业务系统来实现事务</strong>。</li></ul><h3 id="2-4-本地消息表"><a href="#2-4-本地消息表" class="headerlink" title="2.4 本地消息表"></a>2.4 本地消息表</h3><ul><li>本地消息表其实就是利用了 <strong>各系统本地的事务</strong>来实现分布式事务。</li><li>本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 <strong>将业务的执行和将消息放入消息表中的操作放在同一个事务中</strong>，这样就能保证消息放入本地表中业务肯定是执行成功的。</li><li>然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。</li><li>如果调用失败也没事，会有 <strong>后台任务定时去读取本地消息表</strong>，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。<ul><li>这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是幂等的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。</li></ul></li></ul><p><strong>小结</strong></p><ul><li>可以看到本地消息表其实实现的是<strong>最终一致性</strong>，容忍了数据暂时不一致的情况。</li></ul><h3 id="2-5-消息事务"><a href="#2-5-消息事务" class="headerlink" title="2.5 消息事务"></a>2.5 消息事务</h3><ul><li>RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。</li><li>第一步先给 Broker 发送事务消息即半消息，<strong>半消息不是说一半消息，而是这个消息对消费者来说不可见</strong>，然后<strong>发送成功后发送方再执行本地事务</strong>。</li><li>再根据<strong>本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令</strong>。</li><li>并且 RocketMQ 的发送方会提供一个<strong>反查事务状态接口</strong>，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。</li><li>如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。</li><li>如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。</li><li>可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/194126985.png" alt="mark"></p><p><strong>小结</strong></p><ul><li>可以看到消息事务实现的也是<strong>最终一致性</strong>。</li></ul><h3 id="2-6-最大努力通知"><a href="#2-6-最大努力通知" class="headerlink" title="2.6 最大努力通知"></a>2.6 最大努力通知</h3><ul><li>其实我觉得本地消息表也可以算最大努力，事务消息也可以算最大努力。</li><li>就<strong>本地消息表</strong>来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。</li><li>事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。</li></ul><p><strong>小结：</strong></p><ul><li>所以<strong>最大努力通知其实只是表明了一种柔性事务的思想</strong>：我已经尽力我最大的努力想达成事务的最终一致了。</li><li>适用于对时间不敏感的业务，例如短信通知。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>可以看出 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。</li><li>而 TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。</li><li>本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;事务想必大家并不陌生，至于什么是 ACID，也是老生常谈了。&lt;/li&gt;
&lt;li&gt;还是得先说说 ACID，然后再来介绍下什么是分布式事务和常见的分布式事务包括 2PC、3PC、TCC、本地消息表、消息事务、最大努力通知。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式事务" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>排序-01-堆排序</title>
    <link href="http://zhuuu.work/2020/08/12/Sort/%E6%8E%92%E5%BA%8F-01-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/08/12/Sort/%E6%8E%92%E5%BA%8F-01-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-12T10:32:24.000Z</published>
    <updated>2020-09-26T08:34:34.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-01-堆排序"><a href="#排序-01-堆排序" class="headerlink" title="排序-01-堆排序"></a>排序-01-堆排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</li></ul><h2 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h2><ul><li>堆是具有如下性质的完全二叉树<ul><li>每个节点的值都大于或者等于其左右孩子节点的值，成为大顶堆</li><li>每个节点的值都小于或者等于其左右孩子节点的值，成为小顶堆</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210713650.png" alt="mark"></p><p>同时，将堆中节点按照层级进行编号，将这种逻辑结构映射到数组中就是如下的例子</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210812092.png" alt="mark"></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p><a id="more"></a><h2 id="2-堆排序介绍"><a href="#2-堆排序介绍" class="headerlink" title="2. 堆排序介绍"></a>2. 堆排序介绍</h2><ul><li>堆排序(Heap Sort) 是指利用堆这种数据结构所涉及的一种排序算法。</li><li><strong>将n个无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></li><li><strong>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></li><li><strong>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></li></ul><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/211132796.png" alt="mark"></p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><h2 id="3-大顶堆实现堆排"><a href="#3-大顶堆实现堆排" class="headerlink" title="3. 大顶堆实现堆排"></a>3. 大顶堆实现堆排</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"排序前："</span>+Arrays.toString(arr));</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(<span class="string">"排序前："</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-202023330.gif" alt="mark"></p><h2 id="4-小顶堆实现堆排以及TopK"><a href="#4-小顶堆实现堆排以及TopK" class="headerlink" title="4. 小顶堆实现堆排以及TopK"></a>4. 小顶堆实现堆排以及TopK</h2><p><strong>小顶堆实现 (堆排序 以及 topk)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        buildHeap(tree, n);<span class="comment">//第一步是将得到的数组构建成小顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            swap(tree, i, <span class="number">0</span>);<span class="comment">//第一次构建完小顶堆之后，要进行第一个数和最后一个树的交换</span></span><br><span class="line">            <span class="comment">//交换完之后，最上面的数就不是最小数了，因此只需要对最上面的数，进行一个树的调整即可</span></span><br><span class="line">            <span class="comment">//所以，我们使用的时adjustTree而不是buildHeap</span></span><br><span class="line">            adjustTree(tree, i, <span class="number">0</span>);<span class="comment">//这里解释一下，这参数的含义：之所以将i当做数组的长度，</span></span><br><span class="line">            <span class="comment">//是因为我们将第一个数和最后一个数交换之后，就已经把最小的数放在了数组最后，进行</span></span><br><span class="line">            <span class="comment">//树调整的时候，就不需要管最后一个数字了。而0就是因为交换之后需要进行节点调节的那个节点</span></span><br><span class="line">            <span class="comment">//换到了第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这个函数写完之后，就可以将任意一个数组，构建成小顶堆了，构建完小顶堆之后，就要进行堆排序了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (n-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="comment">//i从最后一个子节点的父节点开始，所以i = (n-1)/2</span></span><br><span class="line">            adjustTree(tree, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用adjustTree和swap两个函数，可以针对某一个父节点，进行调节。接下来，解决当整个树是</span></span><br><span class="line">    <span class="comment">//乱序的，将一个树构建成一个小顶堆。思路是这样的：从最后一个子节点的父节点开始调节，往上走。</span></span><br><span class="line">    <span class="comment">//不断重复，每往上一个父节点，父节点的下标就减一，可以将adjustTree和swap函数放进一个for循环</span></span><br><span class="line">    <span class="comment">//就是上面的for循环</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 表示从某一个节点开始，调整一次树，使之成为堆，其中i表示某一个节点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustTree</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n) &#123;<span class="comment">//这是递归头。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先确定i节点的左右两个孩子的下标</span></span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c2 = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//接下来，在这三个值中，找出最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = i;<span class="comment">//先假设最小值为这个父节点</span></span><br><span class="line">        <span class="keyword">if</span>(c1&lt;n &amp;&amp; tree[c1]&gt;tree[max]) &#123;<span class="comment">//要保证c1不会出界</span></span><br><span class="line">            max = c1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c2&lt;n &amp;&amp; tree[c2]&gt;tree[max]) &#123;<span class="comment">//保证c2不会出界  c2&lt;n</span></span><br><span class="line">            max = c2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的条件判断，就可以将最小值的下标保存到max中了，如果最小值max就是i，也就是</span></span><br><span class="line">        <span class="comment">//父节点最小，就不用调整，但是如果父节点不是最小，就要进行交换了</span></span><br><span class="line">        <span class="keyword">if</span>(max!=i) &#123;</span><br><span class="line">            swap(tree,max,i);</span><br><span class="line">            adjustTree(tree,n,max);<span class="comment">//交换之后，将父节点下放一级，就有可能会破坏下一层结构，</span></span><br><span class="line">            <span class="comment">//所以，递归调用adjustTree.使用递归之后，就要添加递归头了</span></span><br><span class="line">        &#125;              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] tree, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = tree[i];</span><br><span class="line">        tree[i] = tree[j];</span><br><span class="line">        tree[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">32</span>, <span class="number">56</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">32</span>&#125;;<span class="comment">//原始数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] topk = topK(data, <span class="number">5</span>);<span class="comment">//调用topK方法，返回前k大的数组，返回的数组并不是有序的，而是一个小顶堆，如果想返回一个有序的，可以调用上面HeapSort类中的heapSort方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; topk.length; i++) &#123;<span class="comment">//循环输出小顶堆</span></span><br><span class="line">            System.out.println(topk[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topK(<span class="keyword">int</span>[] data, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] topk = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//根据传进来的K创建长度为k的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            topk[i] = data[i];<span class="comment">//先将源数据的前k个的数赋值给topK数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeapSort.buildHeap(topk, k);<span class="comment">//对这个topK数组进行一次最小堆的构建。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; data.length; i++) &#123;<span class="comment">//从源数据的第K个数开始循环，如果循环的数比堆顶元素还小，直接pass，</span></span><br><span class="line">            <span class="comment">// 如果比堆顶元素要大，就将此数放在堆顶，同时进行一次以它为起始点的树的调整。</span></span><br><span class="line">            <span class="keyword">int</span> temp = data[i];</span><br><span class="line">            <span class="keyword">if</span> (topk[<span class="number">0</span>] &lt; temp) &#123;</span><br><span class="line">                topk[<span class="number">0</span>] = temp;</span><br><span class="line">                HeapSort.adjustTree(topk, k, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再简单总结下堆排序的基本思路：</p><p>　　<strong>a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-01-堆排序&quot;&gt;&lt;a href=&quot;#排序-01-堆排序&quot; class=&quot;headerlink&quot; title=&quot;排序-01-堆排序&quot;&gt;&lt;/a&gt;排序-01-堆排序&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆排序是利用&lt;strong&gt;堆&lt;/strong&gt;这种数据结构而设计的一种排序算法，堆排序是一种&lt;strong&gt;选择排序，&lt;/strong&gt;它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-堆&quot;&gt;&lt;a href=&quot;#1-堆&quot; class=&quot;headerlink&quot; title=&quot;1. 堆&quot;&gt;&lt;/a&gt;1. 堆&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆是具有如下性质的完全二叉树&lt;ul&gt;
&lt;li&gt;每个节点的值都大于或者等于其左右孩子节点的值，成为大顶堆&lt;/li&gt;
&lt;li&gt;每个节点的值都小于或者等于其左右孩子节点的值，成为小顶堆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210713650.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时，将堆中节点按照层级进行编号，将这种逻辑结构映射到数组中就是如下的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210812092.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大顶堆：arr[i] &amp;gt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;gt;= arr[2i+2]&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小顶堆：arr[i] &amp;lt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;lt;= arr[2i+2]&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆排序" scheme="http://zhuuu.work/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-345-反转字符串中的元音字母</title>
    <link href="http://zhuuu.work/2020/08/12/Leetcode/Leetcode-345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/"/>
    <id>http://zhuuu.work/2020/08/12/Leetcode/Leetcode-345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</id>
    <published>2020-08-12T08:33:53.000Z</published>
    <updated>2020-10-08T01:34:46.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-345-反转字符串中的元音字母"><a href="#Leecode-345-反转字符串中的元音字母" class="headerlink" title="Leecode-345-反转字符串中的元音字母"></a>Leecode-345-<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">反转字符串中的元音字母</a></h1><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><p><strong>题目描述：</strong></p><p>将元音字母进行交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given s &#x3D; &quot;leetcode&quot;, return &quot;leotcede&quot;.</span><br></pre></td></tr></table></figure><img src='https://camo.githubusercontent.com/6e66ca91f2688beacd6f9dd3ef2774abb53dda73/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65663235666637632d306636332d343230642d386233302d6561666265656133356431312e676966'><p><strong>Solution：双指针</strong></p><ul><li><p>本题为基础双指针法交换前后元音元素；</p></li><li><p><strong>一般遇见字符串问题，能转成字符数组就尽量转(方便)；</strong></p></li><li><p>转换成数组后，分别定义前后两个索引指针用 while 依次遍历数组；</p></li><li><p>定义 isVowel() 方法将非元音元素返回给判断处，然后移动指针直到符合元音的位置，然后 tmp 进行交换即可；</p></li><li><p>最后扫描完数组后，<strong>一定要在返回的时候再转成字符串 String 输出。</strong></p></li></ul><a id="more"></a><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将字符串转换成字符数组（方便操作）</span></span><br><span class="line">        <span class="comment">// 以上只是针对Java语言来说 因为charAt(i) 每次都要检查是否越界 有性能的消耗</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right= n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环交换</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 从左边判断当前元素是否是元音</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; n &amp;&amp; !isVowel(arr[left]))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从右边判断当前元素是否是元音</span></span><br><span class="line">            <span class="keyword">while</span>(right &gt; <span class="number">0</span> &amp;&amp; !isVowel(arr[right]))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有元音的话</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有的话交换前后的元音字符</span></span><br><span class="line">            swap(arr,left,right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指针后移</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后转换回字符串进行输出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是元音字符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这里直接用return 语句返回，不要返回true 或者 false</span></span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">'a'</span> || ch == <span class="string">'e'</span> || ch == <span class="string">'i'</span> || ch == <span class="string">'o'</span> || ch == <span class="string">'u'</span></span><br><span class="line">                || ch == <span class="string">'A'</span> || ch == <span class="string">'E'</span> || ch == <span class="string">'I'</span> || ch == <span class="string">'O'</span> || ch == <span class="string">'U'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)只需要遍历所有元素一次</li><li>空间复杂度：O(1)只需要使用两个额外的变量</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        vowels = [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>]</span><br><span class="line">        string = list(s)</span><br><span class="line">        i,j = <span class="number">0</span>,len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                string[i],string[j]= string[j],string[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(string)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-345-反转字符串中的元音字母&quot;&gt;&lt;a href=&quot;#Leecode-345-反转字符串中的元音字母&quot; class=&quot;headerlink&quot; title=&quot;Leecode-345-反转字符串中的元音字母&quot;&gt;&lt;/a&gt;Leecode-345-&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-vowels-of-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;反转字符串中的元音字母&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：双指针&quot;&gt;&lt;a href=&quot;#思路：双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：双指针&quot;&gt;&lt;/a&gt;思路：双指针&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将元音字母进行交换&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given s &amp;#x3D; &amp;quot;leetcode&amp;quot;, return &amp;quot;leotcede&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;img src=&#39;https://camo.githubusercontent.com/6e66ca91f2688beacd6f9dd3ef2774abb53dda73/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65663235666637632d306636332d343230642d386233302d6561666265656133356431312e676966&#39;&gt;

&lt;p&gt;&lt;strong&gt;Solution：双指针&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本题为基础双指针法交换前后元音元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;一般遇见字符串问题，能转成字符数组就尽量转(方便)；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;转换成数组后，分别定义前后两个索引指针用 while 依次遍历数组；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义 isVowel() 方法将非元音元素返回给判断处，然后移动指针直到符合元音的位置，然后 tmp 进行交换即可；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后扫描完数组后，&lt;strong&gt;一定要在返回的时候再转成字符串 String 输出。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-11-慢查询优化</title>
    <link href="http://zhuuu.work/2020/08/12/Mysql/Mysql-11-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://zhuuu.work/2020/08/12/Mysql/Mysql-11-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2020-08-12T08:02:27.000Z</published>
    <updated>2020-09-22T14:22:05.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-11-慢查询优化"><a href="#Mysql-11-慢查询优化" class="headerlink" title="Mysql-11-慢查询优化"></a>Mysql-11-慢查询优化</h1><p><strong>注意sql查询慢的原因都是:引起filesort</strong></p><h2 id="1-分析慢查询日志"><a href="#1-分析慢查询日志" class="headerlink" title="1. 分析慢查询日志"></a>1. 分析慢查询日志</h2><ul><li><p>直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句</p><p>   例如：执行<code>EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">得到如下结果： 显示结果分析：  </span><br><span class="line"></span><br><span class="line">            table |  type | possible_keys | key |key_len  | ref | rows | Extra  EXPLAIN列的解释：           </span><br><span class="line"></span><br><span class="line">            table                 显示这一行的数据是关于哪张表的           </span><br><span class="line"></span><br><span class="line">           type                  这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL </span><br><span class="line"></span><br><span class="line">            rows                显示需要扫描行数</span><br><span class="line"></span><br><span class="line">            key                   使用的索引</span><br></pre></td></tr></table></figure><p>以下通过explain显示出mysql执行的字段内容：</p><ul><li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li>select_type: SELECT 查询的类型.</li><li>table: 查询的是哪个表</li><li>partitions: 匹配的分区</li><li>type: join 类型</li><li><strong>possible_keys: 此次查询中可能选用的索引</strong></li><li><strong>key: 此次查询中确切使用到的索引.</strong></li><li>ref: 哪个字段或常数与 key 一起被使用</li><li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li><li>filtered: 表示此查询条件所过滤的数据的百分比</li><li>extra: 额外的信息</li></ul><p><strong>注意 : 可以使用explain命令加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引。</strong></p><a id="more"></a><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><ul><li><p><strong>like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。</strong></p></li><li><p><strong>or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效</strong></p></li><li><p><strong>联合索引，不是使用第一列索引，索引失效。</strong></p></li><li><p><strong>数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。</strong></p></li><li><p><strong>在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</strong></p></li><li><p><strong>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</strong></p></li><li><p><strong>对索引字段进行计算操作、字段上使用函数。（索引为 emp(ename,empno,sal)）</strong></p></li></ul><h2 id="2-优化一：索引"><a href="#2-优化一：索引" class="headerlink" title="2. 优化一：索引"></a>2. 优化一：索引</h2><ul><li><p><strong>使用LIKE关键字的查询语句</strong></p><ul><li>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</li></ul></li><li><p>使用多列索引的查询语句</p></li></ul><p>​    MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</p><h2 id="3-优化二-：-表结构"><a href="#3-优化二-：-表结构" class="headerlink" title="3. 优化二 ： 表结构"></a>3. 优化二 ： 表结构</h2><ul><li>合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，<strong>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</strong></li></ul><ol><li><strong>将字段很多的表分解成多个表</strong> </li></ol><p>​    <strong>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</strong>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><ol start="2"><li><strong>增加中间表</strong></li></ol><p>​    <strong>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中</strong>，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</p><h2 id="4-优化三-：-分解关联查询"><a href="#4-优化三-：-分解关联查询" class="headerlink" title="4. 优化三 ： 分解关联查询"></a>4. 优化三 ： 分解关联查询</h2><p>将一个大的查询分解为多个小查询是很有必要的。<strong>(检查自己的sql是不是写错了)</strong></p><p> 很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag </span><br><span class="line">        JOIN tag_post ON tag_id = tag.id</span><br><span class="line">        JOIN post ON tag_post.post_id = post.id</span><br><span class="line">        WHERE tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line">        分解为：</span><br><span class="line"></span><br><span class="line">        SELECT * FROM tag WHERE tag = <span class="string">'mysql'</span>;</span><br><span class="line">        SELECT * FROM tag_post WHERE tag_id = <span class="number">1234</span>;</span><br><span class="line">        SELECT * FROM post WHERE post.<span class="function">id <span class="title">in</span> <span class="params">(<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="5-优化四：-范围查询优化"><a href="#5-优化四：-范围查询优化" class="headerlink" title="5. 优化四： 范围查询优化"></a>5. 优化四： 范围查询优化</h2><ol><li><strong>优化limit分页</strong></li></ol><ul><li>在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</li><li>一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</li></ul><ol start="2"><li><p><strong>索引覆盖</strong></p><p>优化此类查询的一个最简单的方法是<strong>尽可能的使用索引覆盖扫描</strong>，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p>对于下面的查询：</p></li></ol><p>​    select id,title from collect limit 90000,10;</p><p>   该语句存在的<strong>最大问题在于limit M,N中偏移量M太大</strong>（我们暂不考虑筛选字段上要不要添加索引的影响），导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。 <strong>试想，如我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的100条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到100条满足条件的记录了。</strong></p><h3 id="方法一：虑筛选字段（title）上加索引"><a href="#方法一：虑筛选字段（title）上加索引" class="headerlink" title="方法一：虑筛选字段（title）上加索引"></a>方法一：虑筛选字段（title）上加索引</h3><p>​    title字段加索引 （此效率如何未加验证）</p><h3 id="方法二：先查询出主键id值"><a href="#方法二：先查询出主键id值" class="headerlink" title="方法二：先查询出主键id值"></a>方法二：先查询出主键id值</h3><p><code>select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</code></p><p><strong>原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。</strong></p><h3 id="方法三：-“关延迟联”"><a href="#方法三：-“关延迟联”" class="headerlink" title="方法三：\“关延迟联”**"></a>方法三：<strong><em>\</em>“关延迟联”**</strong></h3><p>如果这个表非常大，那么这个查询可以改写成如下的方式：</p><p>   <code>Select news.id, news.description from news inner join (select id from news order by title limit 50000,5) as myNew using(id);</code></p><p>​    这里的<strong><em>\</em>“关延迟联”**</strong>将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。</p><h3 id="方法四：建立复合索引-acct-id和create-time"><a href="#方法四：建立复合索引-acct-id和create-time" class="headerlink" title="方法四：建立复合索引 acct_id和create_time"></a>方法四：建立复合索引 acct_id和create_time</h3><p>  select * from acct_trans_log WHERE  acct_id = 3095  order by create_time desc limit 0,10</p><h2 id="6-优化五：分析具体的SQL联表（子）查询"><a href="#6-优化五：分析具体的SQL联表（子）查询" class="headerlink" title="6. 优化五：分析具体的SQL联表（子）查询"></a>6. 优化五：分析具体的SQL联表（子）查询</h2><p><strong>1、两个表选哪个为驱动表，表面是可以以数据量的大小作为依据，但是实际经验最好交给mysql查询优化器自己去判断。</strong></p><p><strong>例如： select * from a where id in (select id from b );</strong> </p><ul><li>对于这条sql语句它的执行计划其实并不是先查询出b表的所有id,然后再与a表的id进行比较。<br><strong>mysql会把in子查询转换成exists相关子查询</strong>，所以它实际等同于这条sql语句：select * from a where exists(select * from b where b.id=a.id );</li><li><strong>而exists相关子查询的执行原理是</strong>: 循环取出a表的每一条记录与b表进行比较，比较的条件是a.id=b.id . 看a表的每条记录的id是否在b表存在，如果存在就行返回a表的这条记录。</li></ul><p><strong><em>\</em>exists查询有什么弊端？**</strong><br>   由exists执行原理可知，a表(外表)使用不了索引，必须全表扫描，因为是拿a表的数据到b表查。而且必须得使用a表的数据到b表中查（外表到里表中），顺序是固定死的。</p><p><strong><em>\</em>如何优化？**</strong><br>   建索引。但是由上面分析可知，要建索引只能在b表的id字段建，不能在a表的id上，mysql利用不上。</p><p><strong><em>\</em>为什么要反过来？**</strong><br>    因为首先可以肯定的是反过来的结果也是一样的。这样就又引出了一个更细致的疑问：在双方两个表的id字段上都建有索引时，到底是a表查b表的效率高，还是b表查a表的效率高？</p><p><strong><em>\</em>该如何进一步优化？**</strong><br>    把查询修改成inner join连接查询：select * from a inner join b on a.id=b.id; （但是仅此还不够，接着往下看）</p><p><strong><em>\</em>为什么不用left join 和 right join？**</strong><br>    这时候表之间的连接的顺序就被固定住了，比如左连接就是必须先查左表全表扫描，然后一条一条的到另外表去查询，右连接同理。仍然不是最好的选择。</p><p><strong><em>\</em>为什么使用inner join就可以？**</strong><br>    inner join中的两张表，如： a inner join b，但实际执行的顺序是跟写法的顺序没有半毛钱关系的，最终执行也可能会是b连接a，顺序不是固定死的。如果on条件字段有索引的情况下，同样可以使用上索引。</p><p><strong>那我们又怎么能知道a和b什么样的执行顺序效率更高？</strong><br>    你不知道，我也不知道。谁知道？mysql自己知道。让mysql自己去判断（查询优化器）。具体表的连接顺序和使用索引情况，mysql查询优化器会对每种情况做出成本评估，最终选择最优的那个做为执行计划。</p><p>​    <strong>在inner join的连接中,mysql会自己评估使用a表查b表的效率高还是b表查a表高，如果两个表都建有索引的情况下，mysql同样会评估使用a表条件字段上的索引效率高还是b表的。</strong></p><p><strong>利用explain字段查看执行时运用到的key（索引）</strong><br>    <strong>而我们要做的就是：把两个表的连接条件的两个字段都各自建立上索引，然后explain 一下，查看执行计划，看mysql到底利用了哪个索引，最后再把没有使用索引的表的字段索引给去掉就行了。</strong></p><p><strong>参考博客 ：</strong> <a href="https://www.cnblogs.com/lfs2640666960/p/8550452.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfs2640666960/p/8550452.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-11-慢查询优化&quot;&gt;&lt;a href=&quot;#Mysql-11-慢查询优化&quot; class=&quot;headerlink&quot; title=&quot;Mysql-11-慢查询优化&quot;&gt;&lt;/a&gt;Mysql-11-慢查询优化&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注意sql查询慢的原因都是:引起filesort&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-分析慢查询日志&quot;&gt;&lt;a href=&quot;#1-分析慢查询日志&quot; class=&quot;headerlink&quot; title=&quot;1. 分析慢查询日志&quot;&gt;&lt;/a&gt;1. 分析慢查询日志&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句&lt;/p&gt;
&lt;p&gt;   例如：执行&lt;code&gt;EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;得到如下结果： 显示结果分析：  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            table |  type | possible_keys | key |key_len  | ref | rows | Extra  EXPLAIN列的解释：           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            table                 显示这一行的数据是关于哪张表的           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           type                  这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            rows                显示需要扫描行数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            key                   使用的索引&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以下通过explain显示出mysql执行的字段内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.&lt;/li&gt;
&lt;li&gt;select_type: SELECT 查询的类型.&lt;/li&gt;
&lt;li&gt;table: 查询的是哪个表&lt;/li&gt;
&lt;li&gt;partitions: 匹配的分区&lt;/li&gt;
&lt;li&gt;type: join 类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;possible_keys: 此次查询中可能选用的索引&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;key: 此次查询中确切使用到的索引.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ref: 哪个字段或常数与 key 一起被使用&lt;/li&gt;
&lt;li&gt;rows: 显示此查询一共扫描了多少行. 这个是一个估计值.&lt;/li&gt;
&lt;li&gt;filtered: 表示此查询条件所过滤的数据的百分比&lt;/li&gt;
&lt;li&gt;extra: 额外的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意 : 可以使用explain命令加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-类初始化造成的死锁</title>
    <link href="http://zhuuu.work/2020/08/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%A0%E6%88%90%E7%9A%84%E6%AD%BB%E9%94%81/"/>
    <id>http://zhuuu.work/2020/08/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%A0%E6%88%90%E7%9A%84%E6%AD%BB%E9%94%81/</id>
    <published>2020-08-12T04:38:38.000Z</published>
    <updated>2020-09-17T01:41:40.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-类初始化造成的死锁"><a href="#Java-基础-类初始化造成的死锁" class="headerlink" title="Java-基础-类初始化造成的死锁"></a>Java-基础-类初始化造成的死锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于类初始化有几个关键特性：</p><ul><li>类初始化的过程其实就是执行类构造器方法<clinit>()的过程；</li><li>在子类初始化完成时，虚拟机会保证其父类有初始化完成；</li><li>多线程环境下，虚拟机执行<clinit>()方法会自动加锁；</li></ul><p>在java中，死锁肯定是在多线程环境下产生的。<strong>多个线程同时需要互相持有的某个资源，自己的资源无法释放，别人的资源又无法得到，造成循环依赖</strong>，进而一直阻塞在那里，这样就形成死锁了。</p><a id="more"></a><h2 id="1-两个类初始化互相依赖"><a href="#1-两个类初始化互相依赖" class="headerlink" title="1. 两个类初始化互相依赖"></a>1. 两个类初始化互相依赖</h2><ul><li>最明显的情况是，2个类在不同的线程中初始化，彼此互相依赖，我们来看个例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"class A init."</span>);</span><br><span class="line">            B b = <span class="keyword">new</span> B();</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"method test called in class A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"class B init."</span>);</span><br><span class="line">            A a = <span class="keyword">new</span> A();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"method test called in class B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                A.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;).start();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                B.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">init</span>.</span></span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 第一个线程执行A.test()的时候，开始初始化类A，该线程获得A.class的锁，第二个线程执行B.test()的时候，开始初始化类B，该线程获得B.class的锁。</span><br><span class="line">2. A在初始化过程中执行代码B b = new B()的时候，发现类B还没有初始化完成，于是尝试获得类B.class的锁；</span><br><span class="line">3. 类B在初始化时执行代码A a = new A()，发现类A也没有初始化完成，于是尝试获得类A.class的锁，但A.class锁已被占用，所以该线程会阻塞住，并等待该锁的释放；</span><br><span class="line">4. 同样第一个线程阻塞住并等待B.class锁的释放，这样就造成循环依赖，形成了死锁。</span><br></pre></td></tr></table></figure><ul><li>如果把上面代码改为如下执行方式，会出现什么结果呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A.test();</span><br><span class="line">    B.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终执行结果为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">method</span> <span class="title">test</span> <span class="title">called</span> <span class="title">in</span> <span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"><span class="title">method</span> <span class="title">test</span> <span class="title">called</span> <span class="title">in</span> <span class="title">class</span> <span class="title">B</span></span></span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 乍一看去，好像A初始化时依赖B，B初始化时依赖A，也会造成死锁，但实际上并不会。</span><br><span class="line">2. A、B两个类的初始化都是在同一个线程里执行的，初始化A的时候，该线程会获得A.class锁，初始化B时会获得B.class锁，而在初始化B时又需要A</span><br><span class="line">3. 但是这2个初始化都是在同一个线程里执行的，该线程会同时获得这2个锁，因此并不会发生锁资源的抢占</span><br></pre></td></tr></table></figure><h2 id="2-子类，父类初始化造成死锁"><a href="#2-子类，父类初始化造成死锁" class="headerlink" title="2. 子类，父类初始化造成死锁"></a>2. 子类，父类初始化造成死锁</h2><ul><li>与第一种情况相比，这种情况造成的死锁会更隐蔽一点，但它们实质上都是同样的原因，来看个具体的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Parent init."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parent EMPTY = <span class="keyword">new</span> Child();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test called in class Parent."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Child init."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Child c = <span class="keyword">new</span> Child();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Parent.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent init.</span><br></pre></td></tr></table></figure><p>我们来分析下造成死锁的原因：</p><ul><li>线程t1执行时会触发Child类的初始化，线程t2执行时会触发Parent类的初始化；</li><li>紧接着线程<code>t1</code>持有<code>Child.class</code>锁，<code>t2</code>持有<code>Parent.class</code>锁，<code>t1</code>初始化时需要先初始化其父类<code>Parent</code></li><li>而类Parent有个常量定义“<strong>public static final Parent EMPTY = new Child();</strong>”，这样类Parent在初始化时需要初始化Child；</li><li>这样线程t1要初始化Parent，尝试获取<code>Parent.class</code>锁，线程t2要初始化Child，尝试获取<code>Child.class</code>锁，彼此互相不能释放资源，因此造成死锁。</li></ul><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><ul><li>在上面这个案例中，我们知道是类初始化时造成了死锁。子类依赖了父类，而父类在初始化过程中又依赖了子类，为了避免这种情况，</li><li>我们<strong>采取了预先在主线程中将数据库相关类全部初始化的方式。</strong><br> 在应用入口处，我们作了如下处理：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Class.forName(<span class="string">"AnnouncementInfo"</span>);</span><br><span class="line">Class c2 = Class.forName(<span class="string">"......"</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li><strong>这样在应用启动时，所有相关类都已经初始化完成(一次性分配了所有资源)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-类初始化造成的死锁&quot;&gt;&lt;a href=&quot;#Java-基础-类初始化造成的死锁&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-类初始化造成的死锁&quot;&gt;&lt;/a&gt;Java-基础-类初始化造成的死锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于类初始化有几个关键特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类初始化的过程其实就是执行类构造器方法&lt;clinit&gt;()的过程；&lt;/li&gt;
&lt;li&gt;在子类初始化完成时，虚拟机会保证其父类有初始化完成；&lt;/li&gt;
&lt;li&gt;多线程环境下，虚拟机执行&lt;clinit&gt;()方法会自动加锁；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在java中，死锁肯定是在多线程环境下产生的。&lt;strong&gt;多个线程同时需要互相持有的某个资源，自己的资源无法释放，别人的资源又无法得到，造成循环依赖&lt;/strong&gt;，进而一直阻塞在那里，这样就形成死锁了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="死锁" scheme="http://zhuuu.work/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="循环依赖" scheme="http://zhuuu.work/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux-00-常用指令</title>
    <link href="http://zhuuu.work/2020/08/11/Linux/Linux-00-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://zhuuu.work/2020/08/11/Linux/Linux-00-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2020-08-11T03:52:53.000Z</published>
    <updated>2020-09-22T07:25:01.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-00-常用指令"><a href="#Linux-00-常用指令" class="headerlink" title="Linux-00-常用指令"></a>Linux-00-常用指令</h1><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关机</span><br><span class="line">    shutdown -h now        立刻关机</span><br><span class="line">    shutdown -h 5        5分钟后关机</span><br><span class="line">    poweroff            立刻关机</span><br><span class="line">重启</span><br><span class="line">    shutdown -r now        立刻重启</span><br><span class="line">    shutdown -r 5        5分钟后重启</span><br><span class="line">    reboot                立刻重启</span><br><span class="line">    </span><br><span class="line">ifconfig  --help：查看网卡信息</span><br></pre></td></tr></table></figure><h2 id="2-目录操作指令"><a href="#2-目录操作指令" class="headerlink" title="2. 目录操作指令"></a>2. 目录操作指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd命令</span><br><span class="line"></span><br><span class="line">该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令：cd 目录</span><br><span class="line"></span><br><span class="line">cd &#x2F;        切换到根目录</span><br><span class="line">cd &#x2F;usr        切换到根目录下的usr目录</span><br><span class="line">cd ..&#x2F;        切换到上一级目录 或者  cd ..</span><br><span class="line">cd ~        切换到home目录</span><br><span class="line">cd -        切换到上次访问的目录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令：ls [-al]</span><br><span class="line"></span><br><span class="line">ls                查看当前目录下的所有目录和文件</span><br><span class="line">ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class="line">ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）</span><br><span class="line">ls &#x2F;dir            查看指定目录下的所有目录和文件   如：ls &#x2F;usr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令：mkdir 目录</span><br><span class="line"></span><br><span class="line">mkdir    aaa            在当前目录下创建一个名为aaa的目录</span><br><span class="line">mkdir    &#x2F;usr&#x2F;aaa    在指定目录下创建一个名为aaa的目录</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">命令：rm [-rf] 目录</span><br><span class="line"></span><br><span class="line">删除文件：</span><br><span class="line">rm 文件        删除当前目录下的文件</span><br><span class="line">rm -f 文件    删除当前目录的的文件（不询问）</span><br><span class="line"></span><br><span class="line">删除目录：</span><br><span class="line">rm -r aaa    递归删除当前目录下的aaa目录</span><br><span class="line">rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</span><br><span class="line"></span><br><span class="line">全部删除：</span><br><span class="line">rm -rf *    将当前目录下的所有目录和文件全部删除</span><br><span class="line">rm -rf &#x2F;*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</span><br><span class="line"></span><br><span class="line">注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录&#x2F;文件&#x2F;压缩包</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一、重命名目录</span><br><span class="line">    命令：mv 当前目录  新目录</span><br><span class="line">    例如：mv aaa bbb    将目录aaa改为bbb</span><br><span class="line">    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</span><br><span class="line"></span><br><span class="line">二、剪切目录</span><br><span class="line">    命令：mv 目录名称 目录的新位置</span><br><span class="line">    示例：将&#x2F;usr&#x2F;tmp目录下的aaa目录剪切到 &#x2F;usr目录下面     mv &#x2F;usr&#x2F;tmp&#x2F;aaa &#x2F;usr</span><br><span class="line">    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</span><br><span class="line"></span><br><span class="line">三、拷贝目录</span><br><span class="line">    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归</span><br><span class="line">    示例：将&#x2F;usr&#x2F;tmp目录下的aaa目录复制到 &#x2F;usr目录下面     cp &#x2F;usr&#x2F;tmp&#x2F;aaa  &#x2F;usr</span><br><span class="line">    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令：find 目录 参数 文件名称</span><br><span class="line">示例：find &#x2F;usr&#x2F;tmp -name &#39;a*&#39;    查找&#x2F;usr&#x2F;tmp目录下的所有以a开头的目录或文件</span><br></pre></td></tr></table></figure><h2 id="3-文件操作命令"><a href="#3-文件操作命令" class="headerlink" title="3. 文件操作命令"></a>3. 文件操作命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令：touch 文件名</span><br><span class="line">示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt</span><br><span class="line"></span><br><span class="line">命令：rm -rf 文件名</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_31142553/article/details/82949867" target="_blank" rel="noopener">https://blog.csdn.net/qq_31142553/article/details/82949867</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">【vi编辑器的3种模式】</span><br><span class="line">    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</span><br><span class="line">1) 命令行模式command mode）</span><br><span class="line">      控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。</span><br><span class="line">      命令行模式下的常用命令：</span><br><span class="line">      【1】控制光标移动：↑，↓，j</span><br><span class="line">      【2】删除当前行：dd </span><br><span class="line">      【3】查找：&#x2F;字符</span><br><span class="line">      【4】进入编辑模式：i o a</span><br><span class="line">      【5】进入底行模式：:</span><br><span class="line">      </span><br><span class="line">2) 编辑模式（Insert mode）</span><br><span class="line">      只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。</span><br><span class="line">      编辑模式下常用命令：</span><br><span class="line">      【1】ESC 退出编辑模式到命令行模式；</span><br><span class="line">      </span><br><span class="line">3) 底行模式（last line mode）</span><br><span class="line">     将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</span><br><span class="line">     底行模式下常用命令：</span><br><span class="line">     【1】退出编辑：   :q</span><br><span class="line">     【2】强制退出：   :q!</span><br><span class="line">     【3】保存并退出：  :wq</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">打开文件</span><br><span class="line"></span><br><span class="line">命令：vi 文件名</span><br><span class="line">示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt</span><br><span class="line"></span><br><span class="line">注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i&#x2F;a&#x2F;o进入编辑模式。</span><br><span class="line"></span><br><span class="line">编辑文件</span><br><span class="line"></span><br><span class="line">使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</span><br><span class="line"></span><br><span class="line">i:在光标所在字符前开始插入</span><br><span class="line">a:在光标所在字符后开始插入</span><br><span class="line">o:在光标所在行的下面另起一新行插入</span><br><span class="line"></span><br><span class="line">保存或者取消编辑</span><br><span class="line"></span><br><span class="line">保存文件：</span><br><span class="line"></span><br><span class="line">第一步：ESC  进入命令行模式</span><br><span class="line">第二步：:     进入底行模式</span><br><span class="line">第三步：wq     保存并退出编辑</span><br><span class="line"></span><br><span class="line">取消编辑：</span><br><span class="line"></span><br><span class="line">第一步：ESC  进入命令行模式</span><br><span class="line">第二步：:     进入底行模式</span><br><span class="line">第三步：q!     撤销本次修改并退出编辑</span><br></pre></td></tr></table></figure><p><strong>文件的查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">文件的查看命令：cat&#x2F;more&#x2F;less&#x2F;tail</span><br><span class="line"></span><br><span class="line">cat：看最后一屏</span><br><span class="line"></span><br><span class="line">示例：使用cat查看&#x2F;etc&#x2F;sudo.conf文件，只能显示最后一屏内容</span><br><span class="line">cat sudo.conf</span><br><span class="line"></span><br><span class="line">more：百分比显示</span><br><span class="line"></span><br><span class="line">示例：使用more查看&#x2F;etc&#x2F;sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看</span><br><span class="line">more sudo.conf</span><br><span class="line"></span><br><span class="line">less：翻页查看</span><br><span class="line"></span><br><span class="line">示例：使用less查看&#x2F;etc&#x2F;sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看</span><br><span class="line">less sudo.conf</span><br><span class="line"></span><br><span class="line">tail：指定行数或者动态查看</span><br><span class="line"></span><br><span class="line">示例：使用tail -10 查看&#x2F;etc&#x2F;sudo.conf文件的后10行，Ctrl+C结束  </span><br><span class="line">tail -10 sudo.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</span><br><span class="line"></span><br><span class="line">示例：给aaa.txt文件权限改为可执行文件权限，aaa.txt文件的权限是-rw-------</span><br><span class="line"></span><br><span class="line">第一位：-就代表是文件，d代表是文件夹</span><br><span class="line">第一段（3位）：代表拥有者的权限</span><br><span class="line">第二段（3位）：代表拥有者所在的组，组员的权限</span><br><span class="line">第三段（最后3位）：代表的是其他用户的权限</span><br><span class="line"></span><br><span class="line">   421  421  421</span><br><span class="line">-  rw-   ---     ---</span><br><span class="line"></span><br><span class="line">命令：chmod +x aaa.txt</span><br><span class="line">或者采用8421法</span><br><span class="line">命令：chmod 100 aaa.txt</span><br></pre></td></tr></table></figure><p><strong>head命令</strong></p><ul><li>可以用来查看文件的开头部分。此命令的格式是：</li></ul><p><code>head 文件名</code></p><p>默认设置，它只查看文件的前10行。但可以通过指定一个数字选项来改变要显示的行数，命令如下：</p><p><code>head –20 文件名</code></p><p>这个命令将会查看文件的前20行。</p><p><strong>tail命令</strong></p><ul><li>和head命令恰恰相反。使用tail命令，可以查看文件结尾的10行。这有助于查看日 志文件的最后10行来阅读重要的系统信息。还可以使用tail观察日志文件更新的过程。</li><li>使用-f选项，tail会自动实时地把打开文件中的新信息显示到屏 幕上。例如，要活跃地观察<code>/var/log/messages</code>，以根用户身份在shell下输入以下命令：</li></ul><p><code>tail –f /var/log/messages</code></p><h2 id="4-压缩文件"><a href="#4-压缩文件" class="headerlink" title="4. 压缩文件"></a>4. 压缩文件</h2><h3 id="4-1-打包和压缩"><a href="#4-1-打包和压缩" class="headerlink" title="4.1 打包和压缩"></a>4.1 打包和压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">linux中的打包文件：aa.tar      </span><br><span class="line">linux中的压缩文件：bb.gz    </span><br><span class="line">linux中打包并压缩的文件：.tar.gz</span><br><span class="line"></span><br><span class="line">Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</span><br><span class="line">而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</span><br><span class="line"></span><br><span class="line">命令：tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class="line">其中：z：调用gzip压缩命令进行压缩</span><br><span class="line">  c：打包文件</span><br><span class="line">  v：显示运行过程</span><br><span class="line">  f：指定文件名</span><br><span class="line">  </span><br><span class="line">示例：打包并压缩&#x2F;usr&#x2F;tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar</span><br><span class="line">tar -zcvf ab.tar aa.txt bb.txt </span><br><span class="line">或：tar -zcvf ab.tar  *</span><br></pre></td></tr></table></figure><h3 id="4-2-解压"><a href="#4-2-解压" class="headerlink" title="4.2 解压"></a>4.2 解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令：tar [-zxvf] 压缩文件   </span><br><span class="line">其中：x：代表解压</span><br><span class="line">示例：将&#x2F;usr&#x2F;tmp 下的ab.tar解压到当前目录下</span><br><span class="line"></span><br><span class="line">示例：将&#x2F;usr&#x2F;tmp 下的ab.tar解压到根目录&#x2F;usr下</span><br><span class="line">tar -xvf ab.tar -C &#x2F;usr------C代表指定解压的位置</span><br></pre></td></tr></table></figure><h2 id="5-查找命令"><a href="#5-查找命令" class="headerlink" title="5. 查找命令"></a>5. 查找命令</h2><p>grep命令是一种强大的文本搜索工具</p><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd  查找指定ssh服务进程 </span><br><span class="line">ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除gerp身 </span><br><span class="line">ps -ef | grep sshd -c 查找指定进程个数 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grep命令的最大功能是在一堆文件中查找一个特定的字符串。</span><br><span class="line"></span><br><span class="line">grep money test.txt</span><br></pre></td></tr></table></figure><p>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 </p><p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; -ls  在当前目录查找以.log结尾的文件，并显示详细信息。 </span><br><span class="line">find &#x2F;root&#x2F; -perm 600   查找&#x2F;root&#x2F;目录下权限为600的文件 </span><br><span class="line">find . -type f -name &quot;*.log&quot;  查找当目录，以.log结尾的普通文件 </span><br><span class="line">find . -type d | sort   查找当前所有目录并排序 </span><br><span class="line">find . -size +100M  查找当前目录大于100M的文件</span><br></pre></td></tr></table></figure><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。</p><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis ls    将和ls文件相关的文件都查找出来</span><br></pre></td></tr></table></figure><p><code>which</code>命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which pwd  查找pwd命令所在路径 </span><br><span class="line">which java  查找path中java的路径</span><br></pre></td></tr></table></figure><h2 id="6-磁盘空间"><a href="#6-磁盘空间" class="headerlink" title="6. 磁盘空间"></a>6. 磁盘空间</h2><p>有关磁盘空间的命令</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>mount</td><td>挂载文件系统</td></tr><tr><td>umount</td><td>卸载已挂载上的文件系统</td></tr><tr><td>df</td><td>检查各个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td>du</td><td>显示文件目录和大小</td></tr><tr><td>fsck</td><td>主要是检查和修复Linux文件系统</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount命令的功能是挂载文件系统，可以挂载硬盘、光盘、软盘，也可以挂载NFS网络文件系统。这个命令的标准用法如下：</span><br><span class="line"></span><br><span class="line">mount –t 设备类型 存放目录 </span><br><span class="line">mount IP地址：&#x2F;所提供的目录 存放目录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">umount命令的功能是卸载已挂上的文件系统，在关闭系统前应该把所有挂载上的文件系统卸载。这个命令和mount命令是相对的。用法：</span><br><span class="line"></span><br><span class="line">umount 已挂上的目录或设备</span><br><span class="line"></span><br><span class="line">卸载已挂上的&#x2F;cdrom目录，输入命令：</span><br><span class="line"></span><br><span class="line">umount &#x2F;cdrom</span><br><span class="line"></span><br><span class="line">卸载已挂上的某个分区，输入命令：</span><br><span class="line"></span><br><span class="line">umount &#x2F;dev&#x2F;hdb1</span><br></pre></td></tr></table></figure><p><strong>df [-选项]</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>把全部的文件系统和各分区的硬盘使用情形列出来，包括0区块的，例如/proc这个文件系统</td></tr><tr><td>-i</td><td>列出I-nodes的使用量</td></tr><tr><td>-k</td><td>把各分区的大小和挂上来的文件分区的大小用k表示</td></tr><tr><td>-t</td><td>列出某一文件系统的所有分区磁盘空间使用量</td></tr><tr><td>-x</td><td>列出不是某一文件系统的所有分区磁盘空间使用量，和-t选项相反</td></tr><tr><td>-T</td><td>列出每个分区所属文件系统的名称</td></tr></tbody></table><p>例如，要列出全部文件系统和各分区的磁盘使用情况，输入命令：</p><p><code>df –a</code></p><p><strong>du命令的功能是用于显示文件目录或大小。标准用法：</strong></p><p>du [-选项]</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示全部目录及其次目录下的每个文件所占的磁盘空间</td></tr><tr><td>-b</td><td>显示目录和文件的大小，以B为单位</td></tr><tr><td>-c</td><td>最后再加上一个总计</td></tr><tr><td>-h</td><td>以KB、MB、GB为单位，提高信息可读性</td></tr><tr><td>-s</td><td>只列出各文件大小的总和</td></tr><tr><td>-x</td><td>只计算属于同一文件系统的文件</td></tr></tbody></table><p><strong>fsck命令</strong>的功能是检查和修复Linux文件系统，这个命令最好在没有人或是没有分区挂上来时使用，其实每次开机系统都会做一次检查，看是否有坏轨或数据流失的现象。用法：</p><p>fsck (-选项) 分区名称</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>自动修复文件系统，不询问任何问题，比较危险</td></tr><tr><td>-A</td><td>依照/etc/fstab配置文件的内容，检查该文件内所列全部文件系统。若没有附加参数”-P”，则会先检查/目录的文件系统，而不会同时检查所有文件系统</td></tr><tr><td>-R</td><td>采取互动方式，在修复时询问问题，让用户确认并决定处理方式</td></tr><tr><td>-S</td><td>依次检查作业而不是同时执行。当依次指定多个文件系统且采用互动的方式进行检查时，请使用此参数以便顺序执行，否则fsck可能会同时询问数个问题，让人不知所措</td></tr><tr><td>-V</td><td>显示命令执行的过程</td></tr><tr><td>-T</td><td>指定要检查的文件系统的类型</td></tr><tr><td>-N</td><td>不是真正执行指令，仅列出实际执行时会进行的动作</td></tr></tbody></table><p><strong>tar命令</strong></p><p>tar命令最早是用来做磁带备份的，但是由于硬盘容量越来越大，因此现在主要用这个命令来备份所有的文件。tar这个命令把大量的文件和目录打包成一个文件。</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>创建一个新归档</td></tr><tr><td>-f</td><td>当与-c选项一起使用时，创建的tar文件使用该选项指定的文件名；当与-x选项一起使用时，则解除该选项指定的归档</td></tr><tr><td>-t</td><td>显示包括在tar文件中的文件列表</td></tr><tr><td>-v</td><td>显示文件的归档进度</td></tr><tr><td>-x</td><td>从归档中抽取文件</td></tr><tr><td>-z</td><td>使用gzip压缩tar文件</td></tr><tr><td>-j</td><td>使用bzip2压缩tar文件</td></tr></tbody></table><p>要创建一个tar文件，输入命令：</p><p><code>tar –cvf filename.tar directory/file /home/mine</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">上面的命令将directory&#x2F;file、&#x2F;home&#x2F;mine放入归档文件中。</span><br><span class="line"></span><br><span class="line">要列出tar文件的内容，输入命令：</span><br><span class="line"></span><br><span class="line">tar –tvf filename.tar</span><br><span class="line"></span><br><span class="line">要抽取tar文件的命令，输入命令：</span><br><span class="line"></span><br><span class="line">tar –xvf filename.tar</span><br><span class="line"></span><br><span class="line">这个命令不会删除tar文件，但会把解除归档的内容复制到当前工作目录下，并保留归档文件所使用的任何目录结构。</span><br><span class="line"></span><br><span class="line">请记住，tar默认不压缩文件。要创建一个使用tar和bzip2来归档压缩的文件，使用-j选项：</span><br><span class="line"></span><br><span class="line">tar –cjvf filename.tbz file</span><br><span class="line"></span><br><span class="line">如果使用bunzip2命令解压filename.tbz文件，则filename.tbz会被删除，以filename.tar代替。</span><br><span class="line"></span><br><span class="line">要扩展并解除归档bzip tar文件，输入命令：</span><br><span class="line"></span><br><span class="line">tar –xjvf filename.tbz</span><br><span class="line"></span><br><span class="line">要创建一个用tar和gzip归档并压缩的文件，使用-z选项：</span><br><span class="line"></span><br><span class="line">tar –czvf filename.tgz file</span><br><span class="line"></span><br><span class="line">如果使用gunzip命令解压filename.tgz文件，则filename.tgz会被删除，以filename.tar代替。</span><br></pre></td></tr></table></figure><p><strong>ps命令</strong></p><p>ps命令用来<strong>查看在计算机系统中有哪些程序正在执行</strong>，及其执行的情况。这是一个相当强大的命令，可以用它来找出所有的<code>process id</code>和名称。另外，ps命令也可以用来列出所有程序占用内存的情况。用法如下：</p><p>ps –(选项)</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-l</td><td>用长格式列出</td></tr><tr><td>-u</td><td>列出使用者的名称和使用时间</td></tr><tr><td>-m</td><td>列出内存分布的情况</td></tr><tr><td>-r</td><td>只列出正在执行的前台程序，不列出其他信息</td></tr><tr><td>-x</td><td>列出所有程序，包括那些没有终端机的程序</td></tr></tbody></table><p><strong>top命令</strong></p><ul><li>可以查看目前程序的执行情景和内存使用。它和ps类似，不过，它会几秒钟更新一次系统状态，方便追踪。要离开这个程序，按Ctrl+C键就可以了。</li></ul><p><strong>kill命令</strong></p><ul><li>用来终止一个正在执行中的进程。如果一个程序执行过程中失败了，可以把这个程序终止，避免留在内存中占用系统资源。不过，它的实际意义是送一个信号给这个正在执行的程序，叫它自杀。可以送很多信号给这些程序，也可以让他们受到信号后做很多事情。标准用法：</li></ul><p><code>kill –(选项) pid</code></p><ul><li>在执行kill命令前。可以先用ps命令查一下某宕掉程序的pid，然后使用kill除去某个程序。例如，终止pid为90的程序：<code>kill 90</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将 pid 为 323 的行程砍掉 (kill) ：</span><br><span class="line"></span><br><span class="line">kill -9 323</span><br><span class="line"></span><br><span class="line">将 pid 为 456 的行程重跑 (restart) ：</span><br><span class="line"></span><br><span class="line">kill -HUP 456</span><br></pre></td></tr></table></figure><p><strong>chmod命令</strong></p><ul><li>用来改变许可权限。读取、写入和执行是许可权限中的三个主要设置。因为用户在他们的账号被创建时就被编入一个组群，所以还可以指定那些组群可以读取、写入或执行某一文件。其中：<ul><li>r—文件可以被读取<br>w—文件可以被写入<br>x—文件可以被执行，如果文件是程序的话</li></ul></li></ul><p>可以使用带有-l的ls命令来仔细查看一个文件的许多细节。</p><p><code>chmod</code>命令用来设定文件的权限。标准用法：</p><p><code>chmod</code> 文件的使用者(u,g,o,a)增减(+,-,=)权限名称(r,w,x) 文件</p><table><thead><tr><th>文件的使用者</th><th>说明</th><th>权限</th><th>说明</th><th>增减</th><th>说明</th></tr></thead><tbody><tr><td>u</td><td>拥有文件的用户</td><td>r</td><td>读取权</td><td>+</td><td>添加权限</td></tr><tr><td>g</td><td>所有者所在的组群</td><td>w</td><td>写入权</td><td>-</td><td>删除权限</td></tr><tr><td>o</td><td>其他人</td><td>x</td><td>执行权</td><td>=</td><td>是它称为唯一权限</td></tr><tr><td>a</td><td>全部(u,g和o)</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>删除某一文件的所有权限，输入命令：</p><p><code>chmod a-rwx test.txt</code></p><p>为文件所有者添加权限，输入命令：</p><p><code>chmod u+rwx test</code></p><p>还可以用数字表示权限：4——读取，2——写入，1——执行。下面的两个命令等价：</p><p><code>chmod 751 filename</code><br><code>chmod u+rwx,g=rx,0=x filename</code></p><h2 id="7-网络相关"><a href="#7-网络相关" class="headerlink" title="7. 网络相关"></a>7. 网络相关</h2><p><strong>执行ping命令</strong></p><ul><li>它会使用ICMP传输协议，发出要求回应的信息，若远程主机的网络没有什么问题，就会回应信息，因而得知该主机运作正常。</li></ul><p>标准用法：</p><p>ping (-选项) 主机名称或IP地址</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c 次数</td><td>设置完成要求回应的次数。ping命令会反复发出信息，直到达到设定的次数为止</td></tr><tr><td>D</td><td>使用Socket的SO_DEBUG功能</td></tr><tr><td>F</td><td>大量而且快速地送网络封包给一台机器，看它的回应。一般不到几秒钟，送出去的封包就会超过两千个</td></tr><tr><td>I 秒数</td><td>指定收发信息的间隔时间，单位为s，预置位1s。与参数f不兼容</td></tr><tr><td>S bytes</td><td>设置数据包的大小。预设置为56B，加上8B ICMP头文件，共64B</td></tr><tr><td>R</td><td>忽略网关，直接将数据保送到远程主机上。如果该主机并非局域网的一份子，就会传回错误信息</td></tr><tr><td>Q</td><td>不显示命令的执行过程，只显示结果</td></tr><tr><td>V</td><td>详细显示命令的执行过程，包括非回应信息和其它信息</td></tr><tr><td>T 存活数值</td><td>设置存活数值TTL的大小。TTL是IP协议包中的一个值，它告诉网络，数据包在网络中的时间是否太长而应被丢弃</td></tr></tbody></table><p>举例说明，检测des.bllod.net主机网络功能是否正常，送出去要去信息需完成5次回应，每次间隔10s，数据包的大小为512B，输入命令：</p><p><code>ping –c 5 –i 10 –s 504 –t 64 des.blood.net</code></p><p><strong>netstat命令</strong></p><ul><li>netstat命令的主要功能是了解Linux系统的网络情况。假设没有指定任何参数给netstat命令，则效果和指定-F参数相同。</li></ul><p>用法：</p><p>netstat (-选项)</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>显示所有连线中的Socket</td></tr><tr><td>F</td><td>显示FIB</td></tr><tr><td>a</td><td>全部列出，包括正在等待的程序</td></tr><tr><td>c</td><td>持续列出网络状态</td></tr><tr><td>i</td><td>显示网络界面信息</td></tr><tr><td>n</td><td>使用网络ip地址代替名称</td></tr><tr><td>o</td><td>显示计时器</td></tr><tr><td>r</td><td>显示网络路径表</td></tr><tr><td>t</td><td>显示TCP协议的连接情形</td></tr><tr><td>u</td><td>显示UDP协议的连接情形</td></tr><tr><td>v</td><td>显示版本信息</td></tr><tr><td>w</td><td>显示RAW传输协议的连接情形</td></tr></tbody></table><p><strong>参考博客</strong> ： <a href="https://blog.csdn.net/qq_23329167/article/details/83856430?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/qq_23329167/article/details/83856430?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.channel_param</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-command-manual.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-00-常用指令&quot;&gt;&lt;a href=&quot;#Linux-00-常用指令&quot; class=&quot;headerlink&quot; title=&quot;Linux-00-常用指令&quot;&gt;&lt;/a&gt;Linux-00-常用指令&lt;/h1&gt;&lt;h2 id=&quot;1-基本命令&quot;&gt;&lt;a href=&quot;#1-基本命令&quot; class=&quot;headerlink&quot; title=&quot;1. 基本命令&quot;&gt;&lt;/a&gt;1. 基本命令&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutdown -h now        立刻关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutdown -h 5        5分钟后关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    poweroff            立刻关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;重启&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutdown -r now        立刻重启&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutdown -r 5        5分钟后重启&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reboot                立刻重启&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ifconfig  --help：查看网卡信息&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;2-目录操作指令&quot;&gt;&lt;a href=&quot;#2-目录操作指令&quot; class=&quot;headerlink&quot; title=&quot;2. 目录操作指令&quot;&gt;&lt;/a&gt;2. 目录操作指令&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pwd命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;命令：cd 目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd &amp;#x2F;        切换到根目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd &amp;#x2F;usr        切换到根目录下的usr目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd ..&amp;#x2F;        切换到上一级目录 或者  cd ..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd ~        切换到home目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd -        切换到上次访问的目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;命令：ls [-al]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls                查看当前目录下的所有目录和文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls &amp;#x2F;dir            查看指定目录下的所有目录和文件   如：ls &amp;#x2F;usr&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;命令：mkdir 目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir    aaa            在当前目录下创建一个名为aaa的目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir    &amp;#x2F;usr&amp;#x2F;aaa    在指定目录下创建一个名为aaa的目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Linux常用指令" scheme="http://zhuuu.work/tags/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-String,StringBuilder,StringBuffer</title>
    <link href="http://zhuuu.work/2020/08/11/JavaInterview/Java-%E5%9F%BA%E7%A1%80-String,StringBuilder,StringBuffer/"/>
    <id>http://zhuuu.work/2020/08/11/JavaInterview/Java-%E5%9F%BA%E7%A1%80-String,StringBuilder,StringBuffer/</id>
    <published>2020-08-11T03:38:38.000Z</published>
    <updated>2020-09-10T08:08:17.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-String-StringBuilder-StringBuffer"><a href="#Java-基础-String-StringBuilder-StringBuffer" class="headerlink" title="Java-基础-String,StringBuilder,StringBuffer"></a>Java-基础-String,StringBuilder,StringBuffer</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>java中<code>String、StringBuffer、StringBuilder</code>是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-145020237.png" alt="mark"></p><a id="more"></a><h2 id="1-可变和不可变"><a href="#1-可变和不可变" class="headerlink" title="1. 可变和不可变"></a>1. 可变和不可变</h2><p><strong>1.可变与不可变</strong></p><p>　　<code>String</code>类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。</p><p>　　　　<strong>private final char value[];</strong></p><p>　　<code>StringBuilder与StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。</p><p>　　　　<strong>char[] value;</strong></p><h3 id="1-1-你见到的字符串被改变的？？？（这是一个假象）"><a href="#1-1-你见到的字符串被改变的？？？（这是一个假象）" class="headerlink" title="1.1 你见到的字符串被改变的？？？（这是一个假象）"></a>1.1 <strong>你见到的字符串被改变的？？？（这是一个假象）</strong></h3><ul><li>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 <strong>String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，这样不仅效率低下，而且大量浪费有限的内存空间，所以经常改变内容的字符串最好不要用 String 。</strong>因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-144909950.png" alt="mark"></p><ul><li>我们可以看到，初始String值为“hello”，然后在这个字符串后面加上新的字符串“world”，这个过程是需要重新在栈堆内存中开辟内存空间的，最终得到了“hello world”字符串也相应的需要开辟内存空间，这样短短的两个字符串，却需要开辟三次内存空间，不得不说这是对内存空间的极大浪费。为了应对经常性的字符串相关的操作，就需要使用Java提供的其他两个操作字符串的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。</li></ul><h2 id="2-多线程安全"><a href="#2-多线程安全" class="headerlink" title="2. 多线程安全"></a>2. 多线程安全</h2><ol><li><p><code>String</code>中的对象是不可变的，也就可以理解为常量，<strong>显然线程安全</strong>。</p></li><li><p><code>AbstractStringBuilder</code>是<code>StringBuilder</code>与<code>StringBuffer</code>的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。</p></li><li><p><code>StringBuffer</code>对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全的</strong>。看如下源码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);        <span class="comment">//存在 public synchronized int indexOf(String str, int fromIndex) 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>StringBuilder并没有对方法进行加同步锁，所以是<strong>非线程安全的</strong>。</li></ol><h2 id="3-StringBuilder和StringBuffer共同点"><a href="#3-StringBuilder和StringBuffer共同点" class="headerlink" title="3. StringBuilder和StringBuffer共同点"></a>3. StringBuilder和StringBuffer共同点</h2><ul><li>StringBuilder与StringBuffer有公共父类AbstractStringBuilder(<strong>抽象类</strong>)。</li><li><strong>抽象类与接口的其中一个区别</strong>是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。</li><li><code>StringBuilder、StringBuffer</code>的方法都会调用<code>AbstractStringBuilder</code>中的公共方法，如<code>super.append</code>(…)。只是StringBuffer会在方法上加synchronized关键字，进行同步。</li></ul><h2 id="4-字符串常量池"><a href="#4-字符串常量池" class="headerlink" title="4. 字符串常量池"></a>4. 字符串常量池</h2><ul><li>Java中的字符串常量池（<code>String Pool</code>）是存储在Java<strong>堆内存中的字符串池</strong>。我们知道String是java中比较特殊的类，我们可以使用new运算符创建String对象，也可以用双引号（”“）创建字串对象。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-151808077.png" alt="mark"></p><ul><li>之所以有字符串常量池，是因为String在Java中是不可变（immutable）的，它是String interning概念的实现。字符串常量池也是亨元模式（Flyweight）的实例。</li><li>字符串常量池有助于为Java运行时节省大量空间，虽然创建字符串时需要更多的时间。</li><li>当我们使用<strong>双引号创建一个字符串时</strong>，首<strong>先在字符串常量池中查找是否有相同值的字符串，如果发现则返回其引用，否则它会在池中创建一个新的字符串，然后返回新字符串的引用。</strong></li><li>如果使用<strong>new运算符创建字符串，则会强制String类在堆空间中创建一个新的String对象。</strong>我们可以使用intern()方法将其放入字符串常量池或从字符串常量池中查找具有相同的值字符串对象并返回其引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java String Pool example</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s2 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1 == s2 :"</span>+(s1==s2));</span><br><span class="line">        System.out.println(<span class="string">"s1 == s3 :"</span>+(s1==s3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-面试题"><a href="#4-1-面试题" class="headerlink" title="4.1 面试题"></a>4.1 面试题</h3><ul><li>下面语句创建了几个对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><ul><li>在上面的语句中，可能创建1或2个字符串对象。如果池中已经有一个字符串<em>“Cat”</em>，那么堆中只会创建一个字符串<em>“str”</em>。</li><li>如果池中没有字符串字面量<em>“Cat”</em>，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共2个字符串对象。</li></ul><h3 id="4-2-作用"><a href="#4-2-作用" class="headerlink" title="4.2 作用"></a>4.2 作用</h3><ul><li>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。</li><li><strong>为 了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串池，</strong>每当代码创建字符串常量时，JVM会首先检查字符串常量池。如果字符串已经存在池中， 就返回池中的实例引用。</li><li>如果字符串不在池中，就会实例化一个字符串并放到池中。Java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突 进行共享。</li></ul><p><strong>参考博客：</strong></p><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303" target="_blank" rel="noopener">https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-String-StringBuilder-StringBuffer&quot;&gt;&lt;a href=&quot;#Java-基础-String-StringBuilder-StringBuffer&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-String,StringBuilder,StringBuffer&quot;&gt;&lt;/a&gt;Java-基础-String,StringBuilder,StringBuffer&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;java中&lt;code&gt;String、StringBuffer、StringBuilder&lt;/code&gt;是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-145020237.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="String" scheme="http://zhuuu.work/tags/String/"/>
    
      <category term="SringBuilder" scheme="http://zhuuu.work/tags/SringBuilder/"/>
    
      <category term="StringBuffer" scheme="http://zhuuu.work/tags/StringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-并发详解</title>
    <link href="http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-08-10T09:38:38.000Z</published>
    <updated>2020-08-10T07:50:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-并发详解"><a href="#Java-基础-并发详解" class="headerlink" title="Java-基础-并发详解"></a>Java-基础-并发详解</h1><h1 id="一、使用线程"><a href="#一、使用线程" class="headerlink" title="一、使用线程"></a>一、使用线程</h1><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><ul><li><strong>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程</strong>，</li><li><strong>因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</strong></li></ul><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><ul><li>需要实现接口中的 run() 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><ul><li>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><ul><li>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</li><li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p><strong>实现接口会更好一些</strong>，因为：</p><ul><li>Java <strong>不支持多重继承，因此继承了 Thread 类就无法继承其它类</strong>，但是可以实现多个接口；</li><li>类可能只要求可执行就行，<strong>继承整个 Thread 类开销过大。</strong></li></ul><h1 id="二、中断"><a href="#二、中断" class="headerlink" title="二、中断"></a>二、中断</h1><ul><li>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</li></ul><h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的 <code>interrupt()</code> 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 <code>InterruptedException</code>，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p><strong>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure><h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><ul><li><strong>调用 Executor 的 shutdown() 方法</strong>会等待线程都执行完毕之后再关闭，</li><li>但是如果调<strong>用的是 shutdownNow() 方法</strong>，则相当于调用每个线程的 interrupt() 方法。</li></ul><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><ul><li>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h1 id="三、互斥同步"><a href="#三、互斥同步" class="headerlink" title="三、互斥同步"></a>三、互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>1. 同步一个代码块</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</strong></p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure><p><strong>2. 同步一个方法</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它和同步代码块一样，作用于同一个对象。</strong></p><p><strong>3. 同步一个类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p><strong>4. 同步一个静态方法</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用于整个类。</strong></p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><ul><li>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。<strong>(底层是AQS)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>1. 锁的实现</strong>  </p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong>  </p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong>  </p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong>  </p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong>  </p><ul><li><strong>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</strong></li></ul><h1 id="四、线程之间的协作"><a href="#四、线程之间的协作" class="headerlink" title="四、线程之间的协作"></a>四、线程之间的协作</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><ul><li><p><strong>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</strong></p></li><li><p>对于以下代码，虽然 b 线程先启动，<strong>但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><ul><li><p><strong>它们都属于 Object 的一部分，而不属于 Thread。</strong></p></li><li><p><strong>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</strong></p></li><li><p><strong>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</strong></p></li><li><p><strong>同时存在虚假唤醒的问题</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p><strong>wait() 和 sleep() 的区别</strong>  </p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><ul><li><p>java.util.concurrent 类库中提供了 <strong>Condition 类</strong>来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p></li><li><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p></li></ul><p><strong>使用 Lock 来获取一个 Condition 对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><h1 id="五、线程状态"><a href="#五、线程状态" class="headerlink" title="五、线程状态"></a>五、线程状态</h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p><h2 id="新建（NEW）"><a href="#新建（NEW）" class="headerlink" title="新建（NEW）"></a>新建（NEW）</h2><ul><li>创建后尚未启动。</li></ul><h2 id="可运行（RUNABLE）"><a href="#可运行（RUNABLE）" class="headerlink" title="可运行（RUNABLE）"></a>可运行（RUNABLE）</h2><ul><li>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要<strong>看底层操作系统的资源调度</strong>。</li></ul><h2 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h2><ul><li>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</li></ul><h2 id="无限期等待（WAITING）"><a href="#无限期等待（WAITING）" class="headerlink" title="无限期等待（WAITING）"></a>无限期等待（WAITING）</h2><p>等待其它线程显式地唤醒。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用  Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h2 id="限期等待（TIMED-WAITING）"><a href="#限期等待（TIMED-WAITING）" class="headerlink" title="限期等待（TIMED_WAITING）"></a>限期等待（TIMED_WAITING）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><h2 id="死亡（TERMINATED）"><a href="#死亡（TERMINATED）" class="headerlink" title="死亡（TERMINATED）"></a>死亡（TERMINATED）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h1 id="六-：-AQS-应用"><a href="#六-：-AQS-应用" class="headerlink" title="六 ： AQS 应用"></a>六 ： AQS 应用</h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><ul><li><p>用来控制一个或者多个线程等待多个线程。</p></li><li><p><strong>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</strong></p></li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><ul><li><strong>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</strong></p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七：其他组件"><a href="#七：其他组件" class="headerlink" title="七：其他组件"></a>七：其他组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future<V> 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future<V> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。<strong>当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">other task is running...</span><br><span class="line">4950</span><br></pre></td></tr></table></figure><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>java.util.concurrent.BlockingQueue</code> 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong>  ：<code>LinkedBlockingQueue、ArrayBlockingQueue</code>（固定长度）</li><li><strong>优先级队列</strong>  ：<code>PriorityBlockingQueue</code></li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><ul><li>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><ul><li>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" width="300px"> </div><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-基础-并发详解&quot;&gt;&lt;a href=&quot;#Java-基础-并发详解&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-并发详解&quot;&gt;&lt;/a&gt;Java-基础-并发详解&lt;/h1&gt;&lt;h1 id=&quot;一、使用线程&quot;&gt;&lt;a href=&quot;#一、使用线程&quot;
      
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="http://zhuuu.work/tags/%E9%94%81/"/>
    
      <category term="并发" scheme="http://zhuuu.work/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-接口和抽象类</title>
    <link href="http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2020-08-10T09:38:38.000Z</published>
    <updated>2020-09-20T07:11:31.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-接口和抽象类"><a href="#Java-基础-接口和抽象类" class="headerlink" title="Java-基础-接口和抽象类"></a>Java-基础-接口和抽象类</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200810-134343284.png" alt="mark"></p><a id="more"></a><h2 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1. 抽象类"></a>1. 抽象类</h2><h4 id="（1）抽象类的含义"><a href="#（1）抽象类的含义" class="headerlink" title="（1）抽象类的含义"></a>（1）抽象类的含义</h4><p>  包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的（否则，编译器会报错）</p><h4 id="（2）抽象类的点"><a href="#（2）抽象类的点" class="headerlink" title="（2）抽象类的点"></a>（2）抽象类的点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.含有abstract修饰符的class即为抽象类，abstract类不能创建实例对象。</span><br><span class="line">2.含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。</span><br><span class="line">3.abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。</span><br><span class="line">4.如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</span><br></pre></td></tr></table></figure><h2 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h2><h4 id="（1）接口的含义"><a href="#（1）接口的含义" class="headerlink" title="（1）接口的含义"></a>（1）接口的含义</h4><p>  可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。能有的内容是：static final的静态成员变量、public abstract的抽象方法（可以使用abstract关键字也可以不使用）</p><h4 id="（2）接口的点"><a href="#（2）接口的点" class="headerlink" title="（2）接口的点"></a>（2）接口的点</h4><p>1.接口中的域隐式地是static和final的；<br> 2.接口可以嵌套在类或其他接口中；<br> 3.接口是实现多重继承的途径；<br> 4.接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。<br> 5.接口不能有构造器；<br> 6.接口中不能有main()方法；</p><h2 id="3、语法的区别"><a href="#3、语法的区别" class="headerlink" title="3、语法的区别"></a>3、语法的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.普通成员变量：抽象类中可以有普通成员变量，接口中没有普通成员变量（static final变量）；</span><br><span class="line">2.方法：抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法；</span><br><span class="line">3.静态成员变量：抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</span><br><span class="line">4.静态方法：抽象类中可以包含静态方法，但不能是抽象静态方法；接口中不能包含静态方法（静态的方法不能被覆写）</span><br><span class="line">5.构造方法（静态的）：抽象类可以有构造方法，接口中不能有构造方法；</span><br><span class="line">6.方法访问权限：抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</span><br><span class="line">7.子类实现和继承： 一个类可以实现多个接口，但只能继承一个抽象类。</span><br><span class="line">8.初始化过程：当一个类在初始化时，要求其父类全部都已经初始化过了；但是一个接口在初始化时，并不要求其父接口全部都完成初始化，只有在真正使用父接口的时候（如引用接口中定义的常量），才会初始化。</span><br></pre></td></tr></table></figure><h2 id="4、应用上的区别"><a href="#4、应用上的区别" class="headerlink" title="4、应用上的区别"></a>4、应用上的区别</h2><ul><li>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约；</li><li>而抽象类在代码实现方面发挥作用，可以实现代码的重用。  </li><li>例如，<strong>模板方法设计模式是抽象类的一个典型应用</strong>，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。</li></ul><h2 id="5-使用接口的原因"><a href="#5-使用接口的原因" class="headerlink" title="5. 使用接口的原因"></a>5. 使用接口的原因</h2><p>1）为了能够向上转型为多个基类型（由此而带来的灵活性）；<br> 2）与使用抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。</p><h2 id="6、问题：使用接口还是抽象类"><a href="#6、问题：使用接口还是抽象类" class="headerlink" title="6、问题：使用接口还是抽象类"></a>6、问题：使用接口还是抽象类</h2><p>答：如果要创建不带任何方法定义和成员变量的基类，就应该选择接口而不是抽象类。抽象类为了代码的复用，接口为了多态性。</p><p><strong>参考视频：</strong> <a href="https://www.bilibili.com/video/BV1Ak4y1o7y8?p=182" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ak4y1o7y8?p=182</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-接口和抽象类&quot;&gt;&lt;a href=&quot;#Java-基础-接口和抽象类&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-接口和抽象类&quot;&gt;&lt;/a&gt;Java-基础-接口和抽象类&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200810-134343284.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="接口" scheme="http://zhuuu.work/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="抽象类" scheme="http://zhuuu.work/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-泛型擦除</title>
    <link href="http://zhuuu.work/2020/08/05/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    <id>http://zhuuu.work/2020/08/05/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/</id>
    <published>2020-08-05T09:38:38.000Z</published>
    <updated>2020-09-04T08:31:01.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-泛型擦除"><a href="#Java-基础-泛型擦除" class="headerlink" title="Java-基础-泛型擦除"></a>Java-基础-泛型擦除</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>[参考博客][<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html]" target="_blank" rel="noopener">https://www.cnblogs.com/wuqinglong/p/9456193.html]</a></p><ul><li>大家都知道，Java的泛型是伪泛型，<strong>这是因为Java在编译期间，所有的泛型信息都会被擦掉</strong>，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，<strong>使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</strong></li><li><strong>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code></strong>，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，<strong>但是仍然无法在运行时刻出现的类型转换异常的情况</strong>，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</li></ul><a id="more"></a><h2 id="1-通过两个例子证明Java类型的类型擦除"><a href="#1-通过两个例子证明Java类型的类型擦除" class="headerlink" title="1. 通过两个例子证明Java类型的类型擦除"></a>1. 通过两个例子证明Java类型的类型擦除</h2><ol><li><h4 id="原始类型相等"><a href="#原始类型相等" class="headerlink" title="原始类型相等"></a>原始类型相等</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个<code>ArrayList</code>数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过<code>list1</code>对象和<code>list2</code>对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为<code>true</code>。说明泛型类型<code>String</code>和<code>Integer</code>都被擦除掉了，只剩下原始类型。</p><ol start="2"><li><h4 id="通过反射添加其它类型元素"><a href="#通过反射添加其它类型元素" class="headerlink" title="通过反射添加其它类型元素"></a>通过反射添加其它类型元素</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);  <span class="comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span></span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod("add", Object.class).invoke(list, "asd");</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p><h2 id="2-类型擦除后保留的原始类型"><a href="#2-类型擦除后保留的原始类型" class="headerlink" title="2. 类型擦除后保留的原始类型"></a>2. 类型擦除后保留的原始类型</h2><ul><li><p>在上面，两次提到了原始类型，什么是原始类型？</p><p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p></li></ul><p><strong>例3.原始类型Object</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair的原始类型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在<code>Pair&lt;T&gt;</code>中，T 是一个无限定的类型变量，所以用<code>Object</code>替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的<code>Pair</code>，如<code>Pair&lt;String&gt;</code>或<code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的<code>Pair</code>类型了，原始类型都是<code>Object</code>。</p><p><strong>从上面的例2中，我们也可以明白<code>ArrayList&lt;Integer&gt;</code>被擦除类型后，原始类型也变为<code>Object</code>，所以通过反射我们就可以存储字符串了。</strong></p><p>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>那么原始类型就是<code>Comparable</code>。</p><p>要区分原始类型和泛型变量的类型。</p><p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> i = Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        Number f = Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        Object o = Test.add(<span class="number">1</span>, <span class="string">"asd"</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> a = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="keyword">int</span> b = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        Number c = Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例4.Object泛型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">    list.add(<span class="number">1</span>);  </span><br><span class="line">    list.add(<span class="string">"121"</span>);  </span><br><span class="line">    list.add(<span class="keyword">new</span> Date());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-带来的问题和解决方法"><a href="#3-带来的问题和解决方法" class="headerlink" title="3. 带来的问题和解决方法"></a>3. 带来的问题和解决方法</h2><p>因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题，但是也引起来许多新问题，所以，SUN对这些问题做出了种种限制，避免我们发生各种错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-泛型擦除&quot;&gt;&lt;a href=&quot;#Java-基础-泛型擦除&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-泛型擦除&quot;&gt;&lt;/a&gt;Java-基础-泛型擦除&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;[参考博客][&lt;a href=&quot;https://www.cnblogs.com/wuqinglong/p/9456193.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wuqinglong/p/9456193.html]&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大家都知道，Java的泛型是伪泛型，&lt;strong&gt;这是因为Java在编译期间，所有的泛型信息都会被擦掉&lt;/strong&gt;，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，&lt;strong&gt;使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如在代码中定义&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;和&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;等类型，在编译后都会变成&lt;code&gt;List&lt;/code&gt;&lt;/strong&gt;，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，&lt;strong&gt;但是仍然无法在运行时刻出现的类型转换异常的情况&lt;/strong&gt;，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="泛型" scheme="http://zhuuu.work/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-146-LRU缓存机制</title>
    <link href="http://zhuuu.work/2020/08/05/Leetcode/Leetcode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/08/05/Leetcode/Leetcode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2020-08-05T07:52:22.000Z</published>
    <updated>2020-09-15T14:39:24.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-146-LRU缓存机制"><a href="#Leecode-146-LRU缓存机制" class="headerlink" title="Leecode-146. LRU缓存机制"></a>Leecode-<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h1><h2 id="思路：递归-迭代"><a href="#思路：递归-迭代" class="headerlink" title="思路：递归/迭代"></a>思路：递归/迭代</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><ul><li>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。</li><li>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><h2 id="方案：-哈希链表"><a href="#方案：-哈希链表" class="headerlink" title="方案： 哈希链表"></a>方案： 哈希链表</h2><ul><li>LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</li><li>注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 缓存容量为 2 *&#x2F;</span><br><span class="line">LRUCache cache &#x3D; new LRUCache(2);</span><br><span class="line">&#x2F;&#x2F; 你可以把 cache 理解成一个队列</span><br><span class="line">&#x2F;&#x2F; 假设左边是队头，右边是队尾</span><br><span class="line">&#x2F;&#x2F; 最近使用的排在队头，久未使用的排在队尾</span><br><span class="line">&#x2F;&#x2F; 圆括号表示键值对 (key, val)</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 1)]</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(2, 2), (1, 1)]</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 1</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 1), (2, 2)]</span><br><span class="line">&#x2F;&#x2F; 解释：因为最近访问了键 1，所以提前至队头</span><br><span class="line">&#x2F;&#x2F; 返回键 1 对应的值 1</span><br><span class="line">cache.put(3, 3);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(3, 3), (1, 1)]</span><br><span class="line">&#x2F;&#x2F; 解释：缓存容量已满，需要删除内容空出位置</span><br><span class="line">&#x2F;&#x2F; 优先删除久未使用的数据，也就是队尾的数据</span><br><span class="line">&#x2F;&#x2F; 然后把新的数据插入队头</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(3, 3), (1, 1)]</span><br><span class="line">&#x2F;&#x2F; 解释：cache 中不存在键为 2 的数据</span><br><span class="line">cache.put(1, 4);    </span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 4), (3, 3)]</span><br><span class="line">&#x2F;&#x2F; 解释：键 1 已存在，把原始值 1 覆盖为 4</span><br><span class="line">&#x2F;&#x2F; 不要忘了也要将键值对提前到队头</span><br></pre></td></tr></table></figure><ul><li>分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。</li><li>因为显然 cache <strong>必须有顺序之分</strong>，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；<strong>如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。</strong></li><li>那么，什么数据结构同时符合上述条件呢？<strong>哈希表查找快，但是数据无固定顺序</strong>；<strong>链表有顺序之分，插入删除快，但是查找慢。</strong>所以结合一下，形成一种新的数据结构：哈希链表。</li><li><strong>LRU 缓存算法的核心数据结构就是哈希链表</strong>，双向链表和哈希表的结合体。这个数据结构长这样：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200805-165923396.png" alt="mark"></p><p><strong>思想很简单，就是借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点。回想刚才的例子，这种数据结构是不是完美解决了 LRU 缓存的需求？</strong></p><p>也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存键值对呢，只存值不就行了？</p><p>想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个可不写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动实现版本</strong></p><ol><li><strong>Node结构</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">public</span> Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>双向链表</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head, tail; <span class="comment">// 头尾虚节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 链表元素数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头部添加节点 x</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.next = head.next;</span><br><span class="line">        x.prev = head;</span><br><span class="line">        head.next.prev = x;</span><br><span class="line">        head.next = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中的 x 节点（x 一定存在）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail.prev == head)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node last = tail.prev;</span><br><span class="line">        remove(last);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>缓存实现</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key -&gt; Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; map;</span><br><span class="line">    <span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).val;</span><br><span class="line">        <span class="comment">// 利用 put 方法把该数据提前</span></span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先把新节点 x new出来</span></span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key,value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前key存在</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">// 删除旧的节点，新的插入到头部</span></span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            cache.addFirst(x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新map对应的数据</span></span><br><span class="line">            map.put(key,x);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果之前key不存在</span></span><br><span class="line">            <span class="keyword">if</span> (cap == cache.size())&#123;</span><br><span class="line">                <span class="comment">// 删除链表的最后一个数据</span></span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接添加到头部</span></span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            map.put(key,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.map.keySet());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res1 = cache.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res2 = cache.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res3 = cache.get(<span class="number">3</span>);</span><br><span class="line">        System.out.println(res3);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(cache.map.keySet());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res4 = cache.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(res4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res5 = cache.get(<span class="number">3</span>);</span><br><span class="line">        System.out.println(res5);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res6 = cache.get(<span class="number">4</span>);</span><br><span class="line">        System.out.println(res6);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充一段伪代码逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key 映射到 Node(key, val)</span></span><br><span class="line">HashMap&lt;Integer, Node&gt; map;</span><br><span class="line"><span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">DoubleList cache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key 不存在) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        将数据 (key, val) 提到开头；</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">    <span class="keyword">if</span> (key 已存在) &#123;</span><br><span class="line">        把旧的数据删除；</span><br><span class="line">        将新节点 x 插入到开头；</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache 已满) &#123;</span><br><span class="line">            删除链表的最后一个数据腾位置；</span><br><span class="line">            删除 map 中映射到该数据的键；</span><br><span class="line">        &#125; </span><br><span class="line">        将新节点 x 插入到开头；</span><br><span class="line">        map 中新建 key 对新节点 x 的映射；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-146-LRU缓存机制&quot;&gt;&lt;a href=&quot;#Leecode-146-LRU缓存机制&quot; class=&quot;headerlink&quot; title=&quot;Leecode-146. LRU缓存机制&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;146. LRU缓存机制&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：递归-迭代&quot;&gt;&lt;a href=&quot;#思路：递归-迭代&quot; class=&quot;headerlink&quot; title=&quot;思路：递归/迭代&quot;&gt;&lt;/a&gt;思路：递归/迭代&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。&lt;/li&gt;
&lt;li&gt;写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;方案：-哈希链表&quot;&gt;&lt;a href=&quot;#方案：-哈希链表&quot; class=&quot;headerlink&quot; title=&quot;方案： 哈希链表&quot;&gt;&lt;/a&gt;方案： 哈希链表&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。&lt;/li&gt;
&lt;li&gt;注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="缓存机制" scheme="http://zhuuu.work/tags/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    
      <category term="LRU" scheme="http://zhuuu.work/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-10-乐观锁和悲观锁</title>
    <link href="http://zhuuu.work/2020/08/03/Mysql/Mysql-10-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://zhuuu.work/2020/08/03/Mysql/Mysql-10-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2020-08-03T08:02:27.000Z</published>
    <updated>2020-09-19T13:54:22.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-10-乐观锁和悲观锁"><a href="#Mysql-10-乐观锁和悲观锁" class="headerlink" title="Mysql-10-乐观锁和悲观锁"></a>Mysql-10-乐观锁和悲观锁</h1><h2 id="1-乐观锁和悲观锁"><a href="#1-乐观锁和悲观锁" class="headerlink" title="1. 乐观锁和悲观锁"></a>1. 乐观锁和悲观锁</h2><p><strong>首先说明，乐观锁和悲观锁都是针对读（select）来说的。</strong></p><p><strong>也就是一句话：读用乐观锁，写用悲观锁。</strong></p><a id="more"></a><h3 id="1-1-乐观锁"><a href="#1-1-乐观锁" class="headerlink" title="1.1 乐观锁"></a>1.1 乐观锁</h3><ul><li>总是认为不会产生并发问题，每次去<strong>取数据的时候总认为不会有其他线程对数据进行修改</strong>，因此不会上锁，但是在<strong>更新时会判断其他线程在这之前有没有对数据进行修改</strong>，</li><li>一般会使用<strong>版本号机制</strong>或<strong>CAS操作实现</strong>。</li><li>乐观锁适用于多读的应用类型，这样可以提高吞吐量</li></ul><ol><li><p><strong>version方式</strong>：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。</p><ul><li>当线程A要更新数据值时，在读取数据的同时也会读取version值，</li><li>在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li></ul></li></ol><p>   核心SQL代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> x=x+<span class="number">1</span>, <span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>CAS操作方式：</strong>即<code>compare and swap</code> 或者 <code>compare and set</code>，涉及到三个操作数，数据所在的内存值，预期值，新值。<ul><li>当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个<strong>自旋操作</strong>，即不断的重试。</li></ul></li></ol><h3 id="1-2-悲观锁"><a href="#1-2-悲观锁" class="headerlink" title="1.2 悲观锁"></a>1.2 悲观锁</h3><ul><li>悲观锁(<code>Pessimistic Lock</code>), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</li><li>传统的关系型数据库里边就用到了很多这种锁机制，比如<strong>行锁，表锁等，读锁，写锁</strong>等，都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往<strong>依靠数据库提供的锁机制</strong></li></ul><p><strong>首先说明，乐观锁和悲观锁都是针对读（select）来说的。</strong></p><p>案例：</p><p>某商品，用户购买后库存数应-1，而某两个或多个用户同时购买，此时三个执行程序均同时读得库存为“<strong>n</strong>”，之后进行了一些操作，最后将均执行<em>update table set 库存数=n-1</em>，那么，很显然这是错误的。</p><p>解决：</p><ol><li><p><strong>使用悲观锁</strong>（其实说白了也就是<strong>排他锁</strong>）</p><p>|– 程序A在查询库存数时使用排他锁（select * from table where id=10 for update）</p><p>|– 然后进行后续的操作，包括更新库存数，最后提交事务。</p><p>|– 程序B在查询库存数时，如果A还未释放排他锁，它将等待……</p><p>|– 程序C同B……</p></li><li><p><strong>使用乐观锁</strong>（靠表设计和代码来实现）</p><p>|– 一般是在该商品表添加<strong>version版本</strong>字段或者<strong>timestamp时间戳</strong>字段</p><p>|– 程序A查询后，执行更新变成了：<br><code>*update table set num=num-1 where id=10 and version=23*</code></p><p>这样，保证了修改的数据是和它查询出来的数据是一致的（其他执行程序肯定未进行修改）。当然，如果更新失败，表示在更新操作之前，有其他执行程序已经更新了该库存数，那么就可以尝试<strong>重试</strong>来保证更新成功。为了尽可能避免更新失败，可以合理调整重试次数（阿里巴巴开发手册规定重试次数不低于三次）。</p></li></ol><p><strong>总结：对于以上，可以看得出来乐观锁和悲观锁的区别：</strong></p><ul><li><p>悲观锁实际使用了排他锁来实现（<strong>select \</strong>** for update**）。文章开头说到，<code>innodb</code>加行锁的前提是：必须是通过索引条件来检索数据，否则会切换为表锁。</p><p>因此，悲观锁在未通过索引条件检索数据时，会锁定整张表。导致其他程序不允许“<strong>加锁的查询操作</strong>”，影响吞吐。故如果在查询居多的情况下，推荐使用乐观锁。</p><p>“<strong>加锁的查询操作</strong>”：加过排他锁的数据行在其他事务中是不能修改的，也不能通过<strong>for update</strong>或<strong>lock in share mode</strong>的加锁方式查询，但可以直接通过<code>select ...from...</code>查询数据，因为<strong>普通查询没有任何锁机制</strong>。</p></li><li><p>乐观锁更新有可能会失败，甚至是更新几次都失败，这是有风险的。所以如果写入居多，对吞吐要求不高，可使用悲观锁。</p></li></ul><p><strong>参考博客 ：</strong></p><p> <a href="https://blog.csdn.net/localhost01/article/details/78720727?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">https://blog.csdn.net/localhost01/article/details/78720727?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight</a></p><p>  <a href="https://blog.csdn.net/L_BestCoder/article/details/79298417" target="_blank" rel="noopener">https://blog.csdn.net/L_BestCoder/article/details/79298417</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-10-乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#Mysql-10-乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;Mysql-10-乐观锁和悲观锁&quot;&gt;&lt;/a&gt;Mysql-10-乐观锁和悲观锁&lt;/h1&gt;&lt;h2 id=&quot;1-乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#1-乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;1. 乐观锁和悲观锁&quot;&gt;&lt;/a&gt;1. 乐观锁和悲观锁&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;首先说明，乐观锁和悲观锁都是针对读（select）来说的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是一句话：读用乐观锁，写用悲观锁。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JUC-19-AQS</title>
    <link href="http://zhuuu.work/2020/08/03/JUC/JUC-19-AQS/"/>
    <id>http://zhuuu.work/2020/08/03/JUC/JUC-19-AQS/</id>
    <published>2020-08-03T08:02:24.000Z</published>
    <updated>2020-09-18T03:18:54.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-19-AQS"><a href="#JUC-19-AQS" class="headerlink" title="JUC-19-AQS"></a>JUC-19-AQS</h1><h2 id="1-AQS结构"><a href="#1-AQS结构" class="headerlink" title="1. AQS结构"></a>1. AQS结构</h2><ul><li>AQS（<code>AbstractQueuedSynchronizer</code>）是Java众多锁以及并发工具的基础类，底层采用乐观锁，大量采用CAS操作保证其原子性，并且在并发冲突时，采用自旋方法重试。实现了轻量高效的获取锁。</li></ul><h3 id="1-1-信号量"><a href="#1-1-信号量" class="headerlink" title="1.1 信号量"></a>1.1 信号量</h3><ul><li>在AQS中，状态是由<code>volatile state</code>来表示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><ul><li>该属性值表示锁的状态。<ul><li>state为0表示锁未被占用，</li><li>state为1表示锁被线程持有，</li><li>而state大于1表示锁被重入。</li></ul></li></ul><p>而本文分析的是独占锁，那么同一时刻，锁只能被一个线程持有。</p><p>不仅需要记录锁的状态，还需要记录当前获取锁的线程，实现重入。可以通过来记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2-等待队列"><a href="#1-2-等待队列" class="headerlink" title="1.2 等待队列"></a>1.2 等待队列</h3><ul><li>等待队列采用悲观锁的思想，表示当前所等待的资源，状态或条件短时间内可能无法满足，而调用<code>park</code>方法（借助操作系统）来完成线程的阻塞。</li><li>在AQS中，队列时一个双端链表，将当前线程包装成某种类型的数据结构扔到等待队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 节点所代表的线程  </span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;    </span><br><span class="line"><span class="comment">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用  </span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;  </span><br><span class="line"><span class="keyword">volatile</span> Node next;  </span><br><span class="line"><span class="comment">// 线程所处的等待锁的状态，初始化时，该值为0。  </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;  </span><br><span class="line"><span class="comment">//队列中节点线程被取消</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">//节点将其前驱节点设置为-1，当前驱节点释放锁后，会自动唤醒该节点。  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;  </span><br><span class="line"><span class="comment">//线程被重新包装为Node节点，并存入Condition队列中。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;  </span><br><span class="line"><span class="comment">//共享锁唤醒风暴时，将0-&gt;PROPAGATE，表示被传播唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;  </span><br><span class="line"><span class="comment">// 该属性用于条件队列或者共享锁 。在Condition队列中，使用其作为指针。</span></span><br><span class="line">Node nextWaiter;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在独占锁下，我们需要关注的就是下面几个参数：</p><ul><li><code>thread</code>：当前Node所代表的线程；</li><li><code>waitStatus</code>：表示节点所处的等待状态；</li><li><code>prev next</code>节点的前驱和后继</li></ul><h3 id="1-3-CAS操作"><a href="#1-3-CAS操作" class="headerlink" title="1.3 CAS操作"></a>1.3 CAS操作</h3><ul><li>CAS采用乐观锁机制，保证操作的原子性。一般是改变状态或改变指针（引用）指向。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-091408589.png" alt="mark"></p><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>在AQS源码中：</p><ol><li>锁属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//当前持有锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>sync queue</code>相关的属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread属性为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 队尾，新入队的节点</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>Node</code>相关属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点所代表的线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程所处的等待锁的状态，初始化时，该值为0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="2-lock-接口"><a href="#2-lock-接口" class="headerlink" title="2. lock 接口"></a>2. lock 接口</h2><p>Lock是一个接口，方法定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void lock() &#x2F;&#x2F; 如果锁可用就获得锁，如果锁不可用就阻塞直到锁释放</span><br><span class="line">void lockInterruptibly() &#x2F;&#x2F; 和 lock()方法相似, 但阻塞的线程可中断，抛出 java.lang.InterruptedException异常</span><br><span class="line">boolean tryLock() &#x2F;&#x2F; 非阻塞获取锁;尝试获取锁，如果成功返回true</span><br><span class="line">boolean tryLock(long timeout, TimeUnit timeUnit) &#x2F;&#x2F;带有超时时间的获取锁方法</span><br><span class="line">void unlock() &#x2F;&#x2F; 释放锁</span><br></pre></td></tr></table></figure><p>实现Lock接口的类有很多，以下为几个常见的锁实现</p><ul><li><strong>ReentrantLock：表示重入锁</strong>，它是唯一一个实现了Lock接口的类。重入锁指的是线程在获得锁之后，再次获取该锁不需要阻塞，而是直接关联一次计数器增加重入次数</li><li><strong>ReentrantReadWriteLock：重入读写锁，它实现了ReadWriteLock接口</strong>，在这个类中维护了两个锁，一个是ReadLock，一个是WriteLock，他们都分别实现了Lock接口。读写锁是一种适合读多写少的场景下解决线程安全问题的工具，基本原则是：<code>读和读不互斥、读和写互斥、写和写互斥</code>。也就是说涉及到影响数据变化的操作都会存在互斥。</li><li><strong>StampedLock： stampedLock是JDK8引入的新的锁机制，可以简单认为是读写锁的一个改进版本</strong>，读写锁虽然通过分离读和写的功能使得读和读之间可以完全并发，但是读和写是有冲突的，如果大量的读线程存在，可能会引起写线程的饥饿。stampedLock是一种乐观的读策略，使得乐观锁完全不会阻塞写线程</li></ul><h2 id="3-ReentrantLock实现"><a href="#3-ReentrantLock实现" class="headerlink" title="3. ReentrantLock实现"></a>3. ReentrantLock实现</h2><h3 id="3-1-加锁逻辑"><a href="#3-1-加锁逻辑" class="headerlink" title="3.1 加锁逻辑"></a>3.1 加锁逻辑</h3><p><code>ReentrantLock</code>有公平锁和非公平锁两种实现，<strong>默认实现非公平锁。但是可配置为公平锁</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock <span class="keyword">lock</span>=<span class="keyword">new</span> ReentrantLock(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>调用公平锁加锁逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//开始加锁，将state修改为1</span></span><br><span class="line">    acquire(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>真正的加锁方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;    </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))   </span><br><span class="line">        selfInterrupt();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. tryAcquire(arg)</strong><br> 该方法由继承AQS的子类实现，为获取锁的具体逻辑；</p><p><strong>2. addWaiter(Node.EXCLUSIVE)</strong><br> 该方法由AQS实现，负责在获取锁失败后调用，将当前请求锁的线程包装成Node并且放到<code>等待队列中</code>，并返回该Node。</p><p><strong>3. acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</strong><br> 该方法由AQS实现。针对上面加入到队列的Node不断尝试两种操作之一：</p><ul><li>若前驱节点是head节点的时候，尝试获取锁；</li><li>调用<code>park</code>将当前线程挂起，线程阻塞。</li></ul><p><strong>4. selfInterrupt</strong><br>该方法由AQS实现。<strong>恢复用户行为。</strong></p><ul><li><p>用户在外界调用<code>t1.interrupt()</code>进行中断。</p></li><li><p>线程在<code>parkAndCheckInterrupt</code>方法被唤醒之后。会调用<code>Thread.interrupted();</code>判断线程的中断标识，而该方法调用完毕会清除中断标识位。</p></li><li><p>而AQS为了不改变用户标识。再次调用<code>selfInterrupt</code>恢复用户行为。</p></li></ul><h3 id="3-2-构建等待队列-addWaiter"><a href="#3-2-构建等待队列-addWaiter" class="headerlink" title="3.2 构建等待队列 addWaiter"></a>3.2 构建等待队列 addWaiter</h3><ul><li>我们使用<code>ReentrantLock</code>独占锁时，等待队列是<code>延迟加载</code>的。</li><li>也就是说<strong>若是线程交替执行</strong>，那么借助<code>信号量（状态）</code>来保证。</li><li>若是<strong>线程并发执行</strong>，就需要将阻塞线程放入到队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个方法可能存在并发问题。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;  </span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);  </span><br><span class="line">    Node pred = tail;  </span><br><span class="line">    <span class="comment">//队列已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        node.prev = pred;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;  </span><br><span class="line">            pred.next = node;  </span><br><span class="line">            <span class="keyword">return</span> node;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//队列不存在</span></span><br><span class="line">    enq(node);  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>队列不存在的情况(初始化队列 enq(Node))</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094601871.png" alt="mark"></p><p>注意，该方法处理<code>CAS</code>操作是原子性的，其他操作都存在并发冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">         Node t = tail;  </span><br><span class="line">         <span class="comment">// 初始化队列 （一个Thread 为null的空node）</span></span><br><span class="line">         <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  </span></span><br><span class="line">             <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))  </span><br><span class="line">                 tail = head;  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">             <span class="comment">// (维护队列 CAS改变队尾)</span></span><br><span class="line">             node.prev = t;  </span><br><span class="line">             <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  </span><br><span class="line">                 t.next = node;  </span><br><span class="line">                 <span class="keyword">return</span> t;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法采用自旋+CAS。CAS是保证同一时刻只有一个线程能成功改变引用的指向。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094805424.png" alt="mark"></p><ul><li><p>根据上面的流程图，sync queue的创建过程。<strong>head节点是<code>new Node()</code>产生的，即其中的属性为默认值。</strong>也就是thread属性为null。也就是说<strong>正在执行的线程也会在<code>sync queue</code>中占据头节点，但是节点中不会保存线程信息。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094839510.png" alt="mark"></p></li></ul><p><strong>尾分叉问题：</strong></p><p>上面已经说了，该方法是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1：可能多个节点的prev指针都指向尾结点，导致尾分叉</span></span><br><span class="line">node.prev = t;  </span><br><span class="line"><span class="comment">//步骤2：但同一时刻，tail引用只会执行一个node。</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  </span><br><span class="line">   <span class="comment">//步骤3：现在环境是线程安全，旧尾结点的后继指针指向新尾结点。</span></span><br><span class="line">   t.next = node;  </span><br><span class="line">   <span class="keyword">return</span> t;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094920922.png" alt="mark"></p><p>执行完<code>步骤2</code>，但<code>步骤3</code>还未执行时，恰好有线程从头节点开始往后遍历。<strong>此时（旧）尾结点中的next域还为null。</strong>它是遍历不到新加进来的尾结点的。这显然是不合理的。</p><p>但此时<code>步骤1</code>是执行成功的，所以<strong>若是tail节点往前遍历，实际上是可以遍历到所有节点的</strong>，这也是为什么在AQS源码中，有时候常常会出现<strong>从尾结点开始逆向遍历链表的情况</strong>。</p><p>那些“分叉”的节点，肯定会入队失败。那么继续自旋，等待所有的线程节点全部入队成功。</p><h3 id="3-3-尝试获取锁-tryAcquire"><a href="#3-3-尝试获取锁-tryAcquire" class="headerlink" title="3.3 尝试获取锁 tryAcquire"></a>3.3 尝试获取锁 tryAcquire</h3><ul><li><strong>根据标志位state，来判断锁是否被占用</strong>。此时可能锁未被占用，由于是公平锁，于是会去判断<code>sync queue</code>中是否有人在排队。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();  </span><br><span class="line">    <span class="comment">//获取Lock对象的上锁情况，0-表示无线程持有；1-表示被线程持有；大于1-表示锁被重入</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();  </span><br><span class="line">    <span class="comment">//若此刻无人占有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;    <span class="comment">//判断队列中是否有前辈。若返回false代表没有，开始尝试加锁</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//此刻队列中没有存在前辈，尝试加锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);   <span class="comment">//将当前线程修改为持有锁的线程（后续判断可重入）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//若是当前线程是持有锁的线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  </span><br><span class="line">        <span class="comment">//当前状态+1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;  </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);  </span><br><span class="line">        setState(nextc);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//否则，代表加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法不具有原子性，可能多个线程都觉得自己不需要排队，最终还是依靠外面</span></span><br><span class="line"><span class="comment">//条件上的CAS来保持其原子性。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Node t = tail;   </span><br><span class="line">    Node h = head;  </span><br><span class="line">    Node s;  </span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;  </span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是<code>判断队列中是否存在元素</code>。可能存在以下几种情况：</p><ul><li><strong>此时未维护队列</strong>，<code>h!=t</code>返回false，即无人排队；</li><li>此时队列<strong>只有头节点</strong>（哑结点），<code>h!=t</code>返回false，即无人排队；</li><li>此时队列中<strong>存在2个的节点</strong>。若线程是头结点的后继节点线程（即处理正在办理业务的线程，进来的线程是第一个排队的线程）。那么<code>s.thread != Thread.currentThread()</code>返回false，即可是尝试加锁。</li><li>队列存在<strong>2个以上节点</strong>，且进来的线程不是第一个排队的线程，那么该线程需要乖乖的排队</li></ul><p>当然该方法不是并发安全的方法，即可能存在多个线程觉得自己无需排队，最终还是依靠<code>CAS</code>来争夺锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">    <span class="comment">//线程安全   </span></span><br><span class="line">    setExclusiveOwnerThread(current);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一时刻，只有一个线程可以成功改变state的状态。记录该线程为独占锁线程，一般后续可以重入。</p><p>没成功获取锁那么会调用<code>2.2 中的方法，将该线程加入到阻塞队列中</code>。</p><h3 id="3-4-阻塞线程-acquireQueued"><a href="#3-4-阻塞线程-acquireQueued" class="headerlink" title="3.4 阻塞线程 acquireQueued"></a>3.4 阻塞线程 acquireQueued</h3><ul><li>若执行到该方法，说明<code>addWaiter</code>方法已经成功将该线程包装为Node节点放到了队尾。</li><li>在该方法中依旧尝试获取锁；</li><li>再次获取锁失败后，会将其阻塞；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="comment">//获取node的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  </span><br><span class="line">            <span class="comment">//若前驱节点在办理业务，那么它将再次获取一次锁。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  </span><br><span class="line">                <span class="comment">//获取锁成功，此处便是线程安全。</span></span><br><span class="line">                <span class="comment">//将自己设置为头节点，并将自己设置为哑节点</span></span><br><span class="line">                setHead(node);  </span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC  </span></span><br><span class="line">                failed = <span class="keyword">false</span>;  </span><br><span class="line">                <span class="keyword">return</span> interrupted;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//获取锁失败，将自己挂起。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                parkAndCheckInterrupt())  </span><br><span class="line">                interrupted = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            cancelAcquire(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法时<code>自旋方法</code>，而出口就是获取到锁。若线程获取不到锁，便会将自己阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法时node线程获取锁成功后执行的，故是线程安全的。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;  </span><br><span class="line">    head = node;  </span><br><span class="line">    node.thread = <span class="keyword">null</span>;  </span><br><span class="line">    node.prev = <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-103752407.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//上一个节点的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;  </span><br><span class="line">    <span class="comment">//  Node.SIGNAL==-1</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    <span class="comment">//ws大于0，则说明该节点已经被取消了。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            node.prev = pred = pred.prev;  </span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);  </span><br><span class="line">        pred.next = node;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//CAS变更ws的状态</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是加锁失败开始执行的。也就是一个线程决定挂起之前需要执行的操作。这里就用到了节点中的信号量<code>waitStatus</code>。</p><ol><li>判断前驱节点<code>waitStatus</code>的值，会做出如下操作：<br> 1.1 前驱节点<code>waitStatus</code>若是-1，直接返回true。<br> 1.2 前驱节点<code>waitStatus</code>若大于0，证明前驱节点已被取消，那么在链表中删除前驱节点，直到node的前驱节点的<code>waitStatus</code>不大于0为止。然后返回false<br> 1.3. 若前驱节点<code>waitStatus</code>等于0，使用CAS尝试改变前驱节点<code>waitStatus</code>状态，由0到-1，然后返回false。</li></ol><ol start="2"><li>若是返回true，那么去阻塞该节点，若是返回false，那么继续自旋，继续上述过程，直至该方法返回true为止，方法返回true，便会执行下列方法，阻塞线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//将线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);  </span><br><span class="line">    <span class="comment">//线程被唤起时，查看线程的中断标识（注意，查看完毕后，中断标识归位）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：当前节点在阻塞之前，会将前驱节点的<code>waitStatus</code>设置为-1，就可保证前驱节点在适当的时机唤醒自己。</strong></p><h2 id="4-附录"><a href="#4-附录" class="headerlink" title="4. 附录"></a>4. 附录</h2><h3 id="4-1-CAS对象"><a href="#4-1-CAS对象" class="headerlink" title="4.1 CAS对象"></a>4.1 CAS对象</h3><p>开始我认为对象的CAS算法，实际上会是B对象去覆盖堆内存上的A对象，其实不然。比较交换的是引用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法是获取引用。而非堆上的内存。</span></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        valueOffset = unsafe.objectFieldOffset  </span><br><span class="line">            (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ex); &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-加锁总结"><a href="#5-加锁总结" class="headerlink" title="5. 加锁总结"></a>5. 加锁总结</h2><ol><li>因为AQS的等待队列是延迟加载，只有多个线程并发访问时，才会开始维护队列。</li><li>因为head节点中不包含<code>thread</code>属性的值，又被称为<code>哑节点</code>。</li><li>head是正在办理业务的节点，而他的后继节点是第一个排队节点。</li></ol><blockquote><ol><li>尝试加锁过程</li></ol></blockquote><ol><li>根据status判断当前锁是否被持有，若被持有，直接<code>维护队列</code>；</li><li>若未被持有，判断当前队列是否有节点在排队，若有节点排队，直接<code>维护队列</code>；</li><li>若无节点排队，则通过CAS修改锁状态标识，修改成功代表线程持有该锁；</li><li>使用<code>exclusiveOwnerThread</code>来保存持有锁的线程（解决线程重入）；</li></ol><blockquote><ol start="2"><li>维护队列过程</li></ol></blockquote><p>最终线程的head节点为哑节点。后续线程被组装成node节点，维护在链表中。</p><blockquote><ol start="3"><li>线程阻塞过程</li></ol></blockquote><ol><li>判断node节点是否为head节点的后续节点（第一个排队节点），若是的话，尝试获取锁。若获取到，将其设置为head节点，并将其设置为哑节点；</li><li>在阻塞前，会将自己的前驱节点的<code>waitStatus</code>设置为<code>SIGNAL</code>。以便可以唤醒自己。</li></ol><h2 id="6-锁的释放"><a href="#6-锁的释放" class="headerlink" title="6. 锁的释放"></a>6. 锁的释放</h2><h3 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h3><p>加锁的过程分析完以后，再来分析一下释放锁的过程，调用release方法，这个方法里面做两件事，</p><p><strong>1，释放锁 ；</strong></p><p><strong>2，唤醒park的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><ul><li>这个动作可以认为就是一个设置锁状态的操作，而且是将状态减掉传入的参数值（参数是1），如果结果状态为0，就将排它锁的Owner设置为null，以使得其它的线程有机会进行执行。</li><li>在排它锁中，加锁的时候状态会增加1（当然可以自己修改这个值），在解锁的时候减掉1，同一个锁，在可以重入后，可能会被叠加为2、3、4这些值，只有unlock()的次数与lock()的次数对应才会将Owner线程设置为空，而且也只有这种情况下才会返回true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3><ul><li>在方法unparkSuccessor(Node)中，就意味着真正要释放锁了，它传入的是head节点（head节点是占用锁的节点），当前线程被释放之后，需要唤醒下一个节点的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//判断后继节点是否为空或者是否是取消状态,</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点, 至于为什么从尾部开始向前遍历，因为在doAcquireInterruptibly.cancelAcquire方法的处理过程中只设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除锁的节点图文解析</strong></p><ul><li>head节点表示获取锁成功的节点，当头结点在释放同步状态时，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头结点，节点的变化过程如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/103308919.png" alt="mark"></p><p>这个过程也是涉及到两个变化</p><ul><li>修改head节点指向下一个获得锁的节点</li><li>新的获得锁的节点，将prev的指针指向null</li></ul><p><strong>注意：</strong></p><ul><li><strong>这里有一个小的变化，就是设置head节点不需要用CAS，原因是设置head节点是由获得锁的线程来完成的，而同步锁只能由一个线程获得，所以不需要CAS保证</strong></li><li><strong>只需要把head节点设置为原首节点的后继节点，并且断开原head节点的next引用即可</strong></li></ul><p><strong>参考博客</strong></p><p><a href="https://www.jianshu.com/p/dcc608274b88" target="_blank" rel="noopener">https://www.jianshu.com/p/dcc608274b88</a></p><p><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017372067</a></p><p><a href="https://www.cnblogs.com/fsmly/p/11274572.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsmly/p/11274572.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-19-AQS&quot;&gt;&lt;a href=&quot;#JUC-19-AQS&quot; class=&quot;headerlink&quot; title=&quot;JUC-19-AQS&quot;&gt;&lt;/a&gt;JUC-19-AQS&lt;/h1&gt;&lt;h2 id=&quot;1-AQS结构&quot;&gt;&lt;a href=&quot;#1-AQS结构&quot; class=&quot;headerlink&quot; title=&quot;1. AQS结构&quot;&gt;&lt;/a&gt;1. AQS结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;AQS（&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;）是Java众多锁以及并发工具的基础类，底层采用乐观锁，大量采用CAS操作保证其原子性，并且在并发冲突时，采用自旋方法重试。实现了轻量高效的获取锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-信号量&quot;&gt;&lt;a href=&quot;#1-1-信号量&quot; class=&quot;headerlink&quot; title=&quot;1.1 信号量&quot;&gt;&lt;/a&gt;1.1 信号量&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在AQS中，状态是由&lt;code&gt;volatile state&lt;/code&gt;来表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; state;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;该属性值表示锁的状态。&lt;ul&gt;
&lt;li&gt;state为0表示锁未被占用，&lt;/li&gt;
&lt;li&gt;state为1表示锁被线程持有，&lt;/li&gt;
&lt;li&gt;而state大于1表示锁被重入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而本文分析的是独占锁，那么同一时刻，锁只能被一个线程持有。&lt;/p&gt;
&lt;p&gt;不仅需要记录锁的状态，还需要记录当前获取锁的线程，实现重入。可以通过来记录。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Thread exclusiveOwnerThread;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhuuu.work/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-07-物理层</title>
    <link href="http://zhuuu.work/2020/08/02/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-07-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/08/02/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-07-%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2020-08-02T04:45:24.000Z</published>
    <updated>2020-10-04T11:15:05.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-07-物理层"><a href="#计算机网络-07-物理层" class="headerlink" title="计算机网络-07-物理层"></a>计算机网络-07-物理层</h1><h1 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h1><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h1 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h1><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/191456101.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络-07-物理层&quot;&gt;&lt;a href=&quot;#计算机网络-07-物理层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-07-物理层&quot;&gt;&lt;/a&gt;计算机网络-07-物理层&lt;/h1&gt;&lt;h1 id=&quot;通信方式&quot;&gt;&lt;a href=&quot;#通信方式&quot; cla
      
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-06-数据链路层</title>
    <link href="http://zhuuu.work/2020/08/01/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-06-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/08/01/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-06-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-08-01T04:45:24.000Z</published>
    <updated>2020-10-04T11:13:38.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-06-数据链路层"><a href="#计算机网络-06-数据链路层" class="headerlink" title="计算机网络-06-数据链路层"></a>计算机网络-06-数据链路层</h1><h1 id="前言-链路层的基本问题"><a href="#前言-链路层的基本问题" class="headerlink" title="前言 : 链路层的基本问题"></a>前言 : 链路层的基本问题</h1><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-093935934.png" alt="mark"></p><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h3><ul><li><p>透明表示一个实际存在的事物看起来好像不存在一样。</p></li><li><p>帧使用首部和尾部进行定界，<strong>如果帧的数据部分含有和首部尾部相同的内容</strong>，那么帧的开始和结束位置就会被错误的判定。</p></li><li><p>需要在数据部分出现首部尾部相同的内容前面插入转义字符。<strong>如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符</strong>。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，<strong>用户察觉不到转义字符的存在</strong>。</p></li></ul><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h3><ul><li>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</li></ul><a id="more"></a><h1 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h1><h2 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h2><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h2 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h2><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><h2 id="1-频分复用"><a href="#1-频分复用" class="headerlink" title="1. 频分复用"></a>1. 频分复用</h2><ul><li>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/191122799.png" alt="mark"></p><h2 id="2-时分复用"><a href="#2-时分复用" class="headerlink" title="2. 时分复用"></a>2. 时分复用</h2><ul><li>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/191142061.png" alt="mark"></p><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p><h2 id="3-统计时分复用"><a href="#3-统计时分复用" class="headerlink" title="3. 统计时分复用"></a>3. 统计时分复用</h2><ul><li>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/191205257.png" alt="mark"></p><h2 id="4-波分复用"><a href="#4-波分复用" class="headerlink" title="4. 波分复用"></a>4. 波分复用</h2><ul><li>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</li></ul><h2 id="5-码分复用"><a href="#5-码分复用" class="headerlink" title="5. 码分复用"></a>5. 码分复用</h2><ul><li>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}" class="mathjax-pic"/> 和 <img src="https://latex.codecogs.com/gif.latex?\vec{T}" class="mathjax-pic"/> 有</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/191315812.png" alt="mark" style="zoom:80%;" /><h1 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h1><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为   <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-095659471.png" alt="mark"></p><h1 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h1><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100345698.png" alt="mark"></p><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100434363.png" alt="mark"></p><h1 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h1><ul><li>MAC 地址是链路层地址，<strong>长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</strong></li><li><strong>一台主机拥有多少个网络适配器就有多少个 MAC 地址</strong>。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</li></ul><h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100818521.png" alt="mark"></p><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p>以太网是一种星型拓扑结构局域网。</p><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p><strong>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</strong></p><p>以太网帧格式：</p><ul><li><strong>类型</strong>  ：标记上层使用的协议；</li><li><strong>数据</strong>  ：<strong>长度在 46-1500 之间</strong>，如果太小则需要填充；</li><li><strong>FCS</strong>  ：帧检验序列，使用的是 CRC 检验方法；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/190817970.png" alt="mark"></p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><ul><li><p><strong>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</strong></p></li><li><p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p></li><li><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/190903624.png" alt="mark"></p><h1 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h1><ul><li>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</li><li>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</li><li>使用 <strong>VLAN 干线连接来建立虚拟局域网</strong>，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/191021361.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-06-数据链路层&quot;&gt;&lt;a href=&quot;#计算机网络-06-数据链路层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-06-数据链路层&quot;&gt;&lt;/a&gt;计算机网络-06-数据链路层&lt;/h1&gt;&lt;h1 id=&quot;前言-链路层的基本问题&quot;&gt;&lt;a href=&quot;#前言-链路层的基本问题&quot; class=&quot;headerlink&quot; title=&quot;前言 : 链路层的基本问题&quot;&gt;&lt;/a&gt;前言 : 链路层的基本问题&lt;/h1&gt;&lt;h3 id=&quot;1-封装成帧&quot;&gt;&lt;a href=&quot;#1-封装成帧&quot; class=&quot;headerlink&quot; title=&quot;1. 封装成帧&quot;&gt;&lt;/a&gt;1. 封装成帧&lt;/h3&gt;&lt;p&gt;将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-093935934.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-透明传输&quot;&gt;&lt;a href=&quot;#2-透明传输&quot; class=&quot;headerlink&quot; title=&quot;2. 透明传输&quot;&gt;&lt;/a&gt;2. 透明传输&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;透明表示一个实际存在的事物看起来好像不存在一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;帧使用首部和尾部进行定界，&lt;strong&gt;如果帧的数据部分含有和首部尾部相同的内容&lt;/strong&gt;，那么帧的开始和结束位置就会被错误的判定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要在数据部分出现首部尾部相同的内容前面插入转义字符。&lt;strong&gt;如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符&lt;/strong&gt;。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，&lt;strong&gt;用户察觉不到转义字符的存在&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-差错检测&quot;&gt;&lt;a href=&quot;#3-差错检测&quot; class=&quot;headerlink&quot; title=&quot;3. 差错检测&quot;&gt;&lt;/a&gt;3. 差错检测&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="mac地址" scheme="http://zhuuu.work/tags/mac%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>JVM-12-四种引用类型</title>
    <link href="http://zhuuu.work/2020/08/01/JVM_Notes/JVM-12-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhuuu.work/2020/08/01/JVM_Notes/JVM-12-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-08-01T02:38:38.000Z</published>
    <updated>2020-09-14T14:39:43.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-12-四种引用类型"><a href="#JVM-12-四种引用类型" class="headerlink" title="JVM-12-四种引用类型"></a>JVM-12-四种引用类型</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200804-142140836.png" alt="mark"></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><ul><li><p><strong>在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象</strong>。也就是说，只有对象处于可触及状态，程序才能使用它。这 就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了。</p></li><li><p>但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因 为也许将来还会派用场。<strong>对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃 圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。</strong></p></li><li><p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。<strong>这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用</strong>。</p></li></ul><a id="more"></a><h2 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h2><ul><li><strong>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用</strong>。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。<strong>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Arraylist&lt;String&gt;();</span><br><span class="line">list.add(str);</span><br></pre></td></tr></table></figure><blockquote><p>在list集合里的数据不会释放，即使内存不足也不会</p></blockquote><h2 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h2><ul><li>如果一个对象只具有软引用，那就类似于可有可物的生活用品。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</strong>只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li><li>软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</li></ul><h2 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h2><ul><li>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。<strong>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</strong>不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</li><li>弱引用可以和一个<strong>引用队列</strong>（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object c = <span class="keyword">new</span> Car(); <span class="comment">//只要c还指向car object, car object就不会被回收</span></span><br><span class="line">WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> WeakReference(Car)(car);</span><br></pre></td></tr></table></figure><p>当要获得weak reference引用的object时, 首先需要判断它是否已经被回收:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weakCar.get();</span><br></pre></td></tr></table></figure><p>如果此方法为空, 那么说明weakCar指向的对象已经被回收了.</p><p>下面来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">private</span> String colour;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, String colour)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">    <span class="keyword">this</span>.colour = colour;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getColour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> colour;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColour</span><span class="params">(String colour)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colour = colour;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> colour +<span class="string">"car costs $"</span>+price;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWeakReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Car car = <span class="keyword">new</span> Car(<span class="number">22000</span>,<span class="string">"silver"</span>);</span><br><span class="line">    WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> WeakReference&lt;Car&gt;(car);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(weakCar.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"Object is alive for "</span>+i+<span class="string">" loops - "</span>+weakCar);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Object has been collected."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在上例中, 程序运行一段时间后, 程序打印出”Object has been collected.” 说明, weak reference指向的对象的被回收了.</span><br><span class="line"></span><br><span class="line">如果要想打出的是</span><br><span class="line">Object is alive for “+i+” loops - “+weakCar</span><br><span class="line"></span><br><span class="line">那么只要在这句话前面加上</span><br><span class="line">System.out.println(“car&#x3D;&#x3D;&#x3D;&#x3D; “+car);</span><br><span class="line">因为在此强引用了car对象</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。</strong></p><p>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p><p><strong>这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</strong></p></blockquote><h2 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h2><ul><li>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就<strong>和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</li><li>虚引用与软引用和弱引用的一个区别在于：<strong>虚引用必须和引用队列（ReferenceQueue）联合使用</strong>。</li><li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line"></span><br><span class="line">强引用：</span><br><span class="line">String str &#x3D; “abc”;</span><br><span class="line">list.add(str);</span><br><span class="line">软引用：</span><br><span class="line">如果弱引用对象回收完之后，内存还是报警，继续回收软引用对象</span><br><span class="line">弱引用：</span><br><span class="line">如果虚引用对象回收完之后，内存还是报警，继续回收弱引用对象</span><br><span class="line">虚引用：</span><br><span class="line">虚拟机的内存不够使用，开始报警，这时候垃圾回收机制开始执行System.gc(); String s &#x3D; “abc”;如果没有对象回收了， 就回收没虚引用的对象</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-12-四种引用类型&quot;&gt;&lt;a href=&quot;#JVM-12-四种引用类型&quot; class=&quot;headerlink&quot; title=&quot;JVM-12-四种引用类型&quot;&gt;&lt;/a&gt;JVM-12-四种引用类型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200804-142140836.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象&lt;/strong&gt;。也就是说，只有对象处于可触及状态，程序才能使用它。这 就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因 为也许将来还会派用场。&lt;strong&gt;对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃 圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。&lt;strong&gt;这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="http://zhuuu.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://zhuuu.work/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JUC-18-CAS</title>
    <link href="http://zhuuu.work/2020/07/31/JUC/JUC-18-CAS/"/>
    <id>http://zhuuu.work/2020/07/31/JUC/JUC-18-CAS/</id>
    <published>2020-07-31T08:02:24.000Z</published>
    <updated>2020-08-11T08:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-18-CAS"><a href="#JUC-18-CAS" class="headerlink" title="JUC-18-CAS"></a>JUC-18-CAS</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>CAS<strong>（Compare-and-Swap），即比较并替换</strong>，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题，本文将深入的介绍CAS的原理。</li></ul><p>[参考博客][<a href="https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]</a></p><h2 id="2-CAS"><a href="#2-CAS" class="headerlink" title="2. CAS"></a>2. CAS</h2><h3 id="2-1-一个例子"><a href="#2-1-一个例子" class="headerlink" title="2.1 一个例子"></a>2.1 一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREADS_COUNT);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。</p><p>通过<strong>分析字节码</strong>我们知道，这是因为volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示），在并发的情况下，putstatic指令可能把较小的race值同步回主内存之中，导致我们每次都无法获得想要的结果。那么，应该怎么解决这个问题了？</p><a id="more"></a><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-170802496.png" alt="mark"></p><p><strong>解决方案1：Synchronized</strong></p><ul><li>首先我们想到的是用synchronized来修饰increase方法。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-170849960.png" alt="mark"></p><p>使用synchronized修饰后，increase方法变成了一个原子操作，因此是肯定能得到正确的结果。但是，我们知道，每次自增都进行加锁，性能可能会稍微差了点，有更好的方案吗？</p><p><strong>解决方案2：Atomic</strong></p><ul><li><p>答案当然是有的，这个时候我们可以使用Java并发包原子操作类（Atomic开头），例如以下代码。</p></li><li><p>将例子中的代码稍做修改：race改成使用AtomicInteger定义，“race++”改成使用“<code>race.getAndIncrement()</code>”，<code>AtomicInteger.getAndIncrement()</code>是原子操作，因此我们可以确保每次都可以获得正确的结果，并且在性能上有不错的提升</p></li><li><p><strong>通过方法调用，我们可以发现，<code>getAndIncrement</code>方法调用<code>getAndAddInt</code>方法，最后调用的是compareAndSwapInt方法，即本文的主角CAS，接下来我们开始介绍CAS。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-171109399.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-171128020.png" alt="mark"></p><h3 id="2-2-JDK中的CAS实现"><a href="#2-2-JDK中的CAS实现" class="headerlink" title="2.2 JDK中的CAS实现"></a>2.2 JDK中的CAS实现</h3><ol><li>JDK中提供了CAS支持？</li></ol><ul><li><p>通过调用JNI(<code>java Native interface</code>)</p></li><li><p>java中提供了对CAS的支持，具体在<strong>sun.misc.unsafe类中</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数var1 : 要操作的对象</strong></p><p><strong>参数var2 : 要操作的对象属性地址的偏移量</strong></p><p><strong>参数var4 : 期望值</strong></p><p><strong>参数var6 : 需要更新的新值</strong></p><ul><li>并且<code>compareAndSwapLong</code> 是使用CPU底层指令来实现的。以常用的Intel x86平台，最后映射到cpu的 <code>cmpxchg</code> 来实现，这是一个原子指令。</li><li>系统底层进行CAS操作的时候，会判断当前系统是否是多核心，<strong>如果是就给 “ 总线加锁”</strong>，加锁之后，只有一个线程会对总线加锁成功，也就是说CAS的操作是平台级别的。</li></ul><h3 id="2-3-CAS带来的问题"><a href="#2-3-CAS带来的问题" class="headerlink" title="2.3 CAS带来的问题"></a>2.3 CAS带来的问题</h3><ul><li><p>循环时间长开销很大。</p></li><li><p><strong>只能保证一个变量的原子操作。</strong></p></li><li><p><strong>ABA 问题 ： 一句话总结，狸猫换太子</strong></p><ul><li><p>解决方案： <code>AtomicStampReference</code> （Pair对象）</p></li><li><pre><code class="java"><span class="comment">// 内部类：不但要提供数据引用，还要提供版本号    </span><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>{        <span class="keyword">final</span> T reference;        <span class="keyword">final</span> <span class="keyword">int</span> stamp;        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>{            <span class="keyword">this</span>.reference = reference;             <span class="keyword">this</span>.stamp = stamp;        }        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>{            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);        }    }    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair&lt;!--￼<span class="number">2</span>--&gt;</code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-18-CAS&quot;&gt;&lt;a href=&quot;#JUC-18-CAS&quot; class=&quot;headerlink&quot; title=&quot;JUC-18-CAS&quot;&gt;&lt;/a&gt;JUC-18-CAS&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CAS&lt;strong&gt;（Compare-and-Swap），即比较并替换&lt;/strong&gt;，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题，本文将深入的介绍CAS的原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[参考博客][&lt;a href=&quot;https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-CAS&quot;&gt;&lt;a href=&quot;#2-CAS&quot; class=&quot;headerlink&quot; title=&quot;2. CAS&quot;&gt;&lt;/a&gt;2. CAS&lt;/h2&gt;&lt;h3 id=&quot;2-1-一个例子&quot;&gt;&lt;a href=&quot;#2-1-一个例子&quot; class=&quot;headerlink&quot; title=&quot;2.1 一个例子&quot;&gt;&lt;/a&gt;2.1 一个例子&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.CountDownLatch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;VolatileTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; race = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; THREADS_COUNT = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; CountDownLatch countDownLatch = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CountDownLatch(THREADS_COUNT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;increase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        race++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread[] threads = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread[THREADS_COUNT];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; THREADS_COUNT; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            threads[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        increase();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    countDownLatch.countDown();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            threads[i].start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        countDownLatch.await();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(race);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;我们知道，运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;分析字节码&lt;/strong&gt;我们知道，这是因为volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示），在并发的情况下，putstatic指令可能把较小的race值同步回主内存之中，导致我们每次都无法获得想要的结果。那么，应该怎么解决这个问题了？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-05-网络层</title>
    <link href="http://zhuuu.work/2020/07/30/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-05-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/07/30/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-05-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2020-07-30T04:45:24.000Z</published>
    <updated>2020-10-04T11:06:18.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-05-网络层"><a href="#计算机网络-05-网络层" class="headerlink" title="计算机网络-05-网络层"></a>计算机网络-05-网络层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（<code>Address Resolution Protocol</code>）</li><li>网际控制报文协议 ICMP（<code>Internet Control Message Protocol</code>）</li><li>网际组管理协议 IGMP（<code>Internet Group Management Protocol</code>）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145836206.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145806629.png" alt="mark"></p><a id="more"></a><h2 id="1-IP首部格式"><a href="#1-IP首部格式" class="headerlink" title="1. IP首部格式"></a>1. IP首部格式</h2><ul><li><p><strong>版本</strong>   : 有 4（<code>IPv4</code>）和 6（<code>IPv6</code>）两个值；</p></li><li><p><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度</strong>   : 包括首部长度和数据部分长度。</p></li><li><p><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p></li><li><p><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-150110526.png" alt="mark"></p><h2 id="2-IP-地址编址方式"><a href="#2-IP-地址编址方式" class="headerlink" title="2. IP 地址编址方式"></a>2. IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-155800467.png" alt="mark"></p><h3 id="2-2-子网划分"><a href="#2-2-子网划分" class="headerlink" title="2.2 子网划分"></a>2.2 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><h3 id="2-3-无分类"><a href="#2-3-无分类" class="headerlink" title="2.3 无分类"></a>2.3 无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="3-地址解析协议-ARP协议"><a href="#3-地址解析协议-ARP协议" class="headerlink" title="3. 地址解析协议 ARP协议"></a>3. 地址解析协议 ARP协议</h2><ul><li>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-160941278.png" alt="mark"></p><ul><li>ARP 实现由 IP 地址得到 MAC 地址。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161128364.png" alt="mark"></p><ul><li><strong>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</strong></li><li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161409408.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161422234.png" alt="mark"></p><h2 id="4-网际控制报文协议-ICMP"><a href="#4-网际控制报文协议-ICMP" class="headerlink" title="4. 网际控制报文协议 ICMP"></a>4. 网际控制报文协议 ICMP</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161731437.png" alt="mark"></p><ul><li>ICMP 报文分为<strong>差错报告报文</strong>和<strong>询问报文</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161929687.png" alt="mark"></p><h3 id="4-1-Ping"><a href="#4-1-Ping" class="headerlink" title="4.1 Ping"></a>4.1 Ping</h3><ul><li><strong>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</strong></li><li>Ping 的原理是通过向目的主机发送<code>ICMP Echo</code>请求报文，目的主机收到之后会发送 <code>Echo</code>回答报文。<code>Ping</code> 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</li></ul><h3 id="4-2-Traceroute"><a href="#4-2-Traceroute" class="headerlink" title="4.2 Traceroute"></a>4.2 Traceroute</h3><p><code>Traceroute</code> 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p><code>Traceroute</code> 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="5-网络地址转换-NAT"><a href="#5-网络地址转换-NAT" class="headerlink" title="5. 网络地址转换 NAT"></a>5. 网络地址转换 NAT</h2><ul><li><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p></li><li><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162506572.png" alt="mark"></p><h2 id="6-虚拟网络-VPN"><a href="#6-虚拟网络-VPN" class="headerlink" title="6. 虚拟网络 VPN"></a>6. 虚拟网络 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162739534.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162754293.png" alt="mark"></p><h2 id="7-路由器"><a href="#7-路由器" class="headerlink" title="7. 路由器"></a>7. 路由器</h2><h3 id="7-1-路由器结构"><a href="#7-1-路由器结构" class="headerlink" title="7.1 路由器结构"></a>7.1 路由器结构</h3><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-170149630.png" alt="mark"></p><h3 id="7-2-路由分组转发流程"><a href="#7-2-路由分组转发流程" class="headerlink" title="7.2 路由分组转发流程"></a>7.2 路由分组转发流程</h3><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-170414340.png" alt="mark"></p><h3 id="7-3-路由选择协议"><a href="#7-3-路由选择协议" class="headerlink" title="7.3 路由选择协议"></a>7.3 路由选择协议</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的<strong>自治系统 AS</strong>，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p><strong>可以把路由选择协议划分为两大类：</strong></p><ul><li><strong>自治系统内部的路由选择：RIP 和 OSPF</strong></li><li><strong>自治系统间的路由选择：BGP</strong></li></ul><h3 id="1-内部网关协议-RIP"><a href="#1-内部网关协议-RIP" class="headerlink" title="1. 内部网关协议 RIP"></a>1. 内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-OSPF"><a href="#2-内部网关协议-OSPF" class="headerlink" title="2. 内部网关协议 OSPF"></a>2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3 id="3-外部网关协议BGP"><a href="#3-外部网关协议BGP" class="headerlink" title="3. 外部网关协议BGP"></a>3. 外部网关协议BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-171655956.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-05-网络层&quot;&gt;&lt;a href=&quot;#计算机网络-05-网络层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-05-网络层&quot;&gt;&lt;/a&gt;计算机网络-05-网络层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址解析协议 ARP（&lt;code&gt;Address Resolution Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;网际控制报文协议 ICMP（&lt;code&gt;Internet Control Message Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;网际组管理协议 IGMP（&lt;code&gt;Internet Group Management Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145836206.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145806629.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="ip" scheme="http://zhuuu.work/tags/ip/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-04-抓包</title>
    <link href="http://zhuuu.work/2020/07/29/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-04-%E6%8A%93%E5%8C%85/"/>
    <id>http://zhuuu.work/2020/07/29/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-04-%E6%8A%93%E5%8C%85/</id>
    <published>2020-07-29T04:02:24.000Z</published>
    <updated>2020-10-04T11:02:17.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-04-抓包"><a href="#计算机网络-04-抓包" class="headerlink" title="计算机网络-04-抓包"></a>计算机网络-04-抓包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="1-抓包的作用"><a href="#1-抓包的作用" class="headerlink" title="1. 抓包的作用"></a>1. 抓包的作用</h2><p>在日常工作中，我们经常会用到抓包工具，看看前后台的数据传输、分析分析协议内容之类的。对于抓包工具在测试中的使用粗略归纳了几点：</p><p><strong>1.从功能测试角度，通过抓包查看隐藏字段</strong></p><ul><li>Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 C RSF 攻击，防网络爬虫，以及一些其他用途。<br> 这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。</li></ul><p><strong>2. 通过抓包工具了解协议内容，方便开展接口和性能测试</strong></p><ul><li>性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；<br> 接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。</li></ul><p><strong>3. 需要通过抓包工具，检查数据加密</strong></p><ul><li>安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。</li></ul><p><strong>4. 处理前后端 bug 归属之争</strong></p><ul><li>在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么 可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。</li></ul><p><strong>5. 通过抓包分析，可以更好的理解整个系统</strong></p><ul><li>经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。</li></ul><a id="more"></a><h2 id="2-中间人攻击"><a href="#2-中间人攻击" class="headerlink" title="2. 中间人攻击"></a>2. 中间人攻击</h2><p>首先fiddler截获客户端浏览器发送给服务器的https请求， 此时还未建立握手。</p><p>第一步， fiddler向服务器发送请求进行握手， 获取到服务器的CA证书， 用根证书公钥进行解密， 验证服务器数据签名， 获取到服务器CA证书公钥。</p><p>第二步， fiddler伪造自己的CA证书， 冒充服务器证书传递给客户端浏览器， 客户端浏览器做跟fiddler一样的事。</p><p>第三步， 客户端浏览器生成https通信用的对称密钥， 用fiddler伪造的证书公钥加密后传递给服务器， 被fiddler截获。</p><p>第四步， fiddler将截获的密文用自己伪造证书的私钥解开， 获得https通信用的对称密钥。</p><p>第五步， fiddler将对称密钥用服务器证书公钥加密传递给服务器， 服务器用私钥解开后建立信任， 握手完成， 用对称密钥加密消息， 开始通信。</p><p>第六步， fiddler接收到服务器发送的密文， 用对称密钥解开， 获得服务器发送的明文。再次加密， 发送给客户端浏览器。</p><p>第七步， 客户端向服务器发送消息， 用对称密钥加密， 被fidller截获后， 解密获得明文。</p><p>由于fiddler一直拥有通信用对称密钥， 所以在整个https通信过程中信息对其透明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-04-抓包&quot;&gt;&lt;a href=&quot;#计算机网络-04-抓包&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-04-抓包&quot;&gt;&lt;/a&gt;计算机网络-04-抓包&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;1-抓包的作用&quot;&gt;&lt;a href=&quot;#1-抓包的作用&quot; class=&quot;headerlink&quot; title=&quot;1. 抓包的作用&quot;&gt;&lt;/a&gt;1. 抓包的作用&lt;/h2&gt;&lt;p&gt;在日常工作中，我们经常会用到抓包工具，看看前后台的数据传输、分析分析协议内容之类的。对于抓包工具在测试中的使用粗略归纳了几点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.从功能测试角度，通过抓包查看隐藏字段&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 C RSF 攻击，防网络爬虫，以及一些其他用途。&lt;br&gt; 这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 通过抓包工具了解协议内容，方便开展接口和性能测试&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；&lt;br&gt; 接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 需要通过抓包工具，检查数据加密&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 处理前后端 bug 归属之争&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么 可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 通过抓包分析，可以更好的理解整个系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-03-传输层</title>
    <link href="http://zhuuu.work/2020/07/28/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-03-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/07/28/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-03-%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2020-07-28T04:02:24.000Z</published>
    <updated>2020-10-04T11:04:38.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-03-传输层"><a href="#计算机网络-03-传输层" class="headerlink" title="计算机网络-03-传输层"></a>计算机网络-03-传输层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>推荐博客：</strong> <a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p><p><strong>传输层和网络层的关系</strong></p><ul><li>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</li><li>传输层提供了进程中的逻辑通信，传输层向高层用户屏蔽了网络层的核心实现，使得应用进程看起来像是两个传输层实体之间一条端到端的逻辑通信信道。</li></ul><p>实际上，<strong>传输层和应用程序进程之间通过Socket（套接字）</strong>关联，这样通过Socket就可以区别同一主机上的不同应用进程，从而传输层提供服务变为可能；</p><p>实际上，每个套接字都有一个唯一的ID，被称为<strong>端口号</strong>；而在传输层接收到来自应用程序的分组并通过添加传输层首部而形成报文段的过程中，该端口号被写入；端口号大小在<code>0-65535</code>之间，其中<code>0-1023</code>属于周知端口号，它们为特定的Socket而拥有。</p><a id="more"></a><h2 id="1-UDP-和-TCP的特点"><a href="#1-UDP-和-TCP的特点" class="headerlink" title="1. UDP 和 TCP的特点"></a>1. UDP 和 TCP的特点</h2><ul><li><strong>用户数据报协议（UDP）</strong>（User Datagram Protocol）<ul><li>无连接的，尽最大努力交付</li><li>没有拥塞控制</li><li>面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）</li><li>支持一对一，一对多，多对一和多对多的交互通信。</li></ul></li><li><strong>传输控制协议 TCP</strong> （Transmission Control Protocol）<ul><li>面向连接的，提供可靠交付</li><li>有流量控制，拥塞避免，提供全双工通信</li><li>面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</li><li>每一条 TCP 连接只能是点对点的（一对一）。</li></ul></li></ul><h2 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h2><h3 id="2-1-UDP首部格式"><a href="#2-1-UDP首部格式" class="headerlink" title="2.1 UDP首部格式"></a>2.1 UDP首部格式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-102741716.png" alt="mark"></p><ul><li>首部字段只有8个字节，包括源端口，目的端口，长度，检验和。12字节的伪首部是为了计算检验和临时添加的</li></ul><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h2><h3 id="3-1-TCP-首部格式"><a href="#3-1-TCP-首部格式" class="headerlink" title="3.1 TCP 首部格式"></a>3.1 TCP 首部格式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-105028905.png" alt="mark"></p><ul><li><p><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong>：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认ACK :</strong> 当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步SYN</strong> : 在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止FIN :</strong> 用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p><strong>窗口</strong> ： 窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h3 id="3-2-TCP-的-三次握手（面试必问）"><a href="#3-2-TCP-的-三次握手（面试必问）" class="headerlink" title="3.2 TCP 的 三次握手（面试必问）"></a>3.2 TCP 的 三次握手（面试必问）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-110028209.png" alt="mark"></p><p>假设A是客户端，B是服务器端。</p><ul><li>首先B处于Listen(监听)状态，等待客户的连接请求。</li><li>A向B发送连接请求报文，SYN = 1 ，ACK = 0，选择一个初始的序号x</li><li>B收到连接请求报文，如果同意建立连接，则向A发送连接确认报文，SYN = 1，ACK = 1,确认号是 x + 1,同时也选择一个初始序号y</li><li>A收到B的连接确认报文后，还要向B发出确认，确认号为 y + 1,序号是 x +  1</li><li>B收到A的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><ul><li>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误的打开连接。</li><li><strong>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发送回的连接确认。</strong>客户端等待一个<strong>超时重传时间</strong>之后，就会重新请求连接。但是这个滞留的连接最后还是到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端就会忽略服务器之后发送的滞留连接请求的连接确认，不进行第三次握手，所以不会再次重复的打开连接。</li></ul><h3 id="3-3-TCP的四次挥手（面试必问）"><a href="#3-3-TCP的四次挥手（面试必问）" class="headerlink" title="3.3 TCP的四次挥手（面试必问）"></a>3.3 TCP的四次挥手（面试必问）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-111815380.png" alt="mark"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论ACK，因为ACK在连接建立之后都是1.</p><ul><li>A发送连接释放报文，FIN = 1</li><li>B 收到之后发出确认，此时TCP处于半关闭状态，B 能向A  发送数据但是 A 不能向 B 发送数据。</li><li>当B 不再不要连接的时候，发出连接释放报文， FIN = 1；</li><li>A 收到后发出确认，进入TIME-WAIT状态，等待2MSL (最大报文存活时间)后释放连接。</li><li>B 收到 A  的 确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><ul><li>客户端发送了FIN 连接释放报文之后，服务器收到了这个报文，就进入了CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。</li></ul><p><strong>TIME_WAIT</strong> </p><p>客户端接收到服务器段的FIN报文后进入此状态，此时并不是直接进入CLOSED状态，还需要等待一个<strong>时间计时器设置的时间2MSL</strong> 。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h3 id="3-4-TCP-的-可靠传输"><a href="#3-4-TCP-的-可靠传输" class="headerlink" title="3.4 TCP 的 可靠传输"></a>3.4 TCP 的 可靠传输</h3><ul><li><strong>TCP使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么 就重传这个报文段。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-133408214.png" alt="mark"></p><ul><li><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><ul><li>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</li></ul></li><li><p>超时时间 RTO 应该略大于 RTTs，<strong>TCP 使用的超时时间计算如下：</strong></p><ul><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-133514339.png" alt="mark"></li><li>其中 RTT<sub>d</sub> 为偏差的加权平均值。</li></ul></li></ul><h3 id="3-5-TCP-滑动窗口"><a href="#3-5-TCP-滑动窗口" class="headerlink" title="3.5 TCP 滑动窗口"></a>3.5 TCP 滑动窗口</h3><ul><li><p>窗口是缓存的一部分，用来暂时存放字节流。<strong>发送方和接收方各有一个窗口</strong>，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</strong></p></li><li><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。</p><ul><li>如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；</li><li>接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-134644530.png" alt="mark"></p><h3 id="3-6-TCP-流量控制"><a href="#3-6-TCP-流量控制" class="headerlink" title="3.6 TCP 流量控制"></a>3.6 TCP 流量控制</h3><ul><li><strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收</strong></li><li>接收方发送的确认报文中的窗口字段可以用来控制发送方的窗口大小，从而影响发送方的发送速率。将窗口字段设置成0，则发送方不能发送数据。</li></ul><h3 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a>3.7 TCP 拥塞控制</h3><ul><li><strong>如果网络出现拥塞</strong>，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。</li><li>因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。</li><li><strong>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-135235298.png" alt="mark"></p><p>TCP 主要通过四种算法来进行拥塞控制：<strong>慢开始，拥塞避免，快重传，快恢复。</strong></p><ul><li>发送方需要维护一个叫做<strong>拥塞窗口（cwnd）的状态变量</strong>，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</li></ul><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><h4 id="3-7-1-慢开始和拥塞避免"><a href="#3-7-1-慢开始和拥塞避免" class="headerlink" title="3.7.1 慢开始和拥塞避免"></a>3.7.1 慢开始和拥塞避免</h4><ul><li><p>发送的最初执行<strong>慢开始，令 cwnd = 1，发送方只能发送 1 个报文段</strong>；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p></li><li><p>注意到慢开始<strong>每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快</strong>，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。<strong>设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</strong></p></li><li><p><strong>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</strong></p></li></ul><h4 id="3-7-2-快重传和快恢复"><a href="#3-7-2-快重传和快恢复" class="headerlink" title="3.7.2 快重传和快恢复"></a>3.7.2 快重传和快恢复</h4><ul><li><p><strong>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。</strong>例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p></li><li><p><strong>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传</strong>，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p></li><li><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。<strong>因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</strong></p></li><li><p><strong>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-140417321.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-03-传输层&quot;&gt;&lt;a href=&quot;#计算机网络-03-传输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-03-传输层&quot;&gt;&lt;/a&gt;计算机网络-03-传输层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;推荐博客：&lt;/strong&gt; &lt;a href=&quot;https://blog.csdn.net/qq_39326472/article/details/88089747&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_39326472/article/details/88089747&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层和网络层的关系&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。&lt;/li&gt;
&lt;li&gt;传输层提供了进程中的逻辑通信，传输层向高层用户屏蔽了网络层的核心实现，使得应用进程看起来像是两个传输层实体之间一条端到端的逻辑通信信道。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，&lt;strong&gt;传输层和应用程序进程之间通过Socket（套接字）&lt;/strong&gt;关联，这样通过Socket就可以区别同一主机上的不同应用进程，从而传输层提供服务变为可能；&lt;/p&gt;
&lt;p&gt;实际上，每个套接字都有一个唯一的ID，被称为&lt;strong&gt;端口号&lt;/strong&gt;；而在传输层接收到来自应用程序的分组并通过添加传输层首部而形成报文段的过程中，该端口号被写入；端口号大小在&lt;code&gt;0-65535&lt;/code&gt;之间，其中&lt;code&gt;0-1023&lt;/code&gt;属于周知端口号，它们为特定的Socket而拥有。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>排序-03-快速排序</title>
    <link href="http://zhuuu.work/2020/07/27/Sort/%E6%8E%92%E5%BA%8F-03-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/07/27/Sort/%E6%8E%92%E5%BA%8F-03-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-27T10:33:24.000Z</published>
    <updated>2020-09-16T06:31:53.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-03-快速排序"><a href="#排序-03-快速排序" class="headerlink" title="排序-03-快速排序"></a>排序-03-快速排序</h1><h2 id="1-思想"><a href="#1-思想" class="headerlink" title="1. 思想"></a>1. 思想</h2><ul><li><strong>快速排序,说白了就是给基准数据找其正确索引位置的过程.</strong></li></ul><p>举个栗子：</p><ul><li>如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105141936.png" alt="mark"></p><a id="more"></a><ul><li>首先从后半部分开始，<strong>如果扫描到的值大于基准数据就让high减1</strong>,<strong><em>如果发现有元素比该基准数据的值小(如上图中18&lt;=tmp)，就将high位置的值赋值给low位置</em></strong> ,结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105611384.png" alt="mark"></p><ul><li>然后开始从前往后扫描,<strong>如果扫描到的值小于基准数据就让low加1</strong>,<strong><em>如果发现有元素大于基准数据的值(如上图46=&gt;tmp)，就再将low位置的值赋值给high位置的值</em></strong>,指针移动并且数据交换后的结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105635565.png" alt="mark"></p><ul><li>然后再开始从后向前扫描,原理同上,发现上图<code>11&lt;=tmp</code>,则将high位置的值赋值给low位置的值,结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105749727.png" alt="mark"></p><ul><li><strong>这样一遍走下来,可以很清楚的知道,其实快速排序的本质就是把基准数大的都放在基准数的右边,把比基准数小的放在基准数的左边,这样就找到了该数据在数组中的正确位置.</strong></li><li><strong>以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。</strong></li></ul><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2. 结论"></a>2. 结论</h2><p>从上面的过程中可以看到:</p><p>  ①先从队尾开始向前扫描且当<code>low &lt; high</code>时,如果<code>a[high] &gt; tmp</code>则<code>high–</code>,但如果<code>a[high] &lt; tmp</code>,则将<code>high</code>的值赋值给<code>low</code>,即<code>arr[low] = a[high]</code>,同时要转换数组扫描的方式,即需要从队首开始向队尾进行扫描了<br>  ②同理,当从队首开始向队尾进行扫描时,如果<code>a[low] &lt; tmp</code>,则<code>low++</code>,但如果<code>a[low] &gt; tmp</code>了,则就需要将<code>low</code>位置的值赋值给<code>high</code>位置,即<code>arr[low] = arr[high]</code>,同时将数组扫描方式换为由队尾向队首进行扫描.</p><p>​    ③不断重复①和②,知道<code>low&gt;=high</code>时(其实是<code>low=high</code>),<code>low</code>或<code>high</code>的位置就是该基准数据在数组中的正确索引位置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">76</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">22</span> &#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"排序后:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 找寻基准数据的正确索引</span></span><br><span class="line">            <span class="keyword">int</span> index = getIndex(arr, low, high);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序</span></span><br><span class="line">            quickSort(arr, low, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基准数据</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 当队尾的元素大于等于基准数据时,向前挪动high指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果队尾元素小于tmp了,需要将其赋值给low</span></span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            <span class="comment">// 当队首元素小于等于tmp时,向前挪动low指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= tmp) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当队首元素大于tmp时,需要将其赋值给high</span></span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置</span></span><br><span class="line">        <span class="comment">// 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low]</span></span><br><span class="line">        arr[low] = tmp;</span><br><span class="line">        <span class="keyword">return</span> low; <span class="comment">// 返回tmp的正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-优化"><a href="#3-优化" class="headerlink" title="3. 优化"></a>3. 优化</h2><p>参考博客 ： <a href="https://blog.csdn.net/qq_19525389/article/details/81436838" target="_blank" rel="noopener">https://blog.csdn.net/qq_19525389/article/details/81436838</a></p><p><strong>1、快速排序的基本思想：</strong></p><ul><li>快速排序使用<strong>分治</strong>的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。</li><li>之后分别对这两部分记录继续进行排序，递归地以达到整个序列有序的目的。</li></ul><p><strong>2、快速排序的三个步骤：</strong></p><p>(1<strong>)选择基准</strong>：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</p><p>(2)<strong>分割操作</strong>：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p><p>(3)<strong>递归地</strong>对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><p><strong>优化一 ： 选择基准的方式</strong></p><ul><li><p>对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p></li><li><p>最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列</p></li></ul><p>我们介绍<strong>三种选择基准的方法</strong></p><ol><li>思想：取序列的第一个或最后一个元素作为基准</li></ol><p>基本的快速排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr[low];<span class="comment">//选择选取序列的第一个元素作为基准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：基本的快速排序选取第一个或最后一个元素作为基准。但不是一种好方法</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113020716.png" alt="mark"></p><p>测试数据分析：如果输入序列是随机的，处理时间可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为起泡排序，时间复杂度为Θ(n^2)。而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为枢纽元是非常糟糕的，为了避免这个情况，就引入了下面两个获取基准的方法。</p><p><strong>方法(2)：随机选取基准</strong></p><p>引入的原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴</p><p>思想：取待排序列中任意一个元素作为基准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/*随机选择枢轴的位置，区间在low和high之间*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivotRandom</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((unsigned)time(NULL));<span class="comment">//产生枢轴的位置</span></span><br><span class="line"><span class="keyword">int</span> pivotPos = rand()%(high - low) + low;</span><br><span class="line"> </span><br><span class="line">swap(arr[pivotPos],arr[low]);<span class="comment">//把枢轴位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数</span></span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113115935.png" alt="mark"></p><p><strong>方法三： 三数取中</strong></p><ul><li>引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取枢轴</li><li>具体思想：对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">举例：待排序序列为：8 1 4 9 6 3 5 2 7 0</span><br><span class="line"></span><br><span class="line">左边为：8，右边为0，中间为6.</span><br><span class="line"></span><br><span class="line">我们这里取三个数排序后，中间那个数作为枢轴，则枢轴为6</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivotMedianOfThree</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);<span class="comment">//计算数组中间的元素的下标</span></span><br><span class="line"><span class="comment">//使用三数取中法选择枢轴</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[high])<span class="comment">//目标: arr[mid] &lt;= arr[high]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[mid],arr[high]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; arr[high])<span class="comment">//目标: arr[low] &lt;= arr[high]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[low],arr[high]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[low]) <span class="comment">//目标: arr[low] &gt;= arr[mid]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[mid],arr[low]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此时，arr[mid] &lt;= arr[low] &lt;= arr[high]</span></span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line"><span class="comment">//low的位置上保存这三个位置中间的值</span></span><br><span class="line"><span class="comment">//分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113256817.png" alt="mark"></p><p><strong>优化二：当待排序序列长度分割到一定大小后，使用插入排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</span><br><span class="line"></span><br><span class="line">截止范围：待排序序列长度N &#x3D; 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。摘自《数据结构与算法分析》Mark Allen Weiness 著</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (high - low + <span class="number">1</span> &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">InsertSort(arr,low,high);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//else时，正常执行快排</span></span><br></pre></td></tr></table></figure><p>测试数据：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113505110.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试数据分析：针对随机数组，使用三数取中选择枢轴+插排，效率还是可以提高一点，</span><br><span class="line">但是针对已排序的数组，是没有任何用处的。因为待排序序列是已经有序的，那么每次划分只能使待排序序列减一。</span><br><span class="line">此时，插排是发挥不了作用的。所以这里看不到时间的减少。另外，三数取中选择枢轴+插排还是不能处理重复数组</span><br></pre></td></tr></table></figure><p><strong>优化三：在一次分割结束后，可以把key相等的元素聚集在一起，不用在对key相等的元素分割</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line"></span><br><span class="line">待排序序列 <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">三数取中选取枢轴：下标为<span class="number">4</span>的数<span class="number">6</span></span><br><span class="line"></span><br><span class="line">转换后，待分割序列：<span class="number">6</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">             枢轴key：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">本次划分后，未对与key元素相等处理的结果：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">下次的两个子序列为：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> 和 <span class="number">7</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">本次划分后，对与key元素相等处理的结果：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">下次的两个子序列为：<span class="number">1</span> <span class="number">4</span> 和 <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">经过对比，我们可以看出，在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少</span><br><span class="line"></span><br><span class="line">具体过程：在处理过程中，会有两个步骤</span><br><span class="line"></span><br><span class="line">第一步，在划分过程中，把与key相等元素放入数组的两端</span><br><span class="line"></span><br><span class="line">第二步，划分结束后，把与key相等的元素移到枢轴周围</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br><span class="line">待排序序列 <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">三数取中选取枢轴：下标为<span class="number">4</span>的数<span class="number">6</span></span><br><span class="line"></span><br><span class="line">转换后，待分割序列：<span class="number">6</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">             枢轴key：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">第一步，在划分过程中，把与key相等元素放入数组的两端 </span><br><span class="line"></span><br><span class="line">结果为：<span class="number">6</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span>(枢轴) <span class="number">7</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">此时，与<span class="number">6</span>相等的元素全放入在两端了</span><br><span class="line"></span><br><span class="line">第二步，划分结束后，把与key相等的元素移到枢轴周围</span><br><span class="line"></span><br><span class="line">结果为：<span class="number">1</span> <span class="number">4</span> <span class="number">66</span>(枢轴)  <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">此时，与<span class="number">6</span>相等的元素全移到枢轴周围了</span><br><span class="line"></span><br><span class="line">之后，在<span class="number">1</span> <span class="number">4</span> 和 <span class="number">7</span> <span class="number">8</span> <span class="number">7</span>两个子序列进行快排</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gather</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> boundKey, <span class="keyword">int</span> *left, <span class="keyword">int</span> *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> count = boundKey - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = boundKey - <span class="number">1</span>; i &gt;= low; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[boundKey])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr, i, count);</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*left = count;</span><br><span class="line">count = boundKey + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = boundKey + <span class="number">1</span>; i &lt;= high; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[boundKey])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr, i, count);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*right = count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因：在数组中，如果有相等的元素，那么就可以减少不少冗余的划分。这点在重复数组中体现特别明显啊。</strong></p><p>其实这里，插排的作用还是不怎么大的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-03-快速排序&quot;&gt;&lt;a href=&quot;#排序-03-快速排序&quot; class=&quot;headerlink&quot; title=&quot;排序-03-快速排序&quot;&gt;&lt;/a&gt;排序-03-快速排序&lt;/h1&gt;&lt;h2 id=&quot;1-思想&quot;&gt;&lt;a href=&quot;#1-思想&quot; class=&quot;headerlink&quot; title=&quot;1. 思想&quot;&gt;&lt;/a&gt;1. 思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速排序,说白了就是给基准数据找其正确索引位置的过程.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105141936.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="快速排序" scheme="http://zhuuu.work/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-02-应用层</title>
    <link href="http://zhuuu.work/2020/07/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-02-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/07/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-02-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-07-27T04:02:24.000Z</published>
    <updated>2020-10-04T11:01:57.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-02-应用层"><a href="#计算机网络-02-应用层" class="headerlink" title="计算机网络-02-应用层"></a>计算机网络-02-应用层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>一图胜千言</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172919828.png" alt="mark"></p><a id="more"></a><h2 id="1-DNS-域名系统"><a href="#1-DNS-域名系统" class="headerlink" title="1. DNS : 域名系统"></a>1. DNS : 域名系统</h2><ul><li>DNS 是一个由分层DNS服务器组成的<strong>分布式数据库</strong>，使得主机可以查询主机名和ip相互转换的规则。</li><li><strong>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174020503.png" alt="mark"></p><ul><li>DNS 可以<strong>使用UDP或者TCP进行传输，使用的端口号都是53</strong>，大多数情况DNS使用UDP进行传输，这就要求域名解析器和域名服务器有自己处理超时和重传从而保证可靠性。</li></ul><h3 id="1-1-实现原理"><a href="#1-1-实现原理" class="headerlink" title="1.1 实现原理"></a>1.1 实现原理</h3><ul><li><p><strong>首先，DNS使用UDP作为传输协议，DNS使用53号端口</strong>。</p></li><li><p>当主机上的DNS客户端收到一个转换请求的时候，<strong>客户端将向网络发送一个DNS查询报文</strong>，然后客户端将收到一个包含相关信息的DNS回答报文，这个报文里有客户端想要的内容</p></li><li><p><strong>之后DNS服务器将IP地址返回给请求的提出者即可</strong></p></li><li><p>DNS查询有两种，一种是<strong>递归查询</strong>一种是<strong>迭代查询</strong>；实践中，查询通常满足这样的模式：<strong>从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的</strong>。</p></li><li><p><strong>DNS缓存</strong>原理十分简单，每当DNS服务器发出请求后收到回答时，就<strong>将回答的内容缓存在它自己的主机空间上</strong>。这样，如果有相同的请求到达时，就不需要再去发出请求，直接使用缓存即可；因为有了缓存，本地DNS就可以直接提供一些经常被访问的主机名所对应的IP地址，而不需要询问根DNS服务器了。</p></li></ul><h2 id="2-文件传送协议：FTP"><a href="#2-文件传送协议：FTP" class="headerlink" title="2. 文件传送协议：FTP"></a>2. 文件传送协议：FTP</h2><ul><li>FTP 使用 TCP 建立链接，他需要两个链接来传送一个文件<ul><li><strong>控制连接</strong>：<strong>服务器打开端口号21等待客户端连接</strong>，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并返回服务器的应答</li><li><strong>数据连接</strong>：<strong>用来传送一个数据文件</strong>。</li></ul></li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><ul><li>主动模式：<strong>服务器端主动</strong>建立数据连接，其中服务器的端口号是20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174711960.png" alt="mark"></p><ul><li>被动模式：客户端主动和<strong>服务器建立数据连接</strong>，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174747930.png" alt="mark"></p><p>注意：</p><ul><li><strong>主动模式要求客户端开放端口号给服务器，需要配置客户端的防火墙。</strong></li><li>被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</li></ul><h2 id="3-动态主机配置协议（DHCP）"><a href="#3-动态主机配置协议（DHCP）" class="headerlink" title="3. 动态主机配置协议（DHCP）"></a>3. 动态主机配置协议（DHCP）</h2><ul><li>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</li><li>DHCP 配置的内容<strong>不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</strong></li></ul><h3 id="3-1-DHCP工作工程"><a href="#3-1-DHCP工作工程" class="headerlink" title="3.1 DHCP工作工程"></a>3.1 DHCP工作工程</h3><ol><li><p>客户端发送Discover 报文，该报文的目的地址是 255.255.255.255:<strong>67</strong>,源地址是0.0.0.0：<strong>68</strong>.</p></li><li><p>放入UDP中，该报文被广播到同一个子网的所有主机上，如果客户端和DHCP服务器不在同一个子网，就需要使用中继代理。</p></li><li><p>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</p></li><li><p>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</p></li><li><p>DHCP服务器发送Ack 报文，表示该客户端此时可以使用提供给它的信息。</p></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-085949476.png" alt="mark"></p><h2 id="4-远程登录协议"><a href="#4-远程登录协议" class="headerlink" title="4. 远程登录协议"></a>4. 远程登录协议</h2><ul><li>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</li><li>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</li></ul><h2 id="5-电子邮件协议"><a href="#5-电子邮件协议" class="headerlink" title="5. 电子邮件协议"></a>5. 电子邮件协议</h2><ul><li>一个电子邮件由三部分组成：用户代理，邮件服务器和邮件协议。</li><li>邮件协议包含发送协议和读取协议：<ul><li>发送协议：SMTP</li><li>读取协议： POP3 和 IMAP</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-091118003.png" alt="mark"></p><h3 id="5-1-SMTP"><a href="#5-1-SMTP" class="headerlink" title="5.1 SMTP"></a>5.1 SMTP</h3><ul><li>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</li><li>端口号25</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-091207208.png" alt="mark"></p><h3 id="5-2-POP3"><a href="#5-2-POP3" class="headerlink" title="5.2 POP3"></a>5.2 POP3</h3><ul><li>端口号110</li><li>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</li></ul><h3 id="5-3-IMAP"><a href="#5-3-IMAP" class="headerlink" title="5.3 IMAP"></a>5.3 IMAP</h3><ul><li>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</li><li>端口号143</li></ul><h2 id="6-常用端口号"><a href="#6-常用端口号" class="headerlink" title="6. 常用端口号"></a>6. 常用端口号</h2><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">端口号</th><th align="center">传输层协议</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">域名解析</td><td align="center">DNS</td><td align="center">53</td><td align="center">UDP/TCP</td><td align="center">长度超过 512 字节时使用 TCP</td></tr><tr><td align="center">动态主机配置协议</td><td align="center">DHCP</td><td align="center">67/68</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">简单网络管理协议</td><td align="center">SNMP</td><td align="center">161/162</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">文件传送协议</td><td align="center">FTP</td><td align="center">20/21</td><td align="center">TCP</td><td align="center">控制连接 21，数据连接 20</td></tr><tr><td align="center">远程终端协议</td><td align="center">TELNET</td><td align="center">23</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传送协议</td><td align="center">HTTP</td><td align="center">80</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">简单邮件传送协议</td><td align="center">SMTP</td><td align="center">25</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">邮件读取协议</td><td align="center">POP3</td><td align="center">110</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">网际报文存取协议</td><td align="center">IMAP</td><td align="center">143</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传送协议+SSL</td><td align="center">HTTPS</td><td align="center">443</td><td align="center">TCP</td><td align="center"></td></tr></tbody></table><h2 id="7-Web-请求页面的过程"><a href="#7-Web-请求页面的过程" class="headerlink" title="7.  Web 请求页面的过程"></a>7.  Web 请求页面的过程</h2><h3 id="7-1-DHCP配置主机信息"><a href="#7-1-DHCP配置主机信息" class="headerlink" title="7.1 DHCP配置主机信息"></a>7.1 DHCP配置主机信息</h3><ul><li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li><li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li><li>该数据报则被放置在MAC 帧中，该帧的目的地址 <code>FF FF FF FF FF FF</code>,广播到与交换机连接的所有设备。</li><li>连接到交换机的<strong>DHCP的服务器</strong>收到广播帧之后，不断向上分解得到IP数据报，UDP报文段，DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址，DNS服务器的IP地址，默认路由网关的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段又被放入IP数据报中，最后放入MAC帧中。</li><li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地s址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li><li><strong>主机</strong>收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li></ul><h3 id="7-2-ARP-解析MAC地址"><a href="#7-2-ARP-解析MAC地址" class="headerlink" title="7.2 ARP 解析MAC地址"></a>7.2 ARP 解析MAC地址</h3><ul><li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li><li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li><li>该DNS查询报文被放入目的地址为DNS服务器的IP地址的IP数据报中。</li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li><li><strong>DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议。</strong></li><li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（<code>FF FF FF FF FF FF</code>）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li><li><strong>网关路由器收到该帧后，不断向上分解得到ARP报文，发现其中IP地址和其接口IP地址匹配，因此就发送一个ARP回答报文，包含了他的MAC地址，发送回主机。</strong></li></ul><h3 id="7-3-DNS解析域名"><a href="#7-3-DNS解析域名" class="headerlink" title="7.3 DNS解析域名"></a>7.3 DNS解析域名</h3><ul><li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p></li><li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p></li><li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p></li><li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p></li><li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p></li></ul><h3 id="7-4-HTTP请求页面"><a href="#7-4-HTTP请求页面" class="headerlink" title="7.4 HTTP请求页面"></a>7.4 HTTP请求页面</h3><ul><li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p></li><li><p>在<strong>生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接</strong>。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p></li><li><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p></li><li><p><strong>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</strong></p></li><li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p></li><li><p><strong>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</strong></p></li></ul><p><strong>参考博客：</strong><a href="https://blog.csdn.net/JAck_chen0309/article/details/105020259![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-110232883.png)" target="_blank" rel="noopener">https://blog.csdn.net/JAck_chen0309/article/details/105020259![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-110232883.png)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-02-应用层&quot;&gt;&lt;a href=&quot;#计算机网络-02-应用层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-02-应用层&quot;&gt;&lt;/a&gt;计算机网络-02-应用层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一图胜千言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172919828.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-01-概述</title>
    <link href="http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-07-26T03:02:24.000Z</published>
    <updated>2020-07-26T09:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-01-概述"><a href="#计算机网络-01-概述" class="headerlink" title="计算机网络-01-概述"></a>计算机网络-01-概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-164551248.jpg" alt="mark"></p><ul><li>本教程是秋招面试复习用计算机网络知识点(意味着书上的“废话” 不会在本系列学习笔记中出现)</li><li>配套教材《计算机网络-自顶向下的方法》</li></ul><a id="more"></a><h2 id="1-网络中的网络"><a href="#1-网络中的网络" class="headerlink" title="1. 网络中的网络"></a>1. 网络中的网络</h2><ul><li>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165259125.png" alt="mark"></p><h2 id="2-ISP"><a href="#2-ISP" class="headerlink" title="2. ISP"></a>2. ISP</h2><ul><li>互联网提供商ISP可以从互联网管理机构获取许多IP地址</li><li>同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165342332.png" alt="mark"></p><ul><li>目前互联网是一种多层次的ISP结构，ISP根据覆盖面积的大小分为<ul><li>第一层ISP</li><li>区域ISP</li><li>接入ISP</li></ul></li><li>互联网交换节点IXP 允许两个ISP直接相连而不用经过第三个ISP</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165517216.png" alt="mark"></p><h2 id="3-主机之间的通信方式"><a href="#3-主机之间的通信方式" class="headerlink" title="3. 主机之间的通信方式"></a>3. 主机之间的通信方式</h2><ul><li><strong>客户端-服务器（C/S）</strong>:客户是服务的请求方，服务器是服务的提供方。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165625304.png" alt="mark"></p><ul><li><strong>对等（P2P）</strong>:不区分客户和服务器。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165638288.png" alt="mark"></p><h2 id="4-电路交换和分组交换"><a href="#4-电路交换和分组交换" class="headerlink" title="4. 电路交换和分组交换"></a>4. 电路交换和分组交换</h2><h3 id="4-1-电路交换"><a href="#4-1-电路交换" class="headerlink" title="4.1 电路交换"></a>4.1 电路交换</h3><ul><li>电路交换用于电话通信系统，两个用户通信之前需要建立一条专用的物理链路，并且整个通信过程中始终占用该链路。</li><li>由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</li></ul><h3 id="4-2-分组交换"><a href="#4-2-分组交换" class="headerlink" title="4.2 分组交换"></a>4.2 分组交换</h3><ul><li>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一条传输线路上同时传输多个分组互相不回影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</li><li>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，<strong>分组交换也使用了存储转发过程。</strong></li></ul><h2 id="5-时延"><a href="#5-时延" class="headerlink" title="5. 时延"></a>5. 时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170041265.png" alt="mark"></p><h3 id="5-1-排队时延"><a href="#5-1-排队时延" class="headerlink" title="5.1 排队时延"></a>5.1 排队时延</h3><ul><li>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li></ul><h3 id="5-2-处理时延"><a href="#5-2-处理时延" class="headerlink" title="5.2 处理时延"></a>5.2 处理时延</h3><ul><li>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</li></ul><h3 id="5-3-传输时延"><a href="#5-3-传输时延" class="headerlink" title="5.3 传输时延"></a>5.3 传输时延</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170144654.png" alt="mark"></p><p>其中 l 表示数据帧的长度，v 表示传输速率。</p><h3 id="5-4-传播时延"><a href="#5-4-传播时延" class="headerlink" title="5.4 传播时延"></a>5.4 传播时延</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170258454.png" alt="mark"></p><p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p><h2 id="6-计算机网络体系结构（重点）"><a href="#6-计算机网络体系结构（重点）" class="headerlink" title="6. 计算机网络体系结构（重点）"></a>6. 计算机网络体系结构（重点）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170612601.png" alt="mark"></p><h3 id="6-1-五层协议（面试答这个）"><a href="#6-1-五层协议（面试答这个）" class="headerlink" title="6.1 五层协议（面试答这个）"></a>6.1 五层协议（面试答这个）</h3><ul><li><p><strong>应用层：</strong> 为了特定的<strong>应用程序</strong>提供数据传输服务（例如HTTP,DNS协议）。<strong>数据单位是报文</strong></p></li><li><p><strong>传输层：</strong> 为进程提供<strong>通用数据传输服务</strong>。用于应用层协议很多，定义通用传输协议就可以支持不断的增多应用层协议。运输层包括两种协议：</p><ul><li><strong>传输控制协议TCP:</strong>提供面向链接，可靠的数据传输服务，数据单位是报文段。（TCPt提供完整性服务）</li><li><strong>用户数据报协议UDP</strong> ： 提供无连接，尽最大努力的数据传输服务，数据单位是用户数据报。（UDP 主要提供及时性服务。）</li></ul></li><li><p><strong>网络层</strong>：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。<strong>网络层把传输层传递下来的报文段或者用户数据报封装成分组。</strong></p></li><li><p><strong>数据链路层</strong>：<strong>网络层针对的还是主机之间的数据传输服务</strong>。而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。<strong>数据链路层把网络层传下来的分组封装成帧。</strong></p></li><li><p><strong>物理层：</strong>考虑的是怎么样在传输媒体或者介质上传输数据比特流，而不是具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使得数据链路层感觉不到这些差异。</p></li></ul><h3 id="6-2-OSI"><a href="#6-2-OSI" class="headerlink" title="6.2 OSI"></a>6.2 OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><p><strong>表示层</strong>  ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p></li><li><p><strong>会话层</strong>  ：建立及管理会话。</p></li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="6-3-TCP-IP"><a href="#6-3-TCP-IP" class="headerlink" title="6.3 TCP / IP"></a>6.3 TCP / IP</h3><ul><li>它只有四层，相当于五层协议中的数据链路层和物理层合并为接口层</li><li>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172620266.png" alt="mark"></p><h2 id="7-数据在各层之间的传递过程"><a href="#7-数据在各层之间的传递过程" class="headerlink" title="7. 数据在各层之间的传递过程"></a>7. 数据在各层之间的传递过程</h2><ul><li><strong>在向下的过程中，需要添加下层协议所需要的首部或者尾部</strong></li><li><strong>在向上的过程中，需要不断拆开首部和尾部</strong></li></ul><p><strong>需要注意的是：</strong></p><ul><li><strong>路由器</strong>只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-01-概述&quot;&gt;&lt;a href=&quot;#计算机网络-01-概述&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-01-概述&quot;&gt;&lt;/a&gt;计算机网络-01-概述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-164551248.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本教程是秋招面试复习用计算机网络知识点(意味着书上的“废话” 不会在本系列学习笔记中出现)&lt;/li&gt;
&lt;li&gt;配套教材《计算机网络-自顶向下的方法》&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JUC-16-Future</title>
    <link href="http://zhuuu.work/2020/07/25/JUC/JUC-16-Future/"/>
    <id>http://zhuuu.work/2020/07/25/JUC/JUC-16-Future/</id>
    <published>2020-07-25T14:02:24.000Z</published>
    <updated>2020-07-25T09:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-16-Future"><a href="#JUC-16-Future" class="headerlink" title="JUC-16-Future"></a>JUC-16-Future</h1><h2 id="1-Future-接口"><a href="#1-Future-接口" class="headerlink" title="1. Future 接口"></a>1. Future 接口</h2><ul><li><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。</p></li><li><p>必要时通过get 方法获取执行结果，该方法会阻塞直到任务返回结果。</p></li><li><p><strong>当一个线程需要等待另外一个线程把某个任务执行完成后它才能继续执行，此时可以似乎用FutureTask</strong></p></li><li><p>Future类位于java.util.concurrent包下，它是一个接口：</p></li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> FutureTask </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Executor </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; The result type returned by this Future's &lt;tt&gt;get&lt;/tt&gt; method </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Attempts to cancel execution of this task.  This attempt will </span></span><br><span class="line"><span class="comment">     * fail if the task has already completed, has already been cancelled, </span></span><br><span class="line"><span class="comment">     * or could not be cancelled for some other reason. If successful, </span></span><br><span class="line"><span class="comment">     * and this task has not started when &lt;tt&gt;cancel&lt;/tt&gt; is called, </span></span><br><span class="line"><span class="comment">     * this task should never run.  If the task has already started, </span></span><br><span class="line"><span class="comment">     * then the &lt;tt&gt;mayInterruptIfRunning&lt;/tt&gt; parameter determines </span></span><br><span class="line"><span class="comment">     * whether the thread executing this task should be interrupted in </span></span><br><span class="line"><span class="comment">     * an attempt to stop the task.     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this task was cancelled before it completed </span></span><br><span class="line"><span class="comment">     * normally. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this task completed. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Waits if necessary for the computation to complete, and then </span></span><br><span class="line"><span class="comment">     * retrieves its result. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Waits if necessary for at most the given time for the computation </span></span><br><span class="line"><span class="comment">     * to complete, and then retrieves its result, if available. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p><ul><li><strong>cancel（</strong>）<ul><li>用来取消任务，如果取消成功返回true,取消失败返回false.</li><li>参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li></ul></li><li><strong>isCancelled（）</strong><ul><li>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li></ul></li><li><strong>isDone（）</strong><ul><li>方法表示任务是否已经完成，若任务完成，则返回true；</li></ul></li><li><strong>get()</strong><ul><li>用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回。</li></ul></li><li><strong>get(long timeout, TimeUnit unit)</strong><ul><li>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul></li></ul><p><strong>总结：</strong></p><ul><li>Future 提供以下三种功能<ul><li>判断任务是否完成。</li><li>能够中断任务。</li><li>能够获取任务执行的结果。</li></ul></li><li>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</li></ul><h2 id="2-FutureTask-类"><a href="#2-FutureTask-类" class="headerlink" title="2. FutureTask 类"></a>2. FutureTask 类</h2><p><strong>概述</strong></p><ul><li><strong>FutureTask 类的实现基于 AQS</strong> ， <strong>JUC 中很多可阻塞的类都是基于AQS实现的。</strong></li><li><strong>AQS是一个同步框架，它提供通用机制来控制原子性管理同步状态，阻塞和唤醒线程，以及维护被阻塞线程的队列。</strong><ul><li><strong>JDK6 中被广泛使用</strong></li><li><strong>基于AQS的实现同步器包括 ： （ReetrantLock , Semaphore,CountDownLatch,ReetrantReadWriteLock,FutureTask）</strong></li></ul></li></ul><ul><li>首先是介绍下FutureTask类中的变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示当前task的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//表示当前task尚未执行</span></span><br><span class="line"><span class="comment">//场景：1、任务刚新建还未入队列</span></span><br><span class="line"><span class="comment">//     2、任务刚新建已入队列，还未被线程执行</span></span><br><span class="line"><span class="comment">//     3、任务刚新建已入队列，正在被线程执行run() 注意：当执行任务有结果后才会修改当前任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//表示当前task正在结束，但是还未完全结束的一种临界状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//表示当前task正常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//表示当前task执行过程中发生异常，内部封装的callable.run() 向上抛出了异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//表示当前task被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//表示当前task正在中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//表示当前task已中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//submit(runnable/callable)     runnable 使用装饰者模式装饰为 callable</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">//正常情况下：任务执行结束，outcome保存执行结果。 即callable的返回值</span></span><br><span class="line"><span class="comment">//异常情况下：callable向上抛出异常信息，outcome保存异常信息</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"><span class="comment">//当前任务被执行时，保存执行当前任务的当前线程的对象引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">//因为会有很多线程去get当前任务的结果。所以，这里使用 链表 这种数据结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    <span class="comment">//thread变量 保存线程对象引用</span></span><br><span class="line">    <span class="comment">//next变量 保存当前节点的下一个节点</span></span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器（2个构造器）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">this</span>.callable = callable;  </span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);  </span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Runnable注入会被Executors.callable()函数转换为Callable类型，即FutureTask最终都是执行Callable类型的任务。</p><p>这里使用到了适配器模式：将Runnable 接口 的任务 转换成 Callable接口的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * A callable that runs given task and returns given result </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Runnable task;  </span><br><span class="line">    <span class="keyword">final</span> T result;  </span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.task = task;  </span><br><span class="line">        <span class="keyword">this</span>.result = result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        task.run();  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行一个task的步骤是：<ul><li>submit(runnable/callable) -&gt; 调用 sumbit()提交我们自定义的工作单元 </li><li>newTaskFor(runnable/callable) -&gt;  调用newTaskFor将runnable/callable 封装成FutureTask</li><li>execute(task) -&gt;  执行execute()将传入的task放到线程池中</li><li>threadpool  -&gt; 当线程池中有空闲线程，就会执行任务的run()。否则，就会进入任务队列等待被执行</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit(runnable/callable) -&gt; newTaskFor(runnable/callable) -&gt; execute(task) -&gt; threadpool</span></span><br><span class="line"><span class="comment">//当线程池中没有空闲线程来执行当前任务，则会先进入任务队列中，等待空闲线程调用；如果有就直接执行。</span></span><br><span class="line"><span class="comment">//任务执行入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//条件1：true -&gt; 当前任务的状态不是新建状态。(可能已经被执行或者取消)</span></span><br><span class="line">    <span class="comment">//条件2：true -&gt; cas失败，表示当前有其它线程抢占了这个任务</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前线程开始执行当前任务</span></span><br><span class="line">    <span class="comment">//前置条件：1、当前任务的状态是新建状态 2、当前线程抢占到当前任务的执行权</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//表示外部传入的自定义的业务程序。 是callable或者是用runnable装饰后的callable</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">//条件1：防止空指针异常</span></span><br><span class="line">        <span class="comment">//条件2：防止有外部线程将任务cancel了</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            <span class="comment">//要返回的结果</span></span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">//true -&gt; callable程序执行成功，未抛出异常</span></span><br><span class="line">            <span class="comment">//false -&gt; callable程序执行失败，抛出异常</span></span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">//说明当前任务正常结束</span></span><br><span class="line">                <span class="comment">//设置result给outcome</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//只会在当前任务被cancel时执行</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用cas把任务当前状态设置成完成中</span></span><br><span class="line">    <span class="comment">//执行失败的情况：外部线程在当前线程执行set之前把当前任务cancel(很小概率事件)</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//将callable</span></span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用cas把任务当前状态设置成完成中</span></span><br><span class="line">    <span class="comment">//执行失败的情况：外部线程在当前线程执行set之前把当前任务cancel(很小概率事件)</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">//将结果赋值给outcome后，将当前任务的状态直接修改为NORMAL(正常完成)状态</span></span><br><span class="line">        <span class="comment">//putOrderedInt(Object obj, long offset, int value) obj:包含要修改field的对象 offset:obj中整型field的偏移量 value:field将被设置的新值</span></span><br><span class="line">        <span class="comment">//设置obj对象中offset偏移地址对应的整型field的值为指定值。</span></span><br><span class="line">        <span class="comment">//这是一个有序或者有延迟的putIntVolatile方法，并且不保证值的改变被其他线程立即看到。</span></span><br><span class="line">        <span class="comment">//只有在field被 volatile 修饰并且期望被意外修改的时候使用才有用。</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">    <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            <span class="comment">//释放cpu资源</span></span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get () 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景：多个线程等待当前任务执行完成后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前任务状态</span></span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">//true -&gt; 任务状态可能为 未执行、正在执行、完成中</span></span><br><span class="line">    <span class="comment">//当任务状态为以上情况时，调用get()的外部线程会被阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">//返回线程当前状态</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//System.nanoTime() 返回的是纳秒，nanoTime返回的可能是任意时间，甚至可能是负数</span></span><br><span class="line">    <span class="comment">//timed true -&gt; 表示带超时时间，deadline = System.nanoTime()</span></span><br><span class="line">    <span class="comment">//      false -&gt; 表示不带超时时间，deadline = 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//引用当前线程封装成WaitNode对象</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//表示是否入队</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//ture -&gt; 说明当前线程是被其它线程中断而唤醒的</span></span><br><span class="line">        <span class="comment">//interrupted() 返回true后 会将Thread的中断标记重置为false</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//当前线程node出队</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="comment">//向get()抛出中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前线程被其它线程正常唤醒(使用了unpark(thread))的场景，继续执行自旋逻辑</span></span><br><span class="line">        <span class="comment">//获取当前任务最新状态</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//true -&gt; 表示当前任务已经有结果了</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="comment">//true -&gt; 说明已经为当前线程创建node节点，需要执行 node.thread = null (helpGC)</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//返回任务状态</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//true -&gt; 表示当前任务正在完成中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            <span class="comment">//将当前cpu的资源释放，进行下次抢占cpu资源</span></span><br><span class="line">            <span class="comment">//注意：yield()会释放CPU资源，但是是与其它线程一起重新抢占资源。当前线程可能还会获取到执行权，也有可能被其他线程获取到</span></span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//场景：第一次自旋</span></span><br><span class="line">        <span class="comment">//true -&gt; 当前线程还未创建WaitNode对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//为当前线程创建WaitNode对象，并把当前线程赋值到thread全局变量中</span></span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="comment">//场景：第二次自旋</span></span><br><span class="line">        <span class="comment">//true -&gt; 当前线程已经创建WaitNode对象，但是还未入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)&#123;</span><br><span class="line">            <span class="comment">//把当前线程node节点的next指针 指向到原队列的头结点</span></span><br><span class="line">            <span class="comment">//waiters 表示队列头指针</span></span><br><span class="line">            q.next = waiters;</span><br><span class="line">            <span class="comment">//用cas方式设置waiters指针指向当前线程的node节点(头插法)</span></span><br><span class="line">            <span class="comment">//true -&gt; 入队成功</span></span><br><span class="line">            <span class="comment">//false -&gt; 有其它线程抢先入队，进入下次自旋</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, waiters, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//场景：第三次自旋</span></span><br><span class="line">        <span class="comment">//判断是否有带入超时时间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;<span class="comment">//有超时时间的场景</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">//true -&gt; 表示等待超时了</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">//当前线程node出队</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="comment">//无论完成与否，直接返回当前状态</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程进入有时间限制的休眠状态，有其它线程将其 唤醒 或者 中断 或者 时间到了 就会重新激活</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//无超时时间的场景</span></span><br><span class="line">            <span class="comment">//park() 会将当前线程状态变为waitting(休眠)</span></span><br><span class="line">            <span class="comment">//当前线程进入休眠状态， 有其它线程将其 唤醒 或者 中断 就会重新激活</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//正常情况下：outcome保存的是callable运行出来的结果</span></span><br><span class="line">    <span class="comment">//非正常情况下：outcome保存的是callable运行时抛出的异常信息</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="comment">//true -&gt; 表示当前任务正常完成</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="comment">//直接返回callable运行结果</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="comment">//true -&gt; 表示当前任务被取消</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="comment">//抛出取消中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">//抛出自定义的callable程序执行时产生的异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 ： </p><ol><li>get任务执行结果的线程并不只有一个，而是有很多个在同一链表中的线程竞争获取。</li><li>当任务还未执行完毕，线程就会进行休眠，等待其它线程唤醒(可能是正常唤醒，也可能是任务中断)</li></ol><ul><li><strong>cancel()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mayInterruptIfRunning 设成false话，不允许在线程运行时中断，设成true的话就允许。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//state == NEW：true -&gt; 表示当前任务处于运行中 或者 处于线程池队列中</span></span><br><span class="line">        <span class="comment">//UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)</span></span><br><span class="line">        <span class="comment">//  true -&gt; 表示cas成功，将当前任务状态修改为 中断中 或者 取消</span></span><br><span class="line">        <span class="comment">//注意，这里的if取反，上述条件都为true才会执行下面的逻辑。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取执行当前task的线程</span></span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="comment">//可能会为null，因为可能当前task还在任务队列中排队</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//如果不为null，则给runner线程一个中断信号</span></span><br><span class="line">                        <span class="comment">//只是会给任务一个中断标志，能否中断要看task中是否有响应中断的程序</span></span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    <span class="comment">//执行完中断后将任务的状态改为已中断</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>最后要讲下finishCompletion()这个方法，看了上面的源码可以发现，有3个地方都执行了这个方法，分别是cancel()、set()、setException()。<br>其作用就是当任务执行有结果了(无论好坏)都会唤醒waiters链表中的 所有 线程继续执行自旋逻辑。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒所有waiters中的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">//将waiters头结点赋值给q</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">//用cas将头结点置为null，防止该任务被其它线程取消 且 help gc</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">                <span class="comment">//获取当前节点的thread对象</span></span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="comment">//true -&gt; thread对象存在防止空指针</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//清空当前节点引用的thread对象 help gc</span></span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//唤醒该线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前节点的下一个节点</span></span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="comment">//true -&gt; 已经处于队列末尾</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//退出自旋</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//清空当前节点的next指针指向的对象引用 help gc</span></span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                <span class="comment">//当前节点指针指向下一个节点</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所有waiters队列中的线程唤醒完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义扩展的操作</span></span><br><span class="line">    done();</span><br><span class="line">    <span class="comment">//释放资源 help gc</span></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-16-Future&quot;&gt;&lt;a href=&quot;#JUC-16-Future&quot; class=&quot;headerlink&quot; title=&quot;JUC-16-Future&quot;&gt;&lt;/a&gt;JUC-16-Future&lt;/h1&gt;&lt;h2 id=&quot;1-Future-接口&quot;&gt;&lt;a href=&quot;#1-Future-接口&quot; class=&quot;headerlink&quot; title=&quot;1. Future 接口&quot;&gt;&lt;/a&gt;1. Future 接口&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;必要时通过get 方法获取执行结果，该方法会阻塞直到任务返回结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;当一个线程需要等待另外一个线程把某个任务执行完成后它才能继续执行，此时可以似乎用FutureTask&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Future类位于java.util.concurrent包下，它是一个接口：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="异步计算" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring-11-设计模式</title>
    <link href="http://zhuuu.work/2020/07/25/Spring/Spring-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/07/25/Spring/Spring-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-25T07:11:24.000Z</published>
    <updated>2020-09-20T12:03:36.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-11-设计模式"><a href="#Spring-11-设计模式" class="headerlink" title="Spring-11-设计模式"></a>Spring-11-设计模式</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。</p></li><li><p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p></li></ul><a id="more"></a><h2 id="1-IOC"><a href="#1-IOC" class="headerlink" title="1. IOC"></a>1. IOC</h2><ul><li><strong>IoC(Inversion of Control,控制翻转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想</li><li>它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。</li><li><strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-112218699.png" alt="mark"></p><ul><li><p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> </p></li><li><p>IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p></li><li><p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：<a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener">https://www.zhihu.com/question/23277575/answer/169698662</a> ，非常不错。</p></li></ul><h3 id="1-1-控制反转的理解"><a href="#1-1-控制反转的理解" class="headerlink" title="1.1 控制反转的理解"></a>1.1 控制反转的理解</h3><ul><li>举个例子：“对象a 依赖了对象 b，<strong>当对象 a 需要使用 对象 b的时候必须自己去创建。</strong></li><li>但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以<strong>指定 IOC 容器去创建一个对象b注入到对象 a 中</strong>”。</li><li>对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。</li></ul><p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><ul><li>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</li></ul><p><strong>两者对比：</strong></p><ul><li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code> 来说会占用更少的内存，程序启动速度更快。</li><li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li></ul><p><strong>ApplicationContext的三个实现类：</strong></p><ol><li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li><li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li><li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line"><span class="string">"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml"</span>);</span><br><span class="line"> </span><br><span class="line">HelloApplicationContext obj = (HelloApplicationContext) context.getBean(<span class="string">"helloApplicationContext"</span>);</span><br><span class="line">obj.getMsg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3. 单例模式"></a>3. 单例模式</h2><ul><li>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。</li><li>事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</li></ul><p><strong>使用单例模式的好处:</strong></p><ul><li><strong>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言</strong>，是非常可观的一笔系统开销；</li><li><strong>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力</strong>，缩短 GC 停顿时间。</li></ul><p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p><ul><li><code>prototype</code> : 每次请求都会创建一个新的 bean 实例。</li><li><code>request</code> : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前<code>HTTP request</code>内有效。</li><li><code>session</code> : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 <code>HTTP session</code> 内有效。</li><li><code>global-session</code>： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><h3 id="3-1-Spring实现单例模式的方法"><a href="#3-1-Spring实现单例模式的方法" class="headerlink" title="3.1 Spring实现单例模式的方法"></a>3.1 Spring实现单例模式的方法</h3><ul><li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li><li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li></ul><p><strong>底层实现</strong></p><ul><li><strong>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-代理模式"><a href="#4-代理模式" class="headerlink" title="4. 代理模式"></a>4. 代理模式</h2><ul><li>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong></li><li>便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</li></ul><p><strong>Spring AOP 就是基于动态代理的</strong>，</p><ul><li>如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，</li><li>而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> <strong>生成一个被代理对象的子类来作为代理</strong>，如下图所示</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-115307397.png" alt="mark"></p><ul><li>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</li><li>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。<strong>日志功能</strong>、<strong>事务管理</strong>等等场景都用到了 AOP 。</li></ul><h3 id="4-1-Spring-AOP-和-AspectJ-AOP有什么区别？"><a href="#4-1-Spring-AOP-和-AspectJ-AOP有什么区别？" class="headerlink" title="4.1 Spring AOP 和 AspectJ AOP有什么区别？"></a>4.1 Spring AOP 和 AspectJ AOP有什么区别？</h3><ul><li><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</li><li>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</li><li>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</li></ul><h2 id="5-模板方式模式"><a href="#5-模板方式模式" class="headerlink" title="5. 模板方式模式"></a>5. 模板方式模式</h2><ul><li>模板方法模式是一种行为设计模式，它<strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。</strong> </li><li>模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-115654822.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是我们的模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PrimitiveOperation1();  </span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">        PrimitiveOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span>  <span class="title">PrimitiveOperation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//被子类实现的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateImpl</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>一般情况下，我们都是使用<strong>继承的方式来实现模板模式</strong>，但是 Spring 并没有使用这种方式，而是使用<code>Callback</code> 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</li></ul><h2 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6. 观察者模式"></a>6. 观察者模式</h2><ul><li>观察者模式是一种对象行为型模式。它<strong>表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。</strong></li><li><strong>Spring 事件驱动模型就是观察者模式很经典的一个应用。</strong></li><li>Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</li></ul><h4 id="6-1-Spring-事件驱动模型中的三种角色"><a href="#6-1-Spring-事件驱动模型中的三种角色" class="headerlink" title="6.1 Spring 事件驱动模型中的三种角色"></a>6.1 Spring 事件驱动模型中的三种角色</h4><ol><li><strong>事件角色</strong></li></ol><p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p><p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p><ul><li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li><li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li><li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li><li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-120618675.png" alt="mark"></p><ol start="2"><li><strong>监听器角色</strong></li></ol><ul><li><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。</li><li>所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口实现 <code>onApplicationEvent()</code> 方法即可完成监听事件</li></ul><ol start="3"><li><strong>事件发布者角色</strong></li></ol><ul><li><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，</li><li>阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</li></ul><h4 id="6-2-Spring-事件总结"><a href="#6-2-Spring-事件总结" class="headerlink" title="6.2 Spring 事件总结"></a>6.2 Spring 事件总结</h4><ul><li><strong>定义一个事件:</strong> 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li><li><strong>定义一个事件监听者</strong>：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li><li><strong>使用事件发布者发布消息</strong>: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source,String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用onApplicationEvent接收消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;</span><br><span class="line">        String msg = event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">"接收到的信息是："</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</li></ul><h2 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7. 适配器模式"></a>7. 适配器模式</h2><h3 id="7-1-Spring中适配器模式"><a href="#7-1-Spring中适配器模式" class="headerlink" title="7.1 Spring中适配器模式"></a>7.1 Spring中适配器模式</h3><ul><li>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</li></ul><ul><li>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code> 。</li><li>Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。</li><li>每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。</li><li>Spring预定义的<strong>通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象</strong>（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</li></ul><h3 id="7-2-SpringMVC-适配器"><a href="#7-2-SpringMVC-适配器" class="headerlink" title="7.2 SpringMVC 适配器"></a>7.2 SpringMVC 适配器</h3><ul><li>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</li><li><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</li></ul><h2 id="8-装饰者模式"><a href="#8-装饰者模式" class="headerlink" title="8. 装饰者模式"></a>8. 装饰者模式</h2><ul><li>装饰者模式可以<strong>动态地给对象添加一些额外的属性或行为</strong>。</li><li>相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，<strong>设计一个Decorator套在原有代码外面。</strong></li><li>其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-121636150.png" alt="mark"></p><p>比如：</p><ul><li><strong>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。</strong>我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？</li><li><strong>这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。</strong>这些类基本上都是动态地给一个对象添加一些额外的职责</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>Spring 框架中用到了哪些设计模式？</p><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li><li>…</li></ul><p>参考博客 ： <a href="https://blog.csdn.net/qq_34337272/article/details/90487768" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/90487768</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-11-设计模式&quot;&gt;&lt;a href=&quot;#Spring-11-设计模式&quot; class=&quot;headerlink&quot; title=&quot;Spring-11-设计模式&quot;&gt;&lt;/a&gt;Spring-11-设计模式&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-14-ThreadLocal</title>
    <link href="http://zhuuu.work/2020/07/22/jdk_SourceCode/JDK1.8-14-ThreadLocal/"/>
    <id>http://zhuuu.work/2020/07/22/jdk_SourceCode/JDK1.8-14-ThreadLocal/</id>
    <published>2020-07-22T05:33:53.000Z</published>
    <updated>2020-08-13T02:41:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8-14-ThreadLocal"><a href="#JDK1-8-14-ThreadLocal" class="headerlink" title="JDK1.8-14-ThreadLocal"></a>JDK1.8-14-ThreadLocal</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>参考博客： <a href="https://www.cnblogs.com/fsmly/p/11020641.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsmly/p/11020641.html</a></p><p><strong>总结几个字：线程自己的本地变量</strong></p><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>多线程访问同一个共享变量时候容易出现并发问题，特别是多个线程对同一个变量进行写入的时候，为了确保线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程的安全性。</li><li><strong>ThreadLocal 是除了加锁这种同步方式以外的一种保证一种规避多线程访问出现线程不安全的方法，当我们创建一个共享变量后，如果每个线程对其进行访问的时候访问都是线程自己的变量就不会存在线程不安全的问题。</strong></li><li>ThreadLocal 是 JDK包提供的，它提供<strong>线程的本地变量</strong>，如果创建一个ThreadLocal变量，那么访问这个变量的每一个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而避免了线程安全性问题。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/132845616.png" alt="mark"></p><!--more--><h2 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2.简单使用"></a>2.简单使用</h2><ul><li>在下面的例子中，在每个线程的内部都设置了本地变量的值，然后调用print 方法打印当前本地变量的值。</li><li>如果在打印之后调用本地变量的remove方法后会删除把本地内存中的变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">" :"</span> + localVar.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        localVar.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">                localVar.set(<span class="string">"localVar1"</span>);</span><br><span class="line">                <span class="comment">//调用打印方法</span></span><br><span class="line">                print(<span class="string">"thread1"</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">"after remove : "</span> + localVar.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">                localVar.set(<span class="string">"localVar2"</span>);</span><br><span class="line">                <span class="comment">//调用打印方法</span></span><br><span class="line">                print(<span class="string">"thread2"</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">"after remove : "</span> + localVar.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行后的结果：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/133208433.png" alt="mark"></p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><ul><li>下面是ThreadLocal的类图结构，从图中可知，<code>java.lang.Thread</code>中有两个变量<code>threadLocals</code> 和 <code>inheritableThreadLocals</code> 。两者都是<code>ThreadLocal</code>内部类 <code>ThreadLocalMap</code> 类型的变量。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/090201253.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/090208752.png" alt="mark"></p><ul><li>在默认情况下，每个线程中这两个变量都是<code>null</code>,之后我们通过原码后可以看到 <code>ThreadLocalMap</code> 实际上类似于一个 <code>HashMap</code>. 这两个变量只有当线程第一次调用ThreadLocal的 set和 get方法的时候才会创建它们。</li><li>需要注意的是：<strong>每个线程的本地变量</strong>不是存放在 new 出来的<code>TheadLocal</code> 实例中，而是存放在调用线程的<code>ThreadLocals</code> 变量中。（前面说过，这个变量在 <code>java.lang.Thread</code>类中）</li><li>也就是说，<code>ThreadLocal</code> 类型的本地变量实际是存放在具体的线程空间上，其本身相当于装在本地变量的工具壳，通过 set 方法将value 添加到 <code>threadlocals</code> 变量中，当调用线程的时候能够将它从 <code>threadLocals</code>变量中取出。</li><li>如果调用的线程一直不终止，那么这个本地变量将会一直存放在他的<code>threadLocals</code> 中，所以不使用本地变量的时候需要从它的<code>threadLocals</code> 取出变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment"> * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/134134649.png" alt="mark"></p><h3 id="3-1-set-方法"><a href="#3-1-set-方法" class="headerlink" title="3.1  set 方法"></a>3.1  set 方法</h3><ul><li>源码分析<strong>(重点是类似与Hashmap 的 ThreadlocalMap)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1) 获取当前线程（调用者线程）</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2) 以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//(3) 如果map不为null，就直接添加本地变量，key为当前线程的引用，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//(4) 如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，(2)处调用getMap方法<strong>获得当前线程对应的threadLocals变量</strong>(参照上面的图示和文字说明)，该方法代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals; <span class="comment">//获取线程自己的变量threadLocals，并绑定到当前调用线程的成员变量threadLocals上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果调用getMap 的返回值不为null,就直接将 value 设置到 threadLocals变量中<strong>（此时 key 是当前线程的引用，值是本地变量）</strong></li><li>如果调用 getMap 方法返回null 说明是第一次调用 set 方法(前面说到过,threadLocals默认值是 Null , 只有调用 set 方法的时候才会创建map),这个时候就需要调用 createMap方法来创建<code>ThreadLocalMap</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createMap 方法不仅创建了 <code>threadLocals</code>变量 ,通过是也将本地变量的值放到了 <code>threadLocals</code> 中.</li></ul><h3 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2 get 方法"></a>3.2 get 方法</h3><ul><li><p>在get 方法的实现中，首先获取当前调用者线程</p><ul><li>如果当前线程的<code>threadLocals</code> 不为 <code>null</code> ,就直接返回当前线程绑定的本地变量值，</li><li>否则执行 <code>setInitialValue</code>的方法初始化 <code>threadLocals</code> 变量。</li></ul></li><li><p>在 <code>setInitialValue</code> 方法中，类似于 <code>set</code> 方法的实现，都是判断当前线程的<code>threadLocals</code> 变量是否为null,是则添加本地变量（这个时候由于是初始化，所以添加的值是null）,否则创建的是<code>threadLocals变量</code>，同样添加的是null</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2)获取当前线程的threadLocals变量</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//(3)如果threadLocals变量不为null，就可以在map中查找到本地变量的值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(4)执行到此处，threadLocals为null，调用该更改初始化当前线程的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//protected T initialValue() &#123;return null;&#125;</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-remove-方法"><a href="#3-3-remove-方法" class="headerlink" title="3.3 remove 方法"></a>3.3 remove 方法</h3><ul><li>remove 方法判断该当前线程对应的threadLocals变量是否是null,不是 null 的话就直接删除当前线程中的threadLocals变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程绑定的threadLocals</span></span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="comment">//如果map不为null，就移除当前线程中指定ThreadLocal实例的本地变量</span></span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意  ： 这里可能有内存泄露问题</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/095307158.png" alt="mark"></p><ul><li>如上图所示，每个线程内部都有一个名为<code>threadLocals</code> 的成员变量，该变量的类型是<code>ThreadLocal.ThreadLocalMap</code>的类型（类似于一个HashMap） ,其中<strong>key是当前定义的<code>ThreadLocal</code> 变量 this的引用， value 是 使用 set 方法设置的值。</strong></li><li>每个线程的本地变量存放在自己的本地变量 <code>threadLocals</code>中，如果<strong>当前线程一直不消亡，那么这些本地变量会一直存在（所以会内存溢出），因此使用完毕需要remove 掉。</strong></li></ul><h2 id="4-ThreadLocal-不支持继承性"><a href="#4-ThreadLocal-不支持继承性" class="headerlink" title="4. ThreadLocal 不支持继承性"></a>4. ThreadLocal 不支持继承性</h2><ul><li>同一个<code>Threadlocal</code> 变量在父线程中被设置后，在子线程中是获取不到的</li><li>threadLocals 中为当前调用线程对应的本地变量，所以二者自然是不能共享的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)创建ThreadLocal变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在main线程中添加main线程的本地变量</span></span><br><span class="line">        threadLocal.set(<span class="string">"mainVal"</span>);</span><br><span class="line">        <span class="comment">//新创建一个子线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程中的本地变量值:"</span>+threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//输出main线程中的本地变量值</span></span><br><span class="line">        System.out.println(<span class="string">"mainx线程中的本地变量值:"</span>+threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-InheritableThreadLocal类"><a href="#5-InheritableThreadLocal类" class="headerlink" title="5. InheritableThreadLocal类"></a>5. InheritableThreadLocal类</h2><ul><li>在上面说到的ThreadLocal类是不能提供子线程访问父线程的本地变量的，而InheritableThreadLocal类则可以做到这个功能，下面是该类的源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从上面代码可以看出，InheritableThreadLocal类继承了ThreadLocal类，并重写了childValue、getMap、createMap三个方法。</li><li>其中createMap方法在被调用（当前线程调用set方法时得到的map为null的时候需要调用该方法）的时候，创建的是inheritableThreadLocal而不是threadLocals。同理，getMap方法在当前调用者线程调用get方法的时候返回的也不是threadLocals而是inheritableThreadLocal。</li></ul><p>下面我们看看重写的childValue方法在什么时候执行，怎样让子线程访问父线程的本地变量值。我们首先从Thread类开始说起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断名字的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">//(1)获取当前线程(父线程)</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="comment">//安全校验</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123; <span class="comment">//g:当前线程组</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g; <span class="comment">//设置为当前线程组</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();<span class="comment">//守护线程与否(同父线程)</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();<span class="comment">//优先级同父线程</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">//(2)如果父线程的inheritableThreadLocal不为null</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//（3）设置子线程中的inheritableThreadLocals为父线程的inheritableThreadLocals</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在init方法中，首先(1)处获取了当前线程(父线程)，然后（2）处判断当前父线程的inheritableThreadLocals是否为null，</li><li>然后调用createInheritedMap将父线程的inheritableThreadLocals作为构造函数参数创建了一个新的ThreadLocalMap变量，然后赋值给子线程。</li><li>下面是createInheritedMap方法和ThreadLocalMap的构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用重写的方法</span></span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在构造函数中将父线程的inheritableThreadLocals成员变量的值赋值到新的ThreadLocalMap对象中。</li><li>返回之后赋值给子线程的inheritableThreadLocals。</li><li>总之，InheritableThreadLocals类通过重写getMap和createMap两个方法将本地变量保存到了具体线程的inheritableThreadLocals变量中，当线程通过InheritableThreadLocals实例的set或者get方法设置变量的时候，就会创建当前线程的inheritableThreadLocals变量。</li><li>而父线程创建子线程的时候，ThreadLocalMap中的构造函数会将父线程的inheritableThreadLocals中的变量复制一份到子线程的inheritableThreadLocals变量中</li></ul><h2 id="6-从ThreadLocalMap-看-ThreadLocal-的内存泄露问题"><a href="#6-从ThreadLocalMap-看-ThreadLocal-的内存泄露问题" class="headerlink" title="6. 从ThreadLocalMap 看 ThreadLocal 的内存泄露问题"></a>6. 从ThreadLocalMap 看 ThreadLocal 的内存泄露问题</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><ul><li>首先我们看看<code>ThreadLocalMap</code>的类图，在前面的介绍中，我们知道ThreadLocal 是一个工具类，它为用户提供了 <code>set,get,remove</code> 接口操作实际存放本地变量的<code>threadLocals</code> （调用线程的成员变量）， 也知道<code>threadLocals</code>  是一个 <code>ThreadLocalMap</code> 类型的变量</li><li>下面我们来看看<code>ThreadLocalMap</code> 这个内部类，在此之前，我们先回忆以下<code>Java</code>中的四种引用类型，以及相关GC的工作机制</li></ul><p>①<strong>强引用</strong>：Java中默认的引用类型，一个对象如果具有强引用那么只要这种引用还存在就不会被GC。</p><p>②<strong>软引用</strong>：简言之，如果一个对象具有软引用，在JVM发生OOM之前（即内存充足够使用），是不会GC这个对象的；只有到JVM内存不足的时候才会GC掉这个对象。软引用和一个引用队列联合使用，如果软引用所引用的对象被回收之后，该引用就会加入到与之关联的引用队列中</p><p>③<strong>弱引用</strong>（这里讨论ThreadLocalMap中的Entry类的重点） ：如果一个对象只有弱引用，那么这个对象就会被垃圾回收器GC(弱引用的引用的对象只能到下一次之前，无论当前内存是否足够，弱引用所引用的对象都会被GC回收掉)。 弱引用也是和一个引用队列联合使用，如果弱引用的对象被垃圾回收掉，JVM会将这个引用加入到与之关联的弱引用队列中。若引用的对象可以通过弱引用的get方法得到，当引用对象被回收掉之后，在调用get方法就会返回null.</p><p>④<strong>虚引用</strong> : 虚引用是所有引用中最弱的一种引用，目的就是将关联虚引用对象在GC回收掉之后得到一个通知（不能通过get方法获得指引对象。）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/131415452.png" alt="mark"></p><h3 id="6-2-ThreadLocalMap的内部实现"><a href="#6-2-ThreadLocalMap的内部实现" class="headerlink" title="6.2 ThreadLocalMap的内部实现"></a>6.2 ThreadLocalMap的内部实现</h3><ul><li><code>ThreadLocalMap</code> 其实就是一个Entry 数组</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/132245248.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是继承自WeakReference的一个类，该类中实际存放的key是</span></span><br><span class="line"><span class="comment"> * 指向ThreadLocal的弱引用和与之对应的value值(该value值</span></span><br><span class="line"><span class="comment"> * 就是通过ThreadLocal的set方法传递过来的值)</span></span><br><span class="line"><span class="comment"> * 由于是弱引用，当get方法返回null的时候意味着坑能引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** value就是和ThreadLocal绑定的 */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：ThreadLocal的引用，被传递给WeakReference的构造方法</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//WeakReference构造方法(public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent); <span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reference构造方法</span></span><br><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);<span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从上面给的代码中可以看出，当前<code>threadLocal</code> 的引用k被传递给了<code>WeakReference</code>,所以ThreadLocalMap中的key为ThreadLocal的弱引用。</p></li><li><p>当一个线程调用<code>ThreadLocal</code> 的 set 方法设置变量的时候，当前线程<code>ThreadLocalMap</code> 中会存放一个记录，这个记录的key值就是<code>ThreadLocalMap</code> 的弱引用，<code>value</code>就是 set进去的值，这个值可以是任意的对象。</p></li><li><p>如果当前线程一直存在且没有调用<code>ThreadLocal</code>的remove方法，如果这个时候别的地方还有<code>ThreadLocal</code>的引用，那么当前线程的<code>ThreadLocalMap</code> 中会存在对<code>ThreadLocal</code>变量的引用和<code>value</code> 对象的引用，这个弱引用是不会被释放的，就会造成内存泄漏。</p></li><li><p>考虑这个<code>ThreadLocal</code>变量没有其他强依赖，如果当前线程还存在，由于<code>ThreadLocalMap</code> 中的key是弱引用，所以当前线程<code>ThreadLocalMap</code>里面的<code>ThreadLocal</code>变量的弱引用在gc时候就被回收，但是对应的value 还是存在这就可能导致内存泄漏(因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)。</p></li></ul><p><strong>总结：</strong></p><ul><li><code>ThreadLocalMap</code> 中的<strong>Entry数组</strong> 的 key 使用的是 <code>ThreadLocal</code>对象的弱引用，在没有其他地方对ThreadLoca依赖，ThreadLocalMap中的ThreadLocal对象就会被回收掉</li><li>但是对应的不会被回收，这个时候Map中就可能存在key为null但是value不为null的项</li><li>这需要实际的时候使用完毕及时调用remove方法避免内存泄漏。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8-14-ThreadLocal&quot;&gt;&lt;a href=&quot;#JDK1-8-14-ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8-14-ThreadLocal&quot;&gt;&lt;/a&gt;JDK1.8-14-ThreadLocal&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;参考博客： &lt;a href=&quot;https://www.cnblogs.com/fsmly/p/11020641.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/fsmly/p/11020641.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结几个字：线程自己的本地变量&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="面试必备" scheme="http://zhuuu.work/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>各种反转-合集</title>
    <link href="http://zhuuu.work/2020/07/20/LeetcodeExplore/%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/07/20/LeetcodeExplore/%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC-%E5%90%88%E9%9B%86/</id>
    <published>2020-07-20T07:52:53.000Z</published>
    <updated>2020-08-17T08:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种反转-合集"><a href="#各种反转-合集" class="headerlink" title="各种反转-合集"></a>各种反转-合集</h1><p>（本系列是针对Leetcode上常见的反转进行总结。）</p><a id="more"></a><h2 id="1-Leetcode-007-整数反转"><a href="#1-Leetcode-007-整数反转" class="headerlink" title="1. Leetcode 007 整数反转"></a>1. Leetcode 007 整数反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 反转后的结果</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 拿到每一个个位</span></span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 溢出处理</span></span><br><span class="line">        <span class="comment">// ans * 10 + pop &gt; Integer.MAXVAlUE</span></span><br><span class="line">        <span class="comment">// ans * 10 + pop &lt; Integer.MINVALUE</span></span><br><span class="line">        <span class="keyword">if</span> ((ans &gt; Integer.MAX_VALUE/<span class="number">10</span>) </span><br><span class="line">                || (ans == Integer.MAX_VALUE/<span class="number">10</span>) &amp;&amp; pop &gt; <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((ans &lt; Integer.MIN_VALUE/<span class="number">10</span>)</span><br><span class="line">                || (ans == Integer.MIN_VALUE/<span class="number">10</span>) &amp;&amp; pop &lt; -<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Leetcode-415-字符串相加"><a href="#2-Leetcode-415-字符串相加" class="headerlink" title="2. Leetcode   415. 字符串相加"></a>2. Leetcode   <a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 和num2 的长度都小于 5100</span><br><span class="line">num1 和num2 都只包含数字 0-9</span><br><span class="line">num1 和num2 都不包含任何前导零</span><br></pre></td></tr></table></figure><p><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 对溢出进行处理，超过就补一个0</span></span><br><span class="line">            <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 计算总和</span></span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            <span class="comment">// 计算进位</span></span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 拿个位结果</span></span><br><span class="line">            sb.append(tmp % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 继续向前遍历</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完如果有进位再加一个1</span></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)&#123;</span><br><span class="line">            sb.append(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将StringBuilder转为字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;各种反转-合集&quot;&gt;&lt;a href=&quot;#各种反转-合集&quot; class=&quot;headerlink&quot; title=&quot;各种反转-合集&quot;&gt;&lt;/a&gt;各种反转-合集&lt;/h1&gt;&lt;p&gt;（本系列是针对Leetcode上常见的反转进行总结。）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="反转" scheme="http://zhuuu.work/tags/%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>队列和栈-合集</title>
    <link href="http://zhuuu.work/2020/07/20/LeetcodeExplore/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/07/20/LeetcodeExplore/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88-%E5%90%88%E9%9B%86/</id>
    <published>2020-07-20T07:52:53.000Z</published>
    <updated>2020-08-09T13:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列和栈-合集"><a href="#队列和栈-合集" class="headerlink" title="队列和栈-合集"></a>队列和栈-合集</h1><p>（本系列是针对Leetcode上常见的队列和栈进行总结。）</p><a id="more"></a><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><ul><li><p>在数组中，我们可以通过<strong>索引</strong>随机访问元素。但是，在某些情况下，我们可以想要限制处理的顺序。</p></li><li><p>这两种不同的顺序就是 ， <code>先入先出</code> <code>先入后出</code> 。以及两个相应的线性数据结构，<strong>队列和栈</strong></p></li><li><p>在做到算法题的时候，<strong>队列一般用于BFS，而系统栈用于DFS</strong></p></li></ul><h2 id="1-1-队列（先入先出）"><a href="#1-1-队列（先入先出）" class="headerlink" title="1.1 队列（先入先出）"></a>1.1 队列（先入先出）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/134217670.png" alt="mark"></p><!--more--><ul><li>在FIFO 数据结构中，将首先处理添加到队列的第一个元素。</li><li>如上图所示，队列是典型的FIFO的数据结构。<strong>插入</strong>(insert) 操作也称为入队（enqueue），<strong>新元素始终被添加到队列的末尾</strong>。<strong>删除</strong>（delete） 操作也被称为出队(dequeue) 。 你<strong>只能移除第一个元素</strong>。</li><li><strong>总结：队尾入队，队首出队。</strong></li></ul><p><strong>出队：</strong><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/135940985.jpg" alt="mark"></p><p>*<em>入队 : *</em><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/140053661.png" alt="mark"></p><h3 id="1-1-1-数组实现队列"><a href="#1-1-1-数组实现队列" class="headerlink" title="1.1.1 数组实现队列"></a>1.1.1 数组实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实现队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 数组存放元素</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指向开始位置的指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> p_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        p_start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 出队相当于开始索引后移</span></span><br><span class="line">        p_start ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.get(p_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p_start &gt;= data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue q = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        q.enQueue(<span class="number">5</span>);</span><br><span class="line">        q.enQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/145353792.png" alt="mark"></p><ul><li>让我们考虑一种情况，即我们只能分配一个最大长度为 5 的数组。当我们只添加少于 5 个元素时，我们的解决方案很有效。 例如，如果我们只调用入队函数四次后还想要将元素 10 入队，那么我们可以成功。</li><li>但是我们不能接受更多的入队请求，这是合理的，因为现在队列已经满了。但是如果我们将一个元素出队呢？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/145423708.png" alt="mark"></p><h3 id="1-1-2-剑指-Offer-09-用两个栈实现队列"><a href="#1-1-2-剑指-Offer-09-用两个栈实现队列" class="headerlink" title="1.1.2 剑指 Offer 09. 用两个栈实现队列"></a>1.1.2 <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h3><p><strong>题目描述：</strong></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>遇到的问题</strong></p><ul><li><strong>栈无法实现队列的功能：</strong>栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈</li><li><strong>双栈可以实现列表的倒序</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设有含三个元素的栈 </span><br><span class="line">A &#x3D; [1,2,3] 和空栈 B &#x3D; []。</span><br><span class="line">若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A &#x3D; [] , B &#x3D; [3,2,1]，即 栈 B 元素实现栈 A 元素倒序 。</span><br></pre></td></tr></table></figure><ul><li><strong>利用栈B删除队首元素：倒序后，B执行出栈就相当于删除了A的栈底元素，即对应队首元素</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/141348516.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. B不为空，说明已经完成了倒叙，直接返回B栈顶元素即可</span></span><br><span class="line">        <span class="keyword">if</span> (!B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> B.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (A.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 2. 如果A为空,说明两个栈都为空</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 说明两个栈都存在元素</span></span><br><span class="line">            <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">                B.add(A.remove());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> B.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的解析：在我的Leetcode专题里面有，所以这里不再过度阐述。</strong></p><h3 id="1-1-3-622-设计循环队列"><a href="#1-1-3-622-设计循环队列" class="headerlink" title="1.1.3 622. 设计循环队列"></a>1.1.3 <a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></h3><ul><li>此前，我们提供了一种简单但低效的队列实现。（数组实现）</li><li>更有效的方法是使用循环队列，具体来说，我们可以使用固定大小的数组和两个指针来指示起始位置和结束位置。目的是重复使用被浪费的存储空间。</li></ul><p><strong>题目描述：</strong></p><ul><li><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p></li><li><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p></li><li><p>你的实现应该支持如下操作：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue(k): 构造器，设置队列长度为 k 。</span><br><span class="line">Front: 从队首获取元素。如果队列为空，返回 -1 。</span><br><span class="line">Rear: 获取队尾元素。如果队列为空，返回 -1 。</span><br><span class="line">enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</span><br><span class="line">deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</span><br><span class="line">isEmpty(): 检查循环队列是否为空。</span><br><span class="line">isFull(): 检查循环队列是否已满。</span><br></pre></td></tr></table></figure><p><strong>算法思路</strong></p><ul><li>这道题说“循环”的意思是要求我们在数组里实现。</li><li>在数组的操作中，我们参考“动态数组”的实现来完成。主要是为了让每一步操作的复杂度都降到最低。只不过我们自己实现动态扩容和缩容</li></ul><p>注意：</p><ol><li><p>定义循环变量 <code>front</code> 和 <code>rear</code> 。一直保持这个定义，到底是先赋值还是先移动指针就很容易想清楚了。</p><ul><li><code>front</code> 队列头部第一个有效的位置</li><li><code>rear</code>：指向队列尾部（即最后 1 个有效数据）的下一个位置，即下一个从队尾入队元素的位置。</li></ul></li><li><p><strong>为了避免“队列为空”和“队列为满”的判别条件冲突，我们有意浪费了一个位置。</strong></p><ul><li>浪费一个位置是指：循环数组中任何时刻一定至少有一个位置不存放元素。</li><li>判断队列为空的条件 <code>front == rear</code></li><li>判断队列为满的条件 <code>front == (rear + 1) % capacity</code> (可以这样理解，当 <code>rear</code> 循环到数组的前面，要从后面追上 <code>front</code>，还差一格的时候，判定队列为满。)</li></ul></li><li><p>因为有循环的出现，要<strong>特别注意处理数组下标可能越界的情况</strong>。指针后移的时候，索引 + 1，并且要注意取模。</p></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 浪费一个位置</span></span><br><span class="line">        capacity = k + <span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">        front = <span class="number">0</span>; <span class="comment">// 删除元素的时候，只索引 +1（注意取模）</span></span><br><span class="line">        rear  = <span class="number">0</span>; <span class="comment">// 插入元素的时候，先赋值，后索引 +1（注意取模）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先赋值，然后索引 + 1</span></span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先索引 + 1即可</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[(rear - <span class="number">1</span> + capacity) % capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经典设计</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % capacity == front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4-641-设计循环双端队列"><a href="#1-1-4-641-设计循环双端队列" class="headerlink" title="1.1.4 641. 设计循环双端队列"></a>1.1.4 <a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></h3><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span> </span>&#123;</span><br><span class="line">    <span class="comment">// front == rear 队列为空</span></span><br><span class="line">    <span class="comment">// (rear + 1) == front 队列为满</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularDeque</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        capacity = k + <span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertFront</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 索引 + 1 然后赋值</span></span><br><span class="line">        front = (front - <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        arr[front] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertLast</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// front 是在数组的开头，同时防止数组越界</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear = (rear - <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 rear 为0的时候防止数组越界</span></span><br><span class="line">        <span class="comment">// 因为真正的最后有效的元素是 rear - 1</span></span><br><span class="line">        <span class="keyword">return</span> arr[(rear - <span class="number">1</span> + capacity) % capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经典设计</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % capacity == front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-栈（后入先出）"><a href="#2-1-栈（后入先出）" class="headerlink" title="2.1 栈（后入先出）"></a>2.1 栈（后入先出）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200724-160713163.png" alt="mark"></p><ul><li>在 LIFO 数据结构中，将<code>首先处理添加到队列</code>中的<code>最新元素</code>。</li><li>与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 <code>push</code> 。与队列类似，总是<code>在堆栈的末尾添加一个新元素</code>。但是，删除操作，退栈 <code>pop</code> ，将始终<code>删除</code>队列中相对于它的<code>最后一个元素</code>。</li></ul><h3 id="2-1-1-栈的实现"><a href="#2-1-1-栈的实现" class="headerlink" title="2.1.1 栈的实现"></a>2.1.1 栈的实现</h3><ul><li>栈的实现比队列容易。<code>动态数组</code>足以实现堆栈结构。这里我们提供了一个简单的实现供你参考：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        list.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-155-最小栈"><a href="#2-1-2-155-最小栈" class="headerlink" title="2.1.2  155. 最小栈"></a>2.1.2  <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h3><p>题目描述：</p><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(x) ——   将元素 x 推入栈中。</span><br><span class="line">pop() ——     删除栈顶的元素。</span><br><span class="line">top() ——     获取栈顶元素。</span><br><span class="line">getMin() —— 检索栈中的最小元素。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MinStack"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"getMin"</span>,<span class="string">"pop"</span>,<span class="string">"top"</span>,<span class="string">"getMin"</span>]</span><br><span class="line">[[],[-<span class="number">2</span>],[<span class="number">0</span>],[-<span class="number">3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,-<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">0</span>,-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2</span>.</span><br></pre></td></tr></table></figure><p><strong>Solution：辅助栈和数据栈同步</strong></p><ul><li>特点：编写简单，不需要考虑一些边界情况（缺点：可能会存储一些多余的元素）</li><li>规则如下：<ul><li><strong>辅助栈为空的时候，必须放进来新的数字</strong></li><li>新来的数小于等于辅助栈栈顶元素的时候，才放入（<strong>这里“等于要考虑进去”，因为出栈的时候，相等的并且是最小值的元素要同步出栈</strong>），要不然就放入辅助栈栈顶自己</li><li><strong>出栈的时候，辅助栈的栈顶元素要等于数据栈栈顶的元素才出栈</strong></li></ul></li></ul><p><strong>总结：</strong></p><ul><li><strong>出栈的时候，最小值出栈才同步</strong></li><li><strong>入栈的时候，最小值入栈才同步</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data =   <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 思路1：数据栈和辅助栈在任何时候都要同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="keyword">if</span> (helper.isEmpty() || helper.peek() &gt;= x)&#123;</span><br><span class="line">            helper.add(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            helper.add(helper.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个栈都需要pop操作</span></span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty())&#123;</span><br><span class="line">            helper.pop();</span><br><span class="line">            data.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据栈的栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> data.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈元素为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小栈的栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!helper.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> helper.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈元素为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(1) 栈的操作</li><li><strong>空间复杂度</strong>：O(n) 需要一个辅助栈的空间</li></ul><h3 id="2-1-3-20-有效的括号"><a href="#2-1-3-20-有效的括号" class="headerlink" title="2.1.3 20. 有效的括号"></a>2.1.3 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h3><p><strong>题目描述</strong></p><p>给定一个只包括<code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code>的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br><strong>注意空字符串可被认为是有效字符串。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>算法思路</strong></p><ul><li>栈的先入后出的特点和括号排序一致，即遇到左括号入栈，遇到右括号时将对应的栈顶元素左括号出栈，则遍历完所有括号之后<code>stack</code> 仍然为空。</li><li>建立哈希表存储所有左右括号的对应关系，（key 左括号， value 右括号）。这样查询2个括号是否对应只要O(1) 的时间复杂度；<ul><li>建立栈<code>stack</code> ，遍历字符串s并按照算法流程就行判断</li></ul></li></ul><p><strong>算法流程</strong></p><ul><li>如果c 是左括号，则入栈push<ul><li>否则通过哈希表来判断对应关系，若<code>stack</code> 栈顶出栈的括号<code>stack.pop()</code> 与当前括号c不对应，则提前返回false</li></ul></li></ul><p><strong>提前返回false</strong></p><ul><li><strong>提前返回优点：</strong> 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。<ul><li><strong>栈 stack 为空</strong> ： 此时 stack.pop()会报错，因此使用一个取巧的办法，<strong>给stack 赋一个初值 ？</strong> ， <strong>并在哈希表中建立 ？ 和 ？ 的对应关系。</strong>此时当<code>stack</code> 为空且<code>c</code> 是右括号的时候，可以正常提前返回false.</li><li><strong>字符串s 以左括号结尾：</strong> 这种情况下，可以正常的遍历完字符串，但是最后的左括号遗留了下来，这时候要判断最后栈的长度是不是等于1，如果等于，说明多出来一个左括号，不是有效的括号组合。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195452276.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195501520.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195513439.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195521791.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195532859.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// map来预存括号以及辅助判断字符</span></span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'&#123;'</span>,<span class="string">'&#125;'</span>);</span><br><span class="line">        map.put(<span class="string">'['</span>,<span class="string">']'</span>);</span><br><span class="line">        map.put(<span class="string">'('</span>,<span class="string">')'</span>);</span><br><span class="line">        map.put(<span class="string">'?'</span>,<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有左括号直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span> &amp;&amp; !map.containsKey(s.charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈</span></span><br><span class="line">        LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，检查括号符不符合要求</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="comment">// 左括号放入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line">                list.add(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(list.removeLast()) != c)&#123;</span><br><span class="line">                <span class="comment">// 栈顶左括号和右括号是否匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断有没有遗留左括号</span></span><br><span class="line">        <span class="keyword">return</span> list.size() ==  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>复杂度分析</strong><ul><li>时间复杂度 O(N)：正确的括号组合需要遍历 1 遍 <code>s</code>；</li><li>空间复杂度 O(N)：哈希表和栈使用线性的空间大小。</li></ul></li></ul><h3 id="2-1-4-739-每日温度"><a href="#2-1-4-739-每日温度" class="headerlink" title="2.1.4  739. 每日温度"></a>2.1.4  <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h3><p><strong>题目描述：</strong></p><p><strong>本质</strong> ： 找到数组中第一个大于该元素数字的索引 ，并返回索引差值</p><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温 列表长度的范围是<code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在<code>[30, 100]</code>范围内的整数。</p><p><strong>解法思路：单调递减栈</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205146576.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205229904.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205245835.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205259273.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205320457.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205337913.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205344516.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 单调递减栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">                ret[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈为空的话</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)，</strong>其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</li><li><strong>空间复杂度：O(n)，</strong>其中 n是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</li></ul><h3 id="2-1-5-150-逆波兰表达式求值"><a href="#2-1-5-150-逆波兰表达式求值" class="headerlink" title="2.1.5 150. 逆波兰表达式求值"></a>2.1.5 <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h3><p><strong>题目描述</strong></p><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener"> 逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">逆波兰表达式：</span><br><span class="line"></span><br><span class="line">逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</span><br><span class="line"></span><br><span class="line">平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</span><br><span class="line">该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</span><br><span class="line">逆波兰表达式主要有以下两个优点：</span><br><span class="line"></span><br><span class="line">去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</span><br><span class="line">适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><p><strong>方法：单调栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 减少自动装箱拆箱的负担</span></span><br><span class="line">        Integer op1,op2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，进行运算</span></span><br><span class="line">        <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span> :</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 + op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 - op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 * op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 / op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(Integer.valueOf(s));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最后栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-队列和BFS"><a href="#2-队列和BFS" class="headerlink" title="2. 队列和BFS"></a>2. 队列和BFS</h1><h2 id="2-1-BFS"><a href="#2-1-BFS" class="headerlink" title="2.1 BFS"></a>2.1 BFS</h2><ul><li><p>广度优先搜索（BFS）是一个常见应用是从根节点到目标节点的最短路径。</p></li><li><p>在本文中，我们提供了一个示例来解释在 BFS 算法中是如何逐步应用队列的。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/162240980.gif" alt="mark"></p><p><strong>分析</strong></p><ol><li>节点的处理顺序是什么？</li></ol><ul><li>在第一轮中，我们处理根节点。</li><li>在第二轮中，我们处理第二层节点。</li><li>第三轮中，我们处理第三层节点。</li><li>。。。。</li></ul><ul><li>与树的<strong>层序遍历</strong>类似，<code>越是接近根结点的结点将越早地遍历</code>。</li></ul><ol start="2"><li>队列的入队和出队顺序是什么？</li></ol><ul><li>首先将根节点入队，逐个处理已经在队列中的节点，并将所有的邻居添加到队列中。值得注意的是，新添加的节点并不会立即遍历，而是在下一轮搜索中处理。</li><li>节点处理的顺序和添加到队列的顺序是完全相同的，即先进先出（FIFO）,这就是我们为什么使用队列的原因。</li></ul><h2 id="2-2-BFS两种模板"><a href="#2-2-BFS两种模板" class="headerlink" title="2.2 BFS两种模板"></a>2.2 BFS两种模板</h2><ul><li>之前，我们已经介绍了使用 BFS 的两个主要方案：<code>遍历</code>或<code>找出最短路径</code>。通常，这发生在树或图中。正如我们在章节描述中提到的，BFS 也可以用于更抽象的场景中。</li></ul><p><strong>模板一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一轮中，<strong>队列的节点是等待处理的节点</strong></li><li>在每个更外的一层<code>while</code> 循环之后，我们举例根节点更远一步。变量<code>step</code> 从根节点到我们正在访问的节点的距离。</li></ul><p><strong>模板二</strong></p><ul><li>有时候，确保我们永远不会访问同一个节点两次很重要。</li><li>否则的话，我们可能会陷入无限死循环，如果是这样，我们可以添加一个哈希set来解决这样的问题，下面是修改后的伪代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>队列q 就不用说了，BFS核心的数据结构；</strong></li><li><code>cur.adj()</code> 表示 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 的上下左右位置就是相邻的节点；</li><li><code>visited()</code> 节点的作用就是防止走回头路<ul><li><strong>大部分情况下，<code>visited</code> 数组或者说 哈希表 是必须的</strong></li><li><strong>但是像二叉树一般的结构，没有子节点到父节点的指针，不会走回头路就不需要<code>visited</code></strong></li></ul></li></ul><h2 id="2-3-BFS-题目1：-102-二叉树的层序遍历"><a href="#2-3-BFS-题目1：-102-二叉树的层序遍历" class="headerlink" title="2.3 BFS 题目1： 102. 二叉树的层序遍历"></a>2.3 BFS 题目1： <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>思路：BFS</strong></p><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="comment">// res 记录最后结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列（LinkedList实现）</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点放入队列</span></span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出队列首元素并删除</span></span><br><span class="line">                TreeNode curr = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 队首元素放到结果中</span></span><br><span class="line">                    subList.add(curr.val);</span><br><span class="line">                    <span class="comment">// 对子节点进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(curr.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(curr.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200809-163226648.gif" alt="mark"></p><ul><li>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</li></ul><p><strong>复杂度分析</strong></p><p>记树上所有节点的个数为 nn。</p><ul><li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li><li>空间复杂度：队列中元素的个数不超过 nn 个，故渐进空间复杂度为 O(n)。</li></ul><h2 id="2-4-BFS-题目2：111-二叉树的最小深度"><a href="#2-4-BFS-题目2：111-二叉树的最小深度" class="headerlink" title="2.4 BFS 题目2：111. 二叉树的最小深度"></a>2.4 BFS 题目2：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h2><p><strong>题目描述</strong></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>思路：BFS</strong></p><ul><li>首先来看看DFS和BFS的区别</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200728-150819598.gif" alt="mark"></p><ul><li><p>这个遍历顺序也是 BFS 能够用来解「层序遍历」、「最短路径」问题的根本原因。</p></li><li></li></ul><h2 id="2-5-BFS-题目3-：-279-完全平方数"><a href="#2-5-BFS-题目3-：-279-完全平方数" class="headerlink" title="2.5 BFS  题目3 ： 279-完全平方数"></a>2.5 BFS  题目3 ： 279-<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</span><br></pre></td></tr></table></figure><p><strong>解法：BFS（下面一图胜千言）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200809-170946859.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        queue.add(n);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            level++; <span class="comment">// 开始生成下一层</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                <span class="comment">//依次减 1, 4, 9... 生成下一层的节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= cur; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> next = cur - j * j;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">                        queue.offer(next);</span><br><span class="line">                        visited.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-栈和DFS"><a href="#3-栈和DFS" class="headerlink" title="3. 栈和DFS"></a>3. 栈和DFS</h1><ul><li><p>正如我们在本章的描述中提到的，在大多数情况下，我们在能使用 BFS 时也可以使用 DFS。但是有一个重要的区别：遍历顺序。</p></li><li><p>与 BFS 不同，更早访问的结点可能不是更靠近根结点的结点。因此，你在 DFS 中找到的第一条路径可能不是最短路径。</p></li><li><p>在本文中，我们将为你提供一个 DFS 的递归模板，并向你展示栈是如何帮助这个过程的。</p></li></ul><p><strong>模板</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Return true if there is a path from cur to target.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) &#123;</span><br><span class="line">    return true if cur is target;</span><br><span class="line">    for (next : each neighbor of cur) &#123;</span><br><span class="line">        if (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            return true if DFS(next, target, visited) &#x3D;&#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-94-二叉树的中序遍历"><a href="#3-1-94-二叉树的中序遍历" class="headerlink" title="3.1 94. 二叉树的中序遍历"></a>3.1 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h2><p>给定一根二叉树，返回它的中序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否是null</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 1. 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.left,res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 打印</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="comment">// 3. 右子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.right,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前序遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        DFS(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;DFS(root.left,res);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;DFS(root.right,res);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        DFS(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;DFS(root.left,res);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;DFS(root.right,res);&#125;</span><br><span class="line"></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-329-矩阵中的最长递增路径"><a href="#3-3-329-矩阵中的最长递增路径" class="headerlink" title="3.3 329. 矩阵中的最长递增路径"></a>3.3 <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;队列和栈-合集&quot;&gt;&lt;a href=&quot;#队列和栈-合集&quot; class=&quot;headerlink&quot; title=&quot;队列和栈-合集&quot;&gt;&lt;/a&gt;队列和栈-合集&lt;/h1&gt;&lt;p&gt;（本系列是针对Leetcode上常见的队列和栈进行总结。）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://zhuuu.work/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>汇编-07-内存</title>
    <link href="http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-07-%E5%86%85%E5%AD%98/"/>
    <id>http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-07-%E5%86%85%E5%AD%98/</id>
    <published>2020-07-17T03:47:41.000Z</published>
    <updated>2020-07-17T04:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-07-内存"><a href="#汇编-07-内存" class="headerlink" title="汇编-07-内存"></a>汇编-07-内存</h1><ul><li>寄存器很小，不够用，所以说，数据放到了内存中。</li><li>每个应用程序（进程）都有4GB的内存空间（空头支票）</li></ul><p>1 B = 8bit</p><p>1 KB = 1024B</p><p>1 MB = 1024KB</p><p>1 GB = 1024MB</p><h2 id="1-内存地址"><a href="#1-内存地址" class="headerlink" title="1. 内存地址"></a>1. 内存地址</h2><ul><li>给计算机中每个空间分配一个地址（名字） </li><li>32位 ： 寻址能力 ！ （4GB） </li><li></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-07-内存&quot;&gt;&lt;a href=&quot;#汇编-07-内存&quot; class=&quot;headerlink&quot; title=&quot;汇编-07-内存&quot;&gt;&lt;/a&gt;汇编-07-内存&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;寄存器很小，不够用，所以说，数据放到了内存中。&lt;/li&gt;
&lt;li&gt;每个应用程序（进程）都有4GB的内存空间（空头支票）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1 B = 8bit&lt;/p&gt;
&lt;p&gt;1 KB = 1024B&lt;/p&gt;
&lt;p&gt;1 MB = 1024KB&lt;/p&gt;
&lt;p&gt;1 GB = 1024MB&lt;/p&gt;
&lt;h2 id=&quot;1-内存地址&quot;&gt;&lt;a href=&quot;#1-内存地址&quot; class=&quot;headerlink&quot; title=&quot;1. 内存地址&quot;&gt;&lt;/a&gt;1. 内存地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给计算机中每个空间分配一个地址（名字） &lt;/li&gt;
&lt;li&gt;32位 ： 寻址能力 ！ （4GB） &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编-06-寄存器</title>
    <link href="http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-06-%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-06-%E5%AF%84%E5%AD%98%E5%99%A8/</id>
    <published>2020-07-17T03:40:41.000Z</published>
    <updated>2020-07-17T03:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-06-寄存器"><a href="#汇编-06-寄存器" class="headerlink" title="汇编-06-寄存器"></a>汇编-06-寄存器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>寄存器是CPU的组成部分，因为在CPU中，CPU对其读写速度是最快的，不需要IO传输</li><li>但是同时寄存器的数量是有限的，优先到几乎每个寄存器都有自己的名字，而且有些还有多个名字。</li></ul><p> IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类:</p><ul><li>通用寄存器</li><li>段寄存器</li><li>状态和控制寄存器</li><li>指令寄存器</li></ul><h2 id="1-32位通用寄存器"><a href="#1-32位通用寄存器" class="headerlink" title="1. 32位通用寄存器"></a>1. 32位通用寄存器</h2><ul><li>32位通用寄存器有八个<ul><li>eax : 累加和结果寄存器</li><li>ebx：数据指针寄存器</li><li>ecx：循环计数器</li><li>edx：i/o指针</li><li>esi：源地址寄存器</li><li>edi：目标地址寄存器</li><li>ebp：堆栈指针</li><li>esp：栈指针寄存器</li></ul></li></ul><a id="more"></a><p>[参考博客：][<a href="https://blog.csdn.net/lidonghat/article/details/70244288?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight]" target="_blank" rel="noopener">https://blog.csdn.net/lidonghat/article/details/70244288?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight]</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-06-寄存器&quot;&gt;&lt;a href=&quot;#汇编-06-寄存器&quot; class=&quot;headerlink&quot; title=&quot;汇编-06-寄存器&quot;&gt;&lt;/a&gt;汇编-06-寄存器&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;寄存器是CPU的组成部分，因为在CPU中，CPU对其读写速度是最快的，不需要IO传输&lt;/li&gt;
&lt;li&gt;但是同时寄存器的数量是有限的，优先到几乎每个寄存器都有自己的名字，而且有些还有多个名字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;li&gt;段寄存器&lt;/li&gt;
&lt;li&gt;状态和控制寄存器&lt;/li&gt;
&lt;li&gt;指令寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-32位通用寄存器&quot;&gt;&lt;a href=&quot;#1-32位通用寄存器&quot; class=&quot;headerlink&quot; title=&quot;1. 32位通用寄存器&quot;&gt;&lt;/a&gt;1. 32位通用寄存器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;32位通用寄存器有八个&lt;ul&gt;
&lt;li&gt;eax : 累加和结果寄存器&lt;/li&gt;
&lt;li&gt;ebx：数据指针寄存器&lt;/li&gt;
&lt;li&gt;ecx：循环计数器&lt;/li&gt;
&lt;li&gt;edx：i/o指针&lt;/li&gt;
&lt;li&gt;esi：源地址寄存器&lt;/li&gt;
&lt;li&gt;edi：目标地址寄存器&lt;/li&gt;
&lt;li&gt;ebp：堆栈指针&lt;/li&gt;
&lt;li&gt;esp：栈指针寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>汇编-05-位运算</title>
    <link href="http://zhuuu.work/2020/07/16/assembly/%E6%B1%87%E7%BC%96-05-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://zhuuu.work/2020/07/16/assembly/%E6%B1%87%E7%BC%96-05-%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2020-07-16T07:40:41.000Z</published>
    <updated>2020-07-17T02:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-05-位运算"><a href="#汇编-05-位运算" class="headerlink" title="汇编-05-位运算"></a>汇编-05-位运算</h1><p>参考博客链接：<a href="https://www.cnblogs.com/findbetterme/p/10787118.html" target="_blank" rel="noopener">https://www.cnblogs.com/findbetterme/p/10787118.html</a></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量的减少运行的开销，优化算法。</li><li>举个例子，翻转的操作比较常见，比如初始值是1，操作一次变成0，再操作一次变成1。 可能的做法是使用三木运算符，判断原始值是1还是0，如果是1，设置位0。否则设置位0，但是使用位运算，不用判断原始值，直接改变值就可以。<code>1^num //num</code> 为原始值。</li><li>当然，一句代码可能对性能没有什么影响，到那时在高并发，大数据量的情况下可以节省很多开销。</li><li>以下是整理的关于java位运算的部分内容，如有错误，还请指出，以共同进步，先行致谢。</li></ul><h2 id="1-位运算符"><a href="#1-位运算符" class="headerlink" title="1. 位运算符"></a>1. 位运算符</h2><h3 id="1-1-java支持的位运算符"><a href="#1-1-java支持的位运算符" class="headerlink" title="1.1 java支持的位运算符"></a>1.1 java支持的位运算符</h3><ul><li>&amp; ： 按位与</li><li>|  ：按位或</li><li>~  ： 按位非</li><li>^   :   按位异或</li><li>&lt;&lt; :  左位移运算符</li><li><code>&gt;&gt;</code> : 右位移运算符</li><li><code>&gt;&gt;&gt;</code> 无符号右移运算符</li><li><strong>注意：任何语言都没有无符号左移运算符</strong></li></ul><ul><li>位运算符中：除 ~ 以外，其余均为二元运算符。<strong>操作数只能是整型和字符型数据。</strong></li></ul><p>Java使用补码来表示二进制数，在补码表示中，最高位是符号位，正数的符号位为0，负数为1。</p><ul><li>补码的规定如下：<strong>对于正数来说</strong>，最高位是0，其余各位代表数值本身的二进制表示，如 <code>+ 42 的 补码  是  0010 1010</code></li><li><strong>补码对于负数来说，</strong>最高位是 1 ，把其余的位按位取反变成反码，然后对整个数+1，就是该数字的补码 ， <strong>如<code>-1 的补码是 1111 1111</code> （在java中 -1 的 补码 是 <code>1111 1111 1111 1111</code> ,因为java中的int是32位的）</strong></li></ul><h3 id="1-2-按位与（-amp-）"><a href="#1-2-按位与（-amp-）" class="headerlink" title="1.2 按位与（&amp;）"></a>1.2 按位与（&amp;）</h3><p>按位与的运算规则</p><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>&amp;</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p><strong>总结</strong></p><ul><li>两个数同时位1的时候，结果为1</li><li>其余全为0（只要有一个操作数为0，结果就为0）</li></ul><p><strong>举例：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084818815.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084849124.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084853301.png" alt="mark"></p><h3 id="1-3-按位或（-）"><a href="#1-3-按位或（-）" class="headerlink" title="1.3 按位或（|）"></a>1.3 按位或（|）</h3><p>按位或的运算规则</p><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位或</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p><strong>总结</strong></p><ul><li>只有两个操作数对应位同时为0，结果才是0</li><li>其余全是1（只要有一个1，那么结果就是1）</li></ul><h3 id="1-4-按位非（-）"><a href="#1-4-按位非（-）" class="headerlink" title="1.4 按位非（~）"></a>1.4 按位非（~）</h3><table><thead><tr><th>操作数</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>按位或</td><td>1</td><td>0</td></tr></tbody></table><p>在求负数的源码中使用过。</p><h3 id="1-5-按位异或（-）"><a href="#1-5-按位异或（-）" class="headerlink" title="1.5 按位异或（^）"></a>1.5 按位异或（^）</h3><ul><li>按位异或的运算规则</li></ul><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位异或</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>不一样就是1，一样就是0</li></ul><h3 id="1-6-左位移（-lt-lt-）"><a href="#1-6-左位移（-lt-lt-）" class="headerlink" title="1.6 左位移（&lt;&lt;）"></a>1.6 左位移（&lt;&lt;）</h3><ul><li>算数左移（<code>&lt;&lt;</code>） : 符号位不变，<strong>低位补0.</strong>  </li><li>如 <code>2 &lt;&lt; 2</code> 的结果是8.</li></ul><p><strong>举例：<code>2 &lt;&lt; 2</code> 的结果是8.</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/092343752.png" alt="mark"></p><p><strong>总结：</strong></p><ul><li>当移动的位数超过数字本身位数的时候，那么不就全部需要补0的操作吗？</li><li>实际上不是的，<strong>java不可能做这么浪费资源的事情。</strong>在真正执行位移前，其对要移动的位数做了一些预处理，如32处理为0，-1处理为31</li></ul><h3 id="1-7-右位移（-gt-gt-）"><a href="#1-7-右位移（-gt-gt-）" class="headerlink" title="1.7 右位移（&gt;&gt;）"></a>1.7 右位移（&gt;&gt;）</h3><ul><li>低位溢出，符号位不变，<strong>并用符号位补溢出的高位。</strong></li><li>如 <code>-6 &gt;&gt; 2</code> 结果是 <code>-2</code> (相当于除3)</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/093302064.png" alt="mark"></p><h3 id="1-8-无符号右移（-gt-gt-gt-）"><a href="#1-8-无符号右移（-gt-gt-gt-）" class="headerlink" title="1.8 无符号右移（&gt;&gt;&gt;）"></a>1.8 无符号右移（&gt;&gt;&gt;）</h3><ul><li><strong>低位溢出，高位补0</strong></li><li><strong>注意，无符号右移(&gt;&gt;&gt;) 中的符号位（最高位）也跟着在变。</strong></li><li>无符号的意思是将符号位当作数字位来看待。</li><li>如 <code>-1 &gt;&gt;&gt; 1</code> 的结果是<code>2141483647</code></li></ul><p>这个数字应该比较熟悉，看两个输出语句就知道是什么了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(-<span class="number">1</span>&gt;&gt;&gt;<span class="number">1</span>));</span><br><span class="line">System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">1111111111111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111111111111</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/101857332.png" alt="mark"></p><p>除了使用-1&gt;&gt;&gt;1能得到Integer.MAX_VALUE，以下的也能得到同样的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;maxInt</span><br><span class="line">System.out.println(~(1 &lt;&lt; 31));</span><br><span class="line">System.out.println((1 &lt;&lt; -1) -1);</span><br><span class="line">System.out.println(~(1 &lt;&lt; -1));</span><br></pre></td></tr></table></figure><p>使用位运算往往能很巧妙的实现某些算法完成一些复杂的功能。</p><h2 id="2-常见使用"><a href="#2-常见使用" class="headerlink" title="2. 常见使用"></a>2. 常见使用</h2><h3 id="2-1-m-2-n"><a href="#2-1-m-2-n" class="headerlink" title="2.1 m*2 ^n"></a>2.1 m*2 ^n</h3><ul><li><p>可以使用 m &lt;&lt; n 求得结果：</p><ul><li>如 <code>System.*out*.println(&quot;2^3=&quot; + (1&lt;&lt;3));//2^3=8</code></li><li><code>System.*out*.println(&quot;3*2^3=&quot; + (3&lt;&lt;3));//3*2^3=24</code></li></ul></li><li><p>计算结果是不是很正确呢？ <strong>如果非要说 <code>2 &lt;&lt; -1</code> 为什么不等于0.5？ 前面说过，位运算的操作数只能是整型和字符型</strong>。再求int所能表示的最小值的时候，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># minInt</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li>可以发现左移31位和-1位所得的结果是一样的。同理，左移30位和左移-2所得的结果也是一样的。移动一个负数为，是不是等于右移该负数位的绝对值呢？输出一下发现结果不是的。</li><li><strong>java中 Int 所能表示的最大值是31位，加上符号位共32位。在这里有如下的位移法则：</strong><ul><li><strong>法则1： 任何数左移（右移）32的倍数位等于该数本身</strong></li><li><strong>法则2：在位移运算 m &lt;&lt; n 的计算中，若n 是正数，则实际移动的位数是 n % 32；若 n是负数，则实际移动的位数是 （32 + n % 32） ，右移同理</strong></li><li>左移是乘以2的幂，右移是除以2的幂。</li></ul></li></ul><h3 id="2-2-判断一个数的奇偶性"><a href="#2-2-判断一个数的奇偶性" class="headerlink" title="2.2 判断一个数的奇偶性"></a>2.2 判断一个数的奇偶性</h3><p><code>n &amp; 1 == 1? 奇数：偶数</code> </p><ul><li><strong>为什么与1能判断奇偶？</strong></li><li><strong>所谓的二进制就是满2进1，那么好了，偶数的最低位肯定是0（恰好满2，对不对？）</strong></li><li><strong>同理，奇数的最低为肯定是1，<code>对于int类型的1，前31位都是0，无论是1&amp;0 还是 0 &amp; 0结果都是0</code></strong></li><li><strong>那么有区别的肯定就是最低为上的 1 了，若 n 的二进制最低位为是1（奇数），反则就是结果就是0（偶数）</strong></li></ul><h3 id="2-3-不使用临时变量交换两个数字"><a href="#2-3-不使用临时变量交换两个数字" class="headerlink" title="2.3 不使用临时变量交换两个数字"></a>2.3 不使用临时变量交换两个数字</h3><p><strong>在int[]数组首尾互换中，是不看到过这样的代码：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-05-位运算&quot;&gt;&lt;a href=&quot;#汇编-05-位运算&quot; class=&quot;headerlink&quot; title=&quot;汇编-05-位运算&quot;&gt;&lt;/a&gt;汇编-05-位运算&lt;/h1&gt;&lt;p&gt;参考博客链接：&lt;a href=&quot;https://www.cnblogs.com/findbetterme/p/10787118.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/findbetterme/p/10787118.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-088-合并两个有序数组</title>
    <link href="http://zhuuu.work/2020/07/15/Leetcode/Leetcode-088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2020/07/15/Leetcode/Leetcode-088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-15T08:52:53.000Z</published>
    <updated>2020-07-17T07:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-088-合并两个有序数组"><a href="#Leecode-088-合并两个有序数组" class="headerlink" title="Leecode-088-合并两个有序数组"></a>Leecode-088-<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2*，请你将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p><p>说明:</p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</li><li><strong>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一：从头到后双指针"><a href="#方法一：从头到后双指针" class="headerlink" title="方法一：从头到后双指针"></a><strong>方法一：从头到后双指针</strong></h2><ul><li><p>跟合并两个链表很类似，这里也用两个指针指向数组的1的开头，数组2的开头</p></li><li><p>跟链表合并不同的是，如果往数组中插入一个元素，为了保证整体的顺序性，需要挪动前后的元素，所以我们<strong>要再创建一个数组来保存指针指向的元素。</strong></p></li><li><p>之后比较两个数组中的元素<code>nums1[i]</code>和<code>nums2[j]</code>，将其放到新数组中。</p></li><li><p>这种两两合并的好处是可以免掉排序了，比较完之后再放到新数组中，元素都是有序的了。</p></li><li><p>但题目要求是在数组1的基础上进行修改，而不是返回一个新数组，所以我们还得把排序好的新数组内容，再重新赋给数组1。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/152420791.jpg" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代新开的数组</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; m || k &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 两个边界条件 j = m  和 k = n</span></span><br><span class="line">            <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">                <span class="comment">// nums1走完了</span></span><br><span class="line">                arr[i++] = nums2[k++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (k == n)&#123;</span><br><span class="line">                <span class="comment">// nums2走完了</span></span><br><span class="line">                arr[i++] = nums1[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[j] &lt;= nums2[k])&#123;</span><br><span class="line">                arr[i++] = nums1[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i++] = nums2[k++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再把数组重新赋值给nums1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arr.length; l++) &#123;</span><br><span class="line">            nums1[l] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(m + n) 遍历两个数组需要的时间</li><li>空间复杂度： O(m + n) 新开了一个数组大小</li></ul><h2 id="方法二：从后向前迭代数组（空间优化）"><a href="#方法二：从后向前迭代数组（空间优化）" class="headerlink" title="方法二：从后向前迭代数组（空间优化）"></a>方法二：从后向前迭代数组（空间优化）</h2><ul><li><p>虽然方法一已经很ok了，<strong>但是仔细想想，nums1后面那些个0我们是不是没有用呢？</strong></p></li><li><p>另外题目中也说明了，数组1的空间是足够的，它可以完全容纳下数组1的m个元素和数组2的n个元素。</p></li><li><p>这两个条件拼在一起，我们就有了新的比较方式，即：反着比较。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/152800269.jpg" alt="mark"></p><p><strong>思路：</strong></p><ul><li>反向比较<code>nums1[m - 1] 和 nums2[n - 1]</code></li><li>注意:这样我们就不需要额外的空间了，数组1后面空着的我们都可以直接用</li><li><strong>关键：把两个数组后面最大的数放到数组1的最后一位</strong></li><li>依次类推直到两个数组的元素全部比较完。<br>最后数组1就是有序的，这种比较方式不需要再占用额外的空间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于修改元素的指针</span></span><br><span class="line">        <span class="keyword">int</span> k = m + n -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意边界条件， i &lt; 0以及 j &lt; 0,这表示一个数组已经使用完了</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 反向比较的话，拷贝的是较大的元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(m + n) 遍历两个数组需要的时间</li><li><strong>空间复杂度</strong>： O(1) </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-088-合并两个有序数组&quot;&gt;&lt;a href=&quot;#Leecode-088-合并两个有序数组&quot; class=&quot;headerlink&quot; title=&quot;Leecode-088-合并两个有序数组&quot;&gt;&lt;/a&gt;Leecode-088-&lt;a href=&quot;https://leetcode-cn.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并两个有序数组&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两个有序整数数组 &lt;em&gt;nums1&lt;/em&gt; 和 &lt;em&gt;nums2*，请你将 *nums2&lt;/em&gt; 合并到 &lt;em&gt;nums1&lt;/em&gt; 中&lt;em&gt;，&lt;/em&gt;使 &lt;em&gt;nums1&lt;/em&gt; 成为一个有序数组。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums1 &amp;#x3D; [1,2,3,0,0,0], m &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums2 &amp;#x3D; [2,5,6],       n &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2,2,3,5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
