<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱酱酱的学习博客</title>
  <icon>https://www.gravatar.com/avatar/336d255f627c733c7a50883547bcec06</icon>
  <subtitle>From Zero to Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuuu.work/"/>
  <updated>2020-07-26T13:00:06.000Z</updated>
  <id>http://zhuuu.work/</id>
  
  <author>
    <name>Zhuuu</name>
    <email>353446503@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-739-每日温度</title>
    <link href="http://zhuuu.work/20020/06/12/Leetcode/Leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>http://zhuuu.work/20020/06/12/Leetcode/Leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</id>
    <published>+020020-06-12T07:24:53.000Z</published>
    <updated>2020-07-26T13:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-739-每日温度"><a href="#Leecode-739-每日温度" class="headerlink" title="Leecode-739-每日温度"></a>Leecode-739-<a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h1><p><strong>题目描述：</strong></p><p><strong>本质</strong> ： 找到数组中第一个大于该元素数字的索引 ，并返回索引差值</p><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温 列表长度的范围是<code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在<code>[30, 100]</code>范围内的整数。</p><a id="more"></a><p><strong>解法思路：单调递减栈</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205146576.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205229904.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205245835.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205259273.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205320457.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205337913.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205344516.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 单调递减栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">                ret[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈为空的话</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)，</strong>其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</li><li><strong>空间复杂度：O(n)，</strong>其中 n是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-739-每日温度&quot;&gt;&lt;a href=&quot;#Leecode-739-每日温度&quot; class=&quot;headerlink&quot; title=&quot;Leecode-739-每日温度&quot;&gt;&lt;/a&gt;Leecode-739-&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每日温度&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本质&lt;/strong&gt; ： 找到数组中第一个大于该元素数字的索引 ，并返回索引差值&lt;/p&gt;
&lt;p&gt;根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。&lt;/p&gt;
&lt;p&gt;例如，给定一个列表&lt;code&gt;temperatures = [73, 74, 75, 71, 69, 72, 76, 73]&lt;/code&gt;，你的输出应该是 &lt;code&gt;[1, 1, 4, 2, 1, 1, 0, 0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;提示：气温 列表长度的范围是&lt;code&gt;[1, 30000]&lt;/code&gt;。每个气温的值的均为华氏度，都是在&lt;code&gt;[30, 100]&lt;/code&gt;范围内的整数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://zhuuu.work/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Linux-05-C10K</title>
    <link href="http://zhuuu.work/2020/09/10/Linux/Linux-05-C10K/"/>
    <id>http://zhuuu.work/2020/09/10/Linux/Linux-05-C10K/</id>
    <published>2020-09-10T07:12:53.000Z</published>
    <updated>2020-09-16T00:33:31.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-05-C10K"><a href="#Linux-05-C10K" class="headerlink" title="Linux-05-C10K"></a>Linux-05-C10K</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>随着互联网的普及，应用的用户群体几何倍增长，此时<strong>服务器性能问题就出现。最初的服务器是基于进程/线程模型。新到来一个TCP连接，就需要分配一个进程。假如有C10K，就需要创建1W个进程，可想而知单机是无法承受的。</strong></li><li>那么如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题，最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案。</li></ul><h2 id="C10的本质"><a href="#C10的本质" class="headerlink" title="C10的本质"></a>C10的本质</h2><ul><li><strong>C10K问题的本质上是操作系统的问题。</strong></li><li>对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是requests per second。</li><li>当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。</li></ul><p>可见, 解决C10K问题的关键就是尽可能减少这些CPU资源消耗。</p><a id="more"></a><h2 id="C10K的解决方案"><a href="#C10K的解决方案" class="headerlink" title="C10K的解决方案"></a>C10K的解决方案</h2><p>从网络编程技术的角度来说，主要思路：</p><ol><li><strong>每个连接分配一个独立的线程/进程</strong></li><li><strong>同一个线程/进程同时处理多个连接</strong></li></ol><p><strong>方案一：每个连接分配一个独立的线程/进程</strong></p><ul><li>该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以会使资源占用过多，可扩展性差</li></ul><p><strong>方法二： 每个进程/线程同时处理 多个连接(I/O多路复用)</strong></p><ul><li><p><strong>select方式：</strong>使用fd_set结构体告诉内核同时监控那些文件句柄，使用逐个排查方式去检查是否有文件句柄就绪或者超时。该方式有以下缺点：文件句柄数量是有上线的，逐个检查吞吐量低，每次调用都要重复初始化fd_set。</p></li><li><p><strong>poll方式：</strong></p><ul><li>该方式主要解决了select方式的2个缺点，文件句柄上限问题(链表方式存储)以及重复初始化问题(不同字段标注关注事件和发生事件)，</li><li>但是逐个去检查文件句柄是否就绪的问题仍然没有解决。</li></ul></li><li><p><strong>epoll方式：</strong></p><ul><li>该方式可以说是C10K问题的killer，他不去轮询监听所有文件句柄是否已经就绪。epoll只对发生变化的文件句柄感兴趣。</li><li>其工作机制是，使用”事件”的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。</li><li>而且epoll使用一个文件描述符管理多个描述符,将用户进程的文件描述符的事件存放到内核的一个事件表中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。</li><li>而且epoll是通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高。但是epoll是依赖系统的(Linux)。</li></ul></li></ul><p>以及异步I/O以及Windows，该方式在windows上支持很好</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-05-C10K&quot;&gt;&lt;a href=&quot;#Linux-05-C10K&quot; class=&quot;headerlink&quot; title=&quot;Linux-05-C10K&quot;&gt;&lt;/a&gt;Linux-05-C10K&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;随着互联网的普及，应用的用户群体几何倍增长，此时&lt;strong&gt;服务器性能问题就出现。最初的服务器是基于进程/线程模型。新到来一个TCP连接，就需要分配一个进程。假如有C10K，就需要创建1W个进程，可想而知单机是无法承受的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;那么如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题，最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;C10的本质&quot;&gt;&lt;a href=&quot;#C10的本质&quot; class=&quot;headerlink&quot; title=&quot;C10的本质&quot;&gt;&lt;/a&gt;C10的本质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C10K问题的本质上是操作系统的问题。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是requests per second。&lt;/li&gt;
&lt;li&gt;当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见, 解决C10K问题的关键就是尽可能减少这些CPU资源消耗。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="多路复用" scheme="http://zhuuu.work/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-final全家桶</title>
    <link href="http://zhuuu.work/2020/09/08/JavaInterview/Java-%E5%9F%BA%E7%A1%80-final%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <id>http://zhuuu.work/2020/09/08/JavaInterview/Java-%E5%9F%BA%E7%A1%80-final%E5%85%A8%E5%AE%B6%E6%A1%B6/</id>
    <published>2020-09-08T09:34:38.000Z</published>
    <updated>2020-09-19T08:51:48.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-final全家桶"><a href="#Java-基础-final全家桶" class="headerlink" title="Java-基础-final全家桶"></a>Java-基础-final全家桶</h1><h2 id="1-final"><a href="#1-final" class="headerlink" title="1. final"></a>1. final</h2><ul><li>在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。下面将对其详细介绍。</li></ul><h3 id="1-1-修饰类"><a href="#1-1-修饰类" class="headerlink" title="1.1 修饰类"></a>1.1 修饰类</h3><ul><li>当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，<strong>但要注意：</strong></li><li>final类中所有的成员方法都会隐式的定义为final方法。</li></ul><a id="more"></a><h3 id="1-2-修饰方法"><a href="#1-2-修饰方法" class="headerlink" title="1.2 修饰方法"></a>1.2 修饰方法</h3><ul><li>使用final方法的原因主要有两个：<ul><li>(1) 把方法锁定，以防止继承类对其进行更改。</li><li>(2) 效率，在早期的java版本中，会将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。</li></ul></li></ul><p>final方法意味着“最后的、最终的”含义，即此方法不能被重写。</p><p><strong>注意：</strong></p><ul><li><strong>若父类中final方法的访问权限为private，将导致子类中不能直接继承该方法，因此，此时可以在子类中定义相同方法名的函数，此时不会与重写final的矛盾，而是在子类中重新地定义了新方法。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在java中，String被设计成final类，那为什么平时使用时，String的值可以被改变呢？<ul><li>字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。</li><li>当我们对String对象值改变的时候，例如 String a=”A”; a=”B” 。a是String对象的一个引用（我们这里所说的String对象其实是指字符串常量）<ul><li>当a=“B”执行时，并不是原本String对象(“A”)发生改变，而是创建一个新的对象(“B”)，令a引用它。</li></ul></li></ul></li></ul><h3 id="1-3-修饰变量"><a href="#1-3-修饰变量" class="headerlink" title="1.3 修饰变量"></a>1.3 修饰变量</h3><ul><li><p>final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。类似于C++中的const。</p><ul><li>当final修饰一个<strong>基本数据类型</strong>时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li><li>如果final修饰一个<strong>引用类型时</strong>，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。</li></ul></li><li><p><strong>final修饰一个成员变量（属性），必须要显示初始化。**</strong>这里有两种初始化方式**，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</p></li><li><p>当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。</p></li></ul><h2 id="2-finally"><a href="#2-finally" class="headerlink" title="2. finally"></a>2. finally</h2><ul><li>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。（×）（这句话其实存在一定的问题）</li><li>很多人都认为finally语句块一定会执行，但真的是这样么？答案是否定的，例如下面这个例子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164140271.png" alt="mark"></p><p>当我们去掉注释的三行语句，执行结果为：</p><p><code>return 0</code></p><ul><li><p>为什么在以上两种情况下都没有执行finally语句呢，说明什么问题？</p><ul><li><strong>只有与<code>finally</code>对应的<code>try</code>语句块得到执行的情况下，<code>finally</code>语句块才会执行。以上两种情况在执行<code>try</code>语句块之前已经返回或抛出异常，所以try对应的<code>finally</code>语句并没有执行。</strong></li></ul></li><li><p>但是，在某些情况下，即使try语句执行了，finally语句也不一定执行。例如以下情况：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164323776.png" alt="mark"></p><ul><li>finally 语句块还是没有执行，为什么呢？因为我们在 try 语句块中执行了 <code>System.exit (0)</code>语句，终止了 Java 虚拟机的运行。那有人说了，在一般的 Java 应用中基本上是不会调用这个 <code>System.exit(0)</code> 方法的。OK ！没有问题，我们不调用 <code>System.exit(0)</code>这个方法，那么<code>finally</code> 语句块就一定会执行吗？</li><li>再一次让大家失望了，答案还是否定的。当一个线程在执行 try 语句块或者 catch 语句块时被打断（<code>interrupted</code>）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。</li><li>还有更极端的情况，就是在线程运行<code>try</code> 语句块或者 <code>catch</code> 语句块时，突然死机或者断电，<code>finally</code> 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。</li></ul><h3 id="2-1-一个易错点"><a href="#2-1-一个易错点" class="headerlink" title="2.1 一个易错点"></a>2.1 一个易错点</h3><ul><li>在try-catch-finally语句中执行return语句。我们看如下代码：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164625386.png" alt="mark"></p><p><strong>答案：4,4,4 。  为什么呢？</strong></p><ul><li>首先finally语句在改代码中一定会执行，从运行结果来看，每次return的结果都是4（即finally语句），仿佛其他return语句被屏蔽掉了。</li><li>事实也确实如此，因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。 </li></ul><h2 id="3-finalize"><a href="#3-finalize" class="headerlink" title="3. finalize"></a>3. finalize</h2><ul><li><p><code>finalize()</code>是在<code>java.lang.Object</code>里定义的，也就是说每一个对象都有这么个方法。</p></li><li><p><strong>这个方法在gc启动，该对象被回收的时候被调用</strong>。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 </p></li><li><p>特殊情况下，需要程序员实现<code>finalize</code>，当对象被回收的时候释放一些资源，比如：一个<code>socket</code>链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 </p></li></ul><p><strong>使用finalize还需要注意一个事，调用super.finalize();</strong></p><ul><li>一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了</li><li>然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。</li><li>所以，推荐不要使用finalize()方法，它跟析构函数不一样.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-final全家桶&quot;&gt;&lt;a href=&quot;#Java-基础-final全家桶&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-final全家桶&quot;&gt;&lt;/a&gt;Java-基础-final全家桶&lt;/h1&gt;&lt;h2 id=&quot;1-final&quot;&gt;&lt;a href=&quot;#1-final&quot; class=&quot;headerlink&quot; title=&quot;1. final&quot;&gt;&lt;/a&gt;1. final&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。下面将对其详细介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-修饰类&quot;&gt;&lt;a href=&quot;#1-1-修饰类&quot; class=&quot;headerlink&quot; title=&quot;1.1 修饰类&quot;&gt;&lt;/a&gt;1.1 修饰类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，&lt;strong&gt;但要注意：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;final类中所有的成员方法都会隐式的定义为final方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="final" scheme="http://zhuuu.work/tags/final/"/>
    
      <category term="finally" scheme="http://zhuuu.work/tags/finally/"/>
    
      <category term="finalize" scheme="http://zhuuu.work/tags/finalize/"/>
    
  </entry>
  
  <entry>
    <title>Redis-17-动态字符串SDS</title>
    <link href="http://zhuuu.work/2020/09/07/Redis/Redis-17-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/"/>
    <id>http://zhuuu.work/2020/09/07/Redis/Redis-17-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</id>
    <published>2020-09-07T10:32:24.000Z</published>
    <updated>2020-09-21T11:26:16.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-17-动态字符串SDS"><a href="#Redis-17-动态字符串SDS" class="headerlink" title="Redis-17-动态字符串SDS"></a>Redis-17-动态字符串SDS</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>面试场景</strong></p><p>面试官：Redis有哪些数据类型？</p><p>我：String，List，set，zset，hash</p><p>面试官：没了？</p><p><strong>我：哦哦哦，还有HyperLogLog，bitMap，GeoHash，BloomFilter</strong></p><p>面试官：就这？回家等通知吧。(GG)</p><ul><li><p>但是，一场面试少说都是半小时起步上不封顶，你这样一句话就回答了这么重要的五个知识点，这个结果是你想要的么？是面试官想要的么？</p></li><li><p>String在Redis底层是怎么存储的？这些数据类型在Redis中是怎么存放的？Redis快的原因就只有单线程和基于内存么？</p></li></ul><a id="more"></a><h2 id="1-SDS"><a href="#1-SDS" class="headerlink" title="1. SDS"></a>1. SDS</h2><ul><li>Redis是C语言开发的，C语言自己就有字符类型，但是Redis却没直接采用C语言的字符串类型，而是自己构建了<code>动态字符串（SDS）</code>的抽象类型。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/165529250.png" alt="mark"></p><ul><li><p>就好比这样的一个命令，其实我是在Redis创建了两个SDS，一个是名为<code>aobing</code>的Key SDS，另一个是名为<code>cool</code>的Value SDS，就算是字符类型的List，也是由很多的SDS构成的Key和Value罢了。</p></li><li><p>SDS在Redis中除了用作字符串，还用作缓冲区（buffer），那到这里大家都还是有点疑惑的，C语言的字符串不好么为啥用SDS？SDS长啥样？有什么优点呢?</p></li></ul><p><strong>去找到了Redis的源码，可以看到SDS值的结果大概是这样的，源码的在GitHub上是开源的大家一搜就有了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"> <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/165739509.png" alt="mark"></p><ul><li>回到最初的问题，为什么Redis用了自己新开发的SDS，而不用C语言的字符串？那好我们去看看他们的区别。</li></ul><h3 id="1-1-SDS-和-C字符串的区别"><a href="#1-1-SDS-和-C字符串的区别" class="headerlink" title="1.1 SDS 和 C字符串的区别"></a>1.1 SDS 和 C字符串的区别</h3><ol><li><strong>计数方式不同</strong></li></ol><ul><li>C语言对字符串长度的统计，就完全来自遍历，从头遍历到末尾，直到发现空字符就停止，以此统计出字符串的长度，这样获取长度的时间复杂度来说是0（n），大概就像下面这样</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170018810.gif" alt="mark"></p><ul><li><p>但是这样的计数方式会留下隐患，所以Redis没有采用C的字符串，我后面会提到。</p></li><li><p>而Redis我在上面已经给大家看过结构了，他自己本身就保存了长度的信息，所以我们获取长度的时间复杂度为0（1），是不是发现了Redis快的一点小细节了？还没完，不止这些。</p></li></ul><ol start="2"><li><strong>杜绝缓冲区溢出</strong></li></ol><ul><li>字符串拼接是我们经常做的操作，在C和Redis中一样，也是很常见的操作，但是问题就来了，C是不记录字符串长度的，一旦我们调用了拼接的函数，如果没有提前计算好内存，是会产生缓存区溢出的。</li></ul><p>比如本来字符串长这样：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170206424.png" alt="mark"></p><p>你现在需要在后面拼接 ，但是你没计算好内存，结果就可能这样了：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170225389.png" alt="mark"></p><ul><li>这是你要的结果么？很显然，不是，你的结果意外的被修改了，这要是放在线上的系统，这不是完了？那Redis是怎么避免这样的情况的？</li><li>我们都知道，<strong>他结构存储了当前长度，还有free未使用的长度</strong>，那简单呀，你现在做了拼接操作，我去判断一些是否可以放得下，如果长度够就直接执行，如果不够，那我就进行扩容。</li><li>这些大家在Redis源码里面都是可以看到对应的API的，后面我就不一一贴源码了，有兴趣的可以自己去看一波，需要一点C语言的基础。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170510217.png" alt="mark"></p><ol start="3"><li><strong>减少修改字符串时带来的内存重分配次数</strong></li></ol><ul><li>C语言字符串底层也是一个数组，每次创建的时候就创建一个N+1长度的字符，多的那个1，就是为了保存空字符的，这个空字符也是个坑，但是不是这个环节探讨的内容。</li><li>Redis是个高速缓存数据库，如果我们需要对字符串进行频繁的拼接和截断操作，如果我们写代码忘记了重新分配内存，就可能造成缓冲区溢出，以及内存泄露。</li><li>内存分配算法很耗时，且不说你会不会忘记重新分配内存，就算你全部记得，对于一个高速缓存数据库来说，这样的开销也是我们应该要避免的。</li></ul><p><strong>Redis为了避免C字符串这样的缺陷，就分别采用了两种解决方案，去达到性能最大化，空间利用最大化：</strong></p><ul><li>空间预分配：当我们对SDS进行扩展操作的时候，Redis会为SDS分配好内存，并且根据特定的公式，分配多余的free空间，还有多余的1byte空间（这1byte也是为了存空字符），这样就可以避免我们连续执行字符串添加所带来的内存分配消耗。</li></ul><p>比如现在有这样的一个字符：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170956217.png" alt="mark"></p><p>我们调用了拼接函数，字符串变长了，Redis还会根据算法计算出一个free值给他备用：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171058868.png" alt="mark"></p><p>我们再继续拼接，你会发现，备用的free用上了，省去了这次的内存重分配：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171131120.png" alt="mark"></p><ul><li><strong>惰性空间释放</strong>：刚才提到了会预分配多余的空间，很多小伙伴会担心带来内存的泄露或者浪费，别担心，Redis大佬一样帮我们想到了，当我们执行完一个字符串缩减的操作，redis并不会马上收回我们的空间，因为可以预防你继续添加的操作，这样可以减少分配空间带来的消耗，但是当你再次操作还是没用到多余空间的时候，Redis也还是会收回对于的空间，防止内存的浪费的。</li></ul><p>还是一样的字符串：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171207003.png" alt="mark"></p><p>当我们调用了删减的函数，并不会马上释放掉free空间：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171227873.png" alt="mark"></p><p>如果我们需要继续添加这个空间就能用上了，减少了内存的重分配，如果空间不需要了，调用函数删掉就好了：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171246466.png" alt="mark"></p><ol start="4"><li><strong>二进制安全</strong></li></ol><ul><li>仔细看的仔肯定看到上面我不止一次提到了空字符也就是’\0‘，C语言是判断空字符去判断一个字符的长度的，但是有很多数据结构经常会穿插空字符在中间，比如图片，音频，视频，压缩文件的二进制数据，就比如下面这个单词，他只能识别前面的 不能识别后面的字符，那对于我们开发者而言，这样的结果显然不是我们想要的对不对。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171334719.png" alt="mark"></p><ul><li>Redis就不存在这个问题了，他不是保存了字符串的长度嘛，他不判断空字符，他就判断长度对不对就好了，所以redis也经常被我们拿来保存各种二进制数据，我反正是用的很high，经常用来保存小文件的二进制。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171356886.png" alt="mark"></p><p><strong>总结</strong></p><ul><li>大家是不是发现，一个小小的SDS居然有这么多道理在这？</li><li>以前就知道Redis快，最多说个Redis是单线程的，说个多路IO复用，说个基于内存的操作就完了，现在是不是还可以展开说说了？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-17-动态字符串SDS&quot;&gt;&lt;a href=&quot;#Redis-17-动态字符串SDS&quot; class=&quot;headerlink&quot; title=&quot;Redis-17-动态字符串SDS&quot;&gt;&lt;/a&gt;Redis-17-动态字符串SDS&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;面试场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面试官：Redis有哪些数据类型？&lt;/p&gt;
&lt;p&gt;我：String，List，set，zset，hash&lt;/p&gt;
&lt;p&gt;面试官：没了？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我：哦哦哦，还有HyperLogLog，bitMap，GeoHash，BloomFilter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面试官：就这？回家等通知吧。(GG)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;但是，一场面试少说都是半小时起步上不封顶，你这样一句话就回答了这么重要的五个知识点，这个结果是你想要的么？是面试官想要的么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String在Redis底层是怎么存储的？这些数据类型在Redis中是怎么存放的？Redis快的原因就只有单线程和基于内存么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SDS" scheme="http://zhuuu.work/tags/SDS/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-异常</title>
    <link href="http://zhuuu.work/2020/09/07/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/"/>
    <id>http://zhuuu.work/2020/09/07/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/</id>
    <published>2020-09-07T09:34:38.000Z</published>
    <updated>2020-09-07T12:11:38.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-异常"><a href="#Java-基础-异常" class="headerlink" title="Java-基础-异常"></a>Java-基础-异常</h1><h2 id="1-什么是异常？"><a href="#1-什么是异常？" class="headerlink" title="1. 什么是异常？"></a>1. 什么是异常？</h2><ul><li><p>事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用<strong>空的引用</strong>、<strong>数组下标越界</strong>、<strong>内存溢出错误</strong>等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。</p></li><li><p><strong>假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果</strong>。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，<strong>通过异常机制来处理程序运行期间出现的错误</strong>。通过异常机制，我们可以更好地提升程序的健壮性。</p></li><li><p>在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。java中的处理就是中断处理。</p></li></ul><p>　<strong>在Java中，异常类的结构层次图如下图所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/145710336.png" alt="mark"></p><a id="more"></a><p><strong>异常的分类：</strong></p><ul><li><p>在Java中异常被当做对象来处理，根类是<code>java.lang.Throwable</code>类，在Java中定义了很多异常类（如<code>OutOfMemoryError、NullPointerException</code>、<code>IndexOutOfBoundsException</code>等），这些异常类分为两大类：<code>Error</code>和<code>Exception</code>。</p></li><li><p><code>Exception</code>类的异常包括<code>checked exception</code>和<code>unchecked exception</code>（<code>unchecked exception</code>也称运行时异常<code>RuntimeException</code>，当然这里的运行时异常并不是前面我所说的运行期间的异常，只是Java中用运行时异常这个术语来表示，Exception类的异常都是在运行期间发生的）。</p><ul><li><code>unchecked exception</code>（非检查异常），也称运行时异常<code>（RuntimeException）</code>，比如常见的<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</li><li><code>checked exception</code>（检查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），<code>java</code>编译器强制程序员必须进行捕获处理，比如常见的<code>IOExeption</code>和<code>SQLException</code>。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过</li></ul></li><li><p>在Java中，所有异常类的父类是<code>Throwable</code>类，</p><ul><li>Error类是error类型异常的父类，</li><li>Exception类是exception类型异常的父类，<ul><li>RuntimeException类是所有运行时异常的父类</li><li>RuntimeException以外的并且继承Exception的类是非运行时异常。</li><li>典型的<code>RuntimeException</code>包括<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> <code>InterrupterException</code>等。</li><li>典型的非<code>RuntimeException</code>包括<code>IOException</code>、<code>SQLException</code>等。</li></ul></li></ul></li></ul><h2 id="2-Java中如何处理异常？"><a href="#2-Java中如何处理异常？" class="headerlink" title="2. Java中如何处理异常？"></a>2. Java中如何处理异常？</h2><ul><li>在Java中如果需要处理异常，必须先对异常进行捕获，然后再对异常情况进行处理。如何对可能发生异常的代码进行异常捕获和处理呢？使用try和catch关键字即可，如下面一段代码所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">  <span class="keyword">if</span>(!file.exists())</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(被try块包围的代码说明这段代码可能会发生异常，一旦发生异常，异常便会被catch捕获到，然后需要在catch块中进行异常处理。)</p><ul><li>在Java中还提供了另一种异常处理方式即抛出异常，顾名思义，也就是说一旦发生异常，我把这个异常抛出去，让调用者去进行处理，自己不进行具体的处理，此时需要用到throw和throws关键字。　</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            createFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><ul><li>这段代码和上面一段代码的区别是，在实际的createFile方法中并没有捕获异常，而是用throws关键字声明抛出异常，</li><li>即告知这个方法的调用者此方法可能会抛出<code>IOException</code>。那么在main方法中调用<code>createFile</code>方法的时候，采用try…catch块进行了异常捕获处理。</li></ul><ul><li>当然还可以采用throw关键字手动来抛出异常对象。下面看一个例子：然后在catch块中进行捕获。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            System.out.println(getDataByIndex(-<span class="number">1</span>,data));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDataByIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组下标越界"</span>);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>也就说在Java中进行异常处理的话，对于可能会发生异常的代码，可以选择三种方法来进行异常处理：<ul><li>对代码块用<code>try..catch</code>进行异常捕获处理；</li><li>在 该代码的方法体外用<strong>throws进行抛出声明</strong>，告知此方法的调用者这段代码可能会出现这些异常，你需要谨慎处理。<ul><li>如果声明抛出的异常是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。</li><li>如果声明抛出的异常是运行时异常，此方法的调用者可以选择地进行异常捕获处理。</li></ul></li><li>在代码块用throw手动抛出一个异常对象，此时也有两种情况，<strong>跟throw中的类似</strong>：<ul><li>如果抛出的异常对象是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。</li><li>如果抛出的异常对象是运行时异常，此方法的调用者可以选择地进行异常捕获处理。</li></ul></li></ul></li></ul><ul><li>如果最终将异常抛给<code>main</code>方法，则相当于交给<code>jvm</code>自动处理，此时<code>jvm</code>会简单地打印异常信息）<strong>同时是中断处理</strong></li></ul><p><strong>未完待续：</strong></p><p><strong>参考博客 ：</strong> <a href="https://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3769804.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-异常&quot;&gt;&lt;a href=&quot;#Java-基础-异常&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-异常&quot;&gt;&lt;/a&gt;Java-基础-异常&lt;/h1&gt;&lt;h2 id=&quot;1-什么是异常？&quot;&gt;&lt;a href=&quot;#1-什么是异常？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是异常？&quot;&gt;&lt;/a&gt;1. 什么是异常？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用&lt;strong&gt;空的引用&lt;/strong&gt;、&lt;strong&gt;数组下标越界&lt;/strong&gt;、&lt;strong&gt;内存溢出错误&lt;/strong&gt;等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果&lt;/strong&gt;。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，&lt;strong&gt;通过异常机制来处理程序运行期间出现的错误&lt;/strong&gt;。通过异常机制，我们可以更好地提升程序的健壮性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。java中的处理就是中断处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　&lt;strong&gt;在Java中，异常类的结构层次图如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/145710336.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="异常总结" scheme="http://zhuuu.work/tags/%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-15-Mysql死锁</title>
    <link href="http://zhuuu.work/2020/09/07/Mysql/Mysql-15-Mysql%E6%AD%BB%E9%94%81/"/>
    <id>http://zhuuu.work/2020/09/07/Mysql/Mysql-15-Mysql%E6%AD%BB%E9%94%81/</id>
    <published>2020-09-07T08:02:27.000Z</published>
    <updated>2020-09-18T11:06:15.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-15-Mysql死锁"><a href="#Mysql-15-Mysql死锁" class="headerlink" title="Mysql-15-Mysql死锁"></a>Mysql-15-Mysql死锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。</p></li><li><p><code>InnoDB</code>引擎提供了行级锁，表锁。<code>MyISAM</code>提供了表锁，如题，MySQL会发生死锁吗？</p></li></ul><a id="more"></a><h2 id="1-案例一"><a href="#1-案例一" class="headerlink" title="1. 案例一"></a>1. 案例一</h2><ul><li>在InnoDB引擎下，<code>RR(REPEATABLE-READ)</code>级别，如果多个事务争抢同一个资源，会发生死锁。在RR级别下，MySQL提供了next-key lock。假如一个索引的行有<code>10,11,13,20</code></li><li>那么可能的<code>next-key lock</code>的包括</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(无穷小, 10]</span><br><span class="line">(10,11]</span><br><span class="line">(11,13]</span><br><span class="line">(13,20]</span><br><span class="line">(20, 无穷大)</span><br></pre></td></tr></table></figure><ul><li>即：当你查询12时，如果数据未查到，那么将对(12,13]范围内的数据进行锁定。<code>next-key lock</code>的定义可以到官方具体查看，这里做个演示。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174336612.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看隔离级别，</span><br><span class="line">show variables like &#39;%tx_isolation%&#39;;</span><br><span class="line">&#x2F;&#x2F; 设置隔离界别</span><br><span class="line">SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br><span class="line">&#x2F;&#x2F; 不设置自动提交</span><br><span class="line">SET autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><ol><li>首先将隔离级别都设置为RR级别的，并且不让事务自动提交</li><li>根据上面的数据，在事务1中查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 得到空结果集，此时锁定的范围是(33,100]</span><br><span class="line">select * FROM user where id&#x3D;33 for update;</span><br></pre></td></tr></table></figure><ol start="3"><li>在事务2中也进行查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询到空的结果，在事务2中锁定的范围是(34,100]</span><br><span class="line">select * FROM user where id&#x3D;34 for update</span><br></pre></td></tr></table></figure><ol start="4"><li>在事务1中插入数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 虽然事务1锁定了范围，事务2也锁定了范围</span><br><span class="line">insert into user values(35,&#39;ac&#39;,10);</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174511421.png" alt="mark"></p><ol start="5"><li>在事务2中也插入数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into user values(34,&#39;ac&#39;,10)</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174533500.png" alt="mark"></p><p><strong>解决方案</strong></p><ol><li><strong>设置死锁的超时时长</strong></li></ol><p><code>innodb_lock_wait_timeout=500</code></p><ol start="2"><li><strong>查询到当前正在锁定的事务线程，将其杀死</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以看到正在运行的事务线程，还有运行状态</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;trx_mysql_thread_id为上一条命令获取的结果，将具体的数字替换一下即可。</span><br><span class="line">kill trx_mysql_thread_id</span><br></pre></td></tr></table></figure><h2 id="2-案例二"><a href="#2-案例二" class="headerlink" title="2. 案例二"></a>2. 案例二</h2><ul><li><strong>索引不当导致全表扫描</strong></li></ul><ol><li>如果在事务中执行了一条不满足条件的语句，执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。</li><li>类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。</li></ol><p><strong>解决方案</strong></p><ul><li>SQL语句中不要使用太复杂的关联多表的查询；</li><li>使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-15-Mysql死锁&quot;&gt;&lt;a href=&quot;#Mysql-15-Mysql死锁&quot; class=&quot;headerlink&quot; title=&quot;Mysql-15-Mysql死锁&quot;&gt;&lt;/a&gt;Mysql-15-Mysql死锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;引擎提供了行级锁，表锁。&lt;code&gt;MyISAM&lt;/code&gt;提供了表锁，如题，MySQL会发生死锁吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis-13-跳表</title>
    <link href="http://zhuuu.work/2020/09/06/Redis/Redis-13-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/09/06/Redis/Redis-13-%E8%B7%B3%E8%A1%A8/</id>
    <published>2020-09-06T10:32:24.000Z</published>
    <updated>2020-09-10T09:23:53.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-13-跳表"><a href="#Redis-13-跳表" class="headerlink" title="Redis-13-跳表"></a>Redis-13-跳表</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先为什么要把mysql索引和redis跳表放在一起讨论呢，因为他们解决的都是同一种问题，用于<strong>解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置（或者对应的value）</strong></li></ul><a id="more"></a><p>现在我们将问题领域边界划分清楚了，就是为了解决数据集合的查找问题。这一块需要考虑哪些问题呢</p><ol><li>需要支持哪些查找方式，单key/多key/范围查找，</li><li>插入/删除效率</li><li>查找效率（即时间复杂度）</li><li>存储大小（空间复杂度）</li></ol><ul><li>我们看下<strong>几种常用的查找结构</strong></li></ul><ol><li><strong>Hash : hash是key,value形式，通过一个散列函数，能够根据key快速找到value</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200807-154119174.png" alt="mark"></p><ol start="2"><li><strong>B+树</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200807-154302337.png" alt="mark"></p><ul><li>B+树首先是有序结构，为了不至于树的高度太高，影响查找效率，在叶子节点上存储的不是单个数据，而是一页数据，提高了查找效率，而为了更好的支持范围查询，B+树在叶子节点冗余了非叶子节点数据，为了支持翻页，叶子节点之间通过指针连接。</li></ul><p><strong>跳表</strong></p><ul><li><strong>跳表是在链表的基础上进行扩展的，为的是实现redis的sorted set数据结构。（Zset）</strong></li><li>level0: 是存储原始数据的，是一个有序链表，每个节点都在链上</li><li>每个节点都在链上 level0+: 通过指针串联起节点，是原始数据的一个子集，level等级越高，串联的数据越少，这样可以显著提高查找效率，</li></ul><p><strong>总结：</strong></p><table><thead><tr><th>数据结构</th><th>实现原理</th><th>key查询方式</th><th>查找效率</th><th>存储大小</th><th>插入、删除效率</th></tr></thead><tbody><tr><td>Hash</td><td>哈希表</td><td>支持单key</td><td>接近O(1)</td><td>小，除了数据没有额外的存储</td><td>O(1)</td></tr><tr><td>B+树</td><td>平衡二叉树扩展而来</td><td>单key,范围，分页</td><td>O(Log(n)</td><td>除了数据，还多了左右指针，以及叶子节点指针</td><td>O(Log(n)，需要调整树的结构，算法比较复杂</td></tr><tr><td>跳表</td><td>有序链表扩展而来</td><td>单key，分页</td><td>O(Log(n)</td><td>除了数据，还多了指针，但是每个节点的指针小于&lt;2,所以比B+树占用空间小</td><td>O(Log(n)，只用处理链表，算法比较简单</td></tr></tbody></table><h2 id="1-Zset-原理分析"><a href="#1-Zset-原理分析" class="headerlink" title="1. Zset 原理分析"></a>1. Zset 原理分析</h2><h3 id="1-1-Zset编码的选择"><a href="#1-1-Zset编码的选择" class="headerlink" title="1.1 Zset编码的选择"></a>1.1 Zset编码的选择</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165054478.png" alt="mark"></p><p><strong>1.有序集合对象的编码可以是<code>ziplist</code>或者<code>skiplist</code>。同时满足以下条件时使用ziplist编码：</strong></p><ul><li><p>元素数量小于128个</p></li><li><p>所有member的长度都小于64字节</p></li><li><p>其他：</p></li><li><ul><li>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改</li><li>对于一个 <code>REDIS_ENCODING_ZIPLIST</code> 编码的 Zset， 只要满足以上任一条件， 则会被转换为 <code>REDIS_ENCODING_SKIPLIST</code> 编码</li></ul></li></ul><p><strong>2.zset操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</span><br><span class="line">zrem(key, member) ：删除名称为key的zset中的元素member</span><br><span class="line">zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</span><br><span class="line">zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</span><br><span class="line">zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</span><br><span class="line">zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</span><br><span class="line">zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素</span><br><span class="line">zrangebyscore(key, min, max)：返回名称为key的zset中score &gt;= min且score &lt;= max的所有元素 zcard(key)：返回名称为key的zset的基数</span><br><span class="line">zscore(key, element)：返回名称为key的zset中元素element的score zremrangebyrank(key, min, max)：删除名称为key的zset中rank &gt;= min且rank &lt;= max的所有元素 zremrangebyscore(key, min, max) ：删除名称为key的zset中score &gt;= min且score &lt;= max的所有元素</span><br></pre></td></tr></table></figure><h2 id="2-ziplist"><a href="#2-ziplist" class="headerlink" title="2. ziplist"></a>2. ziplist</h2><ul><li>ziplist 编码的 Zset 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。</li><li>ziplist 内的集合元素按 score 从小到大排序，其实质是一个双向链表。虽然元素是按 <code>score</code> 有序排序的， 但对 <code>ziplist</code> 的节点指针只能线性地移动，所以在 <code>REDIS_ENCODING_ZIPLIST</code> 编码的 Zset 中， 查找某个给定元素的复杂度为 O(n)</li></ul><p><strong>如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;操作</span><br><span class="line">ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储顺序</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165634662.png" alt="mark"></p><p><strong>3. 从以上的布局中，我们可以看到ziplist内存数据结构，由如下5部分构成：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165706567.png" alt="mark"></p><p>各个部分在内存上是前后相邻的并连续的，每一部分作用如下：</p><ul><li><p>zlbytes： 存储一个无符号整数，固定四个字节长度（32bit），用于存储压缩列表所占用的字节（也包括<zlbytes>本身占用的4个字节），当重新分配内存的时候使用，不需要遍历整个列表来计算内存大小。</p></li><li><p>zltail： 存储一个无符号整数，固定四个字节长度（32bit），表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。<zltail>的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。</p></li><li><p>zllen： 压缩列表包含的节点个数，固定两个字节长度（16bit）， 表示ziplist中数据项（entry）的个数。由于zllen字段只有16bit，所以可以表达的最大值为2^16-1。</p><p>注意点：如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以表示。ziplist是如何做到的？</p><p>如果<zllen>小于等于2^16-2（也就是不等于2^16-1），那么<zllen>就表示ziplist中数据项的个数；否则，也就是<zllen>等于16bit全为1的情况，那么<zllen>就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。</p></li><li><p>entry，表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。</p></li><li><p>zlend， ziplist最后1个字节，值固定等于255，其是一个结束标记。</p></li></ul><h2 id="3-skiplist"><a href="#3-skiplist" class="headerlink" title="3. skiplist"></a>3. skiplist</h2><ul><li><p>skiplist 编码的 Zset 底层为一个被称为 zset 的结构体，这个结构体中包含一个字典和一个跳跃表。跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 </p><p>O(logN)，最坏 O(N)</p></li><li><p><em>字典则保存着从 member 到 score 的映射，这样就可以用 O(1)的复杂度来查找 member 对应的 score 值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。</em></p></li></ul><p><strong>详细解析</strong></p><ul><li>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。</li><li>简单说来<strong>跳表也是链表</strong>的一种，只不过它在<strong>链表的基础上增加了跳跃功能</strong>，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。</li></ul><p>先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170230031.png" alt="mark"></p><p>在这样一个链表中，如果我们要<strong>查找某个数据，那么需要从头开始逐个进行比较**</strong>，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，<strong>时间复杂度为O(n)。</strong>同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170358081.png" alt="mark"></p><ul><li>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。</li><li>现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。</li><li>当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170518070.png" alt="mark"></p><ol><li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li><li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li><li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li></ol><p><strong>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</strong></p><p><strong>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170624567.png" alt="mark"></p><ul><li>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，</li><li>接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。</li><li>可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</li></ul><h3 id="3-1-小结"><a href="#3-1-小结" class="headerlink" title="3.1 小结"></a>3.1 小结</h3><ul><li><code>skiplist</code>正是受这种多层链表的想法的启发而设计出来的。<strong>实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找</strong>，使得查找的时间复杂度可以降低到O(log n)。</li><li>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。</li><li>如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</li></ul><p><strong>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。</strong>比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/171220254.png" alt="mark"></p><ul><li>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。</li><li>因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。</li><li><strong>实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案</strong>。这在后面我们还会提到。</li></ul><p><strong>总结：</strong></p><ul><li><strong>skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。</strong></li><li><strong>这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。</strong></li></ul><h3 id="3-2-举个例子"><a href="#3-2-举个例子" class="headerlink" title="3.2 举个例子"></a>3.2 举个例子</h3><ul><li>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/171415212.png" alt="mark"></p><ul><li><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p></li><li><p>实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key(score)进行排序的，查找过程也是根据key在比较。</p></li></ul><ul><li>执行<strong>插入操作时计算随机数</strong>的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：<ul><li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li><li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li><li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li></ul></li><li>这个随机数伪码如下：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">level := 1</span><br><span class="line">// random()返回一个[0...1)的随机数</span><br><span class="line"><span class="keyword">while</span> random() &lt; p and level &lt; MaxLevel <span class="keyword">do</span></span><br><span class="line">level := level + 1</span><br><span class="line"><span class="built_in">return</span> leve</span><br><span class="line">    </span><br><span class="line"><span class="comment">## randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：  </span></span><br><span class="line">p = 1/4</span><br><span class="line">MaxLevel = 32</span><br></pre></td></tr></table></figure><h2 id="4-skiplist与平衡树、哈希表的比较"><a href="#4-skiplist与平衡树、哈希表的比较" class="headerlink" title="4. skiplist与平衡树、哈希表的比较"></a>4. skiplist与平衡树、哈希表的比较</h2><ul><li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p></li><li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p></li><li><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p></li><li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p></li><li><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p></li><li><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></li></ul><h2 id="5-Redis中skiplist的实现"><a href="#5-Redis中skiplist的实现" class="headerlink" title="5. Redis中skiplist的实现"></a>5. Redis中skiplist的实现</h2><p>skiplist的数据结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">robj *obj;</span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">&#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p> 简单分析一下几个查询命令:</p><ul><li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li><li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li><li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li><li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key，数据相当于value）。</li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li>当数据较少时，sorted set是由一个ziplist来实现的。</li><li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li></ul><p>看一下sorted set与skiplist的关系，：</p><ul><li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。</li><li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。</li><li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li><li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li></ul><p><strong>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</strong></p><ul><li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li><li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li><li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li></ul><h2 id="6-Redis为什么用skiplist而不用平衡树？"><a href="#6-Redis为什么用skiplist而不用平衡树？" class="headerlink" title="6. Redis为什么用skiplist而不用平衡树？"></a>6. Redis为什么用skiplist而不用平衡树？</h2><p><strong>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因。</strong></p><p><strong>原因一</strong></p><p><code>There are a few reasons:</code></p><p>1) <code>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</code><br><strong>1) 也不是非常耗费内存，实际上取决于生成层数函数里的概率 p，取决得当的话其实和平衡树差不多。</strong></p><p><strong>原因二</strong></p><p>2) <code>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</code><br><strong>2) 因为有序集合经常会进行 ZRANGE 或 ZREVRANGE 这样的范围查找操作，跳表里面的双向链表可以十分方便地进行这类操作</strong></p><p><strong>原因三</strong></p><p>3) <code>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</code><br><strong>3) 实现简单，ZRANK 操作还能达到 o(logn)的时间复杂度</strong></p><p><strong>参考博客 : <a href="https://www.cnblogs.com/yuanfang0903/p/12165394.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanfang0903/p/12165394.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-13-跳表&quot;&gt;&lt;a href=&quot;#Redis-13-跳表&quot; class=&quot;headerlink&quot; title=&quot;Redis-13-跳表&quot;&gt;&lt;/a&gt;Redis-13-跳表&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先为什么要把mysql索引和redis跳表放在一起讨论呢，因为他们解决的都是同一种问题，用于&lt;strong&gt;解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置（或者对应的value）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="跳表" scheme="http://zhuuu.work/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://zhuuu.work/2020/09/05/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://zhuuu.work/2020/09/05/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-09-05T00:02:27.000Z</published>
    <updated>2020-09-20T00:56:42.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么要使用分布式锁呢？</p><p>在<code>Nginx</code>实现负载均衡服务器集群时会产生很多问题，在提高并发的同时，服务器也会产生非常多的问题例如，这些问题应该一一的考虑到。</p><ul><li><strong>分布式Session一致性</strong></li><li><strong>分布式全局ID生成方案</strong></li><li>分布式事务解决方案</li><li>分布式任务调度平台</li><li>分布式配置中心</li><li><strong>分布式锁多种实现方案</strong></li><li>分布式日志收集系统</li><li>各种网站跨域请求解决方案</li><li>高并发下服务降级与限流实战</li><li>……</li></ul><p>本次就先以分布式锁来探讨一下分布式场景下的使用与注意事项，和为什么要使用分布式锁。</p><a id="more"></a><ul><li><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。<strong>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）</strong></p></li><li><p><strong>最多只能同时满足两项</strong>。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都<strong>需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</strong></p></li><li><p>在很多场景中，我们为了<strong>保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等</strong>。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行</p></li><li><p>在单机环境中，<code>Java</code>中其实提供了很多并发处理相关的<code>API</code>，但是这些API在分布式场景中就无能为力了。也就是说单纯的<code>Java Api</code>并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案。</p></li></ul><h2 id="为什么要使用分布式锁？"><a href="#为什么要使用分布式锁？" class="headerlink" title="为什么要使用分布式锁？"></a>为什么要使用分布式锁？</h2><ul><li>原因：采用了集群的部署方案</li></ul><p><strong>如何在单台机器上生成唯一的订单号</strong></p><ul><li>UUID、时间戳、redis等。。。</li></ul><p>其实有一种取巧的解决方案，可以适当的避免突然的高并发下的服务宕机（或反应慢）的尴尬场景。</p><ul><li><strong>可以使用<code>redis</code>提前生成150W订单号（假设是在下单场景下）</strong><ul><li>提前生成好150W订单号，存放在<code>redis</code>中，当客户端下单之后，直接到<code>redis</code>中取对应的订单号即可，</li><li>因为<code>redis</code>本身是单线程的，如果<code>redis</code>还只剩下50W个订单号的时候，在继续生产100W个订单号。（这种技巧视业务场景而定，一般我们在面对需求或者发生的问题时，可以从根源下手，这种情况明显就是针对在高并发场景下能一定程度的提高程序的响应速度。提高了整个程序的健壮性。）</li></ul></li></ul><p><strong>那么如果在集群环境下使用<code>UUID</code>的方式安全嘛？</strong></p><ul><li><p>答案是肯定的，<strong>肯定是不安全的</strong>，大概率是会出现重复的<code>ID</code>的。所以<strong>这个时候就提出了分布式锁。</strong></p></li><li><p>可想而知，在多线程下我们可以简单的使用<code>Lock</code>或者<code>synchronized</code>来实现安全性，但是在分布式场景下，这些就显得力不从心了。因为这个时候在微服务场景下，很有可能同一个服务分别安装在不同的服务器上，这样的话，传统的加锁方式根本不可能保证数据的最终一致性。所以分布式锁就诞生了。</p></li></ul><p>针对分布式锁的实现，目前比较常用的有以下几种方案：</p><ul><li><strong>基于数据库实现分布式锁</strong></li><li><strong>基于缓存（redis，memcached，tair）实现分布式锁</strong></li><li><strong>基于Zookeeper实现分布式锁</strong></li></ul><p>在分析这几种实现方案之前我们先来想一下，我们需要的分布式锁应该是怎么样的？（这里以方法锁为例，资源锁同理）</p><ul><li>可以保证在分布式部署的应用集群中，<strong>同一个方法在同一时间只能被一台机器上的一个线程执行</strong>。</li><li>有<strong>高可用的获取锁和释放锁功能</strong></li><li>获取锁和释放锁的性能要好</li><li>这把锁要是一把<strong>可重入锁</strong>（避免死锁）</li><li>这把锁<strong>最好是一把阻塞锁（</strong>根据业务需求考虑要不要这条）</li></ul><h2 id="1-基于数据库实现分布式锁"><a href="#1-基于数据库实现分布式锁" class="headerlink" title="1. 基于数据库实现分布式锁"></a>1. 基于数据库实现分布式锁</h2><h3 id="1-1-基于数据表"><a href="#1-1-基于数据表" class="headerlink" title="1.1 基于数据表"></a>1.1 基于数据表</h3><ul><li>要实现分布式锁，最简单的方式可能就是直接<strong>创建一张锁表</strong>，然后通过操作该表中的数据来实现了。</li><li><strong>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，</strong></li><li><strong>想要释放锁的时候就删除这条记录。</strong></li></ul><p>创建这样一张数据库表：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091537484.png" alt="mark"></p><p>当我们想要锁住某个方法时，执行以下SQL：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091612208.png" alt="mark"></p><p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091905207.png" alt="mark"></p><ul><li><p>上面这种简单的实现有以下几个问题：</p><ul><li>这把锁强<strong>依赖数据库的可用性</strong>，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把<strong>锁没有失效时间</strong>，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把<strong>锁是非重入的</strong>，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li><li>这把锁<strong>只能是非阻塞的</strong>，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li></ul></li><li><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul></li></ul><h3 id="1-2-基于数据库的排他锁"><a href="#1-2-基于数据库的排他锁" class="headerlink" title="1.2 基于数据库的排他锁"></a>1.2 基于数据库的排他锁</h3><ul><li>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</li><li>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于<code>MySql</code>的<code>InnoDB</code>引擎，可以使用以下方法来实现加锁操作：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-092752416.png" alt="mark"></p><ul><li>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁</li><li>这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。</li><li>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</li></ul><p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-092938397.png" alt="mark"></p><p>通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p><strong>问题：</strong></p><ul><li>但是还是无法直接解决数据库单点和可重入问题。</li><li>这里还可能存在另外一个问题，虽然我们对<code>method_name</code> 使用了唯一索引，并且显示使用<code>for update</code>来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</li><li>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</li></ul><p><strong>总结</strong>：</p><ul><li>这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</li></ul><h3 id="1-3-乐观锁"><a href="#1-3-乐观锁" class="headerlink" title="1.3 乐观锁"></a>1.3 乐观锁</h3><ul><li>乐观锁假设认为数据一般情况下不会造成冲突，<strong>只有在进行数据的提交更新时</strong>，才会检测数据的冲突情况，如果发现冲突了，则返回错误信息</li></ul><p>实现方式：</p><ul><li><p><strong>时间戳</strong>（timestamp）记录机制实现：<strong>给数据库表增加一个时间戳字段类型的字段</strong>，当读取数据时，将<code>timestamp</code>字段的值一同读出，数据每更新一次，<strong>timestamp也同步更新</strong></p></li><li><p>当对数据做提交更新操作时，检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，若相等，则更新，否则认为是失效数据。</p></li><li><p><strong>同样也可以使用version的方式</strong></p></li></ul><p>性能对比</p><p>（1） 悲观锁实现方式是独占数据，其它线程需要等待，不会出现修改的冲突，能够保证数据的一致性，但是依赖数据库的实现，且在线程较多时出现等待造成效率降低的问题。一般情况下，对于数据很敏感且读取频率较低的场景，可以采用悲观锁的方式</p><p>（2） 乐观锁可以多线程同时读取数据，若出现冲突，也可以依赖上层逻辑修改，能够保证高并发下的读取，适用于读取频率很高而修改频率较少的场景</p><p>（3） 由于库存回写数据属于敏感数据且读取频率适中，所以建议使用悲观锁优化</p><h2 id="2-基于Redis来实现分布式锁"><a href="#2-基于Redis来实现分布式锁" class="headerlink" title="2. 基于Redis来实现分布式锁"></a>2. 基于Redis来实现分布式锁</h2><ul><li>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。</li></ul><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li><strong>互斥性。在任意时刻，只有一个客户端能持有锁。</strong></li><li><strong>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</strong></li><li><strong>具有容错性。只要大部分的<code>redis</code>节点正常运行，客户端就可以加锁和解锁。</strong></li><li><strong>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</strong></li></ol><p>可以看到，我们加锁就一行代码：<strong>jedis.set(String key, String value, String nxxx, String expx, int time)</strong>，这个set()方法一共有五个形参：</p><p>可以看到，我们加锁就一行代码：<strong>jedis.set(String key, String value, String nxxx, String expx, int time)</strong>，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是<code>requestId</code>，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li><li>第三个为<code>nxxx</code>，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为<code>expx</code>，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为<code>time</code>，与第四个参数相呼应，代表key的过期时间。</li></ul><p><strong>总的来说</strong></p><ul><li>执行上面的set() 方法就会导致两种结果<ul><li>当前没有锁（key不存在），那么就进行加锁的操作，并对锁设置有效期，同时<code>value</code>表示加锁的客户端</li><li>已有锁存在，不做任何操作。</li></ul></li></ul><ul><li><strong>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性</strong></li><li><strong>其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</strong></li><li><strong>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</strong></li></ul><p><strong>解锁操作：</strong></p><ul><li>首先获取锁对应的value值，检查是否与<code>requestId</code>相等，如果相等则删除锁（解锁）</li></ul><p><strong>总结：</strong></p><ul><li><p>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，</p></li><li><p>同时，很多缓存服务都是<strong>集群部署</strong>的，可以避免单点问题。</p></li><li><p>并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如<code>redis</code>的<code>setnx</code>方法等。</p></li><li><p>并且，这些缓存服务也都提供了<strong>对数据的过期自动删除的支持</strong>，可以直接设置超时时间来控制锁的释放。</p></li></ul><h2 id="3-基于Zookeeper-实现分布式锁"><a href="#3-基于Zookeeper-实现分布式锁" class="headerlink" title="3. 基于Zookeeper 实现分布式锁"></a>3. 基于Zookeeper 实现分布式锁</h2><ul><li>基于<code>zookeeper</code><strong>临时有序节点</strong>可以实现的分布式锁。</li><li><strong>大致思想</strong><ul><li>每个客户端对某个方法加锁时，在<code>zookeeper</code>上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。</li><li><strong>判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。</strong></li><li><strong>当释放锁的时候，只需将这个瞬时节点删除即可。</strong></li><li>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</li></ul></li></ul><p>来看下Zookeeper能不能解决前面提到的问题。</p><ul><li><p><strong>锁无法释放？</strong>使用<code>Zookeeper</code>可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p></li><li><p><strong>非阻塞锁？</strong>  使用<code>Zookeeper</code>可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，<code>Zookeeper</code>会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p></li><li><p><strong>不可重入？</strong>使用<code>Zookeeper</code>也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p></li><li><p><strong>单点问题？</strong>使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p></li></ul><p>可以直接使用zookeeper第三方库<a href="https://curator.apache.org/" target="_blank" rel="noopener">Curator</a>客户端，这个客户端中封装了一个可重入的锁服务。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-094429707.png" alt="mark"></p><ul><li>Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。</li><li>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。</li><li>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。</li></ul><p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。</p><p>这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p><p><strong>总结</strong></p><ul><li><p>使用Zookeeper实现分布式锁的优点</p></li><li><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p></li><li><p>使用Zookeeper实现分布式锁的缺点</p></li><li><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p></li></ul><h2 id="4-三种方案的比较"><a href="#4-三种方案的比较" class="headerlink" title="4. 三种方案的比较"></a>4. 三种方案的比较</h2><p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><h4 id="从理解的难易程度角度（从低到高）"><a href="#从理解的难易程度角度（从低到高）" class="headerlink" title="从理解的难易程度角度（从低到高）"></a>从理解的难易程度角度（从低到高）</h4><p>数据库 &gt; 缓存 &gt; Zookeeper</p><h4 id="从实现的复杂性角度（从低到高）"><a href="#从实现的复杂性角度（从低到高）" class="headerlink" title="从实现的复杂性角度（从低到高）"></a>从实现的复杂性角度（从低到高）</h4><p>Zookeeper &gt;= 缓存 &gt; 数据库</p><h4 id="从性能角度（从高到低）"><a href="#从性能角度（从高到低）" class="headerlink" title="从性能角度（从高到低）"></a>从性能角度（从高到低）</h4><p>缓存 &gt; Zookeeper &gt;= 数据库</p><h4 id="从可靠性角度（从高到低）"><a href="#从可靠性角度（从高到低）" class="headerlink" title="从可靠性角度（从高到低）"></a>从可靠性角度（从高到低）</h4><p>Zookeeper &gt; 缓存 &gt; 数据库</p><p><strong>参考博客：</strong> <a href="https://www.jianshu.com/p/a44c1c47bcee" target="_blank" rel="noopener">https://www.jianshu.com/p/a44c1c47bcee</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为什么要使用分布式锁呢？&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Nginx&lt;/code&gt;实现负载均衡服务器集群时会产生很多问题，在提高并发的同时，服务器也会产生非常多的问题例如，这些问题应该一一的考虑到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式Session一致性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式全局ID生成方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分布式事务解决方案&lt;/li&gt;
&lt;li&gt;分布式任务调度平台&lt;/li&gt;
&lt;li&gt;分布式配置中心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式锁多种实现方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分布式日志收集系统&lt;/li&gt;
&lt;li&gt;各种网站跨域请求解决方案&lt;/li&gt;
&lt;li&gt;高并发下服务降级与限流实战&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次就先以分布式锁来探讨一下分布式场景下的使用与注意事项，和为什么要使用分布式锁。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式锁" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-14-MVCC实现</title>
    <link href="http://zhuuu.work/2020/09/04/Mysql/Mysql-14-MVCC%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhuuu.work/2020/09/04/Mysql/Mysql-14-MVCC%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-09-04T08:02:27.000Z</published>
    <updated>2020-09-21T11:02:34.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-14-MVCC实现"><a href="#Mysql-14-MVCC实现" class="headerlink" title="Mysql-14-MVCC实现"></a>Mysql-14-MVCC实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>MVCC (Multiversion Concurrency Control)</code> 中文叫<strong>多版本并发控制</strong>，是现代数据库（包括 <code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code> 等）引擎实现中常用的处理读写冲突的手段，<strong>目的在于提高数据库高并发场景下的吞吐性能</strong>。</li><li>如此一来不同的事务在并发过程中，<code>SELECT</code> 操作可以不加锁而是通过 <code>MVCC</code> 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。</li></ul><p>下面举一个多版本读的例子，例如两个事务 <code>A</code> 和 <code>B</code> 按照如下顺序进行更新和读取操作</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/164638522.png" alt="mark"></p><a id="more"></a><p>在事务 <code>A</code> 提交前后，事务 <code>B</code> 读取到的 <code>x</code> 的值是什么呢？答案是：事务 <code>B</code> 在不同的隔离级别下，读取到的值不一样。</p><ol><li>如果事务 <code>B</code> 的隔离级别是<strong>读未提交（RU）</strong>，那么两次读取均读取到 <code>x</code> 的最新值，即 <code>20</code>。</li><li>如果事务 <code>B</code> 的隔离级别是<strong>读已提交（RC）</strong>，那么第一次读取到旧值 <code>10</code>，第二次因为事务 <code>A</code> 已经提交，则读取到新值 20。</li><li>如果事务 <code>B</code> 的隔离级别是可重复读或者串行（RR，S），则两次均读到旧值 <code>10</code>，不论事务 <code>A</code> 是否已经提交。</li></ol><p>可见在不同的隔离级别下，数据库通过 <code>MVCC</code> 和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性。</p><h2 id="1-为什么需要MVCC"><a href="#1-为什么需要MVCC" class="headerlink" title="1. 为什么需要MVCC ?"></a>1. 为什么需要MVCC ?</h2><ul><li><code>InnoDB</code> 相比 <code>MyISAM</code> 有两大特点，一是支持事务 二是支持行级锁，事务的引入带来了一些新的挑战。相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况：<ul><li><strong>更新丢失（<code>Lost Update</code>）</strong>：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。如何避免这个问题呢，最好在一个事务对数据进行更改但还未提交时，其他事务不能访问修改同一个数据。</li><li><strong>脏读</strong>（<code>Dirty Reads</code>）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些尚未提交的脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做 <strong>“脏读”</strong>。</li><li><strong>不可重复读</strong>（<code>Non-Repeatable Reads</code>）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li><li><strong>幻读（<code>Phantom Reads</code>）</strong>：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为 <strong>“幻读”</strong>。</li></ul></li></ul><p>以上是并发事务过程中会存在的问题，解决更新丢失可以交给应用，但是后三者需要数据库提供事务间的隔离机制来解决。实现隔离机制的方法主要有两种：</p><ol><li><strong>加读写锁</strong></li><li><strong>一致性快照读，即 <code>MVCC</code></strong></li></ol><h2 id="2-InnoDB-中的-MVCC"><a href="#2-InnoDB-中的-MVCC" class="headerlink" title="2. InnoDB 中的 MVCC"></a>2. <strong>InnoDB 中的 MVCC</strong></h2><ul><li>本文聚焦于 <code>MySQL</code> 中的 <code>MVCC</code> 实现，从 <code>《高性能 MySQL》</code>一书中对 <code>MVCC</code> 的介绍可知：<ul><li><code>MySQL</code> 中 <code>InnoDB</code> 引擎支持 <code>MVCC</code></li><li>应对高并发事务, <code>MVCC</code> 比单纯的加行锁更有效, 开销更小</li><li><code>MVCC</code> 在读已提交<code>（Read Committed）</code>和可重复读<code>（Repeatable Read）</code>隔离级别下起作用</li><li><code>MVCC</code> 既可以基于<strong>乐观锁</strong>又可以基于<strong>悲观锁</strong>来实现</li></ul></li></ul><h3 id="2-1-实现原理"><a href="#2-1-实现原理" class="headerlink" title="2.1 实现原理"></a>2.1 实现原理</h3><ul><li><code>InnoDB</code> 中 <code>MVCC</code> 的实现方式为：每一行记录都有两个隐藏列：<code>DATA_TRX_ID</code>、<code>DATA_ROLL_PTR</code>（如果没有主键，则还会多一个隐藏的主键列）。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/165844142.png" alt="mark"></p><ol><li><h3 id="DATA-TRX-ID"><a href="#DATA-TRX-ID" class="headerlink" title="DATA_TRX_ID"></a><strong>DATA_TRX_ID</strong></h3></li></ol><ul><li>记录最近更新这条行记录的<code>事务 ID</code>，大小为 <code>6</code> 个字节</li></ul><ol start="2"><li><h3 id="DATA-ROLL-PTR"><a href="#DATA-ROLL-PTR" class="headerlink" title="DATA_ROLL_PTR"></a><strong>DATA_ROLL_PTR</strong></h3></li></ol><ul><li>表示指向该行回滚段<code>（rollback segment）</code>的指针，大小为 <code>7</code> 个字节</li><li><code>InnoDB</code> 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 <code>undo</code> 中都通过链表的形式组织。</li></ul><ol start="3"><li><h3 id="DB-ROW-ID"><a href="#DB-ROW-ID" class="headerlink" title="DB_ROW_ID"></a><strong>DB_ROW_ID</strong></h3></li></ol><ul><li>行标识（隐藏单调自增 <code>ID</code>），大小为 <code>6</code> 字节，如果表没有主键，<code>InnoDB</code> 会自动生成一个隐藏主键，因此会出现这个列。</li><li>另外，每条记录的头信息（<code>record header</code>）里都有一个专门的 <code>bit</code>（<code>deleted_flag</code>）来表示当前记录是否已经被删除。</li></ul><h3 id="2-2-Undo-Log-链"><a href="#2-2-Undo-Log-链" class="headerlink" title="2.2 Undo Log 链"></a>2.2 Undo Log 链</h3><p><strong>Undo Log 概念</strong></p><ul><li>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。</li></ul><p><strong>Undo log 的用途</strong></p><p>（1）保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p><p>（2）用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p><ul><li>上文提到，在多个事务并行操作某行数据的情况下，不同事务对该行数据的 UPDATE 会产生多个版本，然后通过回滚指针组织成一条 <code>Undo Log</code> 链</li><li>这节我们通过一个简单的例子来看一下 <code>Undo Log</code> 链是如何组织的，<code>DATA_TRX_ID</code> 和 <code>DATA_ROLL_PTR</code> 两个参数在其中又起到什么样的作用。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/170245411.png" alt="mark"></p><p>事务 <code>A</code> 的操作过程为：</p><ul><li>对 <code>DB_ROW_ID = 1</code> 的这行记录加排他锁</li><li>把该行原本的值拷贝到 <code>undo log</code> 中，<code>DB_TRX_ID</code> 和 <code>DB_ROLL_PTR</code> 都不动</li><li>修改该行的值这时产生一个新版本，更新 <code>DATA_TRX_ID</code> 为修改记录的事务 <code>ID</code> ,将 <code>DATA_ROLL_PTR</code> 指向刚刚拷贝到 <code>undo log</code> 链中的旧版本记录，这样就能通过 <code>DB_ROLL_PTR</code> 找到这条记录的历史版本。</li><li>如果对同一行记录执行连续的 <code>UPDATE</code>，<code>Undo Log</code> 会组成一个链表，遍历这个链表可以看到这条记录的变迁</li><li>记录 <code>redo log</code>，包括 <code>undo log</code> 中的修改</li></ul><p>那么 <code>INSERT</code> 和 <code>DELETE</code> 会怎么做呢？</p><ul><li>其实相比 <code>UPDATE</code> 这二者很简单，</li><li><code>INSERT</code> 会产生一条新纪录，它的 <code>DATA_TRX_ID</code> 为当前插入记录的事务 <code>ID</code>；</li><li><code>DELETE</code> 某条记录时可看成是一种特殊的 <code>UPDATE</code>，其实是软删，真正执行删除操作会在 <code>commit</code> 时，<code>DATA_TRX_ID</code> 则记录下删除该记录的事务 <code>ID</code>。</li></ul><h3 id="2-3-一致性读"><a href="#2-3-一致性读" class="headerlink" title="2.3 一致性读"></a>2.3 一致性读</h3><ul><li>在 <code>RU</code> 隔离级别下，直接读取版本的最新记录就 OK，对于 <code>SERIALIZABLE</code> 隔离级别，则是通过加锁互斥来访问数据，因此不需要 <code>MVCC</code> 的帮助。</li><li>因此 <code>MVCC</code> 运行在 <code>RC</code> 和 <code>RR</code> 这两个隔离级别下，当 <code>InnoDB</code> 隔离级别设置为二者其一时，在 <code>SELECT</code> 数据时就会用到版本链</li></ul><blockquote><p>核心问题是版本链中哪些版本对当前事务可见？</p></blockquote><p><code>InnoDB</code> 为了解决这个问题，设计了 <code>ReadView</code>（可读视图）的概念。</p><h4 id="2-3-1-RR-下的-ReadView-生成"><a href="#2-3-1-RR-下的-ReadView-生成" class="headerlink" title="2.3.1 RR 下的 ReadView 生成"></a>2.3.1 <strong>RR 下的 ReadView 生成</strong></h4><ul><li>在 <code>RR</code> 隔离级别下，每个事务 <code>touch first read</code> 时（本质上就是执行第一个 <code>SELECT</code> 语句时，后续所有的 <code>SELECT</code> 都是复用这个 <code>ReadView</code>，其它 <code>update</code>, <code>delete</code>, <code>insert</code> 语句和一致性读 <code>snapshot</code> 的建立没有关系），会将当前系统中的所有的活跃事务拷贝到一个列表生成<code>ReadView</code>。</li><li>下图中事务 <code>A</code> 第一条 <code>SELECT</code> 语句在事务 <code>B</code> 更新数据前，因此生成的 <code>ReadView</code> 在事务 <code>A</code> 过程中不发生变化，即使事务 <code>B</code> 在事务 <code>A</code> 之前提交，但是事务 <code>A</code> 第二条查询语句依旧无法读到事务 <code>B</code> 的修改。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/170739614.png" alt="mark"></p><p>下图中，事务 <code>A</code> 的第一条 <code>SELECT</code> 语句在事务 <code>B</code> 的修改提交之后，因此可以读到事务 <code>B</code> 的修改。<strong>但是注意，如果事务 <code>A</code> 的第一条 <code>SELECT</code> 语句查询时，事务 <code>B</code> 还未提交，那么事务 <code>A</code> 也查不到事务 <code>B</code> 的修改。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/172156851.png" alt="mark"></p><h4 id="2-3-2-RC-下的-ReadView-生成"><a href="#2-3-2-RC-下的-ReadView-生成" class="headerlink" title="2.3.2 RC 下的 ReadView 生成"></a>2.3.2 <strong>RC 下的 ReadView 生成</strong></h4><ul><li>在 <code>RC</code> 隔离级别下，每个 <code>SELECT</code> 语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 <code>ReadView</code>。二者的区别就在于生成 <code>ReadView</code> 的时间点不同，一个是事务之后第一个 <code>SELECT</code> 语句开始、一个是事务中每条 <code>SELECT</code> 语句开始。<ul><li>如果被访问版本的 <code>trx_id</code> 小于 <code>m_ids</code> 中的最小值 <code>up_limit_id</code>，说明生成该版本的事务在 <code>ReadView</code> 生成前就已经提交了，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 <code>trx_id</code> 大于 <code>m_ids</code> 列表中的最大值 <code>low_limit_id</code>，说明生成该版本的事务在生成 <code>ReadView</code> 后才生成，所以该版本不可以被当前事务访问。需要根据 <code>Undo Log</code> 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。</li><li>如果被访问版本的 <code>trx_id</code> 属性值在 <code>m_ids</code> 列表中最大值和最小值之间（包含），那就需要判断一下 <code>trx_id</code> 的值是不是在 <code>m_ids</code> 列表中。如果在，说明创建 <code>ReadView</code> 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 <code>DB_TRX_ID</code> 再从头计算一次可见性；如果不在，说明创建 <code>ReadView</code> 时生成该版本的事务已经被提交，该版本可以被访问。</li><li>此时经过一系列判断我们已经得到了这条记录相对 <code>ReadView</code> 来说的可见结果。此时，如果这条记录的 <code>delete_flag</code> 为 <code>true</code>，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/172304901.png" alt="mark"></p><p><strong>举个例子</strong></p><p><strong>RC 下的 MVCC 判断流程</strong></p><ul><li>我们现在回看刚刚的查询过程，为什么事务 <code>B</code> 在 <code>RC</code> 隔离级别下，两次查询的 <code>x</code> 值不同。<code>RC</code> 下 <code>ReadView</code> 是在语句粒度上生成的。</li><li>当事务 <code>A</code> 未提交时，事务 <code>B</code> 进行查询，假设事务 <code>B</code> 的事务 <code>ID</code> 为 <code>300</code>，此时生成 <code>ReadView</code> 的 <code>m_ids</code> 为 [200，300]，而最新版本的 <code>trx_id</code> 为 <code>200</code>，处于 <code>m_ids</code> 中，则该版本记录不可被访问，查询版本链得到上一条记录的 trx_id 为 <code>100</code>，小于 <code>m_ids</code> 的最小值 <code>200</code>，因此可以被访问，此时事务 <code>B</code> 就查询到值 <code>10</code> 而非 <code>20</code>。</li><li>待事务 <code>A</code> 提交之后，事务 <code>B</code> 进行查询，此时生成的 <code>ReadView</code> 的 <code>m_ids</code> 为 [300]，而最新的版本记录中 <code>trx_id</code> 为 <code>200</code>，小于 <code>m_ids</code> 的最小值 <code>300</code>，因此可以被访问到，此时事务 <code>B</code> 就查询到 <code>20</code>。</li></ul><p><strong>RR 下的 MVCC 判断流程</strong></p><ul><li>如果在 <code>RR</code> 隔离级别下，为什么事务 <code>B</code> 前后两次均查询到 <code>10</code> 呢？</li><li><code>RR</code> 下生成 <code>ReadView</code> 是在事务开始时，m_ids 为 [200,300]，后面不发生变化，</li><li>因此即使事务 <code>A</code> 提交了，<code>trx_id</code> 为 <code>200</code> 的记录依旧处于 <code>m_ids</code> 中，不能被访问，只能访问版本链中的记录 <code>10</code>。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li><code>RC</code>、<code>RR</code> 两种隔离级别的事务在执行普通的读操作时，通过访问版本链的方法，使得事务间的读写操作得以并发执行，从而提升系统性能。</li><li><code>RC</code>、<code>RR</code> 这两个隔离级别的一个很大不同就是生成 <code>ReadView</code> 的时间点不同，<code>RC</code> 在每一次 <code>SELECT</code> 语句前都会生成一个 <code>ReadView</code>，事务期间会更新，因此在其他事务提交前后所得到的 <code>m_ids</code> 列表可能发生变化，使得先前不可见的版本后续又突然可见了。</li><li>而 <code>RR</code> 只在事务的第一个 <code>SELECT</code> 语句时生成一个 <code>ReadView</code>，事务操作期间不更新。</li></ul><p>参考博客 ： <a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52977862</a></p><p>​                 <a href="https://zhuanlan.zhihu.com/p/64576887" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64576887</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-14-MVCC实现&quot;&gt;&lt;a href=&quot;#Mysql-14-MVCC实现&quot; class=&quot;headerlink&quot; title=&quot;Mysql-14-MVCC实现&quot;&gt;&lt;/a&gt;Mysql-14-MVCC实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MVCC (Multiversion Concurrency Control)&lt;/code&gt; 中文叫&lt;strong&gt;多版本并发控制&lt;/strong&gt;，是现代数据库（包括 &lt;code&gt;MySQL&lt;/code&gt;、&lt;code&gt;Oracle&lt;/code&gt;、&lt;code&gt;PostgreSQL&lt;/code&gt; 等）引擎实现中常用的处理读写冲突的手段，&lt;strong&gt;目的在于提高数据库高并发场景下的吞吐性能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如此一来不同的事务在并发过程中，&lt;code&gt;SELECT&lt;/code&gt; 操作可以不加锁而是通过 &lt;code&gt;MVCC&lt;/code&gt; 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面举一个多版本读的例子，例如两个事务 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 按照如下顺序进行更新和读取操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/164638522.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分库分表" scheme="http://zhuuu.work/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-13-分库分表</title>
    <link href="http://zhuuu.work/2020/09/03/Mysql/Mysql-13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/09/03/Mysql/Mysql-13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2020-09-03T08:02:27.000Z</published>
    <updated>2020-09-18T08:30:45.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-13-分库分表"><a href="#Mysql-13-分库分表" class="headerlink" title="Mysql-13-分库分表"></a>Mysql-13-分库分表</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>当一张表的数据达到几千万时，查询一次所花的时间会变长。业界公认MySQL单表容量在 <strong>1千万</strong> 以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。</li><li>数据切分可以分为：<code>垂直切分</code>和<code>水平切分</code>。</li></ul><a id="more"></a><h2 id="1-垂直切分"><a href="#1-垂直切分" class="headerlink" title="1. 垂直切分"></a>1. 垂直切分</h2><ul><li>垂直切分又可以分为: <code>垂直分库</code>和<code>垂直分表</code>。</li></ul><h3 id="1-1-垂直分库"><a href="#1-1-垂直分库" class="headerlink" title="1.1 垂直分库"></a>1.1 垂直分库</h3><p><code>概念</code> 就是<strong>根据业务耦合性，将关联度低的不同表存储在不同的数据库</strong>。<strong>做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与”微服务治理”的做法相似，</strong></p><ul><li>每个微服务使用单独的一个数据库。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/164635785.png" alt="mark"></p><p><strong>说明：</strong></p><p>一开始我们是单体服务，所以只有一个数据库，所有的表都在这个库里。</p><p>后来因为业务需求,单体服务变成微服务治理。所以将之前的一个商品库，拆分成多个数据库。每个微服务对于一个数据库。</p><h3 id="1-2-垂直分表"><a href="#1-2-垂直分表" class="headerlink" title="1.2 垂直分表"></a>1.2 垂直分表</h3><ul><li><code>概念</code> 把一个表的多个字段分别拆成多个表，一般按字段的冷热拆分，热字段一个表，冷字段一个表。从而提升了数据库性能。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/164630656.png" alt="mark"></p><p>说明：</p><p>一开始商品表中包含商品的所有字段，但是我们发现:</p><p><code>1.商品详情和商品属性字段较长</code>。</p><p><code>2.商品列表的时候我们是不需要显示商品详情和商品属性信息，只有在点进商品商品的时候才会展示商品详情信息</code>。</p><p>所以可以考虑把商品详情和商品属性单独切分一张表，提高查询效率。</p><h3 id="1-3-垂直拆分优缺点"><a href="#1-3-垂直拆分优缺点" class="headerlink" title="1.3 垂直拆分优缺点"></a>1.3 垂直拆分优缺点</h3><p><strong>优点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 解决业务系统层面的耦合，业务清晰</span><br><span class="line">- 与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</span><br><span class="line">- 高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 分库后无法Join，只能通过接口聚合方式解决，提升了开发的复杂度</span><br><span class="line">- 分库后分布式事务处理复杂</span><br><span class="line">- 依然存在单表数据量过大的问题（需要水平切分）</span><br></pre></td></tr></table></figure><h2 id="2-水平切分"><a href="#2-水平切分" class="headerlink" title="2. 水平切分"></a>2. 水平切分</h2><p><strong>产生的原因：</strong></p><ul><li>当一个应用难以再细粒度的垂直切分或切分后数据量行数巨大,</li><li>存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。</li></ul><p><strong>这时候需要考虑水平切分了</strong></p><h3 id="2-1-水平切分"><a href="#2-1-水平切分" class="headerlink" title="2.1 水平切分"></a>2.1 水平切分</h3><p>原因： 上面虽然已经把商品库分成3个库，但是随着业务的增加一个订单库也出现QPS过高，数据库响应速度来不及,<strong>一般mysql单机也就1000左右的QPS</strong>，如果超过1000就要考虑分库。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/170142138.png" alt="mark"></p><h3 id="2-2-水平分表"><a href="#2-2-水平分表" class="headerlink" title="2.2 水平分表"></a>2.2 水平分表</h3><ul><li><code>概念</code> <strong>一般我们一张表的数据不要超过1千万,如果表数据超过1千万，并且还在不断增加数据，那就可以考虑分表。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/170553161.png" alt="mark"></p><h3 id="2-3-水平拆分优缺点"><a href="#2-3-水平拆分优缺点" class="headerlink" title="2.3 水平拆分优缺点"></a>2.3 水平拆分优缺点</h3><p><strong>优点</strong></p><ul><li><strong>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</strong></li><li>应用端改造较小，不需要拆分业务模块</li></ul><p><strong>缺点</strong></p><ul><li>跨分片的事务一致性难以保证</li><li>跨库的Join关联查询性能较差</li><li>数据多次扩展难度和维护量极大</li></ul><h2 id="3-数据分片规则"><a href="#3-数据分片规则" class="headerlink" title="3. 数据分片规则"></a>3. 数据分片规则</h2><ul><li>我们我们考虑去水平切分表，将一张表水平切分成多张表，这就涉及到数据分片的规则，比较常见的有：<code>Hash取模分表</code>、<code>数值Range分表</code>、<code>一致性Hash算法分表</code>。</li></ul><h3 id="3-1-hash-取模分表"><a href="#3-1-hash-取模分表" class="headerlink" title="3.1 hash 取模分表"></a>3.1 hash 取模分表</h3><ul><li>一般采用Hash取模的切分方式，例如：假设按goods_id分4张表。（goods_id%4 取整确定表）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/171007587.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line"> - 数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈。</span><br><span class="line">缺点</span><br><span class="line">- 后期分片集群扩容时，需要迁移旧的数据很难。</span><br><span class="line">- 容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带goods_id时,将会导致无法定位数据库,从而需要同时向4个库发起查询，</span><br><span class="line">再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</span><br></pre></td></tr></table></figure><h3 id="3-2-范围-range分表"><a href="#3-2-范围-range分表" class="headerlink" title="3.2 范围 range分表"></a>3.2 范围 range分表</h3><p><code>概念</code> 按照时间区间或ID区间来切分。</p><p>​        例如：将goods_id为1 - 1000的记录分到第一个表，1001–2000的分到第二个表，以此类推。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/171123540.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">- 单表大小可控</span><br><span class="line">- 天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</span><br><span class="line">- 使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</span><br><span class="line">缺点</span><br><span class="line">- 热点数据成为性能瓶颈。</span><br><span class="line">例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询</span><br></pre></td></tr></table></figure><h3 id="3-3-一致性-hash-算法"><a href="#3-3-一致性-hash-算法" class="headerlink" title="3.3 一致性 hash 算法"></a>3.3 一致性 hash 算法</h3><ul><li>一致性Hash算法能很好的<code>解决因为Hash取模而产生的分片集群扩容时，需要迁移旧的数据的难题</code>。至于具体原理这里就不详细说，</li></ul><h2 id="4-分库分表带来的问题"><a href="#4-分库分表带来的问题" class="headerlink" title="4. 分库分表带来的问题"></a>4. 分库分表带来的问题</h2><p>任何事情都有两面性，分库分表也不例外，如果采用分库分表，会引入新的的问题</p><h4 id="1、分布式事务问题"><a href="#1、分布式事务问题" class="headerlink" title="1、分布式事务问题"></a>1、分布式事务问题</h4><p>使用分布式事务中间件解决，具体是通过<strong>最终一致性还是强一致性分布式事务</strong>，看业务需求，这里就不多说。</p><h4 id="2、跨节点关联查询-Join-问题"><a href="#2、跨节点关联查询-Join-问题" class="headerlink" title="2、跨节点关联查询 Join 问题"></a>2、跨节点关联查询 Join 问题</h4><p>切分之前，我们可以通过Join来完成。而切分之后，数据可能分布在不同的节点上，此时Join带来的问题就比较麻烦了，考虑到性能，尽量避免使用Join查询。</p><p>解决这个问题的一些方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全局表</span><br></pre></td></tr></table></figure><p>全局表，也可看做是 “<strong>数据字典表</strong>“，就是系统中所有模块都可能依赖的一些表，为了避免跨库Join查询，可以将 <strong>这类表在每个数据库中都保存一份</strong>。这些数据通常</p><p>很少会进行修改，所以也不担心一致性的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段冗余</span><br></pre></td></tr></table></figure><p><strong>利用空间换时间，为了性能而避免join查询</strong>。例：订单表保存userId时候,也将userName冗余保存一份，这样查询订单详情时就不需要再去查询”买家user表”了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据组装</span><br></pre></td></tr></table></figure><p><strong>在系统层面，分两次查询</strong>。第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</p><h4 id="3、跨节点分页、排序、函数问题"><a href="#3、跨节点分页、排序、函数问题" class="headerlink" title="3、跨节点分页、排序、函数问题"></a>3、跨节点分页、排序、函数问题</h4><ul><li>跨节点多库进行查询时，会出现Limit分页、Order by排序等问题。分页需要按照指定字段进行排序，<strong>当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；</strong></li><li><strong>当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。</strong></li></ul><h4 id="4、全局主键避重问题"><a href="#4、全局主键避重问题" class="headerlink" title="4、全局主键避重问题"></a>4、全局主键避重问题</h4><p>如果都用<code>主键自增</code>肯定不合理，如果用<code>UUID</code>那么无法做到根据主键排序，所以我们可以考虑通过<code>雪花ID</code>来作为数据库的主键，</p><p>有关雪花ID可以参考博客：<a href="https://www.cnblogs.com/qdhxhz/p/11372658.html" target="_blank" rel="noopener">静态内部类单例模式实现雪花算法</a></p><h4 id="5、数据迁移问题"><a href="#5、数据迁移问题" class="headerlink" title="5、数据迁移问题"></a>5、数据迁移问题</h4><ul><li>采用<code>双写的方式</code>，修改代码，所有涉及到分库分表的表的增、删、改的代码，都要对新库进行增删改。同时，再有一个数据抽取服务，不断地从老库抽数据，往新库写，</li><li>边写边按时间比较数据是不是最新的。</li></ul><p><strong>参考博客 ：</strong> <a href="https://www.cnblogs.com/qdhxhz/p/11608222.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/11608222.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-13-分库分表&quot;&gt;&lt;a href=&quot;#Mysql-13-分库分表&quot; class=&quot;headerlink&quot; title=&quot;Mysql-13-分库分表&quot;&gt;&lt;/a&gt;Mysql-13-分库分表&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当一张表的数据达到几千万时，查询一次所花的时间会变长。业界公认MySQL单表容量在 &lt;strong&gt;1千万&lt;/strong&gt; 以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。&lt;/li&gt;
&lt;li&gt;数据切分可以分为：&lt;code&gt;垂直切分&lt;/code&gt;和&lt;code&gt;水平切分&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分库分表" scheme="http://zhuuu.work/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JUC-20-ThreadPoolExecutor</title>
    <link href="http://zhuuu.work/2020/08/31/JUC/JUC-20-ThreadPoolExecutor/"/>
    <id>http://zhuuu.work/2020/08/31/JUC/JUC-20-ThreadPoolExecutor/</id>
    <published>2020-08-31T08:02:24.000Z</published>
    <updated>2020-09-20T01:32:27.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUC-20-ThreadPoolExecutor"><a href="#JUC-20-ThreadPoolExecutor" class="headerlink" title="JUC-20-ThreadPoolExecutor"></a>JUC-20-ThreadPoolExecutor</h2><h2 id="1-submit-和-execute"><a href="#1-submit-和-execute" class="headerlink" title="1. submit 和 execute"></a>1. submit 和 execute</h2><ol><li><strong>execute</strong></li></ol><ul><li>这个方法是在<code>Executor</code>接口中定义的，不会返回执行结果，在<code>ThreadPoolExecutor</code> 类中有具体的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>submit方法</strong></li></ol><ul><li>这个方法是在<code>ExecutorService</code> 接口中定义的，在<code>AbstractExecutorService</code> 类中有具体的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个Callable</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交一个Runnable</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交一个Runnable并默认值result，在任务执行完毕以后，调用&#123;Future.get()&#125;方法会返回这个默认值</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><strong>其实最终调用的方法，都是execute方法</strong></li><li><strong>sumbit方法相当于把任务包装了一下，返回的是一个Future句柄，这个句柄其实就是FutureTask对象</strong></li></ul><p><strong>区别</strong></p><ul><li><strong>接收的参数不一样</strong></li><li><strong>submit有返回值，而execute没有</strong></li><li><strong>submit方便Exception处理</strong><ul><li>意思就是如果你在你的task里会抛出<code>checked</code>或者<code>unchecked exception</code>，而你又希望外面的调用者能够感知这些<code>exception</code>并做出及时的处理</li><li>那么就需要用到<code>submit</code>，通过捕获<code>Future.get</code>抛出的异常。</li></ul></li></ul><a id="more"></a><h2 id="2-Callable-和-Runnable"><a href="#2-Callable-和-Runnable" class="headerlink" title="2 . Callable 和 Runnable"></a>2 . Callable 和 Runnable</h2><h3 id="2-1-Runnable"><a href="#2-1-Runnable" class="headerlink" title="2.1 Runnable"></a>2.1 Runnable</h3><ul><li>先说一下<code>java.lang.Runnable</code>吧，它是一个接口，在它里面只声明了一个run()方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>由于run()方法返回值为void类型</strong>，所以在执行完任务之后无法返回任何结果。</li></ul><h3 id="2-2-Callable"><a href="#2-2-Callable" class="headerlink" title="2.2 Callable"></a>2.2 Callable</h3><ul><li><code>Callable</code>位于<code>java.util.concurrent</code>包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做<code>call()：</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到，这是一个<strong>泛型接口</strong>，该接口声明了一个名称为call()的方法，同时这个方法可以有返回值V，也可以抛出异常。call()方法返回的类型就是传递进来的V类型。</li></ul><ul><li><strong>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的</strong>，在ExecutorService接口中声明了若干个submit方法的重载版本：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个方法：submit提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个方法：submit提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个方法：submit提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此我们只要创建好我们的线程对象（实现Callable接口或者Runnable接口），然后通过上面3个方法提交给线程池去执行即可。</span></span><br></pre></td></tr></table></figure><h2 id="3-Future"><a href="#3-Future" class="headerlink" title="3. Future"></a>3. Future</h2><ul><li><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</li><li><code>Future&lt;V&gt;</code>接口是用来<strong>获取异步计算结果</strong>的，说白了就是对具体的<code>Runnable</code>或者<code>Callable</code>对象任务执行的结果进行获取(get())，取消(<code>cancel()</code>)，判断是否完成等操作。我们看看Future接口的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在<strong>Future接口中声明了5个方法</strong>，下面依次解释每个方法的作用：</p><ul><li><p><strong>cancel方法</strong>用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p></li><li><p><strong>isCancelled方法</strong>表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</p></li><li><p><strong>isDone方法</strong>表示任务是否已经完成，若任务完成，则返回true；</p></li><li><p><strong>get()方法</strong>用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</p></li><li><p><strong>get(long timeout, TimeUnit unit)</strong>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</p></li></ul></li></ul><ul><li>也就是说<strong>Future提供了三种功能：</strong></li></ul><p>1）判断任务是否完成；</p><p>2）能够中断任务；</p><p>3）能够获取任务执行结果。</p><p><strong>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</strong></p><h2 id="4-FutureTask"><a href="#4-FutureTask" class="headerlink" title="4. FutureTask"></a>4. FutureTask</h2><h3 id="4-1-FutureTask-的-状态"><a href="#4-1-FutureTask-的-状态" class="headerlink" title="4.1 FutureTask 的 状态"></a>4.1 FutureTask 的 状态</h3><ul><li>我们先来看一下FutureTask的实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure><ul><li><code>FutureTask</code>类实现了<code>RunnableFuture</code>接口，我们看一下<code>RunnableFuture</code>接口的实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出<code>RunnableFuture</code>继承了Runnable接口和Future接口，<ul><li>而FutureTask实现了RunnableFuture接口。所以它<strong>既可以作为Runnable被线程执行，</strong></li><li><strong>又可以作为Future得到Callable的返回值。</strong></li></ul></li></ul><p><strong>分析：</strong></p><ul><li>FutureTask除了实现了Future接口外还实现了Runnable接口，因此FutureTask也可以直接提交给Executor执行。 当然也可以调用线程直接执行（FutureTask.run()）。接下来我们根据FutureTask.run()的执行时机来分析其所处的3种状态：<ul><li><strong>未启动（NEW），</strong>FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，而且没有执行FutureTask.run()方法前，这个FutureTask也处于未启动状态。</li><li><strong>已启动(Completing)</strong>，<code>FutureTask.run()</code>被执行的过程中，<code>FutureTask</code>处于已启动状态。</li><li><strong>已完成(Normal)，</strong><code>FutureTask.run()</code>方法执行完正常结束，或者被取消或者抛出异常而结束，FutureTask都处于完成状态。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200915/103146074.png" alt="mark"></p><ul><li>下面我们再来看看<code>FutureTask</code>的方法执行示意图（方法和Future接口基本是一样的，这里就不过多描述了）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200915/103203544.png" alt="mark"></p><p><strong>分析</strong></p><p><strong>get()逻辑</strong></p><ul><li>当FutureTask处于未启动或已启动状态时，如果此时我们执行FutureTask.get()方法将导致调用线程阻塞；</li><li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。</li></ul><p><strong>cancel()逻辑</strong></p><ul><li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会执行。</li><li>当FutureTask处于已启动状态时，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果任务取消成功，cancel(…)返回true；但如果执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时cancel(…)返回false</li><li>当任务已经完成，执行cancel(…)方法将返回false。</li></ul><p><strong>最后我们给出FutureTask的两种构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-FutureTask的使用"><a href="#4-2-FutureTask的使用" class="headerlink" title="4.2 FutureTask的使用"></a>4.2 FutureTask的使用</h3><ul><li><p>通过上面的介绍，我们对Callable，Future，FutureTask都有了比较清晰的了解了，那么它们到底有什么用呢？我们前面说过通过这样的方式去创建线程的话，<strong>最大的好处就是能够返回结果</strong></p></li><li><p>加入有这样的场景，我们现在需要计算一个数据，而这个数据的计算比较耗时，而我们后面的程序也要用到这个数据结果，那么这个时Callable岂不是最好的选择？</p></li><li><p>我们可以开设一个线程去执行计算，而主线程继续做其他事，而后面需要使用到这个数据时，我们再使用Future获取不就可以了吗？下面我们就来编写一个这样的实例。</p></li></ul><p><strong>1、使用Callable+Future获取执行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建Callable对象任务  </span></span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        <span class="comment">//提交任务并获取执行结果  </span></span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        <span class="comment">//关闭线程池  </span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.get()!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">"task运行结果"</span>+result.get());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"未获取到结果"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子线程在进行计算</span><br><span class="line">主线程在执行任务</span><br><span class="line">task运行结果<span class="number">4950</span></span><br><span class="line">所有任务执行完毕</span><br></pre></td></tr></table></figure><p><strong>2、使用Callable+FutureTask获取执行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line"><span class="comment">//        Task task = new Task();</span></span><br><span class="line"><span class="comment">//        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(futureTask);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(futureTask.get()!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"future.get()未获取到结果"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上。</p><h3 id="4-3-补充"><a href="#4-3-补充" class="headerlink" title="4.3 补充"></a>4.3 补充</h3><ul><li>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的。</li><li>Callable规定的方法是call(),Runnable规定的方法是run()。</li><li><strong>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)。</strong></li><li><strong>call方法可以抛出异常，run方法不可以。</strong></li><li>运行Callable的 任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</li><li><strong>加入线程池运行，Runnable使用Executor的execute方法，Callable使用submit方法。</strong></li></ul><p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></p><p><strong>参考博客</strong> : <a href="https://blog.csdn.net/leilifengxingmw/article/details/79533006" target="_blank" rel="noopener">https://blog.csdn.net/leilifengxingmw/article/details/79533006</a></p><p>​                    <a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></p><p>​                    <a href="https://www.cnblogs.com/xiaoxi/p/8303574.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/8303574.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JUC-20-ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#JUC-20-ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;JUC-20-ThreadPoolExecutor&quot;&gt;&lt;/a&gt;JUC-20-ThreadPoolExecutor&lt;/h2&gt;&lt;h2 id=&quot;1-submit-和-execute&quot;&gt;&lt;a href=&quot;#1-submit-和-execute&quot; class=&quot;headerlink&quot; title=&quot;1. submit 和 execute&quot;&gt;&lt;/a&gt;1. submit 和 execute&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;execute&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这个方法是在&lt;code&gt;Executor&lt;/code&gt;接口中定义的，不会返回执行结果，在&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 类中有具体的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Executor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable command)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;submit方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这个方法是在&lt;code&gt;ExecutorService&lt;/code&gt; 接口中定义的，在&lt;code&gt;AbstractExecutorService&lt;/code&gt; 类中有具体的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Callable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Callable&amp;lt;T&amp;gt; task)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Runnable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Future&amp;lt;?&amp;gt; submit(Runnable task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Runnable并默认值result，在任务执行完毕以后，调用&amp;#123;Future.get()&amp;#125;方法会返回这个默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable task, T result)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;其实最终调用的方法，都是execute方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sumbit方法相当于把任务包装了一下，返回的是一个Future句柄，这个句柄其实就是FutureTask对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;接收的参数不一样&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;submit有返回值，而execute没有&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;submit方便Exception处理&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;意思就是如果你在你的task里会抛出&lt;code&gt;checked&lt;/code&gt;或者&lt;code&gt;unchecked exception&lt;/code&gt;，而你又希望外面的调用者能够感知这些&lt;code&gt;exception&lt;/code&gt;并做出及时的处理&lt;/li&gt;
&lt;li&gt;那么就需要用到&lt;code&gt;submit&lt;/code&gt;，通过捕获&lt;code&gt;Future.get&lt;/code&gt;抛出的异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-HTTPS点开网页原理</title>
    <link href="http://zhuuu.work/2020/08/31/NetworkCoding/HTTP-HTTPS%E7%82%B9%E5%BC%80%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/08/31/NetworkCoding/HTTP-HTTPS%E7%82%B9%E5%BC%80%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-31T03:02:24.000Z</published>
    <updated>2020-09-21T01:01:17.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-HTTPS区别"><a href="#HTTP-HTTPS区别" class="headerlink" title="HTTP-HTTPS区别"></a>HTTP-HTTPS区别</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议</p></li><li><p>申请证书上，HTTPS需要使用ca申请证书</p></li><li><p>对于抓包而言 ，HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议</p></li><li><p>连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443</p></li></ul><p><strong>HTTP通信过程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/100535634.png" alt="mark"></p><a id="more"></a><h2 id="2-HTTPS的通信过程"><a href="#2-HTTPS的通信过程" class="headerlink" title="2. HTTPS的通信过程"></a>2. HTTPS的通信过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-105034140.png" alt="mark"></p><p>https通信时，首先建立ssl层的连接，客户端将ssl版本号和加密组件发到服务器端，服务器端收到后对ssl版本号和加密组件进行匹配，同时将CA证书及密钥发送到客户端。客户端对证书进行验证，验证通过后使用非对称加密对数据通信时的密钥进行协商。协商后得到一致的获得一致的对称加密密钥。然后使用对称加密算法进行TCP连接，后续的过程跟http的过程一致。三次握手，数据交换，四次挥手，通信结束。</p><p>过程如下 ：</p><ol><li>客户端和服务器端通过TCP建立连接。</li><li>客户端向服务器发送HTTPS请求。</li><li>服务器响应请求，并将数字证书发送给客户端，数字证书包括公共秘钥、域名、申请证书的公司。</li><li>客户端收到服务器端的数字证书之后，会验证数字证书的合法性。</li><li>如果公钥合格，那么客户端会生成一个用于进行对称加密的密钥client key，并用服务器的公钥对客户端密钥进行非对称加密。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用私钥对其进行非对称解密，得到客户端秘钥。并使用客户端秘钥进行对称加密，生成密文并发送。</li><li>客户端收到密文，并使用客户端秘钥进行解密，渲染网页。</li></ol><h2 id="3-HTTP的工作过程详解"><a href="#3-HTTP的工作过程详解" class="headerlink" title="3. HTTP的工作过程详解"></a>3. HTTP的工作过程详解</h2><p><strong>总结</strong></p><p>HTTP由请求和响应构成，是一个标准的客户端服务器模型（C/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。</p><ol><li>地址解析。域名系统DNS解析域名得到主机的IP地址</li><li>封装HTTP请求数据包。封装的内容有以上部分结合本机自己的信息。</li><li>封装成TCP包，建立TCP连接（TCP的三次握手）</li><li>客户机发送请求命令。 建立连接后，客户机向服务器发送一个请求</li><li>服务器响应。服务器接到请求后，给予相应的响应信息</li><li>服务器关闭TCP连接。一般Web服务器向浏览器发送了请求数据，它要关闭TCP连接</li><li>客户端解析报文，解析HTML代码，并渲染</li></ol><h3 id="3-1-DNS过程（应用层）"><a href="#3-1-DNS过程（应用层）" class="headerlink" title="3.1 DNS过程（应用层）"></a>3.1 DNS过程（应用层）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">其实我们在浏览器中输入URL的时候，浏览器就会开始智能的匹配可能URL，浏览器会从历史记录，书签等地方，找到你已经输入的字符串可能对应的URL，然后给出智能提示</span><br><span class="line"></span><br><span class="line">在输好URL后我们会按下Enter键，浏览器会发起请求，如果URL是域名而不是IP地址，将进行域名解析，所谓域名解析是指什么呢？</span><br><span class="line"></span><br><span class="line">IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址，域名解析就是域名到IP地址的转换过程。</span><br><span class="line">域名解析按下面的步骤进行（部分内容涉及到计算机网络知识）：</span><br><span class="line"></span><br><span class="line">我们本地硬盘下有一个hosts(windows下路径为C:\Windows\System32\drivers\etc)文件，作用是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”。一般来说，系统会首先自动从hosts文件中寻找对应的IP地址，如果有的话就直接使用hosts文件里面的IP地址，然后直接进行端口确认</span><br><span class="line">如果上一步没有找到，浏览器将调用解析程序，并成为DNS服务器的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报的方式发给本地DNS服务器</span><br><span class="line">如果本地DNS服务器查找到相应的域名的IP地址，就把对应的IP地址放在回答报文中返回</span><br><span class="line">如果上一步没有找到，即本地DNS服务器不知道被查询域名的IP地址，由于主机向本地DNS服务器的查询是递归查询，所以此时，本地DNS服务器就会以DNS客户的身份向其他根DNS服务器继续发出查询请求报文。本地DNS服务器向根DNS服务器的查询是迭代查询，当找到相应域名的IP地址后，就会把这个结果返回给最初发起查询请求的浏览器</span><br><span class="line"></span><br><span class="line">递归查询：在该模式下DNS服务器接收到客户机请求，必须返回一个准确的查询结果给客户机。如果该DNS服务器本地没有存储被查询的DNS信息，那么该服务器会（替客户机）询问其他服务器，并将返回的查询结果再返回给客户机。</span><br><span class="line">迭代查询：在该模式下DNS服务器接收到客户机请求，如果该DNS服务器本地没有存储被查询的DNS信息，DNS服务器会向客户机提供其他能够解析查询请求的DNS服务器地址，让客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。</span><br><span class="line">经过上面的步骤后，浏览器已经获得输入域名的IP地址，可以进行下一步了。</span><br></pre></td></tr></table></figure><h3 id="3-2-发起请求建立连接-传输层"><a href="#3-2-发起请求建立连接-传输层" class="headerlink" title="3.2 发起请求建立连接(传输层)"></a>3.2 发起请求建立连接(传输层)</h3><ul><li>浏览器得到<code>IP</code>地址并确认端口后，会向目标服务器发起<code>HTTP</code>请求，<code>HTTP</code>请求是通过<code>TCP</code>连接来发送的(如果是<code>HTTPS</code>则需要先建立SSL连接，再是<code>TCP</code>连接，下面的讨论基于<code>HTTP</code>)，具体如下<ul><li><strong>浏览器会生成目标服务器的<code>HTTP</code>请求报文</strong>，<strong>请求报文一般包含请求方法、请求<code>URI</code>、协议版本、请求首部字段等内容，<code>HTTP</code>请求准备好后，<code>HTTP</code>请求报文从应用层传到传输层后会被分割为报文段，并会发起一条到达目标服务器的<code>TCP</code>连接，开始<code>TCP</code>三次握手</strong>，过程如图所示：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/101827387.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通俗的可以理解为：</span><br><span class="line"></span><br><span class="line">A主动向B打电话：嗨，能听到吗（SYN&#x3D;1，seq&#x3D;x），然后A就开始等待B的回答（SYN-SENT状态），此时A不知道B能不能听到</span><br><span class="line">B听到A的话之后，可以确认它能听到A，但是它还要确认一下A能不能听到他自己的声音，于是B说：我能听到你的声音（ACK&#x3D;1，ack&#x3D;x+1），你能听到我的声音吗（SYN&#x3D;1,seq&#x3D;y），然后B开始等待A的恢复（SYN-RECD状态）</span><br><span class="line">A听到B的话之后，A可以确认两件事，一是B能听到它说话，二是它也能听到B说话，A已经可以随时说话和倾听了（ESTABLISHED状态）。但是此时的B还在等待中，并不知道A能不能听到，所以此时A需要再回复B说：我可以听到你的声音（ACK&#x3D;1，ack&#x3D;y+1）,开始愉快的聊天吧~（seq&#x3D;x+1），B听到这句话后便也可以随时说话和倾听了（ESTABLISHED状态）</span><br><span class="line">之后两个人就可以balabalabala....</span><br></pre></td></tr></table></figure><ul><li><code>HTTP</code>请求的请求报文是直接附在第三次握手的消息中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">穿插补充小知识，为什么是三次握手，而不是两次四次？</span><br><span class="line"></span><br><span class="line">在《计算机网络》一书中也有讲过这个问题，给出的解释是：三次握手是为了防止失效的连接请求报文段被服务端接收，从而产生错误。具体例子如下所述：</span><br><span class="line">client发出的一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</span><br><span class="line">假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。但是由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。而server却以为新的连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</span><br><span class="line">采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接</span><br></pre></td></tr></table></figure><h3 id="3-3-封装成IP数据包（网络层）"><a href="#3-3-封装成IP数据包（网络层）" class="headerlink" title="3.3 封装成IP数据包（网络层）"></a>3.3 封装成IP数据包（网络层）</h3><ul><li>连接建立之后，开始进行数据传输，虽然浏览器知道目标服务器的<code>IP</code>和端口，但是数据总不可能飞过去吧？<code>HTTP</code>请求报文段会从传输层传到网络层，在网络层被封装成<code>IP</code>数据包，网络层规定了通过怎样的路径（所谓的传输路线）到达目标服务器，并把数据包传送给对方。</li></ul><h3 id="3-4-封装成帧-（数据链路层）"><a href="#3-4-封装成帧-（数据链路层）" class="headerlink" title="3.4 封装成帧 （数据链路层）"></a>3.4 封装成帧 （数据链路层）</h3><ul><li>网络层封装好的<code>IP</code>数据包会进一步传到下一层 — 数据链路层，然后会再次被封装到<code>MAC</code>数据帧结构中</li><li>由于<code>IP</code>地址间的通信依赖于<code>MAC</code>地址（网卡所属的固定地址），所以<code>MAC</code>数据帧结构中会有经过<code>ARP</code>协议解析后的<code>MAC</code>地址（不一定是目标服务器的<code>MAC</code>地址，因为实际上通信的双方在同一局域网（LAN）内的情况是很少的，一般都会经过路由中转）。</li></ul><h3 id="3-5-传输比特流-（物理层）"><a href="#3-5-传输比特流-（物理层）" class="headerlink" title="3.5 传输比特流 （物理层）"></a>3.5 传输比特流 （物理层）</h3><ul><li>数据链路层的<code>MAC</code>数据帧再向下传，便会到达物理层，这里要注意<strong><em>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体\</em></strong>。 物理层需要确保原始的数据可在各种物理媒体上传输，它规定了传输媒体的机械特性、电气特性、功能特性、过程特性</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/103108545.png" alt="mark"></p><ul><li>常见的传输媒体有双绞线、电缆、光缆、无线信道等，物理层的任务就是要让数据在这些传输媒体上都能能进行传输</li></ul><h3 id="3-6-服务端的逆操作"><a href="#3-6-服务端的逆操作" class="headerlink" title="3.6 服务端的逆操作"></a>3.6 服务端的逆操作</h3><ul><li><p>通过<code>MAC</code>地址匹配，数据通过传输媒体到达目标服务器的物理层，物理层接收数据比特流然后向上传送到服务器的数据链路层，在数据链路层<code>MAC</code>数据帧将进行封装的逆操作，还原成<code>IP</code>数据包之后向上传送到网络层，网络层也进行封装的逆操作还原成<code>HTTP</code>请求报文段（分割后的一小段一小段的），然后这些报文段向上传到传输层，在传输层按原来的序号重新组装成完整的<code>HTTP</code>请求报文，再向上传到应用层，应用层的<code>HTTP</code>协议便会开始对请求进行处理</p></li><li><p>这个处理可能是直接返回静态的资源，也可能经过<code>PHP</code>、<code>JAVA</code>等语言进行处理等，等处理完成后，会返回一个<code>HTTP</code>响应，它生成一个<code>HTTP</code>响应报文，与<code>HTTP</code>请求报文结构类似，然后这个响应报文会“走过”请求报文来时的路到达浏览器</p></li></ul><h3 id="3-7-客户端的释放链接"><a href="#3-7-客户端的释放链接" class="headerlink" title="3.7 客户端的释放链接"></a>3.7 客户端的释放链接</h3><ul><li>浏览器接收<code>HTTP</code>响应，<strong>然后有可能释放<code>TCP</code>连接，也有可能重新使用这个<code>TCP</code>连接发送新的请求（持久连接）</strong>，此处了解一下<code>TCP</code>连接的释放，不同于<code>TCP</code>连接建立的三次握手，<code>TCP</code>连接的释放是四次挥手，客户端和服务器端都可以发起关闭请求，也存在两者同时发起关闭请求的情况，图中为客户端A主动发起关闭请求：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/103323033.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">同样通俗的解释一波：</span><br><span class="line"></span><br><span class="line">A对B要传的文件已经传完了，于是他对B说：我要传的文件已经传完了，我要准备下线了（seq&#x3D;u，FIN&#x3D;1）。然后A就等待B的回复（FIN-WAIT-1状态）</span><br><span class="line"></span><br><span class="line">B看到A的消息后，回复A说：知道了，但是我还有文件给你（ACK&#x3D;1,ack&#x3D;u+1,seq&#x3D;v）。B进入等他文件传完的状态（CLOSE-WAIT状态）。</span><br><span class="line">A收到B的回复之后，下线不了了，于是继续等待着B的文件传完（FIN-WAIT-2状态）</span><br><span class="line"></span><br><span class="line">几分钟后，B的文件传完了，此时他对A说：我的文件传完了，我也要下线了（seq&#x3D;w,FIN&#x3D;1,ACK&#x3D;1,ack&#x3D;u+1），然后B等待A的回复来确认真的可以下线了（LAST-ACK状态）</span><br><span class="line"></span><br><span class="line">A收到B的回复后，便对A说：好的，那你下线吧（ACK&#x3D;1，seq&#x3D;u+1,ack&#x3D;w+1）。此时A会等待一段时间（2MSL，TIME-WAIT状态），B收到后就直接下线了（CLOSE状态），然后2MSL时间到了之后，A也下线（CLOSE状态）</span><br></pre></td></tr></table></figure><p><strong>几个小问题</strong></p><ul><li><strong>为什么服务器B在接到A的断开请求时不立即同意断开？</strong><ul><li>当服务器B收到断开连接的请求时，服务器可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开</li></ul></li></ul><ul><li><strong>为什么是四次挥手，而不是像建立连接一样的三次</strong><ul><li>因为<code>TCP</code>连接是全双工模式，服务器B收到A的断开请求时，仅仅表明A没有东西传给服务器B了，但此时服务器B可能向A的传输还没结束，所以服务器B要先给A一个确认收到A的断开请求的<code>ACK</code>报文，然后继续向A把信息传完，等传完之后服务器B再向A发送断开请求的报文段，等A收到并回复<code>ACK</code>报文后再释放连接。</li><li>也就是说对于A来说他要发送请求给B并等待B确认，对于B来说也要发送请求给A并等待A确认，两者都经过这两个过程才能完全释放<code>TCP</code>连接，而非单方面的释放。<br>建立连接只需要建立，没有<strong>数据</strong>的影响，而释放连接还要考虑数据是否传输完，所以建立连接的时候B确认收到A的建立请求与B发送建立请求这一步可以合成一步成为<code>TCP</code>建立连接的第二次握手，而释放连接时却必须分开。</li></ul></li></ul><ul><li><strong>最后一次握手后A为什么要等<code>2MSL</code>？</strong><br><strong>首先解释一下<code>MSL</code>，<code>MSL</code>是指最长报文段寿命</strong>，RFC793建议为两分钟，但实际上可据实际情况而定，也就是说一个报文段最久可存在的时间是<code>MSL</code></li></ul><ol><li>这是为了保证A发送的最后一个<code>ACK</code>报文能够到达服务器B，如果这个<code>ACK</code>报文丢失了，服务器B没有收到，B会超时重传第三次握手的<code>FIN+ACK</code>报文给A，这个时候处于等待的A就可以收到这个重传的<code>FIN+ACK</code>报文，并再次发送<code>ACK</code>报文给服务器B，并且重新启动2MSL计时器，最终结果是A和B都正常进入CLOSE状态。如果A发完<code>ACK</code>报文后就直接释放了A–&gt;B的连接，那么A就收不到B重传的<code>FIN+ACK</code>报文，也不能重新发送ACK`报文，那么B就无法按正常步骤释放B–&gt;A的连接</li><li>防止“已失效的连接请求报文”出现在下一个新的连接中，因为一个报文段的寿命是<code>MSL</code>，所以A在发送完最后一个<code>ACK</code>报文段之后，再经过时间2<code>MSL</code>，本连接持续的时间内所产生的所有报文段都将在网络中消失，这样这些旧的报文段便不会出现在下一个新的连接中</li></ol><h3 id="3-8-浏览器的加载过程"><a href="#3-8-浏览器的加载过程" class="headerlink" title="3.8 浏览器的加载过程"></a>3.8 浏览器的加载过程</h3><p>浏览器之后会检查<code>HTTP</code>的响应状态，主要通过响应码来判断</p><blockquote><p>1xx: 表示通知信息的，比如请求收到了或正在处理<br>2xx：表示成功，操作被成功接收并处理<br>3xx：表示重定向，一般完成请求还必须采取进一步的行动<br>4xx：表示客户端的差错<br>5xx：表示服务器的差错</p></blockquote><ul><li><p>如果响应可缓存，浏览器将把响应存入缓存</p></li><li><p>浏览器根据<code>HTTP</code>报头信息解码响应，决定如何处理这些响应，并展现响应，以响应为一个<code>HTML</code>为例</p></li><li><p>浏览器开始自上而下，自左而右的加载<code>HTML</code>文档，最开始会遇到<code>&lt;!DOCTYPE&gt;</code>声明，然后根据<code>&lt;!DOCTYPE&gt;</code>声明浏览器就知道该用哪种规范来解析这个文档</p></li><li><p>再继续边加载边解析，边生成<code>DOM</code>树，加载过程中遇到外部<code>CSS</code>文件，浏览器便会另外发出一个请求，来获取<code>CSS</code>文件（过程和上面说的一样），获取<code>CSS</code>后会生成<code>CSS Rule</code>树。<code>DOM</code>树和<code>CSS Rule</code>树生成<code>Render</code>树，页面可以开始边加载边渲染了</p><ul><li>渲染树和<code>DOM</code>树的关系：那些不可见的<code>DOM</code>元素（如<code>&lt;head&gt;…&lt;/head&gt;</code>，<code>display=none</code>的元素）不会被插入渲染树中；还有像一些节点是绝对定位或浮动，这些节点会在文本流之外，因此他们会在渲染树和<code>DOM</code>树的不同位置，渲染树标识出真实的位置，并用一个占位结构标识出他们原来的位置，而<code>DOM</code>树上是他们原来的位置</li><li>渲染包含”布局”（<code>layout</code>）和”绘制”（<code>paint</code>）这两个步骤，所谓”布局”是指给出每个<code>DOM</code>节点在浏览器窗口中的准确位置，”绘制”是指遍历<code>Render</code>树将布局好的<code>DOM</code>节点绘制在屏幕上。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/105633907.png" alt="mark"></p><ul><li><p>浏览器继续加载渲染，如果遇到<code>＜script＞</code>标签，浏览器会立即执行（暂不考虑<code>defer</code>及<code>async</code>属性），此时会出现页面阻塞，不仅要等待文档中<code>JS</code>文件下载加载完毕，还要等待<code>JS</code>解析执行完毕，才可以恢复<code>HTML</code>文档的加载解析。</p><ul><li>这是浏览器为了防止出现<code>JS</code>修改<code>DOM</code>树，需要重新构建<code>DOM</code>树的情况，<code>DOM</code>树改变浏览器需要回过头来重新渲染这部分代码，所以浏览器希望通过阻塞其他内容的下载和呈现，来避免出现更多的不必要的<code>Reflow</code>（称为回流或者重排）</li><li>如果<code>&lt;script&gt;</code>放在的<code>&lt;head&gt;</code>中，则<code>&lt;body&gt;</code>标签无法被加载，那么页面自然就无法渲染了,因此这将导致在该<code>JS</code>代码完全执行完之前，页面都是一片空白，用户体验非常不好，一般我看到长时间的空白页面，我都非常想直接关闭它。因此会推荐将所有<code>&lt;script&gt;</code>标签尽可能放到<code>&lt;body&gt;</code>标签的底部，以尽量减少对整个页面下载的影响，此时虽然还会存在一个脚本阻塞另一个脚本的问题，但是用户体验比上面的好很多，因为用户看到了大部分内容，而不是空白</li><li><code>defer</code>属性相当于告诉浏览器立即下载，延迟执行。它使得加载后续文档元素的过程将和<code>JS</code>文件的<strong>加载</strong>并行进行（异步），但是<code>JS</code>文件的<strong>执行</strong>要在整个页面解析完成之后，<code>DOMContentLoaded</code>事件触发之前完成，执行顺序为出现的先后顺序。（高程中指出现实中不一定会按照顺序执行，也不一定会在<code>DOMContentLoaded</code>事件触发之前完成，因此最好只包含一个延迟脚本，这可能是与浏览器的实现有关，具体什么情况下会出现我还不知道？？？）</li><li><code>async</code>属性相当于告诉浏览器立即下载执行，并且页面的加载渲染不需要等待该脚本加载和执行，它们两者会异步进行。标记为<code>async</code>的脚本不会按照它们出现的先后顺序执行，而是谁先下载完了谁就先执行，它们一定会在页面的<code>load</code>事件触发之前执行，但可能会在<code>DOMContentLoaded</code>事件触发之前或之后执行。基于前面所说的一点原因，异步脚本最好不要修改<code>DOM</code>，如果由多个异步脚本，它们之间最好没有依赖关系</li></ul></li><li><p>浏览器继续加载渲染，如果遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源，这是异步请求，所以不会等到图片下载完，而是继续渲染后面的<code>HTML</code>文档。</p></li><li><p>等到服务器返回图片文件，如果先前并没有为这个图片设定宽高，那么由于图片占用了一定面积，影响了后面段落的排布，浏览器会进行<code>Reflow</code></p></li><li><p>然后然后终于和<code>＜/html＞</code>碰面了，此次的页面加载渲染过程完成，浏览器也是很累了，然后会立即触发<code>DOMContentLoaded</code>事件，该事件是在形成完整的<code>DOM</code>树之后就会触发，而不会理会图像、<code>JS</code>文件、<code>CSS</code>文件或其他资源是否已经下载完毕</p></li><li><p>当页面完全加载后，也就是所有图像、<code>JS</code>文件、<code>CSS</code>文件等外部资源都加载完成后会触发<code>load</code>事件</p></li><li><p>用户在页面上进行交互时，可能会导致页面进行<code>Repaint</code>或<code>Reflow</code></p><ul><li><code>Repaint</code>：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的<code>Repaint</code>，重绘某一部分</li><li><code>Reflow</code>：如果某个部分发生了的变化影响了布局，那浏览器就需要倒回去重新渲染，每次<code>Reflow</code>必然会导致<code>Repaint</code></li></ul></li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>看似简单的操作背后藏着数不清的小动作，文中也只是涉及了一部分，还有很多相关的过程没有涉及到，但是能力有限，还是慢慢来，暂时就先告一段落</li></ul><p><strong>参考博客 ：</strong> </p><p><a href="https://segmentfault.com/a/1190000014620172" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014620172</a></p><p><a href="https://www.cnblogs.com/chengxs/p/11039155.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxs/p/11039155.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-HTTPS区别&quot;&gt;&lt;a href=&quot;#HTTP-HTTPS区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP-HTTPS区别&quot;&gt;&lt;/a&gt;HTTP-HTTPS区别&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;申请证书上，HTTPS需要使用ca申请证书&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于抓包而言 ，HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTP通信过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/100535634.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络编程" scheme="http://zhuuu.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网页原理" scheme="http://zhuuu.work/tags/%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/"/>
    
      <category term="HTTP" scheme="http://zhuuu.work/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-347-前K个高频元素</title>
    <link href="http://zhuuu.work/2020/08/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2020/08/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2020-08-29T07:51:53.000Z</published>
    <updated>2020-09-09T11:06:05.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-347-Top-K-Frequent-Elements"><a href="#Leecode-347-Top-K-Frequent-Elements" class="headerlink" title="Leecode-347-Top K Frequent Elements"></a>Leecode-347-<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Top K Frequent Elements</a></h1><h2 id="思路：堆"><a href="#思路：堆" class="headerlink" title="思路：堆"></a>思路：堆</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong>高的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>这里题目描述中对时间复杂度做出了要求 ，需要在 O(n log n)的限制。</li></ul><p><strong>Solution : 粗暴排序法</strong></p><ul><li>最简单粗暴的思路就是 <strong>使用排序算法对元素按照频率由高到低进行排序</strong>，然后再取前 k 个元素。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/150737778.png" alt="mark"></p><ul><li>可以发现，使用常规的诸如冒泡，选择，甚至快速排序都不满足要求，它们的时间复杂度要求必须优于O(nlogn)</li></ul><ul><li><p><strong>时间复杂度：O(nlogn)</strong>，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，排序算法时间复杂度为 O(nlogn)；因此整体时间复杂度为 O(nlogn)。</p></li><li><p><strong>空间复杂度：O（n）</strong> ，需要Map来存储n个键值对</p></li></ul><p><strong>接下来我们介绍遇到TopK问题最常用的方法：最大堆或者最小堆</strong></p><p><strong>本题使用的是最小堆</strong></p><p><strong>Solution : 最小堆</strong></p><ul><li>题目最终需要返回的是前k个频率最大的元素。可以想到借助堆这种数据结构，对于k频率之后的元素不用再去处理，进一步优化时间复杂度</li><li>举个例子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/151221418.png" alt="mark"></p><p>具体的操作流程为：</p><ul><li><p>借助<strong>哈希表</strong>来建立数字和其出现次数之间的映射，遍历一遍数组统计元素的频率</p></li><li><p>维护一个元素数目是 k 的最小堆</p></li><li><p>每次都将新的元素和堆顶元素（堆中频率最小的元素）进行比较</p></li><li><p>如果新的元素频率比堆顶的元素大，则弹出堆顶的元素，将新的元素添加进堆中</p></li><li><p>最终，堆中的K个元素就是前 k 个高频元素。</p></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(a) - map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次将新的元素和堆顶元素（堆中频率最小的元素）进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; map.get(pq.peek()))&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出最小堆中的元素</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            res.add(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-347-Top-K-Frequent-Elements&quot;&gt;&lt;a href=&quot;#Leecode-347-Top-K-Frequent-Elements&quot; class=&quot;headerlink&quot; title=&quot;Leecode-347-Top K Frequent Elements&quot;&gt;&lt;/a&gt;Leecode-347-&lt;a href=&quot;https://leetcode-cn.com/problems/top-k-frequent-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Top K Frequent Elements&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：堆&quot;&gt;&lt;a href=&quot;#思路：堆&quot; class=&quot;headerlink&quot; title=&quot;思路：堆&quot;&gt;&lt;/a&gt;思路：堆&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;k&lt;/strong&gt;高的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1,1,1,2,2,3], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。&lt;/li&gt;
&lt;li&gt;你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。&lt;/li&gt;
&lt;li&gt;你可以按任意顺序返回答案。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="TopK算法题" scheme="http://zhuuu.work/tags/TopK%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-try-catch</title>
    <link href="http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-try-catch/"/>
    <id>http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-try-catch/</id>
    <published>2020-08-28T08:39:38.000Z</published>
    <updated>2020-09-18T06:12:19.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-try-catch"><a href="#Java-基础-try-catch" class="headerlink" title="Java-基础-try-catch"></a>Java-基础-try-catch</h1><h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p><strong>绕口令开始</strong></p><p><strong>1、不管有没有异常，<code>finally</code>中的代码都会执行</strong><br><strong>2、当<code>try、catch</code>中有<code>return</code>时，<code>finally</code>中的代码依然会继续执行</strong><br><strong>3、<code>finally</code>是在<code>return</code>后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。</strong><br><strong>4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</strong><br><strong>5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 先执行try中的语句，包括return后面的表达式，</span><br><span class="line">2. 有异常时,先执行catch中的语句，包括return后面的表达式,</span><br><span class="line">3. 然后执行finally中的语句,如果finally里面有return语句，会提前退出，</span><br><span class="line">最后执行try中的return，有异常时执行catch中的return。</span><br><span class="line"></span><br><span class="line">4. 在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的。编译器把finally中的return语句标识为一个warning.</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-举例分析"><a href="#2-举例分析" class="headerlink" title="2. 举例分析"></a>2. 举例分析</h2><ol><li>案例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 try</span><br><span class="line">执行 finally</span><br><span class="line">主方法返回 ：try</span><br></pre></td></tr></table></figure><p><strong>结论：执行try 到了return的时候会去检测finally。finally块存在会先执行finally块的内容，再return。</strong></p><p><strong>案例二：假设finally里面也有return呢？执行的是哪个return？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 <span class="keyword">try</span></span><br><span class="line">执行<span class="keyword">finally</span></span><br><span class="line">主方法返回 ：<span class="keyword">finally</span></span><br></pre></td></tr></table></figure><p><strong>结论：如果finally里面存在return，将直接返回。不再跳回try块的return。</strong></p><p><strong>案例三：catch也是一样的道理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行 <span class="keyword">try</span></span><br><span class="line">执行 <span class="keyword">catch</span></span><br><span class="line">执行<span class="keyword">finally</span></span><br><span class="line">主方法返回 ：<span class="keyword">finally</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-try-catch&quot;&gt;&lt;a href=&quot;#Java-基础-try-catch&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-try-catch&quot;&gt;&lt;/a&gt;Java-基础-try-catch&lt;/h1&gt;&lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;绕口令开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、不管有没有异常，&lt;code&gt;finally&lt;/code&gt;中的代码都会执行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2、当&lt;code&gt;try、catch&lt;/code&gt;中有&lt;code&gt;return&lt;/code&gt;时，&lt;code&gt;finally&lt;/code&gt;中的代码依然会继续执行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;3、&lt;code&gt;finally&lt;/code&gt;是在&lt;code&gt;return&lt;/code&gt;后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 先执行try中的语句，包括return后面的表达式，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 有异常时,先执行catch中的语句，包括return后面的表达式,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 然后执行finally中的语句,如果finally里面有return语句，会提前退出，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	最后执行try中的return，有异常时执行catch中的return。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的。编译器把finally中的return语句标识为一个warning.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="try-catch-finally" scheme="http://zhuuu.work/tags/try-catch-finally/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-线程中断</title>
    <link href="http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</id>
    <published>2020-08-28T08:38:38.000Z</published>
    <updated>2020-08-28T14:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-线程中断"><a href="#Java-基础-线程中断" class="headerlink" title="Java-基础-线程中断"></a>Java-基础-线程中断</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Thread提供了interrupt方法，中断线程的执行：</p><ul><li>如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出<code>InterruptedException</code>,同时清除线程的中断状态;</li><li>如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；</li><li>如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心 interrupt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">         checkAccess();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这个方法不会清除中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-源码实现"><a href="#2-源码实现" class="headerlink" title="2. 源码实现"></a>2. 源码实现</h2><ul><li>之前在分析Thread.start的时候曾经提到，JavaThread有三个成员变量:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于synchronized同步块和Object.wait() </span></span><br><span class="line">ParkEvent * _ParkEvent ; </span><br><span class="line"><span class="comment">//用于Thread.sleep() </span></span><br><span class="line">ParkEvent * _SleepEvent ; </span><br><span class="line"><span class="comment">//用于unsafe.park()/unpark(),供java.util.concurrent.locks.LockSupport调用， </span></span><br><span class="line"><span class="comment">//因此它支持了java.util.concurrent的各种锁、条件变量等线程同步操作,是concurrent的实现基础 </span></span><br><span class="line">Parker* _parker;</span><br></pre></td></tr></table></figure><ul><li>初步猜测interrupt实现应该与此有关系；<br>interrupt方法的源码也在jvm.cpp文件:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Interrupt"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before we operate</span></span><br><span class="line">  oop java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;threadObj()</span> </span>== java_thread ? NULL : Threads_lock);</span><br><span class="line">  <span class="comment">// We need to re-resolve the java_thread, since a GC might have happened during the</span></span><br><span class="line">  <span class="comment">// acquire of the lock</span></span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != NULL) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><ul><li>JVM_Interrupt对参数进行了校验，然后直接调用Thread::interrupt:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  trace(<span class="string">"interrupt"</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Thread::interrupt调用os::interrupt方法实现,os::interrupt方法定义在os_linux.cpp:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取系统native线程对象</span></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">    osthread-&gt;set_interrupted(<span class="literal">true</span>);</span><br><span class="line">   <span class="comment">//内存屏障，使osthread的interrupted状态对其它线程立即可见</span></span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    <span class="comment">//前文说过，_SleepEvent用于Thread.sleep,线程调用了sleep方法，则通过unpark唤醒</span></span><br><span class="line">    ParkEvent * <span class="keyword">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">    <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;unpark() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//_parker用于concurrent相关的锁，此处同样通过unpark唤醒</span></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">  <span class="comment">//synchronized同步块和Object.wait() 唤醒</span></span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由此可见，interrupt其实就是通过ParkEvent的unpark方法唤醒对象；另外要注意：</strong></p><ul><li>object.wait、Thread.sleep和Thread.join会抛出InterruptedException并清除中断状态；</li><li>Lock.lock()方法不会响应中断，Lock.lockInterruptibly()方法则会响应中断并抛出异常，区别在于park()等待被唤醒时lock会继续执行park()来等待锁，而 lockInterruptibly会抛出异常；</li><li>synchronized被唤醒后会尝试获取锁，失败则会通过循环继续park()等待，因此实际上是不会被interrupt()中断的;</li><li>一般情况下，抛出异常时，会清空Thread的interrupt状态，在编程时需要注意；</li></ul><h2 id="3-网络中断相关"><a href="#3-网络中断相关" class="headerlink" title="3. 网络中断相关"></a>3. 网络中断相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>其中blocker是Thread的成员变量,Thread提供了blockedOn方法可以设置blocker:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">           blocker = b;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>如果一个nio通道实现了InterruptibleChannel接口，就可以响应interrupt()中断，其原理就在InterruptibleChannel接口的抽象实现类AbstractInterruptibleChannel的方法begin()中:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread target)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (!open)</span><br><span class="line">                               <span class="keyword">return</span>;</span><br><span class="line">                           open = <span class="keyword">false</span>;</span><br><span class="line">                           interrupted = target;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               AbstractInterruptibleChannel.<span class="keyword">this</span>.implCloseChannel();</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       blockedOn(interruptor);<span class="comment">//设置当前线程的blocker为interruptor</span></span><br><span class="line">       Thread me = Thread.currentThread();</span><br><span class="line">       <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">           interruptor.interrupt(me);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> AsynchronousCloseException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       blockedOn(<span class="keyword">null</span>);<span class="comment">//设置当前线程的blocker为null</span></span><br><span class="line">       Thread interrupted = <span class="keyword">this</span>.interrupted;</span><br><span class="line">      <span class="comment">//如果发生中断，Thread.interrupt方法会调用Interruptible的interrupt方法，</span></span><br><span class="line">     <span class="comment">//设置this.interrupted为当前线程</span></span><br><span class="line">       <span class="keyword">if</span> (interrupted != <span class="keyword">null</span> &amp;&amp; interrupted == Thread.currentThread()) &#123;</span><br><span class="line">           interrupted = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ClosedByInterruptException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!completed &amp;&amp; !open)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AsynchronousCloseException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class java.nio.channels.Channels.WritableByteChannelImpl</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            out.write(buf, <span class="number">0</span>, bytesToWrite);</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(bytesToWrite &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class java.nio.channels.Channels.ReadableByteChannelImpl</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            bytesRead = in.read(buf, <span class="number">0</span>, bytesToRead);</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(bytesRead &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>以上述代码为例，nio通道的ReadableByteChannel每次执行阻塞方法read()前，都会执行begin()，把Interruptible回调接口注册到当前线程上。当线程中断时，Thread.interrupt()触发回调接口Interruptible关闭io通道,导致read方法返回，最后在finally块中执行end()方法检查中断标记，抛出ClosedByInterruptException;</li></ul><p><strong>Selector的实现类似：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread ignore)</span> </span>&#123;</span><br><span class="line">                        AbstractSelector.<span class="keyword">this</span>.wakeup();</span><br><span class="line">                    &#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        AbstractInterruptibleChannel.blockedOn(interruptor);</span><br><span class="line">        Thread me = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">            interruptor.interrupt(me);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractInterruptibleChannel.blockedOn(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.class EPollSelectorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            pollWrapper.poll(timeout);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            end();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到当发生中断时会调用wakeup方法唤醒poll方法，但并不会抛出中断异常；</p><h2 id="4-通过interrupted-关闭线程"><a href="#4-通过interrupted-关闭线程" class="headerlink" title="4. 通过interrupted()关闭线程"></a>4. 通过interrupted()关闭线程</h2><ul><li>总所周知，<code>Thread.stop, Thread.suspend, Thread.resume</code> 都已经被废弃了。因为它们太暴力了，是不安全的，这种暴力中断线程是一种不安全的操作，举个栗子来说明其可能造成的问题：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopThread thread = <span class="keyword">new</span> StopThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 休眠1秒，确保线程进入运行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 暂停线程</span></span><br><span class="line">        thread.stop();</span><br><span class="line"><span class="comment">//      thread.interrupt();</span></span><br><span class="line">        <span class="comment">// 确保线程已经销毁</span></span><br><span class="line">        <span class="keyword">while</span> (thread.isAlive()) &#123; &#125;</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        thread.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这是一个同步原子操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ++x;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 休眠3秒,模拟耗时操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"x="</span> + x + <span class="string">" y="</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，run方法里是一个同步的原子操作，x和y必须要共同增加，然而这里如果调用thread.stop()方法强制中断线程，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">0</span></span><br></pre></td></tr></table></figure><p> 没有异常，也破坏了我们的预期。如果这种问题出现在我们的程序中，会引发难以预期的异常。因此这种不安全的方式很早就被废弃了。取而代之的是interrupt()，上述代码如果采用thread.interrupt()方法，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">1</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ThreadTest$StopThread.run(ThreadTest.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure><p> <strong>x=1,y=1 这个结果是符合我们的预期，同时还抛出了个异常，这个异常下文详说。</strong></p><p><strong>interrupt() 它基于「一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。」思想，是一个比较温柔的做法，它更类似一个标志位。其实作用不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</strong></p><p><strong>interrupt() 并不能真正的中断线程，这点要谨记。需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就需要这样做：</strong></p><ol><li>在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。</li><li>在调用阻塞方法时正确处理InterruptedException异常。（例如：catch异常后就结束线程。）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心 interrupt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">         checkAccess();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这个方法不会清除中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>首先讲 interrupt() 方法：</strong></p><ol><li>interrupt 中断操作时，非自身打断需要先检测是否有中断权限，这由jvm的安全机制配置；</li><li>如果线程处于<code>sleep, wait, join</code>等状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常；</li><li>如果线程处于I/O阻塞状态，将会抛出ClosedByInterruptException（IOException的子类）异常；</li><li>如果线程在Selector上被阻塞，select方法将立即返回；</li><li>如果非以上情况，将直接标记 interrupt 状态；</li></ol><p><strong>注意：interrupt 操作不会打断所有阻塞，只有上述阻塞情况才在jvm的打断范围内，如处于锁阻塞的线程，不会受 interrupt 中断；</strong></p><p><strong>等待情况下中断，抛出异常后线程恢复非中断状态，即 interrupted = false</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"1"</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread has been interrupt!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"isInterrupted: "</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread has been interrupt!</span><br><span class="line">isInterrupted: <span class="keyword">false</span></span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure><p><strong>调用Thread.interrupted() 方法后线程恢复非中断状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"1"</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"first :"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"second:"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first :<span class="keyword">true</span></span><br><span class="line">second:<span class="keyword">false</span></span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure><p><strong>上述两种隐含的状态恢复操作，是符合常理的，因为线程标记为中断后，用户没有真正中断线程，必然将其恢复为false。理论上Thread.interrupted()调用后，如果已中断，应该执行退出操作，不会重复调用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-线程中断&quot;&gt;&lt;a href=&quot;#Java-基础-线程中断&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-线程中断&quot;&gt;&lt;/a&gt;Java-基础-线程中断&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Thread提供了interrupt方法，中断线程的执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出&lt;code&gt;InterruptedException&lt;/code&gt;,同时清除线程的中断状态;&lt;/li&gt;
&lt;li&gt;如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；&lt;/li&gt;
&lt;li&gt;如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 核心 interrupt 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; != Thread.currentThread()) &lt;span class=&quot;comment&quot;&gt;// 非本线程，需要检查权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         checkAccess();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (blockerLock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         Interruptible b = blocker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (b != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             interrupt0();           &lt;span class=&quot;comment&quot;&gt;// 仅仅设置interrupt标志位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             b.interrupt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);    &lt;span class=&quot;comment&quot;&gt;// 调用如 I/O 操作定义的中断方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     interrupt0();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; currentThread().isInterrupted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 这个方法不会清除中断状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isInterrupted(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; ClearInterrupted)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="线程中断" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-05-网络层</title>
    <link href="http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-05-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-05-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2020-08-27T04:45:24.000Z</published>
    <updated>2020-09-16T06:05:42.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-05-网络层"><a href="#计算机网络-05-网络层" class="headerlink" title="计算机网络-05-网络层"></a>计算机网络-05-网络层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（<code>Address Resolution Protocol</code>）</li><li>网际控制报文协议 ICMP（<code>Internet Control Message Protocol</code>）</li><li>网际组管理协议 IGMP（<code>Internet Group Management Protocol</code>）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145836206.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145806629.png" alt="mark"></p><a id="more"></a><h2 id="1-IP首部格式"><a href="#1-IP首部格式" class="headerlink" title="1. IP首部格式"></a>1. IP首部格式</h2><ul><li><p><strong>版本</strong>   : 有 4（<code>IPv4</code>）和 6（<code>IPv6</code>）两个值；</p></li><li><p><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度</strong>   : 包括首部长度和数据部分长度。</p></li><li><p><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p></li><li><p><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-150110526.png" alt="mark"></p><h2 id="2-IP-地址编址方式"><a href="#2-IP-地址编址方式" class="headerlink" title="2. IP 地址编址方式"></a>2. IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-155800467.png" alt="mark"></p><h3 id="2-2-子网划分"><a href="#2-2-子网划分" class="headerlink" title="2.2 子网划分"></a>2.2 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><h3 id="2-3-无分类"><a href="#2-3-无分类" class="headerlink" title="2.3 无分类"></a>2.3 无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="3-地址解析协议-ARP协议"><a href="#3-地址解析协议-ARP协议" class="headerlink" title="3. 地址解析协议 ARP协议"></a>3. 地址解析协议 ARP协议</h2><ul><li>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-160941278.png" alt="mark"></p><ul><li>ARP 实现由 IP 地址得到 MAC 地址。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161128364.png" alt="mark"></p><ul><li><strong>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</strong></li><li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161409408.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161422234.png" alt="mark"></p><h2 id="4-网际控制报文协议-ICMP"><a href="#4-网际控制报文协议-ICMP" class="headerlink" title="4. 网际控制报文协议 ICMP"></a>4. 网际控制报文协议 ICMP</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161731437.png" alt="mark"></p><ul><li>ICMP 报文分为<strong>差错报告报文</strong>和<strong>询问报文</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-161929687.png" alt="mark"></p><h3 id="4-1-Ping"><a href="#4-1-Ping" class="headerlink" title="4.1 Ping"></a>4.1 Ping</h3><ul><li><strong>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</strong></li><li>Ping 的原理是通过向目的主机发送<code>ICMP Echo</code>请求报文，目的主机收到之后会发送 <code>Echo</code>回答报文。<code>Ping</code> 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</li></ul><h3 id="4-2-Traceroute"><a href="#4-2-Traceroute" class="headerlink" title="4.2 Traceroute"></a>4.2 Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="5-网络地址转换-NAT"><a href="#5-网络地址转换-NAT" class="headerlink" title="5. 网络地址转换 NAT"></a>5. 网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162506572.png" alt="mark"></p><h2 id="6-虚拟网络-VPN"><a href="#6-虚拟网络-VPN" class="headerlink" title="6. 虚拟网络 VPN"></a>6. 虚拟网络 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162739534.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-162754293.png" alt="mark"></p><h2 id="7-路由器"><a href="#7-路由器" class="headerlink" title="7. 路由器"></a>7. 路由器</h2><h3 id="7-1-路由器结构"><a href="#7-1-路由器结构" class="headerlink" title="7.1 路由器结构"></a>7.1 路由器结构</h3><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-170149630.png" alt="mark"></p><h3 id="7-2-路由分组转发流程"><a href="#7-2-路由分组转发流程" class="headerlink" title="7.2 路由分组转发流程"></a>7.2 路由分组转发流程</h3><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-170414340.png" alt="mark"></p><h3 id="7-3-路由选择协议"><a href="#7-3-路由选择协议" class="headerlink" title="7.3 路由选择协议"></a>7.3 路由选择协议</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的<strong>自治系统 AS</strong>，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p><strong>可以把路由选择协议划分为两大类：</strong></p><ul><li><strong>自治系统内部的路由选择：RIP 和 OSPF</strong></li><li><strong>自治系统间的路由选择：BGP</strong></li></ul><h3 id="1-内部网关协议-RIP"><a href="#1-内部网关协议-RIP" class="headerlink" title="1. 内部网关协议 RIP"></a>1. 内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-OSPF"><a href="#2-内部网关协议-OSPF" class="headerlink" title="2. 内部网关协议 OSPF"></a>2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3 id="3-外部网关协议BGP"><a href="#3-外部网关协议BGP" class="headerlink" title="3. 外部网关协议BGP"></a>3. 外部网关协议BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-171655956.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-05-网络层&quot;&gt;&lt;a href=&quot;#计算机网络-05-网络层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-05-网络层&quot;&gt;&lt;/a&gt;计算机网络-05-网络层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址解析协议 ARP（&lt;code&gt;Address Resolution Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;网际控制报文协议 ICMP（&lt;code&gt;Internet Control Message Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;网际组管理协议 IGMP（&lt;code&gt;Internet Group Management Protocol&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145836206.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200827-145806629.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="ip" scheme="http://zhuuu.work/tags/ip/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-06-数据链路层</title>
    <link href="http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-06-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-06-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-08-27T04:45:24.000Z</published>
    <updated>2020-09-16T06:13:04.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-06-数据链路层"><a href="#计算机网络-06-数据链路层" class="headerlink" title="计算机网络-06-数据链路层"></a>计算机网络-06-数据链路层</h1><h2 id="前言-链路层的基本问题"><a href="#前言-链路层的基本问题" class="headerlink" title="前言 : 链路层的基本问题"></a>前言 : 链路层的基本问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-093935934.png" alt="mark"></p><a id="more"></a><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h3><ul><li><p>透明表示一个实际存在的事物看起来好像不存在一样。</p></li><li><p>帧使用首部和尾部进行定界，<strong>如果帧的数据部分含有和首部尾部相同的内容</strong>，那么帧的开始和结束位置就会被错误的判定。</p></li><li><p>需要在数据部分出现首部尾部相同的内容前面插入转义字符。<strong>如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符</strong>。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，<strong>用户察觉不到转义字符的存在</strong>。</p></li></ul><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h3><ul><li>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</li></ul><h1 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h1><h2 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h2><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h2 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h2><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h1 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h1><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为   <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-095659471.png" alt="mark"></p><h1 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h1><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100345698.png" alt="mark"></p><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100434363.png" alt="mark"></p><h1 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h1><ul><li>MAC 地址是链路层地址，<strong>长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</strong></li><li><strong>一台主机拥有多少个网络适配器就有多少个 MAC 地址</strong>。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</li></ul><h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-100818521.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-06-数据链路层&quot;&gt;&lt;a href=&quot;#计算机网络-06-数据链路层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-06-数据链路层&quot;&gt;&lt;/a&gt;计算机网络-06-数据链路层&lt;/h1&gt;&lt;h2 id=&quot;前言-链路层的基本问题&quot;&gt;&lt;a href=&quot;#前言-链路层的基本问题&quot; class=&quot;headerlink&quot; title=&quot;前言 : 链路层的基本问题&quot;&gt;&lt;/a&gt;前言 : 链路层的基本问题&lt;/h2&gt;&lt;h3 id=&quot;1-封装成帧&quot;&gt;&lt;a href=&quot;#1-封装成帧&quot; class=&quot;headerlink&quot; title=&quot;1. 封装成帧&quot;&gt;&lt;/a&gt;1. 封装成帧&lt;/h3&gt;&lt;p&gt;将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-093935934.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="mac地址" scheme="http://zhuuu.work/tags/mac%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-04-抓包</title>
    <link href="http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-04-%E6%8A%93%E5%8C%85/"/>
    <id>http://zhuuu.work/2020/08/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-04-%E6%8A%93%E5%8C%85/</id>
    <published>2020-08-27T04:02:24.000Z</published>
    <updated>2020-08-27T06:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-04-抓包"><a href="#计算机网络-04-抓包" class="headerlink" title="计算机网络-04-抓包"></a>计算机网络-04-抓包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="1-抓包的作用"><a href="#1-抓包的作用" class="headerlink" title="1. 抓包的作用"></a>1. 抓包的作用</h2><p>在日常工作中，我们经常会用到抓包工具，看看前后台的数据传输、分析分析协议内容之类的。对于抓包工具在测试中的使用粗略归纳了几点：</p><p><strong>1.从功能测试角度，通过抓包查看隐藏字段</strong></p><ul><li>Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 C RSF 攻击，防网络爬虫，以及一些其他用途。<br> 这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。</li></ul><p><strong>2. 通过抓包工具了解协议内容，方便开展接口和性能测试</strong></p><ul><li>性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；<br> 接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。</li></ul><p><strong>3. 需要通过抓包工具，检查数据加密</strong></p><ul><li>安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。</li></ul><p><strong>4. 处理前后端 bug 归属之争</strong></p><ul><li>在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么 可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。</li></ul><p><strong>5. 通过抓包分析，可以更好的理解整个系统</strong></p><ul><li>经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。</li></ul><a id="more"></a><h2 id="2-中间人攻击"><a href="#2-中间人攻击" class="headerlink" title="2. 中间人攻击"></a>2. 中间人攻击</h2><p>首先fiddler截获客户端浏览器发送给服务器的https请求， 此时还未建立握手。</p><p>第一步， fiddler向服务器发送请求进行握手， 获取到服务器的CA证书， 用根证书公钥进行解密， 验证服务器数据签名， 获取到服务器CA证书公钥。</p><p>第二步， fiddler伪造自己的CA证书， 冒充服务器证书传递给客户端浏览器， 客户端浏览器做跟fiddler一样的事。</p><p>第三步， 客户端浏览器生成https通信用的对称密钥， 用fiddler伪造的证书公钥加密后传递给服务器， 被fiddler截获。</p><p>第四步， fiddler将截获的密文用自己伪造证书的私钥解开， 获得https通信用的对称密钥。</p><p>第五步， fiddler将对称密钥用服务器证书公钥加密传递给服务器， 服务器用私钥解开后建立信任， 握手完成， 用对称密钥加密消息， 开始通信。</p><p>第六步， fiddler接收到服务器发送的密文， 用对称密钥解开， 获得服务器发送的明文。再次加密， 发送给客户端浏览器。</p><p>第七步， 客户端向服务器发送消息， 用对称密钥加密， 被fidller截获后， 解密获得明文。</p><p>由于fiddler一直拥有通信用对称密钥， 所以在整个https通信过程中信息对其透明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-04-抓包&quot;&gt;&lt;a href=&quot;#计算机网络-04-抓包&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-04-抓包&quot;&gt;&lt;/a&gt;计算机网络-04-抓包&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;1-抓包的作用&quot;&gt;&lt;a href=&quot;#1-抓包的作用&quot; class=&quot;headerlink&quot; title=&quot;1. 抓包的作用&quot;&gt;&lt;/a&gt;1. 抓包的作用&lt;/h2&gt;&lt;p&gt;在日常工作中，我们经常会用到抓包工具，看看前后台的数据传输、分析分析协议内容之类的。对于抓包工具在测试中的使用粗略归纳了几点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.从功能测试角度，通过抓包查看隐藏字段&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 C RSF 攻击，防网络爬虫，以及一些其他用途。&lt;br&gt; 这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 通过抓包工具了解协议内容，方便开展接口和性能测试&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；&lt;br&gt; 接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 需要通过抓包工具，检查数据加密&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 处理前后端 bug 归属之争&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么 可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 通过抓包分析，可以更好的理解整个系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--41-数据流中的中位数</title>
    <link href="http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2020-08-26T07:15:53.000Z</published>
    <updated>2020-09-09T04:23:13.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–41-数据流中的中位数"><a href="#剑指offer–41-数据流中的中位数" class="headerlink" title="剑指offer–41-数据流中的中位数"></a>剑指offer–41-<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-两个堆"><a href="#思路-两个堆" class="headerlink" title="思路 : 两个堆"></a><strong>思路 : 两个堆</strong></h2><p><strong>待优化的思路1：快排</strong></p><ul><li>其中位数的计算方法：首先对数组执行排序（使用O<em>(</em>N<em>log</em>N) 时间），然后返回中间元素即可（使用 O(1)时间）。</li><li>针对本题，根据以上思路，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。此方法的时间复杂度为 O(N)，其中包括： 查找元素插入位置O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。</li></ul><p><strong>思路2： 两个堆</strong></p><ul><li>事实上，我们只关心在中间的那两个数（或者一个数），其它数没有必要进行 “比较” 和 “交换” 的操作。</li><li>在我们学习过的数据结构里，堆就有类似的性质，每次都从堆里得到一个 “最值” 而其它元素无需排序，这样就可以以O(logN) 的复杂度每次都从堆中取出最值。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111604101.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111617276.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111821068.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-112110039.png" alt="mark"></p><p><strong>总结：</strong></p><ul><li><strong>为了找到添加新数据以后，数据流的中位数，我们让这个新数据在大顶堆和小顶堆中都走了一遍。而为了让大顶堆的元素多 1 个，我们让从小顶堆中又拿出一个元素“送回”给大顶堆；</strong></li><li>将元素放入优先队列以后，优先队列会以对数时间复杂度自行调整，把“最优值”放入堆顶，这是使用优先队列解决这个问题的原因。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前大顶堆和小顶堆的元素个数之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxheap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minheap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">        minheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        maxheap.offer(num);</span><br><span class="line">        minheap.add(maxheap.poll());</span><br><span class="line">        <span class="comment">// 如果两个堆合起来的元素个数是奇数，小顶堆要拿出堆顶元素给大顶堆</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            maxheap.add(minheap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (maxheap.peek() + minheap.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) maxheap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度：</strong>O(logN) 优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的，综上时间复杂度是 O(logN) 级别的。</li><li><strong>空间复杂度：</strong>O(N) 占用堆的大小</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;a href=&quot;#剑指offer–41-数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;/a&gt;剑指offer–41-&lt;a href=&quot;https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据流中的中位数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;[2,3,4] 的中位数是 3&lt;/p&gt;
&lt;p&gt;[2,3] 的中位数是 (2 + 3) / 2 = 2.5&lt;/p&gt;
&lt;p&gt;设计一个支持以下两种操作的数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void addNum(int num) - 从数据流中添加一个整数到数据结构中。&lt;/li&gt;
&lt;li&gt;double findMedian() - 返回目前所有元素的中位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[1],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,null,1.50000,null,2.00000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,2.00000,null,2.50000]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--52-两个链表的第一个公共节点</title>
    <link href="http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--56-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--56-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2020-08-26T07:12:53.000Z</published>
    <updated>2020-08-26T11:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–52-两个链表的第一个公共节点"><a href="#剑指offer–52-两个链表的第一个公共节点" class="headerlink" title="剑指offer–52-两个链表的第一个公共节点"></a>剑指offer–52-<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191825466.png" alt="mark"></p><p>在节点 c1 开始相交。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191838788.png" alt="mark"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-192018933.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-192115537.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路：</p><ul><li><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p></li><li><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = headA;</span><br><span class="line">        ListNode l2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            <span class="comment">// 我走过你走的路</span></span><br><span class="line">            l1 = l1 == <span class="keyword">null</span>? headB:l1.next;</span><br><span class="line">           <span class="comment">//  你走过我走的路</span></span><br><span class="line">            l2 = l2 == <span class="keyword">null</span>? headA:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 所以我们才能相遇</span></span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O（n + m）</strong></li><li><strong>空间复杂度:O(1)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–52-两个链表的第一个公共节点&quot;&gt;&lt;a href=&quot;#剑指offer–52-两个链表的第一个公共节点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–52-两个链表的第一个公共节点&quot;&gt;&lt;/a&gt;剑指offer–52-&lt;a href=&quot;https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个链表的第一个公共节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入两个链表，找出它们的第一个公共节点。&lt;/p&gt;
&lt;p&gt;如下面的两个链表&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191825466.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在节点 c1 开始相交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191838788.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID</title>
    <link href="http://zhuuu.work/2020/08/25/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <id>http://zhuuu.work/2020/08/25/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8FID/</id>
    <published>2020-08-25T09:38:38.000Z</published>
    <updated>2020-09-20T06:15:49.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>在说分布式ID的具体实现之前，我们来简单分析一下为什么用分布式ID？分布式ID应该满足哪些特征？</li></ul><p><strong>1、什么是分布式ID？</strong></p><p>拿MySQL数据库举个栗子：</p><ul><li>在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。</li><li>但随着数据日渐增长，主从同步也扛不住了，就需要<strong>对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据</strong>，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有<code>唯一ID</code>做标识。此时一个能够生成<code>全局唯一ID</code>的系统是非常必要的。那么这个<code>全局唯一ID</code>就叫<code>分布式ID</code>。</li></ul><p><strong>2、那么分布式ID需要满足那些条件？</strong></p><ul><li>全局唯一：必须保证ID是全局性唯一的，基本要求</li><li>高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈</li><li>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性</li><li>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单</li><li>趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求</li></ul><a id="more"></a><h2 id="一-九种生成方案"><a href="#一-九种生成方案" class="headerlink" title="一. 九种生成方案"></a>一. 九种生成方案</h2><p>今天主要分析一下以下9种，分布式ID生成器方式以及优缺点：</p><ul><li>UUID</li><li>数据库自增ID</li><li>数据库多主模式</li><li>号段模式</li><li>Redis</li><li>雪花算法（SnowFlake）</li><li>滴滴出品（TinyID）</li><li>百度 （Uidgenerator）</li><li>美团（Leaf）</li></ul><p>那么它们都是如何实现？以及各自有什么优缺点？我们往下看</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224053071.png" alt="mark"></p><p><strong>1、基于UUID</strong></p><p>在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是UUID，毕竟它有着全球唯一的特性。那么UUID可以做分布式ID吗？答案是可以的，但是并不推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">       String uuid &#x3D; UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);</span><br><span class="line">       System.out.println(uuid);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>UUID</code>的生成简单到只有一行代码，输出结果 <code>c2b8c2b9e46c47e3b30dca3b0d447718</code>，但UUID却并不适用于实际的业务需求。像用作订单号<code>UUID</code>这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务<code>主键ID</code>，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作<code>分布式ID</code>。</p><p><strong>优点：</strong></p><ul><li>生成足够简单，本地生成无网络消耗，具有唯一性</li></ul><p><strong>缺点：</strong></p><ul><li>无序的字符串，不具备趋势自增特性</li><li>没有具体的业务含义</li><li>长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 <code>UUID</code> 的无序性会导致数据位置频繁变动，严重影响性能。</li></ul><p><strong>2、基于数据库自增ID</strong></p><p>基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224302161.png" alt="mark"></p><p>当我们需要一个ID的时候，向表中插入一条记录返回<code>主键ID</code>，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</p><p><strong>优点：</strong></p><ul><li>实现简单，ID单调自增，数值类型查询速度快</li></ul><p><strong>缺点：</strong></p><ul><li>DB单点存在宕机风险，无法扛住高并发场景</li></ul><p><strong>3、基于数据库集群模式</strong></p><ul><li>前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。</li><li>那这样还会有个问题，两个MySQL实例的自增ID都从1开始，<strong>会生成重复的ID怎么办？</strong></li></ul><p><strong>解决方案</strong>：设置<code>起始值</code>和<code>自增步长</code></p><p>MySQL_1 配置：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224410327.png" alt="mark"></p><p>MySQL_2 配置：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224414705.png" alt="mark"></p><p>这样两个MySQL实例的自增ID分别就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、3、5、7、9</span><br><span class="line">2、4、6、8、10</span><br></pre></td></tr></table></figure><p>那如果集群后的性能还是扛不住高并发咋办？就要进行MySQL扩容增加节点，这是一个比较麻烦的事。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224448462.png" alt="mark"></p><p><strong>缺点：</strong></p><ul><li>增加第三台<code>MySQL</code>实例需要人工修改一、二两台<code>MySQL实例</code>的起始值和步长，把<code>第三台机器的ID</code>起始生成位置设定在比现有<code>最大自增ID</code>的位置远一些，但必须在一、二两台<code>MySQL实例</code>ID还没有增长到<code>第三台MySQL实例</code>的<code>起始ID</code>值的时候，否则<code>自增ID</code>就要出现重复了，<strong>必要时可能还需要停机修改</strong>。</li></ul><p><strong>优点：</strong></p><ul><li>解决DB单点问题</li></ul><p><strong>4、基于数据库的号段模式</strong></p><ul><li>号段模式是当下<strong>分布式ID生成器的主流实现方式之一</strong>，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围</li><li>例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE id_generator (</span><br><span class="line">  id int(10) NOT NULL,</span><br><span class="line">  max_id bigint(20) NOT NULL COMMENT &#39;当前最大id&#39;,</span><br><span class="line">  step int(20) NOT NULL COMMENT &#39;号段的布长&#39;,</span><br><span class="line">  biz_type    int(20) NOT NULL COMMENT &#39;业务类型&#39;,</span><br><span class="line">  version int(20) NOT NULL COMMENT &#39;版本号&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>biz_type ：代表不同业务类型</p><p>max_id ：当前最大的可用id</p><p>step ：代表号段的长度</p><p>version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224734804.png" alt="mark"></p><ul><li>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update id_generator set max_id &#x3D; #&#123;max_id+step&#125;, version &#x3D; version + 1 where version &#x3D; # &#123;version&#125; and biz_type &#x3D; XXX</span><br></pre></td></tr></table></figure><ul><li>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</li></ul><p><strong>5、基于Redis模式</strong></p><p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200916/224902154.png" alt="mark"></p><p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p><ul><li><strong><code>RDB</code>会定时打一个快照进行持久化</strong>，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li><li><strong><code>AOF</code>会对每条写命令进行持久化</strong>，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li></ul><p><strong>6、基于雪花算法（Snowflake）模式</strong></p><ul><li>雪花算法（<code>Snowflake</code>）是<code>twitter</code>公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/161626004.png" alt="mark"></p><ul><li><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。<ul><li><code>Snowflake</code> ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</span><br><span class="line">时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) &#x2F; (1000L * 60 * 60 * 24 * 365) &#x3D; 69年</span><br><span class="line">工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。</span><br><span class="line">序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</span><br></pre></td></tr></table></figure><ul><li>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://github.com/beyondfengyu/SnowFlake</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlakeShortUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_TIMESTAMP = <span class="number">1480166465631L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>;   <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">5</span>;     <span class="comment">//机器标识占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_BIT = <span class="number">5</span>; <span class="comment">//数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_DATA_CENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATA_CENTER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> dataCenterId;  <span class="comment">//数据中心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> machineId;     <span class="comment">//机器标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimeStamp = -<span class="number">1L</span>;  <span class="comment">//上一次时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mill = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastTimeStamp) &#123;</span><br><span class="line">            mill = getNewTimeStamp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataCenterId 数据中心ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> machineId    机器标志ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlakeShortUrl</span><span class="params">(<span class="keyword">long</span> dataCenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"DtaCenterId can't be greater than MAX_DATA_CENTER_NUM or less than 0！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"MachineId can't be greater than MAX_MACHINE_NUM or less than 0！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currTimeStamp = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Clock moved backwards.  Refusing to generate id"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp == lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">//相同毫秒内，序列号自增</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                currTimeStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不同毫秒内，序列号置为0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastTimeStamp = currTimeStamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class="comment">//时间戳部分</span></span><br><span class="line">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       <span class="comment">//数据中心部分</span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             <span class="comment">//机器标识部分</span></span><br><span class="line">                | sequence;                             <span class="comment">//序列号部分</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SnowFlakeShortUrl snowFlake = <span class="keyword">new</span> SnowFlakeShortUrl(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); i++) &#123;</span><br><span class="line">            <span class="comment">//10进制</span></span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、百度（uid-generator）</strong></p><ul><li><code>uid-generator</code>是由百度技术部开发，项目GitHub地址 </li><li><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的<code>snowflake</code>算法不同在于，<code>uid-generator</code>支持自<code>定义时间戳</code>、<code>工作机器ID</code>和 <code>序列号</code> 等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略。</li><li><code>uid-generator</code>需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的<code>workId</code>数据由host，port组成。</li></ul><p><strong>对于<code>uid-generator</code> ID组成结构</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;workId&#96;，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，</span><br><span class="line">需要注意的是，和原始的&#96;snowflake&#96;不太一样，时间的单位是秒，而不是毫秒，</span><br><span class="line">&#96;workId&#96;也不一样，而且同一应用每次重启就会消费一个&#96;workId&#96;</span><br></pre></td></tr></table></figure><p><strong>8、美团（Leaf）</strong></p><p><code>Leaf</code>由美团开发，github地址：<a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fgithub.com%2FMeituan-Dianping%2FLeaf">https://github.com/Meituan-Dianping/Leaf</a><br><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用。</p><p><strong>号段模式</strong></p><ul><li>先导入源码 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fgithub.com%2FMeituan-Dianping%2FLeaf">https://github.com/Meituan-Dianping/Leaf</a> ，在建一张表<code>leaf_alloc</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;leaf_alloc&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;leaf_alloc&#96; (</span><br><span class="line">  &#96;biz_tag&#96; varchar(128)  NOT NULL DEFAULT &#39;&#39; COMMENT &#39;业务key&#39;,</span><br><span class="line">  &#96;max_id&#96; bigint(20) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;当前已经分配了的最大id&#39;,</span><br><span class="line">  &#96;step&#96; int(11) NOT NULL COMMENT &#39;初始步长，也是动态调整的最小步长&#39;,</span><br><span class="line">  &#96;description&#96; varchar(256)  DEFAULT NULL COMMENT &#39;业务key的描述&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;数据库维护的更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;biz_tag&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><ul><li>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leaf.name&#x3D;com.sankuai.leaf.opensource.test</span><br><span class="line">leaf.segment.enable&#x3D;true</span><br><span class="line">leaf.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;leaf_test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;characterSetResults&#x3D;utf8</span><br><span class="line">leaf.jdbc.username&#x3D;root</span><br><span class="line">leaf.jdbc.password&#x3D;root</span><br><span class="line"></span><br><span class="line">leaf.snowflake.enable&#x3D;false</span><br><span class="line">#leaf.snowflake.zk.address&#x3D;</span><br><span class="line">#leaf.snowflake.port&#x3D;</span><br></pre></td></tr></table></figure><ul><li>启动<code>leaf-server</code> 模块的 <code>LeafServerApplication</code>项目就跑起来了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">号段模式获取分布式自增ID的测试url ：http：&#x2F;&#x2F;localhost：8080&#x2F;api&#x2F;segment&#x2F;get&#x2F;leaf-segment-test</span><br><span class="line"></span><br><span class="line">监控号段模式：http:&#x2F;&#x2F;localhost:8080&#x2F;cache</span><br></pre></td></tr></table></figure><p><strong>snowflake模式</strong></p><ul><li><code>Leaf</code>的<code>snowflake</code>模式依赖于<code>ZooKeeper</code>，<strong>不同于<code>原始snowflake</code>算法也主要是在<code>workId</code>的生成上</strong></li><li><code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序Id来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code>。</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163411884.png" alt="mark" style="zoom:200%;" /><ul><li>snowflake模式获取分布式自增ID的测试url：[<a href="http://localhost:8080/api/snowflake/get/test]" target="_blank" rel="noopener">http://localhost:8080/api/snowflake/get/test]</a></li></ul><p><strong>9、滴滴（Tinyid）</strong></p><p><code>Tinyid</code>由滴滴开发，Github地址：<a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fgithub.com%2Fdidi%2Ftinyid">https://github.com/didi/tinyid</a>。</p><p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163635480.png" alt="mark"></p><p><strong>Http方式接入</strong></p><p>（1）导入Tinyid源码：<br>git clone <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fgithub.com%2Fdidi%2Ftinyid.git">https://github.com/didi/tinyid.git</a></p><p>（2）创建数据表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tiny_id_info&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span><br><span class="line">  &#96;biz_type&#96; varchar(63) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;业务类型，唯一&#39;,</span><br><span class="line">  &#96;begin_id&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#39;,</span><br><span class="line">  &#96;max_id&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;当前最大id&#39;,</span><br><span class="line">  &#96;step&#96; int(11) DEFAULT &#39;0&#39; COMMENT &#39;步长&#39;,</span><br><span class="line">  &#96;delta&#96; int(11) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;每次id增量&#39;,</span><br><span class="line">  &#96;remainder&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;余数&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NOT NULL DEFAULT &#39;2010-01-01 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT &#39;2010-01-01 00:00:00&#39; COMMENT &#39;更新时间&#39;,</span><br><span class="line">  &#96;version&#96; bigint(20) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;版本号&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uniq_biz_type&#96; (&#96;biz_type&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8 COMMENT &#39;id信息表&#39;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;tiny_id_token&#96; (</span><br><span class="line">  &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增id&#39;,</span><br><span class="line">  &#96;token&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;token&#39;,</span><br><span class="line">  &#96;biz_type&#96; varchar(63) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;此token可访问的业务类型标识&#39;,</span><br><span class="line">  &#96;remark&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;备注&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NOT NULL DEFAULT &#39;2010-01-01 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT &#39;2010-01-01 00:00:00&#39; COMMENT &#39;更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8 COMMENT &#39;token信息表&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;tiny_id_info&#96; (&#96;id&#96;, &#96;biz_type&#96;, &#96;begin_id&#96;, &#96;max_id&#96;, &#96;step&#96;, &#96;delta&#96;, &#96;remainder&#96;, &#96;create_time&#96;, &#96;update_time&#96;, &#96;version&#96;)</span><br><span class="line">VALUES</span><br><span class="line">    (1, &#39;test&#39;, 1, 1, 100000, 1, 0, &#39;2018-07-21 23:52:58&#39;, &#39;2018-07-22 23:19:27&#39;, 1);</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;tiny_id_info&#96; (&#96;id&#96;, &#96;biz_type&#96;, &#96;begin_id&#96;, &#96;max_id&#96;, &#96;step&#96;, &#96;delta&#96;, &#96;remainder&#96;, &#96;create_time&#96;, &#96;update_time&#96;, &#96;version&#96;)</span><br><span class="line">VALUES</span><br><span class="line">    (2, &#39;test_odd&#39;, 1, 1, 100000, 2, 1, &#39;2018-07-21 23:52:58&#39;, &#39;2018-07-23 00:39:24&#39;, 3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;tiny_id_token&#96; (&#96;id&#96;, &#96;token&#96;, &#96;biz_type&#96;, &#96;remark&#96;, &#96;create_time&#96;, &#96;update_time&#96;)</span><br><span class="line">VALUES</span><br><span class="line">    (1, &#39;0f673adf80504e2eaa552f5d791b644c&#39;, &#39;test&#39;, &#39;1&#39;, &#39;2017-12-14 16:36:46&#39;, &#39;2017-12-14 16:36:48&#39;);</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;tiny_id_token&#96; (&#96;id&#96;, &#96;token&#96;, &#96;biz_type&#96;, &#96;remark&#96;, &#96;create_time&#96;, &#96;update_time&#96;)</span><br><span class="line">VALUES</span><br><span class="line">    (2, &#39;0f673adf80504e2eaa552f5d791b644c&#39;, &#39;test_odd&#39;, &#39;1&#39;, &#39;2017-12-14 16:36:46&#39;, &#39;2017-12-14 16:36:48&#39;);</span><br></pre></td></tr></table></figure><p>（3）配置数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">datasource.tinyid.names&#x3D;primary</span><br><span class="line">datasource.tinyid.primary.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">datasource.tinyid.primary.url&#x3D;jdbc:mysql:&#x2F;&#x2F;ip:port&#x2F;databaseName?autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8</span><br><span class="line">datasource.tinyid.primary.username&#x3D;root</span><br><span class="line">datasource.tinyid.primary.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>（4）启动<code>tinyid-server</code>后测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取分布式自增ID: http:&#x2F;&#x2F;localhost:9999&#x2F;tinyid&#x2F;id&#x2F;nextIdSimple?bizType&#x3D;test&amp;token&#x3D;0f673adf80504e2eaa552f5d791b644c&#39;</span><br><span class="line">返回结果: 3</span><br><span class="line"></span><br><span class="line">批量获取分布式自增ID:</span><br><span class="line">http:&#x2F;&#x2F;localhost:9999&#x2F;tinyid&#x2F;id&#x2F;nextIdSimple?bizType&#x3D;test&amp;token&#x3D;0f673adf80504e2eaa552f5d791b644c&amp;batchSize&#x3D;10&#39;</span><br><span class="line">返回结果:  4,5,6,7,8,9,10,11,12,13</span><br></pre></td></tr></table></figure><p><strong>Java客户端方式接入</strong></p><ul><li>重复Http方式的（2）（3）操作</li><li>引入依赖</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163740832.png" alt="mark"></p><ul><li>配置文件</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163753437.png" alt="mark"></p><ul><li><code>test</code> 、<code>tinyid.token</code>是在数据库表中预先插入的数据，<code>test</code> 是具体业务类型，<code>tinyid.token</code>表示可访问的业务类型</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/163811537.png" alt="mark"></p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二. 总结"></a><strong>二. 总结</strong></h2><ul><li>本文只是简单介绍一下每种分布式ID生成器，旨在给大家一个详细学习的方向，每种生成方式都有它自己的优缺点，具体如何使用还要看具体的业务需求。</li></ul><p><strong>参考博客 ：</strong> <a href="https://zhuanlan.zhihu.com/p/152179727?utm_source" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/152179727?utm_source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式ID&quot;&gt;&lt;a href=&quot;#分布式ID&quot; class=&quot;headerlink&quot; title=&quot;分布式ID&quot;&gt;&lt;/a&gt;分布式ID&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在说分布式ID的具体实现之前，我们来简单分析一下为什么用分布式ID？分布式ID应该满足哪些特征？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1、什么是分布式ID？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿MySQL数据库举个栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。&lt;/li&gt;
&lt;li&gt;但随着数据日渐增长，主从同步也扛不住了，就需要&lt;strong&gt;对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据&lt;/strong&gt;，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有&lt;code&gt;唯一ID&lt;/code&gt;做标识。此时一个能够生成&lt;code&gt;全局唯一ID&lt;/code&gt;的系统是非常必要的。那么这个&lt;code&gt;全局唯一ID&lt;/code&gt;就叫&lt;code&gt;分布式ID&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2、那么分布式ID需要满足那些条件？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局唯一：必须保证ID是全局性唯一的，基本要求&lt;/li&gt;
&lt;li&gt;高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈&lt;/li&gt;
&lt;li&gt;高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性&lt;/li&gt;
&lt;li&gt;好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单&lt;/li&gt;
&lt;li&gt;趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="雪花算法" scheme="http://zhuuu.work/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux-03-PV</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-03-PV/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-03-PV/</id>
    <published>2020-08-25T08:52:53.000Z</published>
    <updated>2020-09-14T12:05:37.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-03-PV"><a href="#Linux-03-PV" class="headerlink" title="Linux-03-PV"></a>Linux-03-PV</h1><h2 id="1-疑惑解答"><a href="#1-疑惑解答" class="headerlink" title="1. 疑惑解答"></a>1. 疑惑解答</h2><ul><li>进程通常分为<strong>就绪、运行和阻塞</strong>三个工作状态。三种状态在某些条件下可以转换，三者之间的转换关系如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-131907370.png" alt="mark"></p><p>进程三个状态之间的转换就是靠PV操作来控制的。</p><p><strong>PV操作主要就是P操作、V操作和信号量。其中信号量起到了至关重要的作用。</strong></p><a id="more"></a><p><strong>信号量</strong></p><p>信号量是最早出现的用来解决<strong>进程同步与互斥问题</strong>的机制。　</p><ul><li>信号量由一个值和一个指针组成，指针指向等待该信号量的进程。信号量的值表示相应资源的使用情况。</li><li>信号量<code>S&gt;=0</code>时，S表示可用资源的数量。<strong>执行一次P操作意味着请求分配一个资源，因此S的值减1；</strong></li><li>当<code>S&lt;0</code>时，表示已经没有可用资源，S的绝对值表示当前等待该资源的进程数。请求者必须等待其他进程释放该类资源，才能继续运行。而执行<strong>一个V操作意味着释放一个资源，因此S的值加1；</strong></li><li>若S&lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。</li></ul><p>注意，信号量的值只能由PV操作来改变。</p><p><strong><em>\</em>关于PV操作容易产生的一些疑问：**</strong></p><p><strong>1，S大于0那就表示有临界资源可供使用，为什么不唤醒进程？</strong></p><ul><li>S大于0的确表示有临界资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒。</li></ul><p><strong>2，S小于0应该是说没有临界资源可供使用，为什么还要唤醒进程？</strong></p><ul><li>V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S&lt;0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。</li><li>比如，有两个某类资源，四个进程A、B、C、D要用该类资源，最开始S=2，当A进入，S=1，当B进入S=0，表明该类资源刚好用完， 当C进入时S=-1，表明有一个进程被阻塞了，D进入，S=-2。当A用完该类资源时，进行V操作，S=-1，释放该类资源，因为S&lt;0，表明有进程阻塞在该类资源上，于是唤醒一个。</li></ul><p><strong>3，如果是互斥信号量的话，应该设置信号量S=1，但是当有5个进程都访问的话，最后在该信号量的链表里会有4个在等待，也是说S=-4，那么第一个进程执行了V操作使S加1，释放了资源，下一个应该能够执行，但唤醒的这个进程在执行P操作时因S&lt;0，也还是执行不了，这是怎么回事呢？</strong></p><ul><li>当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区，并不需要执行P操作了，当执行完了临界区的程序后，就执行V操作。</li></ul><p><strong>4，S的绝对值表示等待的进程数，同时又表示临界资源，这到底是怎么回事？</strong></p><ul><li>当信号量S小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目</li><li>S大于0时表示可用的临界资源数。注意在不同情况下所表达的含义不一样。当等于0时，表示刚好用完。</li></ul><h2 id="2-临界区和临界资源"><a href="#2-临界区和临界资源" class="headerlink" title="2. 临界区和临界资源"></a>2. 临界区和临界资源</h2><ol><li><strong>临界区</strong></li></ol><ul><li>每个进程中访问临界资源的那段<strong>程序代码称为临界区</strong></li><li>每次只准许一个进程进入临界区，进入后不允许其他进程进入。</li></ul><ol start="2"><li><strong>临界资源</strong></li></ol><ul><li>临界资源是一次<strong>仅允许一个进程使用的共享资源</strong></li></ul><ol start="3"><li><strong>进程进入临界区的调度原则是：</strong></li></ol><ul><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区</li><li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ul><h2 id="3-PV操作"><a href="#3-PV操作" class="headerlink" title="3. PV操作"></a>3. PV操作</h2><p><strong>临界区：</strong>我们把并发进程中与共享变量有关的<strong>程序段称为临界区。</strong></p><p><strong>信号量S</strong>：</p><ul><li>信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；</li><li>当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</li></ul><p>​    <strong>P操作P（S）</strong>：将信号量S减去1，若结果小于0，则把调用P（S）的进程置成等待信号量S的状态。即为请求资源。</p><p>​    <strong>V操作V（S）</strong>：将信号量S加上1，若结果不大于0，则释放一个等待信号量S的进程。即为释放资源。</p><p>正如老师上课时所举的父亲给孩子吃苹果的例子一样，假如一个盘子只能放一个苹果，父亲往盘子里放了一个苹果。如果儿子吃了（<strong>V操作</strong>），父亲才可以接着放（<strong>P操作</strong>）；如果儿子不吃，那父亲就不能放苹果，只能等着。</p><p><strong>伪代码如下</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Procedure P (Var S：Semaphore)</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">S：=S - 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> S&lt;0 <span class="keyword">then</span> W(S) </span><br><span class="line"></span><br><span class="line">end; &#123; P &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Procedure V (Var S：Semaphore)</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">S：=S + 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> S&lt; = 0 <span class="keyword">then</span> R(S) </span><br><span class="line"></span><br><span class="line">end; &#123; V &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#       W(S)：表示把调用P（S）的进程置成等待信号量S的状态。</span></span><br><span class="line"><span class="comment">#R(S)：表示释放一个等待信号量S的进程。</span></span><br></pre></td></tr></table></figure><h3 id="3-1-进程互斥"><a href="#3-1-进程互斥" class="headerlink" title="3.1 进程互斥"></a>3.1 进程互斥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    利用信号量和PV操作实现进程互斥的一般模型是：</span><br><span class="line">进程P1              进程P2           ……          进程Pn</span><br><span class="line">……                  ……                           ……</span><br><span class="line">P（S）；              P（S）；                         P（S）；</span><br><span class="line">临界区；             临界区；                        临界区；</span><br><span class="line">V（S）；              V（S）；                        V（S）；</span><br><span class="line">……                  ……            ……           ……</span><br></pre></td></tr></table></figure><pre><code>其中信号量S用于互斥，初值为1。使用PV操作实现进程互斥时应该注意的是：（1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。（2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。（3）互斥信号量的初值一般为1。</code></pre><h3 id="3-2-进程同步"><a href="#3-2-进程同步" class="headerlink" title="3.2 进程同步"></a>3.2 进程同步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">利用信号量和PV操作实现进程同步</span><br><span class="line">PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。</span><br><span class="line"></span><br><span class="line">    使用PV操作实现进程同步时应该注意的是：</span><br><span class="line"></span><br><span class="line">    （1）分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。</span><br><span class="line">    （2）信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。</span><br><span class="line">    （3）同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-03-PV&quot;&gt;&lt;a href=&quot;#Linux-03-PV&quot; class=&quot;headerlink&quot; title=&quot;Linux-03-PV&quot;&gt;&lt;/a&gt;Linux-03-PV&lt;/h1&gt;&lt;h2 id=&quot;1-疑惑解答&quot;&gt;&lt;a href=&quot;#1-疑惑解答&quot; class=&quot;headerlink&quot; title=&quot;1. 疑惑解答&quot;&gt;&lt;/a&gt;1. 疑惑解答&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程通常分为&lt;strong&gt;就绪、运行和阻塞&lt;/strong&gt;三个工作状态。三种状态在某些条件下可以转换，三者之间的转换关系如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-131907370.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程三个状态之间的转换就是靠PV操作来控制的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PV操作主要就是P操作、V操作和信号量。其中信号量起到了至关重要的作用。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程通信方式" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-04-僵尸进程,孤儿进程</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-04-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B,%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-04-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B,%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-08-25T08:52:53.000Z</published>
    <updated>2020-09-03T01:19:12.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-04-僵尸进程-孤儿进程"><a href="#Linux-04-僵尸进程-孤儿进程" class="headerlink" title="Linux-04-僵尸进程,孤儿进程"></a>Linux-04-僵尸进程,孤儿进程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用<code>wait()</code>或者<code>waitpid()</code>系统调用取得子进程的终止状态</li></ul><p>　　<strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p>　　<strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><a id="more"></a><h2 id="1-问题和危害"><a href="#1-问题和危害" class="headerlink" title="1. 问题和危害"></a>1. 问题和危害</h2><p><strong>僵尸进程的危害</strong></p><ul><li><p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号<code>the process ID</code>,退出状态<code>the termination status of the process</code>,运行时间<code>the amount of CPU time taken by the process</code>等)。直到父进程通过<code>wait / waitpid</code>来取时才释放。 </p></li><li><p><strong>如果进程不调用wait / waitpid的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p></li></ul><p><strong>孤儿进程的危害</strong></p><ul><li><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，<code>init</code>进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地<code>wait()</code>它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，<code>init</code>进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></li></ul><p><strong>僵尸进程危害的场景</strong></p><ul><li><p>例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短</p></li><li><p>但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵尸进程，倘若用<code>ps</code>命令查看的话，就会看到很多状态为Z的进程。</p></li><li><p>严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）</p></li><li><p>枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被<code>init</code>进程接管，<code>init</code>进程会<code>wait()</code>这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。</p></li></ul><h2 id="2-问题演示"><a href="#2-问题演示" class="headerlink" title="2. 问题演示"></a>2. 问题演示</h2><p>孤儿进程测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="comment">//创建一个进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am the child process.\n"</span>);</span><br><span class="line">        <span class="comment">//输出进程ID和父进程ID</span></span><br><span class="line">        printf(<span class="string">"pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        printf(<span class="string">"I will sleep five seconds.\n"</span>);</span><br><span class="line">        <span class="comment">//睡眠5s，保证父进程先退出</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        printf(<span class="string">"pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        printf(<span class="string">"child process is exited.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am father process.\n"</span>);</span><br><span class="line">        <span class="comment">//父进程睡眠1s，保证子进程输出进程id</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        printf(<span class="string">"father process is  exited.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/090940937.png" alt="mark"></p><p>僵尸进程测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am child process.I am exiting.\n"</span>);</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"I am father process.I will sleep two seconds\n"</span>);</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//输出进程信息</span></span><br><span class="line">    system(<span class="string">"ps -o pid,ppid,state,tty,command"</span>);</span><br><span class="line">    printf(<span class="string">"father process is exiting.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091128821.png" alt="mark"></p><p>僵尸进程测试2：父进程循环创建子进程，子进程退出，造成多个僵尸进程，程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    <span class="comment">//循环创建子进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork error:"</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"I am a child process.\nI am exiting.\n"</span>);</span><br><span class="line">            <span class="comment">//子进程退出，成为僵尸进程</span></span><br><span class="line">            exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//父进程休眠20s继续创建子进程</span></span><br><span class="line">            sleep(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091246352.png" alt="mark"></p><h2 id="3-问题的解决方法"><a href="#3-问题的解决方法" class="headerlink" title="3. 问题的解决方法"></a>3. 问题的解决方法</h2><p><strong>（1）通过信号机制</strong></p><p>　　子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="comment">//创建捕捉子进程退出信号</span></span><br><span class="line">    signal(SIGCHLD,sig_child);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"I am child process,pid id %d.I am exiting.\n"</span>,getpid());</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"I am father process.I will sleep two seconds\n"</span>);</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//输出进程信息</span></span><br><span class="line">    system(<span class="string">"ps -o pid,ppid,state,tty,command"</span>);</span><br><span class="line">    printf(<span class="string">"father process is exiting.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     pid_t        pid;</span><br><span class="line">     <span class="keyword">int</span>        stat;</span><br><span class="line">     <span class="comment">//处理僵尸进程</span></span><br><span class="line">     <span class="keyword">while</span> ((pid = waitpid(-<span class="number">1</span>, &amp;stat, WNOHANG)) &gt;<span class="number">0</span>)</span><br><span class="line">            printf(<span class="string">"child %d terminated.\n"</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091458045.png" alt="mark"></p><p><strong>（2）fork两次</strong><br>　　《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。测试程序如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    <span class="comment">//创建第一个子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一个子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程再创建子进程</span></span><br><span class="line">        printf(<span class="string">"I am the first child process.pid:%d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork error:"</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个子进程退出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"first procee is exited.\n"</span>);</span><br><span class="line">            exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二个子进程</span></span><br><span class="line">        <span class="comment">//睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        printf(<span class="string">"I am the second child process.pid: %d\tppid:%d\n"</span>,getpid(),getppid());</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程处理第一个子进程退出</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, NULL, <span class="number">0</span>) != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"waitepid error:"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/091537084.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-04-僵尸进程-孤儿进程&quot;&gt;&lt;a href=&quot;#Linux-04-僵尸进程-孤儿进程&quot; class=&quot;headerlink&quot; title=&quot;Linux-04-僵尸进程,孤儿进程&quot;&gt;&lt;/a&gt;Linux-04-僵尸进程,孤儿进程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用&lt;code&gt;wait()&lt;/code&gt;或者&lt;code&gt;waitpid()&lt;/code&gt;系统调用取得子进程的终止状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;strong&gt;孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="僵尸进程" scheme="http://zhuuu.work/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="孤儿进程" scheme="http://zhuuu.work/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-459-重复的子字符串</title>
    <link href="http://zhuuu.work/2020/08/25/Leetcode/Leetcode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/08/25/Leetcode/Leetcode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-25T08:35:53.000Z</published>
    <updated>2020-08-25T08:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-459-重复的子字符串"><a href="#Leecode-459-重复的子字符串" class="headerlink" title="Leecode-459. 重复的子字符串"></a>Leecode-<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果您的字符串 S 包含一个重复的子字符串，那么这意味着您可以多次 “移位和换行”`您的字符串，并使其与原始字符串匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：abcabc</span><br><span class="line"></span><br><span class="line">移位一次：cabcab</span><br><span class="line">移位两次：bcabca</span><br><span class="line">移位三次：abcabc</span><br></pre></td></tr></table></figure><p>现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串。</p><p>基于这个思想，可以每次移动k个字符，直到匹配移动 length - 1 次。但是这样对于重复字符串很长的字符串，效率会非常低。在 LeetCode 中执行时间超时了。</p><p>为了避免这种无用的环绕，可以创建一个新的字符串 str，它等于原来的字符串 S 再加上 S 自身，这样其实就包含了所有移动的字符串。</p><p><strong>比如字符串：S = acd，那么 str = S + S = acdacd</strong></p><p><strong>acd 移动的可能：dac、cda。其实都包含在了 str 中了。就像一个滑动窗口</strong></p><p><strong>一开始 acd (acd) ，移动一次 ac(dac)d，移动两次 a(cda)cd。循环结束</strong></p><p><strong>所以可以直接判断 str 中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String str = s + s;</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).contains(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leecode-459-重复的子字符串&quot;&gt;&lt;a href=&quot;#Leecode-459-重复的子字符串&quot; class=&quot;headerlink&quot; title=&quot;Leecode-459. 重复的子字符串&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://lee
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux-02-进程通信方式</title>
    <link href="http://zhuuu.work/2020/08/25/Linux/Linux-02-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/08/25/Linux/Linux-02-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2020-08-25T07:52:53.000Z</published>
    <updated>2020-09-20T14:40:00.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-02-进程通信方式"><a href="#Linux-02-进程通信方式" class="headerlink" title="Linux-02-进程通信方式"></a>Linux-02-进程通信方式</h1><h2 id="一、管道"><a href="#一、管道" class="headerlink" title="一、管道"></a>一、管道</h2><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p><h3 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</li><li>它只能用于具有<strong>亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</strong>。</li><li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的<code>read、write</code> 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li></ol><h3 id="2、原型"><a href="#2、原型" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 #include &lt;unistd.h&gt;</span><br><span class="line">2 int pipe(int fd[2]);    &#x2F;&#x2F; 返回值：若成功返回0，失败返回-1</span><br></pre></td></tr></table></figure><p><strong>当一个管道建立时，它会创建两个文件描述符</strong>：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-094108517.png" alt="mark"></p><a id="more"></a><p>要关闭管道只需将这两个文件描述符关闭即可。</p><h3 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-094212697.png" alt="mark"></p><p>若要数据流从父进程流向子进程，则关闭父进程的读端（<code>fd[0]</code>）与子进程的写端（<code>fd[1]</code>）；反之，则可以使数据流从子进程流向父进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];  <span class="comment">// 两个文件描述符</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)  <span class="comment">// 创建管道</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create Pipe Error!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)  <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        read(fd[<span class="number">0</span>], buff, <span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、FIFO"><a href="#二、FIFO" class="headerlink" title="二、FIFO"></a>二、FIFO</h2><p>FIFO，也称为命名管道，它是一种文件类型。</p><h3 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><strong>FIFO可以在无关的进程之间交换数据，与无名管道不同。</strong></li><li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li></ol><h3 id="2、原型-1"><a href="#2、原型-1" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 #include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">2 &#x2F;&#x2F; 返回值：成功返回0，出错返回-1</span><br><span class="line">3 int mkfifo(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure><p>其中的 mode 参数与<code>open</code>函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p><p>当 open 一个FIFO时，是否设置非阻塞标志（<code>O_NONBLOCK</code>）的区别：</p><ul><li>若没有指定<code>O_NONBLOCK</code>（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</li><li>若指定了<code>O_NONBLOCK</code>，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</li></ul><h3 id="3、例子-1"><a href="#3、例子-1" class="headerlink" title="3、例子"></a>3、例子</h3><ul><li><strong>FIFO的通信方式类似于在进程中使用文件来传输数据</strong>，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：</li></ul><p><strong>write_fifo.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;   // exit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;    // O_WRONLY</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;     // time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">time_t</span> tp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">        n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">        <span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>read_fifo.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line">        perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">// 以读打开FIFO</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两个终端里用 gcc 分别编译运行上面两个文件，可以看到输出结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">2</span> I am <span class="number">5954</span> process.</span><br><span class="line"> <span class="number">3</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">4</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">5</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">6</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">7</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">8</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">9</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line"><span class="number">10</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line"><span class="number">11</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line"><span class="number">12</span> Send message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">2</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">3</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">4</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">5</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">6</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">7</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">8</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line"> <span class="number">9</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line"><span class="number">10</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line"><span class="number">11</span> Read message: Process <span class="number">5954'</span>s time is Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure><p>上述例子可以扩展成 客户进程—服务器进程 通信的实例，<code>write_fifo</code>的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，<code>read_fifo</code>类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-100921142.png" alt="mark"></p><h2 id="三、消息队列"><a href="#三、消息队列" class="headerlink" title="三、消息队列"></a>三、消息队列</h2><p><strong>消息队列，是消息的链接表，存放在内核中</strong>。一个消息队列由一个标识符（即队列ID）来标识。</p><h3 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li><li><strong>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</strong></li><li><strong>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</strong></li></ol><h3 id="2、原型-2"><a href="#2、原型-2" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：</p><ul><li>如果没有与键值key相对应的消息队列，并且flag中包含了<code>IPC_CREAT</code>标志位。</li><li>key参数为<code>IPC_PRIVATE</code>。</li></ul><p>函数<code>msgrcv</code>在读取消息队列时，type参数有下面几种情况：</p><ul><li><code>type == 0</code>，返回队列中的第一个消息；</li><li><code>type &gt; 0</code>，返回队列中消息类型为 type 的第一个消息；</li><li><code>type &lt; 0</code>，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li></ul><p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）</p><h3 id="3、例子-2"><a href="#3、例子-2" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p><p><strong>msg_server.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取消息</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">        msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">        <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">        msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>msg_client.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加消息，类型为888</span></span><br><span class="line">    msg.mtype = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">    msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取类型为777的消息</span></span><br><span class="line">    msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、信号量"><a href="#四、信号量" class="headerlink" title="四、信号量"></a>四、信号量</h2><p><strong>信号量</strong>（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。<strong>信号量用于实现进程间的互斥与同步，</strong>而不是用于存储进程间通信数据。</p><h3 id="1、特点-3"><a href="#1、特点-3" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li><li><strong>信号量基于操作系统的 PV 操作</strong>，程序对信号量的操作都是原子操作。</li><li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li><li>支持信号量组。</li></ol><h3 id="2、原型-3"><a href="#2、原型-3" class="headerlink" title="2、原型"></a>2、原型</h3><p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。</p><p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf semoparray[], <span class="keyword">size_t</span> numops)</span></span>;</span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>当<code>semget</code>创建新的信号量集合时，必须指定集合中信号量的个数（即<code>num_sems</code>），通常为1； 如果是引用一个现有的集合，则将<code>num_sems</code>指定为 0 。</p><p>在<code>semop</code>函数中，<code>sembuf</code>结构的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short sem_num; <span class="comment">// 信号量组中对应的序号，0～sem_nums-1</span></span><br><span class="line">    short sem_op;  <span class="comment">// 信号量值在一次操作中的改变量</span></span><br><span class="line">    short sem_flg; <span class="comment">// IPC_NOWAIT, SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 sem_op 是一次操作中的信号量的改变量：</p><ul><li><p>若<code>sem_op &gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。</p></li><li><p>若<code>sem_op &lt; 0</code>，请求 sem_op 的绝对值的资源。</p><ul><li><p>如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</p></li><li><p>当相应的资源数不能满足请求时，这个操作与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_flg</span><br></pre></td></tr></table></figure><p>有关。</p><ul><li><p>sem_flg 指定<code>IPC_NOWAIT</code>，则semop函数出错返回<code>EAGAIN</code>。</p></li><li><p>sem_flg 没有指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPC_NOWAIT</span><br></pre></td></tr></table></figure><p>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：</p><ol><li>当相应的资源数可以满足请求，此信号量的semncnt值减1，该信号量的值减去sem_op的绝对值。成功返回；</li><li>此信号量被删除，函数smeop出错返回EIDRM；</li><li>进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的semncnt值减1，函数semop出错返回EINTR</li></ol></li></ul></li></ul></li><li><p>若<code>sem_op == 0</code>，进程阻塞直到信号量的相应值为0：</p><ul><li><p>当信号量已经为0，函数立即返回。</p></li><li><p>如果信号量的值不为0，则依据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_flg</span><br></pre></td></tr></table></figure><p>决定函数动作：</p><ul><li><p>sem_flg指定<code>IPC_NOWAIT</code>，则出错返回<code>EAGAIN</code>。</p></li><li><p>sem_flg没有指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPC_NOWAIT</span><br></pre></td></tr></table></figure><p>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：</p><ol><li>信号量值为0，将信号量的semzcnt的值减1，函数semop成功返回；</li><li>此信号量被删除，函数smeop出错返回EIDRM；</li><li>进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的semncnt值减1，函数semop出错返回EINTR</li></ol></li></ul></li></ul></li></ul><p>在<code>semctl</code>函数中的命令有多种，这里就说两个常用的：</p><ul><li><code>SETVAL</code>：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。</li><li><code>IPC_RMID</code>：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。</li></ul><h3 id="3、例子-3"><a href="#3、例子-3" class="headerlink" title="3、例子"></a>3、例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//    若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//    若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//    释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//    如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id;  <span class="comment">// 信号量集ID</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量集，其中只有一个信号量</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化：初值设为0资源被占用</span></span><br><span class="line">    init_sem(sem_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"Fork Error"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Process child: pid=%d\n"</span>, getpid());</span><br><span class="line">        sem_v(sem_id);  <span class="comment">/*释放资源*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/*父进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(sem_id);   <span class="comment">/*等待资源*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Process father: pid=%d\n"</span>, getpid());</span><br><span class="line">        sem_v(sem_id);   <span class="comment">/*释放资源*/</span></span><br><span class="line">        del_sem(sem_id); <span class="comment">/*删除信号量集*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子如果不加信号量，则父进程会先执行完毕。这里加了信号量让父进程等待子进程执行完以后再执行。</p><h2 id="五、共享内存"><a href="#五、共享内存" class="headerlink" title="五、共享内存"></a>五、共享内存</h2><p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p><h3 id="1、特点-4"><a href="#1、特点-4" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li><li>因为多个进程可以同时操作，所以需要进行同步。</li><li><strong>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</strong></li></ol><h3 id="2、原型-4"><a href="#2、原型-4" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>当用<code>shmget</code>函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p><p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code>shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p><p><code>shmdt</code>函数是用来断开<code>shmat</code>建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p><p><code>shmctl</code>函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是<code>IPC_RMID</code>（从系统中删除该共享内存）。</p><h3 id="3、例子-4"><a href="#3、例子-4" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面这个例子，使用了【共享内存+信号量+消息队列】的组合来实现服务器进程与客户进程间的通信。</p><ul><li>共享内存用来传递数据；</li><li>信号量用来同步；</li><li>消息队列用来 在客户端修改了共享内存后 通知服务器读取。</li></ul><p><strong>server.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;  // shared memory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;  // semaphore</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;  // message queue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;   // memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(<span class="keyword">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    init_sem(sem_id, <span class="number">1</span>);  <span class="comment">/*初值设为1资源未占用*/</span></span><br><span class="line">    <span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">    <span class="keyword">char</span> *shm;</span><br><span class="line">    <span class="keyword">char</span> data[] = <span class="string">"this is server"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">buf1</span>;</span>  <span class="comment">/*用于删除共享内存*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">buf2</span>;</span>  <span class="comment">/*用于删除消息队列*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span>  <span class="comment">/*消息队列用于通知对方更新了共享内存*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存</span></span><br><span class="line">    <span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Create Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">int</span>)shm == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量</span></span><br><span class="line">    semid = creat_sem(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msgrcv(msqid, &amp;msg, <span class="number">1</span>, <span class="number">888</span>, <span class="number">0</span>); <span class="comment">/*读取类型为888的消息*/</span></span><br><span class="line">        <span class="keyword">if</span>(msg.mtext == <span class="string">'q'</span>)  <span class="comment">/*quit - 跳出循环*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(msg.mtext == <span class="string">'r'</span>)  <span class="comment">/*read - 读共享内存*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            sem_p(semid);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,shm);</span><br><span class="line">            sem_v(semid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除共享内存、消息队列、信号量*/</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, &amp;buf1);</span><br><span class="line">    msgctl(msqid, IPC_RMID, &amp;buf2);</span><br><span class="line">    del_sem(semid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>client.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;  // shared memory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;  // semaphore</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;  // message queue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;   // memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1</span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">-1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">    <span class="keyword">char</span> *shm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">/*while循环条件*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取共享内存</span></span><br><span class="line">    <span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">int</span>)shm == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取信号量</span></span><br><span class="line">    <span class="keyword">if</span>((semid = semget(key, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*                 IPC                 *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*    Input r to send data to server.  *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*    Input q to quit.                 *\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please input command: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Data to send: "</span>);</span><br><span class="line">                sem_p(semid);  <span class="comment">/*访问资源*/</span></span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm);</span><br><span class="line">                sem_v(semid);  <span class="comment">/*释放资源*/</span></span><br><span class="line">                <span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">                <span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">                msg.mtype = <span class="number">888</span>;</span><br><span class="line">                msg.mtext = <span class="string">'r'</span>;  <span class="comment">/*发送消息通知服务器读数据*/</span></span><br><span class="line">                msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">                msg.mtype = <span class="number">888</span>;</span><br><span class="line">                msg.mtext = <span class="string">'q'</span>;</span><br><span class="line">                msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Wrong input!\n"</span>);</span><br><span class="line">                <span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">                <span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当<code>scanf()</code>输入字符或字符串时，缓冲区中遗留下了<code>\n</code>，所以每次输入操作后都需要清空标准输入的缓冲区。但是由于 gcc 编译器不支持<code>fflush(stdin)</code>（它只是标准C的扩展），所以我们使用了替代方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 while((c&#x3D;getchar())!&#x3D;&#39;\n&#39; &amp;&amp; c!&#x3D;EOF);</span><br></pre></td></tr></table></figure><h2 id="五种通讯方式总结"><a href="#五种通讯方式总结" class="headerlink" title="五种通讯方式总结"></a>五种通讯方式总结</h2><p>1.管道：速度慢，容量有限，只有父子进程能通讯</p><p>2.FIFO：任何进程间都能通讯，但速度慢   </p><p>3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   </p><p>4.信号量：不能传递复杂消息，只能用来同步   </p><p>5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-02-进程通信方式&quot;&gt;&lt;a href=&quot;#Linux-02-进程通信方式&quot; class=&quot;headerlink&quot; title=&quot;Linux-02-进程通信方式&quot;&gt;&lt;/a&gt;Linux-02-进程通信方式&lt;/h1&gt;&lt;h2 id=&quot;一、管道&quot;&gt;&lt;a href=&quot;#一、管道&quot; class=&quot;headerlink&quot; title=&quot;一、管道&quot;&gt;&lt;/a&gt;一、管道&lt;/h2&gt;&lt;p&gt;管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。&lt;/p&gt;
&lt;h3 id=&quot;1、特点&quot;&gt;&lt;a href=&quot;#1、特点&quot; class=&quot;headerlink&quot; title=&quot;1、特点&quot;&gt;&lt;/a&gt;1、特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。&lt;/li&gt;
&lt;li&gt;它只能用于具有&lt;strong&gt;亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;它可以看成是一种特殊的文件，对于它的读写也可以使用普通的&lt;code&gt;read、write&lt;/code&gt; 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2、原型&quot;&gt;&lt;a href=&quot;#2、原型&quot; class=&quot;headerlink&quot; title=&quot;2、原型&quot;&gt;&lt;/a&gt;2、原型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 #include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 int pipe(int fd[2]);    &amp;#x2F;&amp;#x2F; 返回值：若成功返回0，失败返回-1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;当一个管道建立时，它会创建两个文件描述符&lt;/strong&gt;：&lt;code&gt;fd[0]&lt;/code&gt;为读而打开，&lt;code&gt;fd[1]&lt;/code&gt;为写而打开。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-094108517.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程通信方式" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-12-一对多,多对一，多对多问题</title>
    <link href="http://zhuuu.work/2020/08/25/Mysql/Mysql-12-%E4%B8%80%E5%AF%B9%E5%A4%9A,%E5%A4%9A%E5%AF%B9%E4%B8%80%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/08/25/Mysql/Mysql-12-%E4%B8%80%E5%AF%B9%E5%A4%9A,%E5%A4%9A%E5%AF%B9%E4%B8%80%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-25T06:28:27.000Z</published>
    <updated>2020-08-25T06:50:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-12-一对多-多对一，多对多问题"><a href="#Mysql-12-一对多-多对一，多对多问题" class="headerlink" title="Mysql-12-一对多,多对一，多对多问题"></a>Mysql-12-一对多,多对一，多对多问题</h1><h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p>​    一对一关系示例：</p><ul><li><ul><li>一个学生对应一个学生档案材料，或者每个人都有唯一的身份证编号。</li></ul></li></ul><p>​    一对多关系示例：</p><ul><li><ul><li>一个学生只属于一个班，但是一个班级有多名学生。</li></ul></li></ul><p>​    多对多关系示例：</p><ul><li><ul><li>一个学生可以选择多门课，一门课也有多名学生。</li></ul></li></ul><a id="more"></a><h2 id="2-数据库建表注意"><a href="#2-数据库建表注意" class="headerlink" title="2. 数据库建表注意"></a>2. 数据库建表注意</h2><p><strong>1.一对多关系处理：</strong></p><p>​    <strong>通过学生和班级问题了解一对多：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143534668.png" alt="mark"></p><p><strong>解决方案：</strong></p><ul><li>班级是1端，学生是多端，结合面向对象的思想，1端是父亲，多端是儿子，所以多端具有1端的属性，也就是说多端里面应该放置1端的主键，那么<strong>学生表里面应该放置班级表里面的主键</strong></li></ul><p><strong>2.多对多关系处理：</strong></p><p>  <strong>通过学生选课了解多对多问题的处理：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143627192.png" alt="mark"></p><p><strong>解决方案：</strong></p><ul><li><strong>在多对多中在一个表中添加一个字段就行不通了，所以处理多对多表问题时，就要考虑建立关系表了</strong></li></ul><p><strong>学生表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143739422.png" alt="mark"></p><p><strong>课程表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143932875.png" alt="mark"></p><p><strong>关系表</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-143947893.png" alt="mark"></p><p>注：所以对于多对多表，通过关系表就建立起了两张表的联系！多对多表时建立主外键后，要先删除约束表内容再删除主表内容</p><p>对于<strong>多对多关系，需要转换成1对多关系</strong>，那么就需要一张中间表来转换，这张中间表里面<strong>需要存放学生表里面的主键和课程表里面的主键</strong>，此时学生与中间表示1对多关系，课程与中间表是1对多关系，学生与课程是多对多关系</p><h2 id="3-解决方案总结"><a href="#3-解决方案总结" class="headerlink" title="3. 解决方案总结"></a>3. 解决方案总结</h2><ol><li><strong>一对一的解决方案</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一对一</span><br><span class="line">一张表的一条记录一定只能与另外一张表的一条记录进行对应，反之亦然。</span><br><span class="line"></span><br><span class="line">学生表：姓名，性别，年龄，身高，体重，籍贯，家庭住址，紧急联系人</span><br><span class="line">其中姓名、性别、年龄、身高，体重属于常用数据，但是籍贯、住址和联系人为不常用数据</span><br><span class="line">如果每次查询都是查询所有数据，不常用的数据就会影响效率，实际又不用</span><br><span class="line"></span><br><span class="line">常用信息表：ID(P)，姓名，性别，年龄，身高，体重</span><br><span class="line">不常用信息表：ID(P)，籍贯，家庭住址，紧急联系人</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">将常用的和不常用的信息分享存储，分成两张表</span><br><span class="line">不常用信息表和常用信息表，保证不常用信息表与常用信息表能够对应上：找一个具有唯一性的</span><br><span class="line">字段来共同连接两张表。</span><br><span class="line">一个常用表中的一条记录永远只能在一张不常用表中匹配一条记录，反之亦然。</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>一对多</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一对多</span><br><span class="line">一张表中有一条记录可以对应另外一张表中的多条记录；但是反过来，另外一张表的一条记录</span><br><span class="line">只能对应第一张表的一条记录，这种关系就是一对多或多对一</span><br><span class="line">母亲与孩子的关系：母亲，孩子两个实体</span><br><span class="line">母亲表：ID(P),名字，年龄，性别</span><br><span class="line">孩子表：ID(P),名字，年龄，性别</span><br><span class="line">以上关系：一个妈妈可以在孩子表中找到多条记录（也可能是一条），但是一个孩子只能找到一个妈妈</span><br><span class="line">是一种典型的一对多的关系。</span><br><span class="line"></span><br><span class="line">但是以上设计：解决了实体的设计表问题，但是没有解决关系问题，孩子找不到母亲，母亲也找不到孩子</span><br><span class="line"></span><br><span class="line">解决方案：在某一张表中增加一个字段，能够找到另外一张表中的记录:在孩子表中增加一个字段</span><br><span class="line">指向母亲表，因为孩子表的记录只能匹配到一条母亲表的记录。</span><br><span class="line">母亲表：ID(P),名字，年龄，性别</span><br><span class="line">孩子表：ID(P),名字，年龄，性别，母亲表ID（母亲表主键）</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>多对多</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">多对多</span><br><span class="line">一对表中（A）的一条记录能够对应另外一张表（B）中的多条记录；同时B表中的一条记录</span><br><span class="line">也能对应A表中的多条记录</span><br><span class="line"></span><br><span class="line">老师和学生</span><br><span class="line">老师表 T_ID(P),姓名，性别</span><br><span class="line">学生表 S_ID(P),姓名，性别</span><br><span class="line">以上设计方案：实现了实体的设计，但是没有维护实体的关系</span><br><span class="line">一个老师教过多个学生，一个学生也被多个老师教过</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决方案：增加一张中间关系表</span><br><span class="line">老师与学生的关系表：ID(P),T_ID,S_ID </span><br><span class="line">老师表与中间表形成一对多的关系，而中间表是多表；维护了能够唯一找到一表的关系；</span><br><span class="line">同样的学生表与中间表也是一个一对多的关系; </span><br><span class="line">学生找老师：找出学生ID---&gt;中间表寻找匹配记录（多条）---&gt;老师表匹配（一条）</span><br><span class="line">老师找学生：找出老师ID---&gt;中间表寻找匹配记录（多条）---&gt;学生表匹配（一条）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-12-一对多-多对一，多对多问题&quot;&gt;&lt;a href=&quot;#Mysql-12-一对多-多对一，多对多问题&quot; class=&quot;headerlink&quot; title=&quot;Mysql-12-一对多,多对一，多对多问题&quot;&gt;&lt;/a&gt;Mysql-12-一对多,多对一，多对多问题&lt;/h1&gt;&lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;​    一对一关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生对应一个学生档案材料，或者每个人都有唯一的身份证编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    一对多关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生只属于一个班，但是一个班级有多名学生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    多对多关系示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;一个学生可以选择多门课，一门课也有多名学生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库建表关系" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-Integer和int</title>
    <link href="http://zhuuu.work/2020/08/23/JavaInterview/Java-%E5%9F%BA%E7%A1%80-Integer%E5%92%8Cint/"/>
    <id>http://zhuuu.work/2020/08/23/JavaInterview/Java-%E5%9F%BA%E7%A1%80-Integer%E5%92%8Cint/</id>
    <published>2020-08-23T09:38:38.000Z</published>
    <updated>2020-09-12T09:02:45.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-Integer和int"><a href="#Java-基础-Integer和int" class="headerlink" title="Java-基础-Integer和int"></a>Java-基础-Integer和int</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>int和Integer的区别</strong></p><ul><li><p>Integer的默认值是null，int的默认值是0</p></li><li><p>Integer是int的包装类(引用数据类型 )，int则是java的一种基本数据类型 </p></li><li><p>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </p></li><li><p>Integer变量必须实例化后才能使用，而int变量不需要 </p></li></ul><h2 id="衍生"><a href="#衍生" class="headerlink" title="衍生"></a>衍生</h2><p>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; new Integer(100);</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，<strong>java会自动拆包装为int</strong>，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">int j &#x3D; 100；</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>3、<strong>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false</strong>。（因为 ①当变量值在-128<del>127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②**当变量值在-128</del>127之间时**，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>4、<strong>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false（运用到的设计模式：享元模式 对象池连接的思想）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 100;</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br><span class="line">Integer i &#x3D; 128;</span><br><span class="line">Integer j &#x3D; 128;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>对于第4条的原因：<br>java在编译Integer i = 100 ;时，会翻译成为<code>Integer i = Integer.valueOf(100)</code>；，而java API中对Integer类型的valueOf的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)&#123;</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p><p>如果有错误的地方，还请指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-基础-Integer和int&quot;&gt;&lt;a href=&quot;#Java-基础-Integer和int&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-Integer和int&quot;&gt;&lt;/a&gt;Java-基础-Integer和int&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
    
      <category term="Integer" scheme="http://zhuuu.work/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>Redis-15-mysql和redis缓存不一致</title>
    <link href="http://zhuuu.work/2020/08/22/Redis/Redis-15-mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>http://zhuuu.work/2020/08/22/Redis/Redis-15-mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/</id>
    <published>2020-08-22T10:32:24.000Z</published>
    <updated>2020-09-09T14:38:36.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-15-mysql和redis缓存不一致"><a href="#Redis-15-mysql和redis缓存不一致" class="headerlink" title="Redis-15-mysql和redis缓存不一致"></a>Redis-15-mysql和redis缓存不一致</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>这实际上是个“如果要做的足够精致是非常难的“问题。缓存失效被称为计算机科学里最难的两个问题之一（另外一个是起名字）。</p></li><li><p>先对本题一致性做个说明。这里的不一致是指：假如一个数据访问者同时读取Redis和DB，他能在一段时间里发现二者不一样。</p></li><li><p><strong>不错，如果一份数据放在DB，然后copy到Redis，然后改DB，那么Redis是不会自己魔幻般同步变更的。</strong></p></li><li><p><strong>必须有某种机制告诉Redis该变了。这些机制包括（但不仅仅限于）：</strong></p></li></ul><a id="more"></a><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><ul><li><p>Redis里的数据不立刻更新，等redis里数据自然过期。然后去DB里取，顺带重新set redis。</p></li><li><p>这种用法被称作“Cache Aside”。好处是代码比较简单，坏处是会有一段时间DB和Redis里的数据不一致。</p></li><li><p><strong>这个不一致的时间取决于redis里数据设定的有效期，比如10min。但如果Redis里数据没设置有效期，这招就不灵了。</strong></p></li></ul><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><ul><li>更新DB时总是不直接触碰DB，而是通过代码。而代码做的显式更新DB，然后马上del掉redis里的数据。</li><li>在下次取数据时，模式就恢复到了上一条说的方式。这也算是一种Cache Aside的变体。</li><li>这要做的好处是，数据的一致性会比较好，一般正常情况下，数据不一致的时间会在1s以下，对于绝大部分的场景是足够了。但是有极少几率，由于更新时序，下Redis数据会和DB不一致（这个有文章解释，这里不展开）。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/221825945.png" alt="mark"></p><ul><li><strong>方案1和方案2的做法常规上被称为“Cache“</strong>。</li><li>而且因为1有更新不及时的问题，2有极端情况下数据会不一致的问题，所以常规Cache代码会把1+2组合起来，要求Redis里的数据必须有过期时间，并且不能太长，</li><li>这样即便是不一致也能混过去。同时如果是主动对数据进行更新，Cache的数据更新也会比较及时。</li></ul><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><ul><li><p>并且2并不一定总是行得通。比如OLTP的服务在前面是Cache+DB的模式，而数据是由后台管理系统来更新的，总是不会触碰OLTP服务，更不会动Cache。这时将Redis看作是存储也算是一种方案。就是：</p></li><li><p><strong>Redis里的数据总是不过期，但是有个背景更新任务（“定时执行的代码” 或者 “被队列驱动的代码）读取db，把最新的数据塞给Redis。</strong></p></li><li><p><strong>这种做法将Redis看作是“存储”。</strong>访问者不知道背后的实际数据源，只知道Redis是唯一可以取的数据的地方。当实际数据源更新时，背景更新任务来将数据更新到Redis。这时还是会存在Redis和实际数据源不一致的问题。</p><ul><li>如果是<strong>定时任务</strong>，最长的不一致时长就是更新任务的执行间隔；</li><li>如果是用<strong>类似于队列的方式来更新</strong>，那么不一致时间取决于队列产生和消费的延迟。<ul><li>常用的队列（或等价物）有Redis（怎么还是Redis），Kafka，AMQ，RMQ，binglog，log文件，阿里的canal等。</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/223311394.png" alt="mark"></p><ul><li><strong>这种做法还有一种变体Write Through，写入时直接写DB，DB把数据更新Cache，而读取时读Cache。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200909/223403561.png" alt="mark"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>以上方式无论如何都会有一段时间Redis和DB会不一致</strong>。实践上，这个不一致时间短则几十ms，长可以到几十分钟。<strong>这种程度的一致性对于很多业务场景都已经足够了</strong></li><li>很多时候，用户无法区分自己读取的是Redis还是DB，只能读取到其中的一个。这时数据看起来直觉上是没问题的就可以接受了。只要不出现，用户先看见了数据是A，然后看到数据是B，之后一刷新，又看到A的尴尬场景就行了。</li><li>但对于有些业务，比如协作文档编辑，电商秒杀的扣库存，银行转账等，以上的做法就不够用了。</li></ul><p><strong>第一种方法</strong></p><ul><li>第一种是不要用Redis，只用DB。或者更直接点说是“只要一个单点的数据源”。这样肯定就没有一致性问题</li><li>代价就是CAP中因为CP被满足，因此A被牺牲掉。这就是为啥银行一系统升级就要停服务的原因。</li></ul><p><strong>第二种方法</strong></p><ul><li>另外一种保证一致性的做法就是用某种分布式协议一致性来做，大致可以归结到<ul><li>SAGA或者TCC - 这两种需要业务代码的大量配合。通过业务代码来补偿一致性。</li><li>2PC, 3PC - 现实当中有XA协议。比如Ehcache是支持XA协议的。但是性能表现不佳，运维也麻烦，我比较少见到实际这么干的。</li><li>基于Paxos或者Raft的分布式锁，然后对Redis和DB进行双写，但是除非客户端和服务器么次都去访问分布式锁，也会有一点点不一致的问题。这实际上相当于将多个地方的一致性控制交给了分布式锁的集中维护。</li></ul></li></ul><p>综上，除了单点DB存储之外的方案，其一致性面临的窘境是</p><ul><li><strong>要么，接受“最终一致”</strong>，但到底多久之后一致，不一致时表现怎么样，有很多种做法。分布式一致性有各种各样的模型，比如线性一致性、顺序一致性等。他们都是在“不一致”和“强一致”之间提供某种折衷。这些折衷大量应用于我们常见的诸多业务之中、如社交、IM、电商不触及钱的地方等</li><li><strong>要么，要求必须强一致。</strong>那么在分布式条件下就要牺牲A。比如访问一个Cache，Cache知道自己的数据不是最新的，就要和DB去Sync，Sync的过程中DB的数据还不能改。期间访问者要不收到一个错误“数据不同步，不能访问”，要不就卡在那里等着同步完成。个人以为，这还不如干脆就不要Cache，在维护强一致的同时，用其他方式来优化访问性能。</li></ul><p><strong>参考博客</strong> ：<a href="https://www.zhihu.com/question/319817091/answer/653985863" target="_blank" rel="noopener">https://www.zhihu.com/question/319817091/answer/653985863</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-15-mysql和redis缓存不一致&quot;&gt;&lt;a href=&quot;#Redis-15-mysql和redis缓存不一致&quot; class=&quot;headerlink&quot; title=&quot;Redis-15-mysql和redis缓存不一致&quot;&gt;&lt;/a&gt;Redis-15-mysql和redis缓存不一致&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这实际上是个“如果要做的足够精致是非常难的“问题。缓存失效被称为计算机科学里最难的两个问题之一（另外一个是起名字）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先对本题一致性做个说明。这里的不一致是指：假如一个数据访问者同时读取Redis和DB，他能在一段时间里发现二者不一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不错，如果一份数据放在DB，然后copy到Redis，然后改DB，那么Redis是不会自己魔幻般同步变更的。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;必须有某种机制告诉Redis该变了。这些机制包括（但不仅仅限于）：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="mysql和redis缓存不一致" scheme="http://zhuuu.work/tags/mysql%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    
      <category term="mysql" scheme="http://zhuuu.work/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis-16-Redis分布式</title>
    <link href="http://zhuuu.work/2020/08/22/Redis/Redis-16-Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/08/22/Redis/Redis-16-Redis%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2020-08-22T10:32:24.000Z</published>
    <updated>2020-09-17T07:29:21.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-16-Redis分布式"><a href="#Redis-16-Redis分布式" class="headerlink" title="Redis-16-Redis分布式"></a>Redis-16-Redis分布式</h1><h2 id="1-为什么用Redis"><a href="#1-为什么用Redis" class="headerlink" title="1. 为什么用Redis?"></a>1. 为什么用Redis?</h2><ol><li>单线程的redis为什么这么快??</li></ol><p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。</p><p><strong>回答</strong>:主要是以下三点<br>(一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞<strong>I/O多路复用机制</strong></p><p><strong>关于Redis的 I/O多路复用：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-154227633.png" alt="mark"></p><ul><li>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</li><li>需要说明的是，这个I/O多路复用机制，redis还提供了<code>select、epoll、evport、kqueue</code>等多路复用函数库</li></ul><a id="more"></a><h2 id="2-Redis数据结构应用场景"><a href="#2-Redis数据结构应用场景" class="headerlink" title="2. Redis数据结构应用场景"></a>2. Redis数据结构应用场景</h2><p><strong>redis的数据类型，以及每种数据类型的使用场景</strong></p><p><strong>回答</strong>：一共五种</p><p>(一)String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong>（以及分布式锁）</p><p>(二)hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。就是用这种数据结构存储用户信息，以<code>cookieId</code>作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p><p>(三)list<br>使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</p><p>(四)set<br>因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p><p>另外，就是利用<strong>交集、并集、差集</strong>等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</p><p>(五)<code>sorted set</code><br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>。sorted set可以用来做<strong>延时任务</strong>。最后一个应用就是可以做<strong>范围查找</strong>。</p><h2 id="3-Redis过期策略和内存淘汰机制"><a href="#3-Redis过期策略和内存淘汰机制" class="headerlink" title="3. Redis过期策略和内存淘汰机制"></a>3. Redis过期策略和内存淘汰机制</h2><ul><li>redis的<strong>过期策略以及内存淘汰机制</strong></li></ul><p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p><p><strong>回答</strong>:</p><ul><li>redis采用的是<strong>定期删除+惰性删除策略。</strong></li></ul><p><strong>为什么不用定时删除策略?</strong></p><ul><li>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</li></ul><p><strong>定期删除+惰性删除是如何工作的呢?</strong></p><ul><li><p>定期删除，redis默认每个<code>100ms</code>检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</p></li><li><p>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p></li></ul><p><strong>采用定期删除+惰性删除就没其他问题了么?</strong></p><ul><li>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。</li></ul><p><strong>在redis.conf中有一行配置</strong></p><p><code># maxmemory-policy volatile-lru</code></p><p><strong>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**应该没人用吧。**</span><br><span class="line">2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。**推荐使用，目前项目在用这种。**</span><br><span class="line">3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。**应该也没人用吧，你不删最少使用Key,去随机删。**</span><br><span class="line">4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。**这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐**</span><br><span class="line">5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。**依然不推荐**</span><br><span class="line">6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。**不推荐**</span><br></pre></td></tr></table></figure><p><strong>ps：如果没有设置 <code>expire</code> 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</strong></p><h2 id="4-双写一致性问题"><a href="#4-双写一致性问题" class="headerlink" title="4. 双写一致性问题"></a>4. 双写一致性问题</h2><p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为<strong>最终一致性</strong>和<strong>强一致性</strong>。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p><p><strong>回答</strong>:</p><ul><li>首先，采取正确更新策略，<ul><li>先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li></ul></li></ul><h2 id="5-并发竞争key的问题"><a href="#5-并发竞争key的问题" class="headerlink" title="5. 并发竞争key的问题"></a>5. 并发竞争key的问题</h2><ul><li><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></li></ul><ul><li><strong>回答:</strong>如下所示<br>(1)如果对这个key操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，<strong>要求顺序</strong><br>假设有一个<code>key1</code>,系统A需要将<code>key1</code>设置为<code>valueA</code>,系统B需要将<code>key1</code>设置为<code>valueB</code>,系统C需要将<code>key1</code>设置为<code>valueC</code>.<br>期望按照key1的value值按照 <code>valueA--&gt;valueB--&gt;valueC</code>的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br><span class="line"></span><br><span class="line">那么，假设这会系统B先抢到锁，将key1设置为&#123;valueB 3:05&#125;。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做<span class="built_in">set</span>操作了。以此类推。</span><br><span class="line"></span><br><span class="line">其他方法，比如利用队列，将<span class="built_in">set</span>方法变成串行访问也可以。总之，灵活变通。</span><br></pre></td></tr></table></figure><p><strong>参考博客 ：</strong> <a href="https://blog.csdn.net/tmeng521/article/details/91039391" target="_blank" rel="noopener">https://blog.csdn.net/tmeng521/article/details/91039391</a></p><p>​                    <a href="https://www.cnblogs.com/bigben0123/p/9115597.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigben0123/p/9115597.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-16-Redis分布式&quot;&gt;&lt;a href=&quot;#Redis-16-Redis分布式&quot; class=&quot;headerlink&quot; title=&quot;Redis-16-Redis分布式&quot;&gt;&lt;/a&gt;Redis-16-Redis分布式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么用Redis&quot;&gt;&lt;a href=&quot;#1-为什么用Redis&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么用Redis?&quot;&gt;&lt;/a&gt;1. 为什么用Redis?&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;单线程的redis为什么这么快??&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;:这个问题其实是对redis内部机制的一个考察。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答&lt;/strong&gt;:主要是以下三点&lt;br&gt;(一)纯内存操作&lt;br&gt;(二)单线程操作，避免了频繁的上下文切换&lt;br&gt;(三)采用了非阻塞&lt;strong&gt;I/O多路复用机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Redis的 I/O多路复用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200825-154227633.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。&lt;/li&gt;
&lt;li&gt;需要说明的是，这个I/O多路复用机制，redis还提供了&lt;code&gt;select、epoll、evport、kqueue&lt;/code&gt;等多路复用函数库&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="Redis分布式" scheme="http://zhuuu.work/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-014-最长公共前缀</title>
    <link href="http://zhuuu.work/2020/08/20/Leetcode/Leetcode-014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://zhuuu.work/2020/08/20/Leetcode/Leetcode-014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</id>
    <published>2020-08-20T11:52:53.000Z</published>
    <updated>2020-08-20T05:56:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-014-最长公共前缀"><a href="#Leetcode-014-最长公共前缀" class="headerlink" title="Leetcode-014-最长公共前缀"></a>Leetcode-014-<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">最长公共前缀</a></h1><h2 id="思路：遍历"><a href="#思路：遍历" class="headerlink" title="思路：遍历"></a>思路：遍历</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 横向扫描</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到字符串数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="comment">// 拿到第一个字符串</span></span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两比较，找出最长公共前缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            prefix = longestPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  两两比较，找出最长公共前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longestPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(),str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index))&#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截取字符串</span></span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-014-最长公共前缀&quot;&gt;&lt;a href=&quot;#Leetcode-014-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-014-最长公共前缀&quot;&gt;&lt;/a&gt;Leetcode-014-&lt;a href=&quot;https:/
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-03-红黑树</title>
    <link href="http://zhuuu.work/2020/08/19/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/08/19/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03-%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-08-19T10:32:24.000Z</published>
    <updated>2020-08-19T07:23:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-03-红黑树"><a href="#数据结构-03-红黑树" class="headerlink" title="数据结构-03-红黑树"></a>数据结构-03-红黑树</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p>数据结构在线生成工具 ： <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><strong>二叉排序树</strong>（Binary Sort Tree）或者是一棵空树；或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点 </li></ol><p><strong>关于红黑树</strong></p><ul><li><p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p></li><li><p>因为一棵由n个结点随机构造的二叉查找树的高度为lgn，所以顺理成章，二叉查找树的一般操作的执行时间为O(lgn)。但二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。</p></li><li><p><strong>红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)，为了保证这个性质，所以红黑树有以下几个特性：</strong></p></li></ul><ol><li><strong>一个节点要么是红的要么就是黑的</strong></li><li><strong>根节点一定是黑色的</strong></li><li><strong>从叶子节点到根节点 黑色节点一定是一致的（黑高）</strong></li><li><strong>不能有两个红色节点相连（叶子节点一定是黑色的）</strong></li><li><strong>一般采用红插法，这样可以保证树不会失衡</strong></li></ol><h2 id="2-红黑树的旋转"><a href="#2-红黑树的旋转" class="headerlink" title="2. 红黑树的旋转"></a>2. 红黑树的旋转</h2><p>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。旋转包括两种：左旋和右旋。如下图所示：</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-03-红黑树&quot;&gt;&lt;a href=&quot;#数据结构-03-红黑树&quot; class=&quot;headerlink&quot; title=&quot;数据结构-03-红黑树&quot;&gt;&lt;/a&gt;数据结构-03-红黑树&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据结构在线生成工具 ： &lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="http://zhuuu.work/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis-14-key有效时间设置</title>
    <link href="http://zhuuu.work/2020/08/19/Redis/Redis-14-key%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <id>http://zhuuu.work/2020/08/19/Redis/Redis-14-key%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/</id>
    <published>2020-08-19T10:32:24.000Z</published>
    <updated>2020-08-19T09:14:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-14-key有效时间设置"><a href="#Redis-14-key有效时间设置" class="headerlink" title="Redis-14-key有效时间设置"></a>Redis-14-key有效时间设置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文对redis的过期处理机制做个简单的概述，让大家有个基本的认识。</li><li><strong>Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的</strong>。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</li></ul><a id="more"></a><h2 id="1-有效时间设置"><a href="#1-有效时间设置" class="headerlink" title="1. 有效时间设置"></a>1. 有效时间设置</h2><p>redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。Expires字典保存了所有键的过期时间，Expires也被称为过期字段。<br>四种处理策略</p><ol><li>EXPIRE 将key的生存时间设置为ttl秒</li><li>PEXPIRE 将key的生成时间设置为ttl毫秒</li><li>EXPIREAT 将key的过期时间设置为timestamp所代表的的秒数的时间戳</li><li>PEXPIREAT 将key的过期时间设置为timestamp所代表的的毫秒数的时间戳</li></ol><p>其实以上几种处理方式都是根据PEXPIREAT来实现的，设置生存时间的时候是redis内部计算好时间之后在内存处理的，最终的处理都会转向PEXPIREAT。<br>1、2两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到redis中。<br>3、4两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。</p><h2 id="2-过期键的删除策略"><a href="#2-过期键的删除策略" class="headerlink" title="2. 过期键的删除策略"></a>2. 过期键的删除策略</h2><p>如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢？？如果不是，那过期后到底什么时候被删除呢？？</p><p>其实有三种不同的删除策略：<br>（1）立即删除。在设置键的过期时间时，创建一个回调事件，当过期时间达到时，由时间处理器自动执行键的删除操作。<br>（2）惰性删除。键过期了就过期了，不管。每次从dict字典中按key取值时，先检查此key是否已经过期，如果过期了就删除它，并返回nil，如果没过期，就返回键值。<br>（3）定时删除。每隔一段时间，对expires字典进行检查，删除里面的过期键。<br>可以看到，第二种为被动删除，第一种和第三种为主动删除，且第一种实时性更高。下面对这三种删除策略进行具体分析。</p><h3 id="2-1-立即删除"><a href="#2-1-立即删除" class="headerlink" title="2.1 立即删除"></a>2.1 立即删除</h3><ul><li><p>立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是<strong>立即删除对cpu是最不友好的</strong>。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力。</p></li><li><p>而且目前redis事件处理器对时间事件的处理方式–无序链表，查找一个key的时间复杂度为O(n),所以并不适合用来处理大量的时间事件。</p></li></ul><h3 id="2-2-惰性删除"><a href="#2-2-惰性删除" class="headerlink" title="2.2 惰性删除"></a>2.2 惰性删除</h3><ul><li><p>惰性删除是指，某个键值过期后，此键值不会马上被删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。所以惰性删除的缺点很明显:<strong>浪费内存</strong>。dict字典和expires字典都要保存这个键值的信息。</p></li><li><p>举个例子，对于一些按时间点来更新的数据，比如log日志，过期后在很长的一段时间内可能都得不到访问，这样在这段时间内就要拜拜浪费这么多内存来存log。<strong>这对于性能非常依赖于内存大小的redis来说，是比较致命的</strong>。</p></li></ul><h3 id="2-3-定时删除"><a href="#2-3-定时删除" class="headerlink" title="2.3 定时删除"></a>2.3 定时删除</h3><ul><li>从上面分析来看，立即删除会短时间内占用大量cpu，惰性删除会在一段时间内浪费内存，所以定时删除是一个折中的办法。</li><li>定时删除是：每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对cpu的影响。另一方面定时删除也有效的减少了因惰性删除带来的内存浪费。</li></ul><p><strong>redis使用的过期键值删除策略是：惰性删除加上定期删除，两者配合使用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-14-key有效时间设置&quot;&gt;&lt;a href=&quot;#Redis-14-key有效时间设置&quot; class=&quot;headerlink&quot; title=&quot;Redis-14-key有效时间设置&quot;&gt;&lt;/a&gt;Redis-14-key有效时间设置&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文对redis的过期处理机制做个简单的概述，让大家有个基本的认识。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的&lt;/strong&gt;。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux-08-netstat详解</title>
    <link href="http://zhuuu.work/2020/08/19/Linux/Linux-08-netstat%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/08/19/Linux/Linux-08-netstat%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-08-19T03:44:53.000Z</published>
    <updated>2020-09-22T08:38:20.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-08-netstat详解"><a href="#Linux-08-netstat详解" class="headerlink" title="Linux-08-netstat详解"></a>Linux-08-netstat详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>Netstat</code> 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (<code>Interface Statistics</code>)，<code>masquerade</code> 连接，多播成员 (<code>Multicast Memberships</code>) 等等。</li></ul><p><strong>输出信息含义</strong></p><ul><li>执行<code>netstat</code>后，其输出结果为</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED</span><br><span class="line">tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED</span><br><span class="line">tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED</span><br><span class="line">tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED</span><br><span class="line">tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE</span><br><span class="line"></span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags Type State I-Node Path</span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16178 @000000dd</span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16176 @000000dc</span><br><span class="line">unix 9 [ ] DGRAM 5292 /dev/<span class="built_in">log</span></span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16182 @000000df</span><br></pre></td></tr></table></figure><p>从整体上看，<code>netstat</code>的输出结果可以分为两个部分：</p><ul><li><p>一个是<code>Active Internet connections</code>，称为有源TCP连接，其中”<code>Recv-Q</code>“和”<code>Send-Q</code>“指<code>%0A</code>的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。</p></li><li><p>另一个是<code>Active UNIX domain sockets</code>，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p></li><li><p>其中 ： Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。</p></li></ul><a id="more"></a><h2 id="1-常见参数"><a href="#1-常见参数" class="headerlink" title="1. 常见参数"></a>1. 常见参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-a (all)显示所有选项，默认不显示LISTEN相关</span><br><span class="line">-t (tcp)仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化成数字。</span><br><span class="line">-l 仅列出有在 Listen (监听) 的服務状态</span><br><span class="line"></span><br><span class="line">-p 显示建立相关链接的程序名</span><br><span class="line">-r 显示路由信息，路由表</span><br><span class="line">-e 显示扩展信息，例如uid等</span><br><span class="line">-s 按各个协议进行统计</span><br><span class="line">-c 每隔一个固定时间，执行该netstat命令。</span><br></pre></td></tr></table></figure><ul><li>提示：<code>LISTEN</code>和<code>LISTENING</code>的状态只有用-a或者-l才能看到</li></ul><h2 id="2-使用命令实例"><a href="#2-使用命令实例" class="headerlink" title="2. 使用命令实例"></a>2. 使用命令实例</h2><h3 id="2-1-列出所有端口-包括监听和未监听的"><a href="#2-1-列出所有端口-包括监听和未监听的" class="headerlink" title="2.1 列出所有端口(包括监听和未监听的)"></a>2.1 列出所有端口<strong>(包括监听和未监听的)</strong></h3><p> <strong>列出所有端口 netstat -a</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># netstat -a | more</span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> udp        0      0 *:bootpc                *:*</span><br><span class="line"> </span><br><span class="line">Active UNIX domain sockets (servers and established)</span><br><span class="line"> Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6135     &#x2F;tmp&#x2F;.X11-unix&#x2F;X0</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     5140     &#x2F;var&#x2F;run&#x2F;acpid.socket</span><br></pre></td></tr></table></figure><p> <strong>列出所有 tcp 端口 netstat -at</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># netstat -at</span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> tcp        0      0 localhost:ipp           *:*                     LISTEN</span><br><span class="line"> tcp        0      0 *:smtp                  *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br></pre></td></tr></table></figure><p> <strong>列出所有 udp 端口 netstat -au</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -au</span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> udp        0      0 *:bootpc                *:*</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br><span class="line"> udp        0      0 *:mdns                  *:*</span><br></pre></td></tr></table></figure><h3 id="2-2-列出所有处于监听状态的-Sockets"><a href="#2-2-列出所有处于监听状态的-Sockets" class="headerlink" title="2.2 列出所有处于监听状态的 Sockets"></a>2.2 列出所有处于监听状态的 Sockets</h3><p> <strong>只显示监听端口 netstat -l</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -l</span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:ipp           *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br></pre></td></tr></table></figure><p> <strong>只列出所有监听 tcp 端口 netstat -lt</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -lt</span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> tcp        0      0 *:smtp                  *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br></pre></td></tr></table></figure><p> <strong>只列出所有监听 udp 端口 netstat -lu</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># netstat -lu</span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br><span class="line"> udp        0      0 *:mdns                  *:*</span><br></pre></td></tr></table></figure><p> <strong>只列出所有监听 UNIX 端口 netstat -lx</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># netstat -lx</span><br><span class="line"> Active UNIX domain sockets (only servers)</span><br><span class="line"> Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6294     private&#x2F;maildrop</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6203     public&#x2F;cleanup</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6302     private&#x2F;ifmail</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6306     private&#x2F;bsmtp</span><br></pre></td></tr></table></figure><h3 id="2-3-显示每个协议的统计信息"><a href="#2-3-显示每个协议的统计信息" class="headerlink" title="2.3 显示每个协议的统计信息"></a>2.3 显示每个协议的统计信息</h3><p> <strong>显示所有端口的统计信息 netstat -s</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># netstat -s</span><br><span class="line"> Ip:</span><br><span class="line"> 11150 total packets received</span><br><span class="line"> 1 with invalid addresses</span><br><span class="line"> 0 forwarded</span><br><span class="line"> 0 incoming packets discarded</span><br><span class="line"> 11149 incoming packets delivered</span><br><span class="line"> 11635 requests sent out</span><br><span class="line"> Icmp:</span><br><span class="line"> 0 ICMP messages received</span><br><span class="line"> 0 input ICMP message failed.</span><br><span class="line"> Tcp:</span><br><span class="line"> 582 active connections openings</span><br><span class="line"> 2 failed connection attempts</span><br><span class="line"> 25 connection resets received</span><br><span class="line"> Udp:</span><br><span class="line"> 1183 packets received</span><br><span class="line"> 4 packets to unknown port received.</span><br><span class="line"> .....</span><br></pre></td></tr></table></figure><p> <strong>显示 TCP 或 UDP 端口的统计信息 netstat -st 或 -su</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># netstat -st </span><br><span class="line"># netstat -su</span><br></pre></td></tr></table></figure><h3 id="2-4-在输出中显示PID和进程名称"><a href="#2-4-在输出中显示PID和进程名称" class="headerlink" title="2.4 在输出中显示PID和进程名称"></a>2.4 在输出中显示PID和进程名称</h3><p><code>netstat -p</code> 可以与其它开关一起使用，就可以添加 “PID/进程名称” 到 netstat 输出中，这样 <code>debugging</code> 的时候可以很方便的发现特定端口运行的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># netstat -pt</span><br><span class="line"> Active Internet connections (w&#x2F;o servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line"> tcp        1      0 ramesh-laptop.loc:47212 192.168.185.75:www        CLOSE_WAIT  2109&#x2F;firefox</span><br><span class="line"> tcp        0      0 ramesh-laptop.loc:52750 lax:www ESTABLISHED 2109&#x2F;firefox</span><br></pre></td></tr></table></figure><h3 id="2-5-在输出中不显示主机，端口和用户名-host-port-or-user"><a href="#2-5-在输出中不显示主机，端口和用户名-host-port-or-user" class="headerlink" title="2.5 在输出中不显示主机，端口和用户名(host,port or user)"></a>2.5 在输出中不显示主机，端口和用户名(host,port or user)</h3><p>当你不想让主机，端口和用户名显示，使用 netstat -n。将会使用数字代替那些名称。</p><p>同样可以加速输出，因为不用进行比对查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -an</span><br></pre></td></tr></table></figure><p>如果只是不想让这三个名称中的一个被显示，使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># netsat -a --numeric-ports</span><br><span class="line"># netsat -a --numeric-hosts</span><br><span class="line"># netsat -a --numeric-users</span><br></pre></td></tr></table></figure><h3 id="2-6-持续输出netstat信息"><a href="#2-6-持续输出netstat信息" class="headerlink" title="2.6 持续输出netstat信息"></a>2.6 持续输出netstat信息</h3><ul><li><code>netstat</code> 将每隔一秒输出网络信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># netstat -c</span><br><span class="line"> Active Internet connections (w&#x2F;o servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 ramesh-laptop.loc:36130 101-101-181-225.ama:www ESTABLISHED</span><br><span class="line"> tcp        1      1 ramesh-laptop.loc:52564 101.11.169.230:www      CLOSING</span><br><span class="line"> tcp        0      0 ramesh-laptop.loc:43758 server-101-101-43-2:www ESTABLISHED</span><br><span class="line"> tcp        1      1 ramesh-laptop.loc:42367 101.101.34.101:www      CLOSING</span><br><span class="line"> ^C</span><br></pre></td></tr></table></figure><h3 id="2-7-显示系统不支持的地址族（Address-Families）"><a href="#2-7-显示系统不支持的地址族（Address-Families）" class="headerlink" title="2.7 显示系统不支持的地址族（Address Families）"></a>2.7 显示系统不支持的地址族（<strong>Address Families</strong>）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat --verbose</span><br></pre></td></tr></table></figure><p>在输出的末尾，会有如下的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat: no support for &#96;AF IPX&#39; on this system.</span><br><span class="line">netstat: no support for &#96;AF AX25&#39; on this system.</span><br><span class="line">netstat: no support for &#96;AF X25&#39; on this system.</span><br><span class="line">netstat: no support for &#96;AF NETROM&#39; on this system.</span><br></pre></td></tr></table></figure><h3 id="2-8-显示核心路由信息"><a href="#2-8-显示核心路由信息" class="headerlink" title="2.8 显示核心路由信息"></a>2.8 显示核心路由信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -r</span><br><span class="line"> Kernel IP routing table</span><br><span class="line"> Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line"> 192.168.1.0     *               255.255.255.0   U         0 0          0 eth2</span><br><span class="line"> link-local      *               255.255.0.0     U         0 0          0 eth2</span><br><span class="line"> default         192.168.1.1     0.0.0.0         UG        0 0          0 eth2</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 使用 <code>netstat -rn</code> 显示数字格式，不查询主机名称。</p><h3 id="2-9-找出程序运行的端口"><a href="#2-9-找出程序运行的端口" class="headerlink" title="2.9 找出程序运行的端口"></a>2.9 找出程序运行的端口</h3><ul><li>并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># netstat -ap | grep ssh</span><br><span class="line"> tcp        1      0 dev-db:ssh           101.174.100.22:39213        CLOSE_WAIT  -</span><br><span class="line"> tcp        1      0 dev-db:ssh           101.174.100.22:57643        CLOSE_WAIT  -</span><br></pre></td></tr></table></figure><ul><li><strong>找出运行在指定端口的进程</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -an | grep &#39;:80&#39;</span><br></pre></td></tr></table></figure><h3 id="2-10-显示网络接口列表"><a href="#2-10-显示网络接口列表" class="headerlink" title="2.10 显示网络接口列表"></a>2.10 显示网络接口列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -i</span><br><span class="line"> Kernel Interface table</span><br><span class="line"> Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line"> eth0       1500 0         0      0      0 0             0      0      0      0 BMU</span><br><span class="line"> eth2       1500 0     26196      0      0 0         26883      6      0      0 BMRU</span><br><span class="line"> lo        16436 0         4      0      0 0             4      0      0      0 LRU</span><br></pre></td></tr></table></figure><ul><li>显示详细信息，像是 <code>ifconfig</code> 使用 <code>netstat -ie</code>:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># netstat -ie</span><br><span class="line"> Kernel Interface table</span><br><span class="line"> eth0      Link encap:Ethernet  HWaddr 00:10:40:11:11:11</span><br><span class="line"> UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line"> RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line"> TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line"> collisions:0 txqueuelen:1000</span><br><span class="line"> RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"> Memory:f6ae0000-f6b00000</span><br></pre></td></tr></table></figure><h3 id="2-11-IP和TCP分析"><a href="#2-11-IP和TCP分析" class="headerlink" title="2.11 IP和TCP分析"></a>2.11 IP和TCP分析</h3><p><strong>查看连接某服务端口最多的的IP地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wss8848@ubuntu:~$ netstat -nat | grep &quot;192.168.1.15:22&quot; |awk &#39;&#123;print $5&#125;&#39;|awk -F: &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -20</span><br><span class="line">18 221.136.168.36</span><br><span class="line">3 154.74.45.242</span><br><span class="line">2 78.173.31.236</span><br><span class="line">2 62.183.207.98</span><br><span class="line">2 192.168.1.14</span><br><span class="line">2 182.48.111.215</span><br><span class="line">2 124.193.219.34</span><br><span class="line">2 119.145.41.2</span><br><span class="line">2 114.255.41.30</span><br><span class="line">1 75.102.11.99</span><br></pre></td></tr></table></figure><p> <strong>TCP各种状态列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wss8848@ubuntu:~$ netstat -nat |awk &#39;&#123;print $6&#125;&#39;</span><br><span class="line">established)</span><br><span class="line">Foreign</span><br><span class="line">LISTEN</span><br><span class="line">TIME_WAIT</span><br><span class="line">ESTABLISHED</span><br><span class="line">TIME_WAIT</span><br><span class="line">SYN_SENT</span><br></pre></td></tr></table></figure><ul><li>先把状态全都取出来,然后使用<code>uniq -c</code>统计，之后再进行排序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wss8848@ubuntu:~$ netstat -nat |awk &#39;&#123;print $6&#125;&#39;|sort|uniq -c</span><br><span class="line">143 ESTABLISHED</span><br><span class="line">1 FIN_WAIT1</span><br><span class="line">1 Foreign</span><br><span class="line">1 LAST_ACK</span><br><span class="line">36 LISTEN</span><br><span class="line">6 SYN_SENT</span><br><span class="line">113 TIME_WAIT</span><br><span class="line">1 established)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  最后的命令如下:</span><br><span class="line">netstat -nat |awk &#39;&#123;print $6&#125;&#39;|sort|uniq -c|sort -rn</span><br><span class="line">分析access.log获得访问前10位的ip地址</span><br><span class="line">awk &#39;&#123;print $1&#125;&#39; access.log |sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-08-netstat详解&quot;&gt;&lt;a href=&quot;#Linux-08-netstat详解&quot; class=&quot;headerlink&quot; title=&quot;Linux-08-netstat详解&quot;&gt;&lt;/a&gt;Linux-08-netstat详解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Netstat&lt;/code&gt; 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (&lt;code&gt;Interface Statistics&lt;/code&gt;)，&lt;code&gt;masquerade&lt;/code&gt; 连接，多播成员 (&lt;code&gt;Multicast Memberships&lt;/code&gt;) 等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;输出信息含义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行&lt;code&gt;netstat&lt;/code&gt;后，其输出结果为&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Active Internet connections (w/o servers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Proto Recv-Q Send-Q Local Address Foreign Address State&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Active UNIX domain sockets (w/o servers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Proto RefCnt Flags Type State I-Node Path&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unix 1 [ ] STREAM CONNECTED 16178 @000000dd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unix 1 [ ] STREAM CONNECTED 16176 @000000dc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unix 9 [ ] DGRAM 5292 /dev/&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unix 1 [ ] STREAM CONNECTED 16182 @000000df&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;从整体上看，&lt;code&gt;netstat&lt;/code&gt;的输出结果可以分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个是&lt;code&gt;Active Internet connections&lt;/code&gt;，称为有源TCP连接，其中”&lt;code&gt;Recv-Q&lt;/code&gt;“和”&lt;code&gt;Send-Q&lt;/code&gt;“指&lt;code&gt;%0A&lt;/code&gt;的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另一个是&lt;code&gt;Active UNIX domain sockets&lt;/code&gt;，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其中 ： Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Linux网络管理" scheme="http://zhuuu.work/tags/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux-01-网络IO</title>
    <link href="http://zhuuu.work/2020/08/18/Linux/Linux-01-%E7%BD%91%E7%BB%9CIO/"/>
    <id>http://zhuuu.work/2020/08/18/Linux/Linux-01-%E7%BD%91%E7%BB%9CIO/</id>
    <published>2020-08-18T07:52:53.000Z</published>
    <updated>2020-09-13T11:01:55.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-01-网络IO"><a href="#Linux-01-网络IO" class="headerlink" title="Linux-01-网络IO"></a>Linux-01-网络IO</h1><p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1-用户空间与内核空间"><a href="#1-用户空间与内核空间" class="headerlink" title="1. 用户空间与内核空间"></a>1. 用户空间与内核空间</h3><ul><li>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，<strong>它的寻址空间（虚拟存储空间）为4G（2的32次方）</strong>。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</li><li><strong>针对linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），供内核使用，称为内核空间，</strong></li><li><strong>而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间。</strong></li></ul><h3 id="2-进程切换"><a href="#2-进程切换" class="headerlink" title="2. 进程切换"></a>2. 进程切换</h3><ul><li><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol></li></ul><h3 id="3-进程阻塞"><a href="#3-进程阻塞" class="headerlink" title="3. 进程阻塞"></a>3. 进程阻塞</h3><ul><li>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</li></ul><h3 id="4-文件描述符fd"><a href="#4-文件描述符fd" class="headerlink" title="4. 文件描述符fd"></a>4. 文件描述符fd</h3><ul><li>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</li><li><strong>文件描述符在形式上是一个非负整数。实际上，它是一个索引值</strong>，指向<strong>内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</li></ul><h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><ul><li><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<br><strong>1. 等待数据准备 (Waiting for the data to be ready)</strong><br><strong>2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</strong></p></li><li><p><strong>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</strong><br><strong>- 阻塞 I/O（blocking IO）</strong><br><strong>- 非阻塞 I/O（nonblocking IO）</strong><br><strong>- I/O 多路复用（ IO multiplexing）</strong><br><strong>- 信号驱动 I/O（ signal driven IO）</strong><br><strong>- 异步 I/O（asynchronous IO）</strong></p></li></ul><p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><h3 id="1-阻塞-I-O（blocking-IO）"><a href="#1-阻塞-I-O（blocking-IO）" class="headerlink" title="1. 阻塞 I/O（blocking IO）"></a>1. 阻塞 I/O（blocking IO）</h3><ul><li>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-162629646.png" alt="mark"></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。</p><p>这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h3 id="2-非阻塞-I-O（nonblocking-IO）"><a href="#2-非阻塞-I-O（nonblocking-IO）" class="headerlink" title="2. 非阻塞 I/O（nonblocking IO）"></a>2. 非阻塞 I/O（nonblocking IO）</h3><ul><li>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-163037584.png" alt="mark"></p><ul><li>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。</li><li>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。</li><li>用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</li></ul><blockquote><p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p></blockquote><h3 id="3-异步-I-O（asynchronous-IO）"><a href="#3-异步-I-O（asynchronous-IO）" class="headerlink" title="3. 异步 I/O（asynchronous IO）"></a>3. 异步 I/O（asynchronous IO）</h3><ul><li>Linux下的asynchronous IO其实用得很少。先看一下它的流程：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-164148525.png" alt="mark"></p><h3 id="4-I-O-多路复用（-IO-multiplexing）"><a href="#4-I-O-多路复用（-IO-multiplexing）" class="headerlink" title="4. I/O 多路复用（ IO multiplexing）"></a>4. I/O 多路复用（ IO multiplexing）</h3><ul><li><code>IO multiplexing</code>就是我们说的<code>select，poll，epoll</code>，有些地方也称这种IO方式为<code>event driven IO select/epoll</code>的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是<code>select，poll，epoll</code>这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200818-165609923.png" alt="mark"></p><ul><li><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</li></ul><ul><li><p>所以，I/O 多路复用的特点是<strong>通过一种机制一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p></li><li><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p></li><li><p>在IO multiplexing Model中，实际中，对于每一个<code>socket</code>，一般都设置成为<code>non-blocking</code>，但是，如上图所示，整个用户的<code>process</code>其实是一直被<code>block</code>的。只不过<code>process</code>是被<code>select</code>这个函数<code>block</code>，而不是被<code>socket IO</code>给<code>block</code>。</p></li></ul><h2 id="select-poll-epoll-详解"><a href="#select-poll-epoll-详解" class="headerlink" title="select poll epoll 详解"></a>select poll epoll 详解</h2><p><strong>总结的不错的博客:</strong> <a href="https://blog.csdn.net/jiange_zh/article/details/50811553" target="_blank" rel="noopener">https://blog.csdn.net/jiange_zh/article/details/50811553</a></p><p>(1)select==&gt;时间复杂度O(n)</p><ul><li>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200830/142733029.png" alt="mark"></p><p>(2)poll==&gt;时间复杂度O(n)</p><ul><li>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</li></ul><p>(3)epoll==&gt;时间复杂度O(1)</p><ul><li><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200830/142834510.png" alt="mark"></p><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 </p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><p><strong>epoll的工作方式</strong></p><p>epoll的两种工作方式：<strong>1.水平触发（LT）2.边缘触发（ET）</strong> </p><p><strong>LT模式：</strong></p><ul><li>若就绪的事件一次没有处理完要做的事件，就会一直去处理。</li><li>即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 </li></ul><p><strong>ET模式：</strong></p><ul><li>就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。</li><li>而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。 </li></ul><p>由此可见：ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。<br>注意：ET模式只支持非阻塞的读写：为了保证数据的完整性。</p><p><strong>总结：</strong></p><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-blocking和non-blocking的区别"><a href="#1-blocking和non-blocking的区别" class="headerlink" title="1. blocking和non-blocking的区别"></a>1. blocking和non-blocking的区别</h3><ul><li>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</li></ul><h3 id="2-synchronous-IO和asynchronous-IO的区别"><a href="#2-synchronous-IO和asynchronous-IO的区别" class="headerlink" title="2. synchronous IO和asynchronous IO的区别"></a>2. synchronous IO和asynchronous IO的区别</h3><ul><li>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</li></ul><p><strong>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</strong></p><ul><li><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。<strong>但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</strong></p></li><li><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-01-网络IO&quot;&gt;&lt;a href=&quot;#Linux-01-网络IO&quot; class=&quot;headerlink&quot; title=&quot;Linux-01-网络IO&quot;&gt;&lt;/a&gt;Linux-01-网络IO&lt;/h1&gt;&lt;p&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="多路复用" scheme="http://zhuuu.work/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux-07-内存管理</title>
    <link href="http://zhuuu.work/2020/08/18/Linux/Linux-07-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/08/18/Linux/Linux-07-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-18T03:52:53.000Z</published>
    <updated>2020-09-21T14:36:28.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-07-内存管理"><a href="#Linux-07-内存管理" class="headerlink" title="Linux-07-内存管理"></a>Linux-07-内存管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>操作系统内存管理：</strong>总的来说，操作系统内存管理包括<strong>物理内存管理</strong>和<strong>虚拟内存管理</strong>。</li></ul><p><strong>物理内存管理：</strong></p><ul><li>包括程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式（分页、分段、段页式）。</li></ul><p><strong>虚拟内存管理：</strong></p><ul><li>虚拟内存管理包括虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。</li></ul><a id="more"></a><h2 id="1-计算机存储体系"><a href="#1-计算机存储体系" class="headerlink" title="1. 计算机存储体系"></a>1. 计算机存储体系</h2><ul><li>内存是计算机很重要的一个资源，因为<strong>程序只有被加载到内存中才可以运行</strong>；此外，CPU所需要的指令与数据也都是来自内存的。可以说，内存是影响计算机性能的一个很重要的因素。</li></ul><h3 id="1-1-分层存储器体系"><a href="#1-1-分层存储器体系" class="headerlink" title="1.1 分层存储器体系"></a>1.1 分层存储器体系</h3><ul><li><p>在介绍内存管理的细节前，先要了解一下分层存储器体系：</p><ul><li>大部分的计算机都有一个存储器层次结构，即少量的非常快速、昂贵、易变的高速缓存(cache)；若干兆字节的中等速度、中等价格、易变的主存储器(RAM)；数百兆或数千兆的低速、廉价、不易变的磁盘。这些资源的合理使用与否直接关系着系统的效率。<ul><li>CPU缓存（Cache Memory）：是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。缓存的出现主要是为了解决CPU运算速度与内存 读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据到来或把数据写入内存。</li></ul></li></ul></li><li><p>计算机是一种数据处理设备，它由CPU和内存以及外部设备组成。CPU负责数据处理，内存负责存储，外部设备负责数据的输入和输出，它们之间通过总线连接在一起。</p></li><li><p>CPU内部主要由控制器、运算器和寄存器组成。控制器负责指令的读取和调度，运算器负责指令的运算执行，寄存器负责数据的存储，它们之间通过CPU内的总线连接在一起。</p></li><li><p>每个外部设备(例如：显示器、硬盘、键盘、鼠标、网卡等等)则是由外设控制器、I/O端口、和输入输出硬件组成。</p><ul><li>外设控制器负责设备的控制和操作，I/O端口负责数据的临时存储，输入输出硬件则负责具体的输入输出，它们间也通过外部设备内的总线连接在一起。</li></ul></li></ul><p><strong>在这套设计思想(冯.诺依曼体系架构)里面: 总是有一部分负责控制、一部分负责执行、一部分则负责存储，它之间进行交互以及接口通信则总是通过总线来完成。</strong></p><ul><li>这种设计思路一样的可以应用在我们的软件设计体系里面：组件和组件之间通信通过事件的方式来进行解耦处理，而一个组件内部同样也需要明确好各个部分的职责(一部分负责调度控制、一部分负责执行实现、一部分负责数据存储)。</li></ul><h3 id="1-2-计算存储的层次结构"><a href="#1-2-计算存储的层次结构" class="headerlink" title="1.2 计算存储的层次结构"></a>1.2 计算存储的层次结构</h3><ul><li>当前技术没有能够提供这样的存储器，因此大部分的计算机都有一个存储器层次结构:<ul><li>高速缓存(cache): 少量的非常快速、昂贵、易变的高速缓存(cache)；</li><li>主存储器(RAM): 若干兆字节的中等速度、中等价格、易变的主存储器(RAM)；</li><li>磁盘: 数百兆或数千兆的低速、廉价、不易变的磁盘。</li></ul></li></ul><p>这些资源的合理使用与否直接关系着系统的效率。</p><h2 id="2-内存使用的演化"><a href="#2-内存使用的演化" class="headerlink" title="2. 内存使用的演化"></a>2. 内存使用的演化</h2><h3 id="2-1-没有内存的年代"><a href="#2-1-没有内存的年代" class="headerlink" title="2.1 没有内存的年代"></a>2.1 没有内存的年代</h3><ul><li>在早些的操作系统中，并没有引入内存抽象的概念。<strong>程序直接访问和操作的都是物理内存</strong>，内存的管理也非常简单，除去操作系统所用的内存之外，全部给用户程序使用，想怎么折腾都行，只要别超出最大的容量。比如当执行如下指令时：</li></ul><p><code>mov reg1,1000</code></p><p><strong>1、无内存抽象存在的问题：</strong></p><p>这条指令会毫无想象力的将物理地址1000中的内容赋值给寄存器。不难想象，这种内存操作方式使得操作系统中存在多进程变得完全不可能，比如MS-DOS，你必须执行完一条指令后才能接着执行下一条。如果是多进程的话，由于直接操作物理内存地址，当一个进程给内存地址1000赋值后，另一个进程也同样给内存地址赋值，那么第二个进程对内存的赋值会覆盖第一个进程所赋的值，这回造成两条进程同时崩溃。</p><p><strong>带来两个问题：</strong></p><ol><li>用户程序可以访问任意内存，容易破坏操作系统，造成崩溃</li><li>同时运行多个程序特别困难</li></ol><p>随着计算机技术发展，要求操作系统支持多进程的需求，所谓多进程，并不需要同时运行这些进程，只要它们都处于 ready 状态，操作系统快速地在它们之间切换，就能达到同时运行的假象。每个进程都需要内存，Context Switch 时，之前内存里的内容怎么办？简单粗暴的方式就是先 dump 到磁盘上，然后再从磁盘上 restore 之前 dump 的内容（如果有的话），但效果并不好，太慢了！</p><h3 id="2-2-内存抽象：地址空间"><a href="#2-2-内存抽象：地址空间" class="headerlink" title="2.2 内存抽象：地址空间"></a>2.2 内存抽象：地址空间</h3><ul><li>那怎么才能不慢呢？把进程对应的内存依旧留在物理内存中，需要的时候就切换到特定的区域。这就涉及到了内存的保护机制，毕竟进程之间可以随意读取、写入内容就乱套了，非常不安全。因此操作系统需要对物理内存做一层抽象，也就是「地址空间」(Address Space)，一个进程的地址空间包含了该进程所有相关内存，比如 code / stack / heap。一个 16 KB 的地址空间可能长这样：</li></ul><p>当程序运行时，heap 和 stack 共用中间 free 的区域，当然这只是 OS 层面的抽象。比如下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line"> </span><br><span class="line">x &#x3D; x + 3; &#x2F;&#x2F; this is the line of code we are interested in</span><br></pre></td></tr></table></figure><p>变成汇编指令后，大概是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">128: movl 0x0(%ebx), %eax  ;load 0+ebx into eax</span><br><span class="line">132: addl $0x03, %eax ;add 3 to eax register</span><br><span class="line">135: movl %eax, 0x0(%ebx) ;store eax back to mem</span><br></pre></td></tr></table></figure><ul><li>最前面的是 PC (Program Counter)，用来表示当前 code 的索引，比如 CPU 执行到 128 时，进行了 Context Switch（上下文切换），那么在 Switch 回来后，还可以接着从 132 开始执行（当然需要先把 PC 存起来）。之后的就是汇编代码，告诉 CPU 该如何操作。</li></ul><ul><li><p><strong>基址寄存器与界限寄存器可以简单的动态重定位：</strong>每个内存地址送到内存之前，都会自动加上基址寄存器的内容.</p><ul><li><p>从 32KB 处作为开始，48KB 作为结束。那 32 / 48 可不可以动态设置呢，只要在 CPU 上整两个寄存器，<strong>基址寄存器</strong>base 和 <strong>界限寄存器</strong>bounds 就可以了，base 指明从哪里开始，bounds 指定哪里是边界。 因此真实物理地址和虚拟地址之间的关系是：</p></li><li><pre><code>physical address = virtual address + base</code></pre></li><li><p>有时，CPU 上用来做内存地址翻译的也会被叫做「内存管理单元 MMU」(Memory Management Unit)，随着功能越来越强大，MMU 也会变得越来越复杂。</p></li><li><p>base and bounds 这种做法最大的问题在于空间浪费，Stack 和 Heap 中间有一块 free space，即使没有用，也被占着，那如何才能解放这块区域呢，进入虚拟内存。</p></li></ul></li></ul><h2 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3. 虚拟内存"></a>3. 虚拟内存</h2><ul><li>虚拟内存是现代操作系统普遍使用的一种技术。前面所讲的<strong>抽象满足了多进程的要求，但很多情况下，现有内存无法满足仅仅一个大进程的内存要求</strong>。物理内存不够用的情况下，如何解决呢？<ul><li><strong>覆盖overlays：</strong>在早期的操作系统曾使用覆盖技术来解决这个问题，将一个程序分为多个块，基本思想是先将块0加入内存，块0执行完后，将块1加入内存。依次往复，这个解决方案最大的问题是需要程序员去程序进行分块，这是一个费时费力让人痛苦不堪的过程。后来这个解决方案的修正版就是虚拟内存。</li><li><strong>交换swapping：</strong>可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），或读人保存在外存中而处于就绪状态的程序。</li><li><strong>虚拟内存：</strong>虚拟内存的基本思想是，每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为<strong>页</strong>(Page).每个页都是一段连续的地址。对于进程来看,逻辑上貌似有很多内存空间，其中<strong>一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)</strong>，还有一些没加载在内存中的对应在硬盘上。</li></ul></li></ul><h2 id="4-物理内存：连续分配存储管理方式"><a href="#4-物理内存：连续分配存储管理方式" class="headerlink" title="4. 物理内存：连续分配存储管理方式"></a>4. 物理内存：连续分配存储管理方式</h2><ul><li>连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式。</li></ul><h3 id="4-1-单一连续存储管理"><a href="#4-1-单一连续存储管理" class="headerlink" title="4.1 单一连续存储管理"></a>4.1 单一连续存储管理</h3><ul><li>在这种管理方式中，内存被分为两个区域：系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。其特点是，最简单，适用于单用户、单任务的操作系统。CP／M和 DOS 2．0以下就是采用此种方式。这种方式的最大优点就是易于管理。但也存在着一些问题和不足之处，例如对要求内存空间少的程序，造成内存浪费；程序全部装入，使得很少使用的程序部分也占用—定数量的内存。</li></ul><h3 id="4-2-分区式存储管理"><a href="#4-2-分区式存储管理" class="headerlink" title="4.2 分区式存储管理"></a>4.2 分区式存储管理</h3><ul><li><p>为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。</p></li><li><p>分区式存储管理引人了两个新的问题：内碎片和外碎片。</p></li><li><p>内碎片是占用分区内未被利用的空间，外碎片是占用分区之间难以利用的空闲分区(通常是小空闲分区)。</p></li><li><p>为实现分区式存储管理，操作系统应维护的数据结构为分区表或分区链表。表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。</p></li><li><p>分区式存储管理常采用的一项技术就是<strong><em>\</em>内存紧缩(compaction)。**</strong></p></li></ul><p><a href="https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param</a></p><p>未完待续</p><p><strong>参考博客 ：</strong> <a href="https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-07-内存管理&quot;&gt;&lt;a href=&quot;#Linux-07-内存管理&quot; class=&quot;headerlink&quot; title=&quot;Linux-07-内存管理&quot;&gt;&lt;/a&gt;Linux-07-内存管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作系统内存管理：&lt;/strong&gt;总的来说，操作系统内存管理包括&lt;strong&gt;物理内存管理&lt;/strong&gt;和&lt;strong&gt;虚拟内存管理&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;物理内存管理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包括程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式（分页、分段、段页式）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存管理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟内存管理包括虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-XX-Mysql面试总结</title>
    <link href="http://zhuuu.work/2020/08/17/Mysql/Mysql-XX-Mysql%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://zhuuu.work/2020/08/17/Mysql/Mysql-XX-Mysql%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-17T08:02:27.000Z</published>
    <updated>2020-08-17T01:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-XX-Mysql面试总结"><a href="#Mysql-XX-Mysql面试总结" class="headerlink" title="Mysql-XX-Mysql面试总结"></a>Mysql-XX-Mysql面试总结</h1><p><a href="https://www.jianshu.com/p/c189439fb32e" target="_blank" rel="noopener">https://www.jianshu.com/p/c189439fb32e</a> <strong>一定要看</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql-XX-Mysql面试总结&quot;&gt;&lt;a href=&quot;#Mysql-XX-Mysql面试总结&quot; class=&quot;headerlink&quot; title=&quot;Mysql-XX-Mysql面试总结&quot;&gt;&lt;/a&gt;Mysql-XX-Mysql面试总结&lt;/h1&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux-06-多路复用</title>
    <link href="http://zhuuu.work/2020/08/17/Linux/Linux-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://zhuuu.work/2020/08/17/Linux/Linux-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2020-08-17T03:52:53.000Z</published>
    <updated>2020-09-22T01:15:48.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-06-多路复用"><a href="#Linux-06-多路复用" class="headerlink" title="Linux-06-多路复用"></a>Linux-06-多路复用</h1><h2 id="1-BIO-的缺陷"><a href="#1-BIO-的缺陷" class="headerlink" title="1. BIO 的缺陷"></a>1. BIO 的缺陷</h2><ul><li>BIO中的B 是 <code>Blocking</code> 的阻塞的意思</li><li>作为<strong>服务端开发</strong>，使用<code>ServerSocket</code> 绑定端口号之后会监听该端口,等待<code>accept</code>事件，<code>accept</code>是会阻塞当前线程</li><li>当我们收到<code>accept</code>事件的时候，程序就会拿到客户端与当前服务端连接的<code>Socket</code></li><li>针对这个<code>socket</code>我们可以进行读写，但是呢，这个<code>socket</code>读写都是会阻塞当前线程的。</li><li>一般我们会有使用<strong>多线程方式进行c/s交互，但是这样很难做到C10K</strong>（比如说：1W个客户端就需要和服务端用1W个线程支持，这样的话CPU肯定就爆炸了，同时线程上下文切换也会把机器负载给拉飞。）</li></ul><a id="more"></a><h2 id="2-NIO-解决C10K问题"><a href="#2-NIO-解决C10K问题" class="headerlink" title="2. NIO 解决C10K问题"></a>2. NIO 解决C10K问题</h2><h3 id="2-1-Java角度"><a href="#2-1-Java角度" class="headerlink" title="2.1 Java角度"></a>2.1 Java角度</h3><ul><li>站在java 角度去看，NIO包提供了一套非阻塞的接口，这样就<strong>不需要我们为每一个c/s长连接保留一个单独的处理线程了。</strong></li><li>这个<strong>阻塞BIO之所以需要给每个socket长连接指定一个线程，就是因为它阻塞</strong>嘛</li><li>现在这个NIO API具有非阻塞的特性了，就可以<strong>用1个线程去检查n个socket</strong></li><li>在 java 层面，nio 提供了一个这样的选择器<code>selector</code></li><li>然后我们<strong>需要把需要检查的socket注册到这个<code>selector</code>中</strong>，然后主线程阻塞在<code>selector</code>的<code>select</code>方法中。</li><li>当选择器发现<code>socket</code>就绪了，某个socket就绪了。就会唤醒主线程，</li><li>然后咱们可以通过<code>selector</code> 获取就绪状态的<code>socket</code> 进行相应的处理。</li></ul><p><strong>其实这里selector 里面是native api ,底层Jvm调用SystemCall kernel去实现的</strong></p><h2 id="3-select-…-实现原理"><a href="#3-select-…-实现原理" class="headerlink" title="3. select(…) 实现原理"></a>3. select(…) 实现原理</h2><ul><li><strong>每次调用<code>kernel</code> 的 select函数，都会涉及到用户态/内核态的切换</strong>，<strong>还需要传递需要检查的socket集合</strong>，其实就是需要检查的<code>fd</code>(文件描述符)集合<ul><li>因为咱的程序都是运行在linux或者unix操作系统上，这种操作系统，一切皆文件，<code>socket</code>也不例外，这里传递的fd其实就是文件系统中对应socket生成的文件描述符</li></ul></li><li><strong>操作系统 这个<code>select</code>函数被调用以后，</strong><ul><li><strong>首先会去fd集合中去检查内存中<code>socket</code>套接字的状态，这个时间复杂度是<code>O(N)</code>的</strong>，然后检查完一遍之后，如果有就绪状态的<code>socket</code>,那么就会直接返回，不会阻塞当前线程。</li><li>否则的话，那个就说明当前指定<code>fd</code>集合对应的<code>socket</code>没有就绪状态，那么就需要阻塞当前调用线程了，直到有某个<code>socket</code>有数据之后，才唤醒线程。</li></ul></li></ul><p><strong>select(…) 对监听socket有1024的大小限制</strong></p><ul><li>这个是因为<code>fd</code>集合这个结构是一个<strong><code>bitmap</code>位图的结构</strong>，这个位图结构就是一个长的二进制数,类似<code>0101</code>这种<ul><li>这个<code>bitmap</code>默认长度是<code>1024个bit</code>,想要修改长度非常麻烦，需要<strong>重新编译操作系统内核</strong></li></ul></li><li>处于某种性能考虑,<code>select</code>函数做了两件事<ul><li><strong>第一件事</strong>，跑到就绪状态的<code>socket</code>对应的fd文件中设置一个标记mask,表示这个fd对应的<code>socket</code>就绪了</li><li><strong>第二件事</strong>，返回<code>select</code>函数，对应的也就是唤醒java线程，站在java层面，<strong>他会收到一个int结果值，表示有几个socket处于就绪状态</strong><ul><li>但是具体是哪个<code>socket</code>就绪，<code>java</code>是不知道的，所以接下来会是一个<code>O(N)</code>的系统调用，检查fd集合中每一个socket的就绪状态，其实就是检查文件系统中指定<code>socket</code>的文件描述符的状态，<strong>涉及到用户态和内核态的来回切换，如果<code>bitmap</code>再大，就非常耗费性能</strong></li><li>还有就是<strong>系统调用涉及到参数的数据拷贝</strong>，如果数据太庞大，他也不利于系统的调用速度</li></ul></li></ul></li></ul><h2 id="4-select-深入问题"><a href="#4-select-深入问题" class="headerlink" title="4. select(..) 深入问题"></a>4. select(..) 深入问题</h2><p><strong>问题：select (…) 第一遍 O(N) 去检查未发现就绪的socket ，后续某个socket就绪后，select(…)是如何感知道的？是不断的轮询吗？</strong></p><p><strong>铺垫知识</strong></p><ol><li><strong>操作系统调度</strong></li></ol><ul><li>cpu同一时刻，它只能运行一个进程，操作系统做主要的任务就是系统调度，就是有n个进程，然后让这n个进程在cpu上切换进行</li><li><strong>未挂起的进程都在工作队列内</strong>，都有机会获取到cpu的执行权</li><li><strong>挂起的进程就会从这个工作队列里移除出去</strong>，反映到咱们java层面就是线程阻塞了</li><li>linux系统线程其实就是轻量级进程</li></ul><ol start="2"><li><strong>操作系统中断</strong></li></ol><ul><li><p>比如说，咱们用键盘打字，如果cpu正执行其他程序，一直不释放，那咱这个打字就也没法打了</p></li><li><p>咱们都知道，不是这样的情况，因为就是有系统中断的存在，当按下一个键以后会给主板发送一个电流信号，主板感知到以后，它就会触发这个cpu中断、</p></li><li><p><strong>所以中断 其实就是让cpu给正在执行的进程先保留程序上下文，然后避让出cpu，给中断程序绕道</strong></p></li><li><p><strong>中断程序就会拿到cpu的执行权限</strong>，进行相应代码的执行，比如说键盘的中断程序，就会执行输出的逻辑</p></li></ul><p><strong>回到最开始的问题</strong></p><ul><li>这个<code>select</code>函数，它第一遍轮询，没有发现就绪状态的socket的话，它就会把当前进程保留给需要检查的socket等待队列中</li><li><code>socket</code> 结构 有三块核心区域，分别就是<strong>读缓存，写缓存还有这个等待队列</strong></li><li>这个 <code>select</code> 函数，它会把当前进程保留到每个需要检查的socket 的等待队列中，就会把当前进程从工作队列里面移除了，移除了之后其实就是挂起了当前线程，然后这个select 函数也就不会再运行了</li><li><strong>下一个阶段，假设我们客户端往当前服务器发送了数据</strong>，数据通过网线到网卡，网卡再到DMA硬件的这种方式直接将数据写到内存里面，然后整个过程，CPU是不参与的</li><li>当传输完成以后，它就会触发网络数据传输完毕的中断程序，这个中断程序它会把cpu正在执行的进程给顶掉，然后<strong>cpu就会执行咱这个中断程序的逻辑</strong><ul><li>对应的逻辑是：根据内存中的数据包，然后分析出来数据包是哪个socket的数据，</li><li>同时tcp/ip它又是保证传输的时候是有端口号的，然后根据端口号就能找到对用的socket实例，找到socket实例以后，就会<strong>把数据导入到socket读缓冲里面</strong></li><li><strong>导入完成以后，它就开始去检查socket等待队列</strong>，看是不是有等待者，如果有等待者的话，就会把等待者移动到工作队列里面去，中断程序到这一步就执行完了</li><li>这样咱们的进程就又回到了工作队列，又有机会获取到cpu时间片了</li></ul></li><li>然后当前进程执行的<code>select</code>函数再次检查，就会发现这个就绪的<code>socket了</code>,就会给就绪的<code>socket</code>的<code>fd</code>文件描述符打标记，然后<code>select</code>函数就执行完了，返回到java层面就涉及到内核态和用户态的转换，<strong>后面的事情就是轮询检查</strong>每一个socket的fd是否被打了标记，然后就是处理被打了标记的socket就ok了</li></ul><h2 id="5-poll-和-select-区别"><a href="#5-poll-和-select-区别" class="headerlink" title="5. poll() 和 select()区别"></a>5. poll() 和 select()区别</h2><ul><li><strong>传参不一样</strong> <ul><li><strong>select 用的是bitmap ，</strong>它表示需要检查的socket集合</li><li><strong>poll 使用的是 链表结构，</strong>表示需要检查的socket集合（主要是为了解决socket监听长度超过1024的<code>socket</code>的限制）</li></ul></li></ul><h2 id="6-epoll-的-产生背景"><a href="#6-epoll-的-产生背景" class="headerlink" title="6. epoll 的 产生背景"></a>6. epoll 的 产生背景</h2><ul><li><strong>select 和 poll 的共有缺陷</strong><ul><li><strong>第一个缺陷：</strong> <code>select</code> 和 <code>poll</code> 函数，<strong>这两系统函数每次调用都需要我们提供给它所有的需要监听的socket文件描述符集合，而且主线程是死循环调用<code>select/poll</code>函数的,这里面涉及到用户空间数据到内核空间拷贝的过程</strong><ul><li>咱们需要监听的socket集合，<strong>数据变化非常小</strong></li><li><strong>每次就一到两个socket_fd需要更改，但是没有办法，因为select和poll函数，只是一个很单纯的函数</strong></li><li><strong>它在kernel层面，不会保留任何的数据信息，所以说每次调用都进行了数据拷贝</strong></li></ul></li><li><strong>第二个缺陷：</strong> select 和 poll 函数它的返回值都是int整型值，只能代表有几个socket就绪或者有错误了，它没办法表示具体是哪个socket就绪了<ul><li>这就<strong>导致了程序被唤醒以后，还需要新的一轮系统调用去检查哪个socket是就绪状态的</strong>，然后再进行socket数据处理逻辑，这里走了不少弯路（同时还存在用户态和内核态的切换，这样缺陷就更严重了）</li></ul></li></ul></li></ul><p><strong>epoll 就是为了解决这两个问题</strong></p><h2 id="7-epoll-…-实现原理"><a href="#7-epoll-…-实现原理" class="headerlink" title="7. epoll (…) 实现原理"></a>7. epoll (…) 实现原理</h2><ul><li>epoll 函数<strong>在内核空间内，它有一个对应的数据结构去存储一些数据，这个数据结构其实就是eventpoll对象</strong><ul><li>这个<code>eventpoll</code> 可以通过一个系统函数<code>epoll_create()</code>函数去创建的</li></ul></li><li>创建完成之后，系统函数返回一个<code>eventpoll</code>对象的id，相当于我们在内核空间开辟了一小块空间，并且我们也知道这块空间的位置</li></ul><p><strong>先说下eventpoll 的数据结构：三块重要的区域</strong></p><ul><li>一块是存放<strong>需要监听的socket_fd描述符列表</strong></li><li>另一块就是<strong>就绪列表，存放就绪状态的socket信息</strong></li><li>eventpoll 还有一块空间是<code>eventpoll</code> 的<strong>等待队列，这个等待队列保存的就是调用<code>epoll_wait</code>的进程</strong></li><li><strong>另外呢还提供了两个函数，一个是<code>epoll_ctl</code>函数，一个是<code>epoll_wait</code>函数</strong></li><li><strong>其中存放的socket集合信息采用的是红黑树的数据结构</strong>，socket集合信息经常用增删改查的，这种红黑树再适合不过了，保持了时间复杂度为O(logN)</li></ul><p><strong>epoll_ctl()</strong> </p><ul><li>它可以根据<code>eventpoll-id</code>去增删改内核空间上<code>eventpoll</code> 对象的检查列表（socket信息）</li></ul><p>*<em>epoll_wait() *</em></p><ul><li>它主要的参数是<code>eventpoll-id</code> 表示此次系统调用需要检测的<code>socket_fd</code>集合，是<code>eventpoll</code> 中已经指定好的那些<code>socket</code>信息</li><li><code>epoll_wait</code> <strong>默认情况下会阻塞系统的调用线程</strong>，直到<code>eventpoll</code> 对象中关联的某个或者某些个socket就绪以后，<code>epoll_wait</code>函数才会返回</li><li>返回值是<code>Int</code>类型的<ul><li>返回0，表示没有就绪的socket</li><li>返回大于0，表示有几个就绪的socket</li><li>返回-1表示异常</li></ul></li></ul><h2 id="8-eventpoll-对象就绪列表的维护"><a href="#8-eventpoll-对象就绪列表的维护" class="headerlink" title="8. eventpoll 对象就绪列表的维护"></a>8. eventpoll 对象就绪列表的维护</h2><p><strong>select函数调用的流程：</strong></p><ul><li>socket对象有三块区域<ul><li>读缓冲区</li><li>写缓冲区</li><li>等待队列</li></ul></li><li>select函数调用的时候会把当前进程从工作队列里面拿出来</li><li><strong>然后把进程引用追加到当前进程关注的每一个socket对象的等待队列中</strong></li><li>然后当socket连接的客户端发送完数据之后，数据还是通过硬件DMA的方式把数据写入到内存，然后相应的硬件向CPU发出中断信号,CPU就会让出当前进程位置去执行网络数据就绪的中断程序，</li><li><strong>这个中断程序就会把内存中的网络数据写入到对应的socket读缓冲区里面，之后把这个socket等待队列中的进程全部移动到工作队列中，再然后select函数返回</strong></li></ul><p><strong>epoll函数流程非常相似</strong></p><ul><li><p>当我们调用系统函数<code>epoll_ ctl</code>时候，比如我们新添加一个需要关注的socket,其实<strong>内核程序会把当前的<code>eventpoll</code>对象追加到这个<code>socket</code>的等待队列里头</strong></p></li><li><p>然后当<code>socket</code>连接的客户端发送完数据之后，数据还是通过硬件DMA的方式把数据写入到内存，然后相应的硬件向CPU发出中断信号,CPU就会让出当前进程位置去执行网络数据就绪的中断程序，</p></li><li><p><strong>这个中断程序就会把内存中的网络数据写入到对应的<code>socket</code>读缓冲区里面，然后它发现这个<code>socket</code>的等待队列里头不是进程，而是一个<code>eventpoll</code>对象的引用</strong></p></li><li><p><strong>这个时候呢，他就会根据这个<code>eventpoll</code>对象的引用，将当前<code>socket</code>的引用追加到eventpoll的就绪链表的末尾</strong>（eventpoll 还有一块空间是eventpoll 的等待队列，这个等待队列保存的就是调用epoll_wait 的进程）</p></li><li><p>然后，当中断程序把<code>socket</code>的引用追加到就绪列表的末尾之后，就继续检查eventpoll对象的等待队列，如果有进程，就会把进程转移到工作队列中</p></li><li><p>转移完毕之后，进程就有获取到CPU执行的时间片了，然后就是调用epoll_wait 函数，他这个函数就返回到java层面了</p></li></ul><p><strong>总结：</strong></p><ul><li><strong>eventpoll对象等待队列里面，它有调用event_wait(,,,)函数进去的进程</strong></li><li><strong>然后再把这个进程，从这个eventpoll的等待队列里面迁移到工作队列里面</strong></li></ul><h2 id="9-epoll-wait-获取就绪的socket"><a href="#9-epoll-wait-获取就绪的socket" class="headerlink" title="9. epoll_wait() 获取就绪的socket"></a>9. epoll_wait() 获取就绪的socket</h2><p><strong>epoll_wait() 返回值是Int类型的</strong></p><ul><li>返回0，表示没有就绪的socket</li><li>返回大于0，表示有几个就绪的socket</li><li>返回-1表示异常</li></ul><p><strong>那么获取就绪的socket是怎么实现的呢？</strong></p><ul><li><code>epoll_wait</code> 函数，<strong>调用的时候</strong>会传入一个<code>epoll_event</code>事件数组指针</li><li><code>epoll_wait</code> <strong>函数正常返回之前</strong>，会把就绪的socket事件信息拷贝到这个数组指针里头</li><li>这样返回到上层程序，就能通过这个数组拿到就绪列表</li></ul><h2 id="10-epoll-wait-可不可以设置成非阻塞的"><a href="#10-epoll-wait-可不可以设置成非阻塞的" class="headerlink" title="10. epoll_wait 可不可以设置成非阻塞的"></a>10. epoll_wait 可不可以设置成非阻塞的</h2><ul><li>默认<code>epoll_wait</code> 是阻塞的</li><li>它有一个参数，表示阻塞时间的长度，如果<strong>这个参数设置为0</strong>，表示这个<code>epoll_wait</code> 是一个非阻塞调用的</li><li><strong>每次调用都会去检查就绪列表</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-06-多路复用&quot;&gt;&lt;a href=&quot;#Linux-06-多路复用&quot; class=&quot;headerlink&quot; title=&quot;Linux-06-多路复用&quot;&gt;&lt;/a&gt;Linux-06-多路复用&lt;/h1&gt;&lt;h2 id=&quot;1-BIO-的缺陷&quot;&gt;&lt;a href=&quot;#1-BIO-的缺陷&quot; class=&quot;headerlink&quot; title=&quot;1. BIO 的缺陷&quot;&gt;&lt;/a&gt;1. BIO 的缺陷&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;BIO中的B 是 &lt;code&gt;Blocking&lt;/code&gt; 的阻塞的意思&lt;/li&gt;
&lt;li&gt;作为&lt;strong&gt;服务端开发&lt;/strong&gt;，使用&lt;code&gt;ServerSocket&lt;/code&gt; 绑定端口号之后会监听该端口,等待&lt;code&gt;accept&lt;/code&gt;事件，&lt;code&gt;accept&lt;/code&gt;是会阻塞当前线程&lt;/li&gt;
&lt;li&gt;当我们收到&lt;code&gt;accept&lt;/code&gt;事件的时候，程序就会拿到客户端与当前服务端连接的&lt;code&gt;Socket&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;针对这个&lt;code&gt;socket&lt;/code&gt;我们可以进行读写，但是呢，这个&lt;code&gt;socket&lt;/code&gt;读写都是会阻塞当前线程的。&lt;/li&gt;
&lt;li&gt;一般我们会有使用&lt;strong&gt;多线程方式进行c/s交互，但是这样很难做到C10K&lt;/strong&gt;（比如说：1W个客户端就需要和服务端用1W个线程支持，这样的话CPU肯定就爆炸了，同时线程上下文切换也会把机器负载给拉飞。）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="多路复用" scheme="http://zhuuu.work/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-interrupt()</title>
    <link href="http://zhuuu.work/2020/08/17/JavaInterview/Java-%E5%9F%BA%E7%A1%80-interrupt()/"/>
    <id>http://zhuuu.work/2020/08/17/JavaInterview/Java-%E5%9F%BA%E7%A1%80-interrupt()/</id>
    <published>2020-08-17T03:38:38.000Z</published>
    <updated>2020-09-10T12:47:07.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-interrupt"><a href="#Java-基础-interrupt" class="headerlink" title="Java-基础-interrupt()"></a>Java-基础-interrupt()</h1><h2 id="1-InterruptedException"><a href="#1-InterruptedException" class="headerlink" title="1. InterruptedException"></a>1. InterruptedException</h2><ul><li>当一个方法后面声明可能会抛出<code>InterruptedException</code>异常时，说明该方法是可能会花一点时间，但是可以取消的方法。</li></ul><ul><li>抛<code>InterruptedException</code>的代表方法有：<ul><li><code>java.lang.Object</code> 类的 wait 方法</li><li><code>java.lang.Thread</code> 类的 sleep 方法</li><li><code>java.lang.Thread</code> 类的 join 方法</li></ul></li></ul><a id="more"></a><p>– 需要花点时间的方法</p><ul><li><p>执行<code>wait</code>方法的线程，会进入等待区等待被<code>notify/notify All</code>。在等待期间，线程不会活动。</p></li><li><p>执行<code>sleep</code>方法的线程，会暂停执行参数内所设置的时间。</p></li><li><p>执行<code>join</code>方法的线程，会等待到指定的线程结束为止。</p></li></ul><p>因此，上面的方法都是需要花点时间的方法。</p><p>– 可以取消的方法</p><ul><li>因为需要花时间的操作会降低程序的响应性，所以可能会取消/中途放弃执行这个方法。</li><li>这里主要是通过<code>interrupt</code>方法来取消。</li></ul><ol><li><strong>sleep方法与interrupt方法</strong></li></ol><ul><li>interrupt方法是Thread类的实例方法，在执行的时候并不需要获取Thread实例的锁定，任何线程在任何时刻，都可以通过线程实例来调用其他线程的interrupt方法。</li><li>当在sleep中的线程被调用interrupt方法时，就会放弃暂停的状态，并抛出<code>InterruptedException</code>异常，这样一来，线程的控制权就交给了捕捉这个异常的catch块了。</li></ul><ol start="2"><li><strong>wait方法和interrupt方法</strong></li></ol><ul><li>当线程调用<code>wait</code>方法后，<strong>线程在进入等待区时，会把锁定解除</strong>。</li><li>当对wait中的线程调用<code>interrupt</code>方法时，<strong>会先重新获取锁定</strong>，再抛出<code>InterruptedException</code>异常，获取锁定之前，无法抛出<code>InterruptedException</code>异常。</li></ul><ol start="3"><li><strong>join方法和interrupt方法</strong></li></ol><ul><li>当线程以join方法等待其他线程结束时，一样可以使用interrupt方法取消。因为join方法不需要获取锁定，故而与sleep一样，会马上跳到catch程序块</li></ul><p><strong>线程中断</strong></p><ul><li>每一个线程都有一个boolean类型的标志，此标志意思是当前的请求是否请求中断，默认为false。</li><li>当一个线程A调用了线程B的interrupt方法时，那么线程B的是否请求的中断标志变为true。而线程B可以调用方法检测到此标志的变化。</li></ul><ol><li><strong>对于阻塞方法（join,sleep,wait）</strong></li></ol><ul><li>如果线程B调用了阻塞方法，如果是否请求中断标志变为了true，那么它会抛出InterruptedException异常。<strong>抛出异常的同时它会将线程B的是否请求中断标志置为false</strong></li></ul><ol start="2"><li><strong>对于非阻塞方法</strong></li></ol><ul><li>可以通过线程B的<code>isInterrupted</code>方法进行检测是否请求中断标志为true还是false</li><li>另外还有一个静态的方法<code>interrupted</code>方法也可以检测标志。但是静态方法它检测完以后会自动的将是否请求中断标志位置为false</li></ul><p><strong>讲下列三个方法的时候先给出总结：</strong></p><ul><li><strong>调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真正的停止线程</strong></li><li><strong>interrupted()测试当前线程是否已经是中断状态，执行后具有清除中断状态flag的功能</strong></li><li><strong>isInterrupted()测试线程Thread对象是否已经是中断状态，但不清除中断状态flag</strong></li></ul><h2 id="2-interrupt-方法"><a href="#2-interrupt-方法" class="headerlink" title="2. interrupt()方法"></a>2. interrupt()方法</h2><ul><li><strong>interrupt方法其实只是改变了中断状态而已。</strong></li><li><strong>而sleep、wait和join这些方法的内部会不断的检查中断状态的值，从而自己抛出InterruptEdException。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，如果在线程进行其他处理时，调用了它的interrupt方法，线程也不会抛出InterruptedException的，只有当线程走到了sleep, wait, join这些方法的时候，才会抛出InterruptedException。若是没有调用sleep, wait, join这些方法，或者没有在线程里自己检查中断状态，自己抛出InterruptedException，那InterruptedException是不会抛出来的。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/204151515.png" alt="mark"></p><h2 id="3-isInterrupted-方法"><a href="#3-isInterrupted-方法" class="headerlink" title="3. isInterrupted() 方法"></a>3. isInterrupted() 方法</h2><ul><li>可以用来检查中断状态，并且不会清除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" i = "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main thread interrupt</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.getName() + <span class="string">":"</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">":"</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + Thread.currentThread().isInterrupted());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thread interrupt</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.getName() + <span class="string">":"</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">":"</span> + thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/204610315.png" alt="mark"></p><h2 id="4-interrupted（）-方法"><a href="#4-interrupted（）-方法" class="headerlink" title="4. interrupted（） 方法"></a>4. interrupted（） 方法</h2><ul><li>可以用来检查并清除中断状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" i = "</span> + i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"interrupted 1: "</span> + Thread.interrupted());</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"interrupted 2: "</span> + Thread.interrupted());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/204321165.png" alt="mark"></p><ul><li>控制台第一次打印的结果是true，第二次为false；</li><li>Java Doc中给出的解释是：测试当前线程是否已经中断，线程的中断状态由该方法清除。即如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除flag后以及第二次调用检查中断状态之前，当前线程再次中断的情况除外）</li><li>所以，interrupted()方法具有清除状态flag的功能 </li></ul><h2 id="5-InterruptedException-的处理"><a href="#5-InterruptedException-的处理" class="headerlink" title="5. InterruptedException 的处理"></a>5. InterruptedException 的处理</h2><ul><li>现在知道线程可以检测到自身的标志位的变化，但是他只是一个标志，<strong>如果线程本身不处理的话，那么程序还是会执行下去</strong>，就好比，老师在学校叮嘱要好好学习，具体什么时候，如何好好学习还是看自身。</li><li><strong>因此<code>interrupt()</code> 方法并不能立即中断线程，该方法仅仅告诉线程外部已经有中断请求，至于是否中断还取决于线程自己</strong></li></ul><p>简单的了解了什么是阻塞和中断以后，我们就该了解碰到<code>InterruptedException</code>异常该如何处理了。</p><p><strong>一句话：不要不管不顾</strong></p><ul><li><strong>有时候阻塞的方法抛出<code>InterruptedException</code>异常并不合适</strong>，例如在<code>Runnable</code>中调用了可中断的方法，因为你的程序是实现了<code>Runnable</code>接口，然后在重写<code>Runnable</code>接口的<code>run</code>方法的时候，那么子类抛出的异常要小于等于父类的异常。而在<code>Runnable</code>中<code>run</code>方法是没有抛异常的。<strong>所以此时是不能抛出InterruptedException异常</strong>。</li><li>如果<strong>此时你只是记录日志的话</strong>，那么就是一个<strong>不负责任的做法</strong>，<strong>因为在捕获<code>InterruptedException</code>异常的时候自动的将 是否请求中断标志置为了false。</strong></li><li><strong>至少在捕获了<code>InterruptedException</code>异常之后，如果你什么也不想做，那么就将标志重新置为<code>true</code></strong>，<strong>以便栈中更高层的代码能知道中断，并且对中断作出响应。</strong></li></ul><p><strong>捕获到InterruptedException异常后恢复中断状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.queue = queue; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                 Task task = queue.take(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                 task.execute();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">             <span class="comment">// Restore the interrupted status</span></span><br><span class="line">             <span class="comment">// 向上保存中断的状态</span></span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-interrupt&quot;&gt;&lt;a href=&quot;#Java-基础-interrupt&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-interrupt()&quot;&gt;&lt;/a&gt;Java-基础-interrupt()&lt;/h1&gt;&lt;h2 id=&quot;1-InterruptedException&quot;&gt;&lt;a href=&quot;#1-InterruptedException&quot; class=&quot;headerlink&quot; title=&quot;1. InterruptedException&quot;&gt;&lt;/a&gt;1. InterruptedException&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当一个方法后面声明可能会抛出&lt;code&gt;InterruptedException&lt;/code&gt;异常时，说明该方法是可能会花一点时间，但是可以取消的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;抛&lt;code&gt;InterruptedException&lt;/code&gt;的代表方法有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java.lang.Object&lt;/code&gt; 类的 wait 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt; 类的 sleep 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt; 类的 join 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="打断" scheme="http://zhuuu.work/tags/%E6%89%93%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码-01-DI注入</title>
    <link href="http://zhuuu.work/2020/08/16/Spring/Spring%E6%BA%90%E7%A0%81-01-DI%E6%B3%A8%E5%85%A5/"/>
    <id>http://zhuuu.work/2020/08/16/Spring/Spring%E6%BA%90%E7%A0%81-01-DI%E6%B3%A8%E5%85%A5/</id>
    <published>2020-08-16T07:02:24.000Z</published>
    <updated>2020-08-16T08:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码-01-DI注入"><a href="#Spring源码-01-DI注入" class="headerlink" title="Spring源码-01-DI注入"></a>Spring源码-01-DI注入</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>比如提到spring的自动注入作为一个java程序员肯定自信无比了解；但是笔者要说的自动注入可能会和你理解有很大出入。</li><li>自动注入需要相对于手动装配来说；在spring应用程序当中假设你的A类依赖了B类，需要在A类当中提供一个B类的属性，再加上setter，继而在xml当中配置、描述一下这两个类之间的依赖关系。如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；</li><li>这种由程序员自己配置、描述好依赖关系的写法叫做手动装配；看个例子吧；</li></ul><a id="more"></a><h2 id="1-DI装配方式"><a href="#1-DI装配方式" class="headerlink" title="1. DI装配方式"></a>1. DI装配方式</h2><h3 id="1-1-手动装配"><a href="#1-1-手动装配" class="headerlink" title="1.1 手动装配"></a>1.1 手动装配</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.luban.app;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">B b;</span><br><span class="line">public void setB(B b) &#123;</span><br><span class="line">this.b = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.luban.app;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.luban.app.A"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 由程序员手动指定的依赖关系 称为手动装配--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"b"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span>  <span class="attr">class</span>=<span class="string">"com.luban.app.B"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>但是实际开发中手动装配的场景比较少(比如在缺少源码的情况下可能会使用这种手动装配情况)；<br>关于依赖注入的资料可以参考官网</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies</a></li><li>这一章节提到了一个非常重要的知识点，<strong>也是一个常见的spring面试题目。spring有几种依赖注入方式？那么这个问题应该怎么回答呢？</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200816-162155273.png" alt="mark"></p><h3 id="1-2-DI注入两种方式"><a href="#1-2-DI注入两种方式" class="headerlink" title="1.2 DI注入两种方式"></a>1.2 DI注入两种方式</h3><ul><li><p>官网的意思是DI(依赖注入)一共有两种主要的变体（注意会考），分别是基于构造方法的依赖注入和基于setter（setXxxx(…)）的依赖注入</p></li><li><p>不管是手动装配还是自动装配都是基于这两种方式或者变体方式来的；但是这里一定要回答到主要和变体两个名词，因为有的注入方式就不是这两种，而是这两种其中一种的变体方式；比如在一个类的属性上面加@Autowired，这种方式注入属性的方式就是利用了java的反射知识，</p></li><li><p><code>field.set(value,targetObject)</code>;关于这个我在后面的文章中对spring源码解析的时候会说明<code>@Autowired</code>的原理；所以<code>@Autowired</code>这种注入的方式是setter注入方式的一种变体</p></li><li><p>但是这里需要说明的是所谓的setter其实和属性无关，什么意思呢？一般的setter方法会对应一个属性，但是spring的基于setter的注入方式是不需要属性的，仅仅只需要一个setter方法，下面这个例子来说明这个问题.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring源码-01-DI注入&quot;&gt;&lt;a href=&quot;#Spring源码-01-DI注入&quot; class=&quot;headerlink&quot; title=&quot;Spring源码-01-DI注入&quot;&gt;&lt;/a&gt;Spring源码-01-DI注入&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;比如提到spring的自动注入作为一个java程序员肯定自信无比了解；但是笔者要说的自动注入可能会和你理解有很大出入。&lt;/li&gt;
&lt;li&gt;自动注入需要相对于手动装配来说；在spring应用程序当中假设你的A类依赖了B类，需要在A类当中提供一个B类的属性，再加上setter，继而在xml当中配置、描述一下这两个类之间的依赖关系。如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；&lt;/li&gt;
&lt;li&gt;这种由程序员自己配置、描述好依赖关系的写法叫做手动装配；看个例子吧；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
      <category term="Spring源码学习" scheme="http://zhuuu.work/tags/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://zhuuu.work/2020/08/14/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://zhuuu.work/2020/08/14/JavaInterview/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-08-14T09:38:38.000Z</published>
    <updated>2020-09-20T01:05:59.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前
      
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="分布式事务" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>排序-01-堆排序</title>
    <link href="http://zhuuu.work/2020/08/12/Sort/%E6%8E%92%E5%BA%8F-01-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/08/12/Sort/%E6%8E%92%E5%BA%8F-01-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-12T10:32:24.000Z</published>
    <updated>2020-09-01T13:14:24.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-01-堆排序"><a href="#排序-01-堆排序" class="headerlink" title="排序-01-堆排序"></a>排序-01-堆排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</li></ul><h2 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h2><ul><li>堆是具有如下性质的完全二叉树<ul><li>每个节点的值都大于或者等于其左右孩子节点的值，成为大顶堆</li><li>每个节点的值都小于或者等于其左右孩子节点的值，成为小顶堆</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210713650.png" alt="mark"></p><p>同时，将堆中节点按照层级进行编号，将这种逻辑结构映射到数组中就是如下的例子</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210812092.png" alt="mark"></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p><a id="more"></a><h2 id="2-堆排序介绍"><a href="#2-堆排序介绍" class="headerlink" title="2. 堆排序介绍"></a>2. 堆排序介绍</h2><ul><li>堆排序(Heap Sort) 是指利用堆这种数据结构所涉及的一种排序算法。</li><li><strong>将n个无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></li><li><strong>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></li><li><strong>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></li></ul><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/211132796.png" alt="mark"></p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"排序前："</span>+Arrays.toString(arr));</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(<span class="string">"排序前："</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-202023330.gif" alt="mark"></p><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p><a href="https://blog.csdn.net/qq_36186690/article/details/82505569" target="_blank" rel="noopener">https://blog.csdn.net/qq_36186690/article/details/82505569</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p>再简单总结下堆排序的基本思路：</p><p>　　<strong>a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-01-堆排序&quot;&gt;&lt;a href=&quot;#排序-01-堆排序&quot; class=&quot;headerlink&quot; title=&quot;排序-01-堆排序&quot;&gt;&lt;/a&gt;排序-01-堆排序&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆排序是利用&lt;strong&gt;堆&lt;/strong&gt;这种数据结构而设计的一种排序算法，堆排序是一种&lt;strong&gt;选择排序，&lt;/strong&gt;它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-堆&quot;&gt;&lt;a href=&quot;#1-堆&quot; class=&quot;headerlink&quot; title=&quot;1. 堆&quot;&gt;&lt;/a&gt;1. 堆&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆是具有如下性质的完全二叉树&lt;ul&gt;
&lt;li&gt;每个节点的值都大于或者等于其左右孩子节点的值，成为大顶堆&lt;/li&gt;
&lt;li&gt;每个节点的值都小于或者等于其左右孩子节点的值，成为小顶堆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210713650.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时，将堆中节点按照层级进行编号，将这种逻辑结构映射到数组中就是如下的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/210812092.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大顶堆：arr[i] &amp;gt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;gt;= arr[2i+2]&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小顶堆：arr[i] &amp;lt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;lt;= arr[2i+2]&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆排序" scheme="http://zhuuu.work/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-11-慢查询优化</title>
    <link href="http://zhuuu.work/2020/08/12/Mysql/Mysql-11-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://zhuuu.work/2020/08/12/Mysql/Mysql-11-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2020-08-12T08:02:27.000Z</published>
    <updated>2020-09-13T08:05:40.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-11-慢查询优化"><a href="#Mysql-11-慢查询优化" class="headerlink" title="Mysql-11-慢查询优化"></a>Mysql-11-慢查询优化</h1><p><strong>注意sql查询慢的原因都是:引起filesort</strong></p><h2 id="1-分析慢查询日志"><a href="#1-分析慢查询日志" class="headerlink" title="1. 分析慢查询日志"></a>1. 分析慢查询日志</h2><ul><li><p>直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句</p><p>   例如：执行<code>EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">得到如下结果： 显示结果分析：  </span><br><span class="line"></span><br><span class="line">            table |  type | possible_keys | key |key_len  | ref | rows | Extra  EXPLAIN列的解释：           </span><br><span class="line"></span><br><span class="line">            table                 显示这一行的数据是关于哪张表的           </span><br><span class="line"></span><br><span class="line">           type                  这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL </span><br><span class="line"></span><br><span class="line">            rows                显示需要扫描行数</span><br><span class="line"></span><br><span class="line">            key                   使用的索引</span><br></pre></td></tr></table></figure><p>以下通过explain显示出mysql执行的字段内容：</p><ul><li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li>select_type: SELECT 查询的类型.</li><li>table: 查询的是哪个表</li><li>partitions: 匹配的分区</li><li>type: join 类型</li><li><strong>possible_keys: 此次查询中可能选用的索引</strong></li><li><strong>key: 此次查询中确切使用到的索引.</strong></li><li>ref: 哪个字段或常数与 key 一起被使用</li><li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li><li>filtered: 表示此查询条件所过滤的数据的百分比</li><li>extra: 额外的信息</li></ul><p><strong>注意 : 可以使用explain命令加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引。</strong></p><a id="more"></a><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><ul><li><p><strong>like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。</strong></p></li><li><p><strong>or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效</strong></p></li><li><p><strong>联合索引，不是使用第一列索引，索引失效。</strong></p></li><li><p><strong>数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。</strong></p></li><li><p><strong>在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</strong></p></li><li><p><strong>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</strong></p></li><li><p><strong>对索引字段进行计算操作、字段上使用函数。（索引为 emp(ename,empno,sal)）</strong></p></li></ul><h2 id="2-优化一：索引"><a href="#2-优化一：索引" class="headerlink" title="2. 优化一：索引"></a>2. 优化一：索引</h2><ul><li><p><strong>使用LIKE关键字的查询语句</strong></p><ul><li>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</li></ul></li><li><p>使用多列索引的查询语句</p></li></ul><p>​    MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</p><h2 id="3-优化二-：-表结构"><a href="#3-优化二-：-表结构" class="headerlink" title="3. 优化二 ： 表结构"></a>3. 优化二 ： 表结构</h2><ul><li>合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，<strong>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</strong></li></ul><ol><li><strong>将字段很多的表分解成多个表</strong> </li></ol><p>​    <strong>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</strong>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><ol start="2"><li><strong>增加中间表</strong></li></ol><p>​    <strong>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中</strong>，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</p><h2 id="4-优化三-：-分解关联查询"><a href="#4-优化三-：-分解关联查询" class="headerlink" title="4. 优化三 ： 分解关联查询"></a>4. 优化三 ： 分解关联查询</h2><p>将一个大的查询分解为多个小查询是很有必要的。<strong>(检查自己的sql是不是写错了)</strong></p><p> 很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag </span><br><span class="line">        JOIN tag_post ON tag_id = tag.id</span><br><span class="line">        JOIN post ON tag_post.post_id = post.id</span><br><span class="line">        WHERE tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line">        分解为：</span><br><span class="line"></span><br><span class="line">        SELECT * FROM tag WHERE tag = <span class="string">'mysql'</span>;</span><br><span class="line">        SELECT * FROM tag_post WHERE tag_id = <span class="number">1234</span>;</span><br><span class="line">        SELECT * FROM post WHERE post.<span class="function">id <span class="title">in</span> <span class="params">(<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="5-优化四：-范围查询优化"><a href="#5-优化四：-范围查询优化" class="headerlink" title="5. 优化四： 范围查询优化"></a>5. 优化四： 范围查询优化</h2><ol><li><strong>优化limit分页</strong></li></ol><ul><li>在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</li><li>一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</li></ul><ol start="2"><li><p><strong>索引覆盖</strong></p><p>优化此类查询的一个最简单的方法是<strong>尽可能的使用索引覆盖扫描</strong>，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p>对于下面的查询：</p></li></ol><p>​    select id,title from collect limit 90000,10;</p><p>   该语句存在的<strong>最大问题在于limit M,N中偏移量M太大</strong>（我们暂不考虑筛选字段上要不要添加索引的影响），导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。 <strong>试想，如我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的100条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到100条满足条件的记录了。</strong></p><h3 id="方法一：虑筛选字段（title）上加索引"><a href="#方法一：虑筛选字段（title）上加索引" class="headerlink" title="方法一：虑筛选字段（title）上加索引"></a>方法一：虑筛选字段（title）上加索引</h3><p>​    title字段加索引 （此效率如何未加验证）</p><h3 id="方法二：先查询出主键id值"><a href="#方法二：先查询出主键id值" class="headerlink" title="方法二：先查询出主键id值"></a>方法二：先查询出主键id值</h3><p><code>select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</code></p><p><strong>原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。</strong></p><h3 id="方法三：-“关延迟联”"><a href="#方法三：-“关延迟联”" class="headerlink" title="方法三：\“关延迟联”**"></a>方法三：<strong><em>\</em>“关延迟联”**</strong></h3><p>如果这个表非常大，那么这个查询可以改写成如下的方式：</p><p>   <code>Select news.id, news.description from news inner join (select id from news order by title limit 50000,5) as myNew using(id);</code></p><p>​    这里的<strong><em>\</em>“关延迟联”**</strong>将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。</p><h3 id="方法四：建立复合索引-acct-id和create-time"><a href="#方法四：建立复合索引-acct-id和create-time" class="headerlink" title="方法四：建立复合索引 acct_id和create_time"></a>方法四：建立复合索引 acct_id和create_time</h3><p>  select * from acct_trans_log WHERE  acct_id = 3095  order by create_time desc limit 0,10</p><h2 id="6-优化五：分析具体的SQL联表（子）查询"><a href="#6-优化五：分析具体的SQL联表（子）查询" class="headerlink" title="6. 优化五：分析具体的SQL联表（子）查询"></a>6. 优化五：分析具体的SQL联表（子）查询</h2><p><strong>1、两个表选哪个为驱动表，表面是可以以数据量的大小作为依据，但是实际经验最好交给mysql查询优化器自己去判断。</strong></p><p><strong>例如： select * from a where id in (select id from b );</strong> </p><ul><li>对于这条sql语句它的执行计划其实并不是先查询出b表的所有id,然后再与a表的id进行比较。<br><strong>mysql会把in子查询转换成exists相关子查询</strong>，所以它实际等同于这条sql语句：select * from a where exists(select * from b where b.id=a.id );</li><li><strong>而exists相关子查询的执行原理是</strong>: 循环取出a表的每一条记录与b表进行比较，比较的条件是a.id=b.id . 看a表的每条记录的id是否在b表存在，如果存在就行返回a表的这条记录。</li></ul><p><strong><em>\</em>exists查询有什么弊端？**</strong><br>   由exists执行原理可知，a表(外表)使用不了索引，必须全表扫描，因为是拿a表的数据到b表查。而且必须得使用a表的数据到b表中查（外表到里表中），顺序是固定死的。</p><p><strong><em>\</em>如何优化？**</strong><br>   建索引。但是由上面分析可知，要建索引只能在b表的id字段建，不能在a表的id上，mysql利用不上。</p><p><strong><em>\</em>为什么要反过来？**</strong><br>    因为首先可以肯定的是反过来的结果也是一样的。这样就又引出了一个更细致的疑问：在双方两个表的id字段上都建有索引时，到底是a表查b表的效率高，还是b表查a表的效率高？</p><p><strong><em>\</em>该如何进一步优化？**</strong><br>    把查询修改成inner join连接查询：select * from a inner join b on a.id=b.id; （但是仅此还不够，接着往下看）</p><p><strong><em>\</em>为什么不用left join 和 right join？**</strong><br>    这时候表之间的连接的顺序就被固定住了，比如左连接就是必须先查左表全表扫描，然后一条一条的到另外表去查询，右连接同理。仍然不是最好的选择。</p><p><strong><em>\</em>为什么使用inner join就可以？**</strong><br>    inner join中的两张表，如： a inner join b，但实际执行的顺序是跟写法的顺序没有半毛钱关系的，最终执行也可能会是b连接a，顺序不是固定死的。如果on条件字段有索引的情况下，同样可以使用上索引。</p><p><strong>那我们又怎么能知道a和b什么样的执行顺序效率更高？</strong><br>    你不知道，我也不知道。谁知道？mysql自己知道。让mysql自己去判断（查询优化器）。具体表的连接顺序和使用索引情况，mysql查询优化器会对每种情况做出成本评估，最终选择最优的那个做为执行计划。</p><p>​    <strong>在inner join的连接中,mysql会自己评估使用a表查b表的效率高还是b表查a表高，如果两个表都建有索引的情况下，mysql同样会评估使用a表条件字段上的索引效率高还是b表的。</strong></p><p><strong>利用explain字段查看执行时运用到的key（索引）</strong><br>    <strong>而我们要做的就是：把两个表的连接条件的两个字段都各自建立上索引，然后explain 一下，查看执行计划，看mysql到底利用了哪个索引，最后再把没有使用索引的表的字段索引给去掉就行了。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-11-慢查询优化&quot;&gt;&lt;a href=&quot;#Mysql-11-慢查询优化&quot; class=&quot;headerlink&quot; title=&quot;Mysql-11-慢查询优化&quot;&gt;&lt;/a&gt;Mysql-11-慢查询优化&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注意sql查询慢的原因都是:引起filesort&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-分析慢查询日志&quot;&gt;&lt;a href=&quot;#1-分析慢查询日志&quot; class=&quot;headerlink&quot; title=&quot;1. 分析慢查询日志&quot;&gt;&lt;/a&gt;1. 分析慢查询日志&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句&lt;/p&gt;
&lt;p&gt;   例如：执行&lt;code&gt;EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;得到如下结果： 显示结果分析：  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            table |  type | possible_keys | key |key_len  | ref | rows | Extra  EXPLAIN列的解释：           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            table                 显示这一行的数据是关于哪张表的           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           type                  这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            rows                显示需要扫描行数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            key                   使用的索引&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以下通过explain显示出mysql执行的字段内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.&lt;/li&gt;
&lt;li&gt;select_type: SELECT 查询的类型.&lt;/li&gt;
&lt;li&gt;table: 查询的是哪个表&lt;/li&gt;
&lt;li&gt;partitions: 匹配的分区&lt;/li&gt;
&lt;li&gt;type: join 类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;possible_keys: 此次查询中可能选用的索引&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;key: 此次查询中确切使用到的索引.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ref: 哪个字段或常数与 key 一起被使用&lt;/li&gt;
&lt;li&gt;rows: 显示此查询一共扫描了多少行. 这个是一个估计值.&lt;/li&gt;
&lt;li&gt;filtered: 表示此查询条件所过滤的数据的百分比&lt;/li&gt;
&lt;li&gt;extra: 额外的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意 : 可以使用explain命令加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-类初始化造成的死锁</title>
    <link href="http://zhuuu.work/2020/08/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%A0%E6%88%90%E7%9A%84%E6%AD%BB%E9%94%81/"/>
    <id>http://zhuuu.work/2020/08/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%A0%E6%88%90%E7%9A%84%E6%AD%BB%E9%94%81/</id>
    <published>2020-08-12T04:38:38.000Z</published>
    <updated>2020-09-17T01:41:40.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-类初始化造成的死锁"><a href="#Java-基础-类初始化造成的死锁" class="headerlink" title="Java-基础-类初始化造成的死锁"></a>Java-基础-类初始化造成的死锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于类初始化有几个关键特性：</p><ul><li>类初始化的过程其实就是执行类构造器方法<clinit>()的过程；</li><li>在子类初始化完成时，虚拟机会保证其父类有初始化完成；</li><li>多线程环境下，虚拟机执行<clinit>()方法会自动加锁；</li></ul><p>在java中，死锁肯定是在多线程环境下产生的。<strong>多个线程同时需要互相持有的某个资源，自己的资源无法释放，别人的资源又无法得到，造成循环依赖</strong>，进而一直阻塞在那里，这样就形成死锁了。</p><a id="more"></a><h2 id="1-两个类初始化互相依赖"><a href="#1-两个类初始化互相依赖" class="headerlink" title="1. 两个类初始化互相依赖"></a>1. 两个类初始化互相依赖</h2><ul><li>最明显的情况是，2个类在不同的线程中初始化，彼此互相依赖，我们来看个例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"class A init."</span>);</span><br><span class="line">            B b = <span class="keyword">new</span> B();</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"method test called in class A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"class B init."</span>);</span><br><span class="line">            A a = <span class="keyword">new</span> A();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"method test called in class B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                A.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;).start();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                B.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">init</span>.</span></span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 第一个线程执行A.test()的时候，开始初始化类A，该线程获得A.class的锁，第二个线程执行B.test()的时候，开始初始化类B，该线程获得B.class的锁。</span><br><span class="line">2. A在初始化过程中执行代码B b = new B()的时候，发现类B还没有初始化完成，于是尝试获得类B.class的锁；</span><br><span class="line">3. 类B在初始化时执行代码A a = new A()，发现类A也没有初始化完成，于是尝试获得类A.class的锁，但A.class锁已被占用，所以该线程会阻塞住，并等待该锁的释放；</span><br><span class="line">4. 同样第一个线程阻塞住并等待B.class锁的释放，这样就造成循环依赖，形成了死锁。</span><br></pre></td></tr></table></figure><ul><li>如果把上面代码改为如下执行方式，会出现什么结果呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A.test();</span><br><span class="line">    B.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终执行结果为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">init</span>.</span></span><br><span class="line"><span class="class"><span class="title">method</span> <span class="title">test</span> <span class="title">called</span> <span class="title">in</span> <span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"><span class="title">method</span> <span class="title">test</span> <span class="title">called</span> <span class="title">in</span> <span class="title">class</span> <span class="title">B</span></span></span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 乍一看去，好像A初始化时依赖B，B初始化时依赖A，也会造成死锁，但实际上并不会。</span><br><span class="line">2. A、B两个类的初始化都是在同一个线程里执行的，初始化A的时候，该线程会获得A.class锁，初始化B时会获得B.class锁，而在初始化B时又需要A</span><br><span class="line">3. 但是这2个初始化都是在同一个线程里执行的，该线程会同时获得这2个锁，因此并不会发生锁资源的抢占</span><br></pre></td></tr></table></figure><h2 id="2-子类，父类初始化造成死锁"><a href="#2-子类，父类初始化造成死锁" class="headerlink" title="2. 子类，父类初始化造成死锁"></a>2. 子类，父类初始化造成死锁</h2><ul><li>与第一种情况相比，这种情况造成的死锁会更隐蔽一点，但它们实质上都是同样的原因，来看个具体的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Parent init."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parent EMPTY = <span class="keyword">new</span> Child();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test called in class Parent."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Child init."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Child c = <span class="keyword">new</span> Child();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Parent.test();</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent init.</span><br></pre></td></tr></table></figure><p>我们来分析下造成死锁的原因：</p><ul><li>线程t1执行时会触发Child类的初始化，线程t2执行时会触发Parent类的初始化；</li><li>紧接着线程<code>t1</code>持有<code>Child.class</code>锁，<code>t2</code>持有<code>Parent.class</code>锁，<code>t1</code>初始化时需要先初始化其父类<code>Parent</code></li><li>而类Parent有个常量定义“<strong>public static final Parent EMPTY = new Child();</strong>”，这样类Parent在初始化时需要初始化Child；</li><li>这样线程t1要初始化Parent，尝试获取<code>Parent.class</code>锁，线程t2要初始化Child，尝试获取<code>Child.class</code>锁，彼此互相不能释放资源，因此造成死锁。</li></ul><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><ul><li>在上面这个案例中，我们知道是类初始化时造成了死锁。子类依赖了父类，而父类在初始化过程中又依赖了子类，为了避免这种情况，</li><li>我们<strong>采取了预先在主线程中将数据库相关类全部初始化的方式。</strong><br> 在应用入口处，我们作了如下处理：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Class.forName(<span class="string">"AnnouncementInfo"</span>);</span><br><span class="line">Class c2 = Class.forName(<span class="string">"......"</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li><strong>这样在应用启动时，所有相关类都已经初始化完成(一次性分配了所有资源)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-类初始化造成的死锁&quot;&gt;&lt;a href=&quot;#Java-基础-类初始化造成的死锁&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-类初始化造成的死锁&quot;&gt;&lt;/a&gt;Java-基础-类初始化造成的死锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于类初始化有几个关键特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类初始化的过程其实就是执行类构造器方法&lt;clinit&gt;()的过程；&lt;/li&gt;
&lt;li&gt;在子类初始化完成时，虚拟机会保证其父类有初始化完成；&lt;/li&gt;
&lt;li&gt;多线程环境下，虚拟机执行&lt;clinit&gt;()方法会自动加锁；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在java中，死锁肯定是在多线程环境下产生的。&lt;strong&gt;多个线程同时需要互相持有的某个资源，自己的资源无法释放，别人的资源又无法得到，造成循环依赖&lt;/strong&gt;，进而一直阻塞在那里，这样就形成死锁了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="死锁" scheme="http://zhuuu.work/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="循环依赖" scheme="http://zhuuu.work/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux-00-常用指令</title>
    <link href="http://zhuuu.work/2020/08/11/Linux/Linux-00-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://zhuuu.work/2020/08/11/Linux/Linux-00-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2020-08-11T03:52:53.000Z</published>
    <updated>2020-09-22T07:25:01.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-00-常用指令"><a href="#Linux-00-常用指令" class="headerlink" title="Linux-00-常用指令"></a>Linux-00-常用指令</h1><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关机</span><br><span class="line">    shutdown -h now        立刻关机</span><br><span class="line">    shutdown -h 5        5分钟后关机</span><br><span class="line">    poweroff            立刻关机</span><br><span class="line">重启</span><br><span class="line">    shutdown -r now        立刻重启</span><br><span class="line">    shutdown -r 5        5分钟后重启</span><br><span class="line">    reboot                立刻重启</span><br><span class="line">    </span><br><span class="line">ifconfig  --help：查看网卡信息</span><br></pre></td></tr></table></figure><h2 id="2-目录操作指令"><a href="#2-目录操作指令" class="headerlink" title="2. 目录操作指令"></a>2. 目录操作指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd命令</span><br><span class="line"></span><br><span class="line">该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令：cd 目录</span><br><span class="line"></span><br><span class="line">cd &#x2F;        切换到根目录</span><br><span class="line">cd &#x2F;usr        切换到根目录下的usr目录</span><br><span class="line">cd ..&#x2F;        切换到上一级目录 或者  cd ..</span><br><span class="line">cd ~        切换到home目录</span><br><span class="line">cd -        切换到上次访问的目录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令：ls [-al]</span><br><span class="line"></span><br><span class="line">ls                查看当前目录下的所有目录和文件</span><br><span class="line">ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class="line">ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）</span><br><span class="line">ls &#x2F;dir            查看指定目录下的所有目录和文件   如：ls &#x2F;usr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令：mkdir 目录</span><br><span class="line"></span><br><span class="line">mkdir    aaa            在当前目录下创建一个名为aaa的目录</span><br><span class="line">mkdir    &#x2F;usr&#x2F;aaa    在指定目录下创建一个名为aaa的目录</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">命令：rm [-rf] 目录</span><br><span class="line"></span><br><span class="line">删除文件：</span><br><span class="line">rm 文件        删除当前目录下的文件</span><br><span class="line">rm -f 文件    删除当前目录的的文件（不询问）</span><br><span class="line"></span><br><span class="line">删除目录：</span><br><span class="line">rm -r aaa    递归删除当前目录下的aaa目录</span><br><span class="line">rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</span><br><span class="line"></span><br><span class="line">全部删除：</span><br><span class="line">rm -rf *    将当前目录下的所有目录和文件全部删除</span><br><span class="line">rm -rf &#x2F;*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</span><br><span class="line"></span><br><span class="line">注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录&#x2F;文件&#x2F;压缩包</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一、重命名目录</span><br><span class="line">    命令：mv 当前目录  新目录</span><br><span class="line">    例如：mv aaa bbb    将目录aaa改为bbb</span><br><span class="line">    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</span><br><span class="line"></span><br><span class="line">二、剪切目录</span><br><span class="line">    命令：mv 目录名称 目录的新位置</span><br><span class="line">    示例：将&#x2F;usr&#x2F;tmp目录下的aaa目录剪切到 &#x2F;usr目录下面     mv &#x2F;usr&#x2F;tmp&#x2F;aaa &#x2F;usr</span><br><span class="line">    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</span><br><span class="line"></span><br><span class="line">三、拷贝目录</span><br><span class="line">    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归</span><br><span class="line">    示例：将&#x2F;usr&#x2F;tmp目录下的aaa目录复制到 &#x2F;usr目录下面     cp &#x2F;usr&#x2F;tmp&#x2F;aaa  &#x2F;usr</span><br><span class="line">    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令：find 目录 参数 文件名称</span><br><span class="line">示例：find &#x2F;usr&#x2F;tmp -name &#39;a*&#39;    查找&#x2F;usr&#x2F;tmp目录下的所有以a开头的目录或文件</span><br></pre></td></tr></table></figure><h2 id="3-文件操作命令"><a href="#3-文件操作命令" class="headerlink" title="3. 文件操作命令"></a>3. 文件操作命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令：touch 文件名</span><br><span class="line">示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt</span><br><span class="line"></span><br><span class="line">命令：rm -rf 文件名</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_31142553/article/details/82949867" target="_blank" rel="noopener">https://blog.csdn.net/qq_31142553/article/details/82949867</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">【vi编辑器的3种模式】</span><br><span class="line">    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</span><br><span class="line">1) 命令行模式command mode）</span><br><span class="line">      控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。</span><br><span class="line">      命令行模式下的常用命令：</span><br><span class="line">      【1】控制光标移动：↑，↓，j</span><br><span class="line">      【2】删除当前行：dd </span><br><span class="line">      【3】查找：&#x2F;字符</span><br><span class="line">      【4】进入编辑模式：i o a</span><br><span class="line">      【5】进入底行模式：:</span><br><span class="line">      </span><br><span class="line">2) 编辑模式（Insert mode）</span><br><span class="line">      只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。</span><br><span class="line">      编辑模式下常用命令：</span><br><span class="line">      【1】ESC 退出编辑模式到命令行模式；</span><br><span class="line">      </span><br><span class="line">3) 底行模式（last line mode）</span><br><span class="line">     将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</span><br><span class="line">     底行模式下常用命令：</span><br><span class="line">     【1】退出编辑：   :q</span><br><span class="line">     【2】强制退出：   :q!</span><br><span class="line">     【3】保存并退出：  :wq</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">打开文件</span><br><span class="line"></span><br><span class="line">命令：vi 文件名</span><br><span class="line">示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt</span><br><span class="line"></span><br><span class="line">注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i&#x2F;a&#x2F;o进入编辑模式。</span><br><span class="line"></span><br><span class="line">编辑文件</span><br><span class="line"></span><br><span class="line">使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</span><br><span class="line"></span><br><span class="line">i:在光标所在字符前开始插入</span><br><span class="line">a:在光标所在字符后开始插入</span><br><span class="line">o:在光标所在行的下面另起一新行插入</span><br><span class="line"></span><br><span class="line">保存或者取消编辑</span><br><span class="line"></span><br><span class="line">保存文件：</span><br><span class="line"></span><br><span class="line">第一步：ESC  进入命令行模式</span><br><span class="line">第二步：:     进入底行模式</span><br><span class="line">第三步：wq     保存并退出编辑</span><br><span class="line"></span><br><span class="line">取消编辑：</span><br><span class="line"></span><br><span class="line">第一步：ESC  进入命令行模式</span><br><span class="line">第二步：:     进入底行模式</span><br><span class="line">第三步：q!     撤销本次修改并退出编辑</span><br></pre></td></tr></table></figure><p><strong>文件的查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">文件的查看命令：cat&#x2F;more&#x2F;less&#x2F;tail</span><br><span class="line"></span><br><span class="line">cat：看最后一屏</span><br><span class="line"></span><br><span class="line">示例：使用cat查看&#x2F;etc&#x2F;sudo.conf文件，只能显示最后一屏内容</span><br><span class="line">cat sudo.conf</span><br><span class="line"></span><br><span class="line">more：百分比显示</span><br><span class="line"></span><br><span class="line">示例：使用more查看&#x2F;etc&#x2F;sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看</span><br><span class="line">more sudo.conf</span><br><span class="line"></span><br><span class="line">less：翻页查看</span><br><span class="line"></span><br><span class="line">示例：使用less查看&#x2F;etc&#x2F;sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看</span><br><span class="line">less sudo.conf</span><br><span class="line"></span><br><span class="line">tail：指定行数或者动态查看</span><br><span class="line"></span><br><span class="line">示例：使用tail -10 查看&#x2F;etc&#x2F;sudo.conf文件的后10行，Ctrl+C结束  </span><br><span class="line">tail -10 sudo.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</span><br><span class="line"></span><br><span class="line">示例：给aaa.txt文件权限改为可执行文件权限，aaa.txt文件的权限是-rw-------</span><br><span class="line"></span><br><span class="line">第一位：-就代表是文件，d代表是文件夹</span><br><span class="line">第一段（3位）：代表拥有者的权限</span><br><span class="line">第二段（3位）：代表拥有者所在的组，组员的权限</span><br><span class="line">第三段（最后3位）：代表的是其他用户的权限</span><br><span class="line"></span><br><span class="line">   421  421  421</span><br><span class="line">-  rw-   ---     ---</span><br><span class="line"></span><br><span class="line">命令：chmod +x aaa.txt</span><br><span class="line">或者采用8421法</span><br><span class="line">命令：chmod 100 aaa.txt</span><br></pre></td></tr></table></figure><p><strong>head命令</strong></p><ul><li>可以用来查看文件的开头部分。此命令的格式是：</li></ul><p><code>head 文件名</code></p><p>默认设置，它只查看文件的前10行。但可以通过指定一个数字选项来改变要显示的行数，命令如下：</p><p><code>head –20 文件名</code></p><p>这个命令将会查看文件的前20行。</p><p><strong>tail命令</strong></p><ul><li>和head命令恰恰相反。使用tail命令，可以查看文件结尾的10行。这有助于查看日 志文件的最后10行来阅读重要的系统信息。还可以使用tail观察日志文件更新的过程。</li><li>使用-f选项，tail会自动实时地把打开文件中的新信息显示到屏 幕上。例如，要活跃地观察<code>/var/log/messages</code>，以根用户身份在shell下输入以下命令：</li></ul><p><code>tail –f /var/log/messages</code></p><h2 id="4-压缩文件"><a href="#4-压缩文件" class="headerlink" title="4. 压缩文件"></a>4. 压缩文件</h2><h3 id="4-1-打包和压缩"><a href="#4-1-打包和压缩" class="headerlink" title="4.1 打包和压缩"></a>4.1 打包和压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">linux中的打包文件：aa.tar      </span><br><span class="line">linux中的压缩文件：bb.gz    </span><br><span class="line">linux中打包并压缩的文件：.tar.gz</span><br><span class="line"></span><br><span class="line">Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</span><br><span class="line">而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</span><br><span class="line"></span><br><span class="line">命令：tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class="line">其中：z：调用gzip压缩命令进行压缩</span><br><span class="line">  c：打包文件</span><br><span class="line">  v：显示运行过程</span><br><span class="line">  f：指定文件名</span><br><span class="line">  </span><br><span class="line">示例：打包并压缩&#x2F;usr&#x2F;tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar</span><br><span class="line">tar -zcvf ab.tar aa.txt bb.txt </span><br><span class="line">或：tar -zcvf ab.tar  *</span><br></pre></td></tr></table></figure><h3 id="4-2-解压"><a href="#4-2-解压" class="headerlink" title="4.2 解压"></a>4.2 解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令：tar [-zxvf] 压缩文件   </span><br><span class="line">其中：x：代表解压</span><br><span class="line">示例：将&#x2F;usr&#x2F;tmp 下的ab.tar解压到当前目录下</span><br><span class="line"></span><br><span class="line">示例：将&#x2F;usr&#x2F;tmp 下的ab.tar解压到根目录&#x2F;usr下</span><br><span class="line">tar -xvf ab.tar -C &#x2F;usr------C代表指定解压的位置</span><br></pre></td></tr></table></figure><h2 id="5-查找命令"><a href="#5-查找命令" class="headerlink" title="5. 查找命令"></a>5. 查找命令</h2><p>grep命令是一种强大的文本搜索工具</p><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd  查找指定ssh服务进程 </span><br><span class="line">ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除gerp身 </span><br><span class="line">ps -ef | grep sshd -c 查找指定进程个数 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grep命令的最大功能是在一堆文件中查找一个特定的字符串。</span><br><span class="line"></span><br><span class="line">grep money test.txt</span><br></pre></td></tr></table></figure><p>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 </p><p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; -ls  在当前目录查找以.log结尾的文件，并显示详细信息。 </span><br><span class="line">find &#x2F;root&#x2F; -perm 600   查找&#x2F;root&#x2F;目录下权限为600的文件 </span><br><span class="line">find . -type f -name &quot;*.log&quot;  查找当目录，以.log结尾的普通文件 </span><br><span class="line">find . -type d | sort   查找当前所有目录并排序 </span><br><span class="line">find . -size +100M  查找当前目录大于100M的文件</span><br></pre></td></tr></table></figure><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。</p><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis ls    将和ls文件相关的文件都查找出来</span><br></pre></td></tr></table></figure><p><code>which</code>命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which pwd  查找pwd命令所在路径 </span><br><span class="line">which java  查找path中java的路径</span><br></pre></td></tr></table></figure><h2 id="6-磁盘空间"><a href="#6-磁盘空间" class="headerlink" title="6. 磁盘空间"></a>6. 磁盘空间</h2><p>有关磁盘空间的命令</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>mount</td><td>挂载文件系统</td></tr><tr><td>umount</td><td>卸载已挂载上的文件系统</td></tr><tr><td>df</td><td>检查各个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td>du</td><td>显示文件目录和大小</td></tr><tr><td>fsck</td><td>主要是检查和修复Linux文件系统</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount命令的功能是挂载文件系统，可以挂载硬盘、光盘、软盘，也可以挂载NFS网络文件系统。这个命令的标准用法如下：</span><br><span class="line"></span><br><span class="line">mount –t 设备类型 存放目录 </span><br><span class="line">mount IP地址：&#x2F;所提供的目录 存放目录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">umount命令的功能是卸载已挂上的文件系统，在关闭系统前应该把所有挂载上的文件系统卸载。这个命令和mount命令是相对的。用法：</span><br><span class="line"></span><br><span class="line">umount 已挂上的目录或设备</span><br><span class="line"></span><br><span class="line">卸载已挂上的&#x2F;cdrom目录，输入命令：</span><br><span class="line"></span><br><span class="line">umount &#x2F;cdrom</span><br><span class="line"></span><br><span class="line">卸载已挂上的某个分区，输入命令：</span><br><span class="line"></span><br><span class="line">umount &#x2F;dev&#x2F;hdb1</span><br></pre></td></tr></table></figure><p><strong>df [-选项]</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>把全部的文件系统和各分区的硬盘使用情形列出来，包括0区块的，例如/proc这个文件系统</td></tr><tr><td>-i</td><td>列出I-nodes的使用量</td></tr><tr><td>-k</td><td>把各分区的大小和挂上来的文件分区的大小用k表示</td></tr><tr><td>-t</td><td>列出某一文件系统的所有分区磁盘空间使用量</td></tr><tr><td>-x</td><td>列出不是某一文件系统的所有分区磁盘空间使用量，和-t选项相反</td></tr><tr><td>-T</td><td>列出每个分区所属文件系统的名称</td></tr></tbody></table><p>例如，要列出全部文件系统和各分区的磁盘使用情况，输入命令：</p><p><code>df –a</code></p><p><strong>du命令的功能是用于显示文件目录或大小。标准用法：</strong></p><p>du [-选项]</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示全部目录及其次目录下的每个文件所占的磁盘空间</td></tr><tr><td>-b</td><td>显示目录和文件的大小，以B为单位</td></tr><tr><td>-c</td><td>最后再加上一个总计</td></tr><tr><td>-h</td><td>以KB、MB、GB为单位，提高信息可读性</td></tr><tr><td>-s</td><td>只列出各文件大小的总和</td></tr><tr><td>-x</td><td>只计算属于同一文件系统的文件</td></tr></tbody></table><p><strong>fsck命令</strong>的功能是检查和修复Linux文件系统，这个命令最好在没有人或是没有分区挂上来时使用，其实每次开机系统都会做一次检查，看是否有坏轨或数据流失的现象。用法：</p><p>fsck (-选项) 分区名称</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>自动修复文件系统，不询问任何问题，比较危险</td></tr><tr><td>-A</td><td>依照/etc/fstab配置文件的内容，检查该文件内所列全部文件系统。若没有附加参数”-P”，则会先检查/目录的文件系统，而不会同时检查所有文件系统</td></tr><tr><td>-R</td><td>采取互动方式，在修复时询问问题，让用户确认并决定处理方式</td></tr><tr><td>-S</td><td>依次检查作业而不是同时执行。当依次指定多个文件系统且采用互动的方式进行检查时，请使用此参数以便顺序执行，否则fsck可能会同时询问数个问题，让人不知所措</td></tr><tr><td>-V</td><td>显示命令执行的过程</td></tr><tr><td>-T</td><td>指定要检查的文件系统的类型</td></tr><tr><td>-N</td><td>不是真正执行指令，仅列出实际执行时会进行的动作</td></tr></tbody></table><p><strong>tar命令</strong></p><p>tar命令最早是用来做磁带备份的，但是由于硬盘容量越来越大，因此现在主要用这个命令来备份所有的文件。tar这个命令把大量的文件和目录打包成一个文件。</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>创建一个新归档</td></tr><tr><td>-f</td><td>当与-c选项一起使用时，创建的tar文件使用该选项指定的文件名；当与-x选项一起使用时，则解除该选项指定的归档</td></tr><tr><td>-t</td><td>显示包括在tar文件中的文件列表</td></tr><tr><td>-v</td><td>显示文件的归档进度</td></tr><tr><td>-x</td><td>从归档中抽取文件</td></tr><tr><td>-z</td><td>使用gzip压缩tar文件</td></tr><tr><td>-j</td><td>使用bzip2压缩tar文件</td></tr></tbody></table><p>要创建一个tar文件，输入命令：</p><p><code>tar –cvf filename.tar directory/file /home/mine</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">上面的命令将directory&#x2F;file、&#x2F;home&#x2F;mine放入归档文件中。</span><br><span class="line"></span><br><span class="line">要列出tar文件的内容，输入命令：</span><br><span class="line"></span><br><span class="line">tar –tvf filename.tar</span><br><span class="line"></span><br><span class="line">要抽取tar文件的命令，输入命令：</span><br><span class="line"></span><br><span class="line">tar –xvf filename.tar</span><br><span class="line"></span><br><span class="line">这个命令不会删除tar文件，但会把解除归档的内容复制到当前工作目录下，并保留归档文件所使用的任何目录结构。</span><br><span class="line"></span><br><span class="line">请记住，tar默认不压缩文件。要创建一个使用tar和bzip2来归档压缩的文件，使用-j选项：</span><br><span class="line"></span><br><span class="line">tar –cjvf filename.tbz file</span><br><span class="line"></span><br><span class="line">如果使用bunzip2命令解压filename.tbz文件，则filename.tbz会被删除，以filename.tar代替。</span><br><span class="line"></span><br><span class="line">要扩展并解除归档bzip tar文件，输入命令：</span><br><span class="line"></span><br><span class="line">tar –xjvf filename.tbz</span><br><span class="line"></span><br><span class="line">要创建一个用tar和gzip归档并压缩的文件，使用-z选项：</span><br><span class="line"></span><br><span class="line">tar –czvf filename.tgz file</span><br><span class="line"></span><br><span class="line">如果使用gunzip命令解压filename.tgz文件，则filename.tgz会被删除，以filename.tar代替。</span><br></pre></td></tr></table></figure><p><strong>ps命令</strong></p><p>ps命令用来<strong>查看在计算机系统中有哪些程序正在执行</strong>，及其执行的情况。这是一个相当强大的命令，可以用它来找出所有的<code>process id</code>和名称。另外，ps命令也可以用来列出所有程序占用内存的情况。用法如下：</p><p>ps –(选项)</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-l</td><td>用长格式列出</td></tr><tr><td>-u</td><td>列出使用者的名称和使用时间</td></tr><tr><td>-m</td><td>列出内存分布的情况</td></tr><tr><td>-r</td><td>只列出正在执行的前台程序，不列出其他信息</td></tr><tr><td>-x</td><td>列出所有程序，包括那些没有终端机的程序</td></tr></tbody></table><p><strong>top命令</strong></p><ul><li>可以查看目前程序的执行情景和内存使用。它和ps类似，不过，它会几秒钟更新一次系统状态，方便追踪。要离开这个程序，按Ctrl+C键就可以了。</li></ul><p><strong>kill命令</strong></p><ul><li>用来终止一个正在执行中的进程。如果一个程序执行过程中失败了，可以把这个程序终止，避免留在内存中占用系统资源。不过，它的实际意义是送一个信号给这个正在执行的程序，叫它自杀。可以送很多信号给这些程序，也可以让他们受到信号后做很多事情。标准用法：</li></ul><p><code>kill –(选项) pid</code></p><ul><li>在执行kill命令前。可以先用ps命令查一下某宕掉程序的pid，然后使用kill除去某个程序。例如，终止pid为90的程序：<code>kill 90</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将 pid 为 323 的行程砍掉 (kill) ：</span><br><span class="line"></span><br><span class="line">kill -9 323</span><br><span class="line"></span><br><span class="line">将 pid 为 456 的行程重跑 (restart) ：</span><br><span class="line"></span><br><span class="line">kill -HUP 456</span><br></pre></td></tr></table></figure><p><strong>chmod命令</strong></p><ul><li>用来改变许可权限。读取、写入和执行是许可权限中的三个主要设置。因为用户在他们的账号被创建时就被编入一个组群，所以还可以指定那些组群可以读取、写入或执行某一文件。其中：<ul><li>r—文件可以被读取<br>w—文件可以被写入<br>x—文件可以被执行，如果文件是程序的话</li></ul></li></ul><p>可以使用带有-l的ls命令来仔细查看一个文件的许多细节。</p><p><code>chmod</code>命令用来设定文件的权限。标准用法：</p><p><code>chmod</code> 文件的使用者(u,g,o,a)增减(+,-,=)权限名称(r,w,x) 文件</p><table><thead><tr><th>文件的使用者</th><th>说明</th><th>权限</th><th>说明</th><th>增减</th><th>说明</th></tr></thead><tbody><tr><td>u</td><td>拥有文件的用户</td><td>r</td><td>读取权</td><td>+</td><td>添加权限</td></tr><tr><td>g</td><td>所有者所在的组群</td><td>w</td><td>写入权</td><td>-</td><td>删除权限</td></tr><tr><td>o</td><td>其他人</td><td>x</td><td>执行权</td><td>=</td><td>是它称为唯一权限</td></tr><tr><td>a</td><td>全部(u,g和o)</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>删除某一文件的所有权限，输入命令：</p><p><code>chmod a-rwx test.txt</code></p><p>为文件所有者添加权限，输入命令：</p><p><code>chmod u+rwx test</code></p><p>还可以用数字表示权限：4——读取，2——写入，1——执行。下面的两个命令等价：</p><p><code>chmod 751 filename</code><br><code>chmod u+rwx,g=rx,0=x filename</code></p><h2 id="7-网络相关"><a href="#7-网络相关" class="headerlink" title="7. 网络相关"></a>7. 网络相关</h2><p><strong>执行ping命令</strong></p><ul><li>它会使用ICMP传输协议，发出要求回应的信息，若远程主机的网络没有什么问题，就会回应信息，因而得知该主机运作正常。</li></ul><p>标准用法：</p><p>ping (-选项) 主机名称或IP地址</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c 次数</td><td>设置完成要求回应的次数。ping命令会反复发出信息，直到达到设定的次数为止</td></tr><tr><td>D</td><td>使用Socket的SO_DEBUG功能</td></tr><tr><td>F</td><td>大量而且快速地送网络封包给一台机器，看它的回应。一般不到几秒钟，送出去的封包就会超过两千个</td></tr><tr><td>I 秒数</td><td>指定收发信息的间隔时间，单位为s，预置位1s。与参数f不兼容</td></tr><tr><td>S bytes</td><td>设置数据包的大小。预设置为56B，加上8B ICMP头文件，共64B</td></tr><tr><td>R</td><td>忽略网关，直接将数据保送到远程主机上。如果该主机并非局域网的一份子，就会传回错误信息</td></tr><tr><td>Q</td><td>不显示命令的执行过程，只显示结果</td></tr><tr><td>V</td><td>详细显示命令的执行过程，包括非回应信息和其它信息</td></tr><tr><td>T 存活数值</td><td>设置存活数值TTL的大小。TTL是IP协议包中的一个值，它告诉网络，数据包在网络中的时间是否太长而应被丢弃</td></tr></tbody></table><p>举例说明，检测des.bllod.net主机网络功能是否正常，送出去要去信息需完成5次回应，每次间隔10s，数据包的大小为512B，输入命令：</p><p><code>ping –c 5 –i 10 –s 504 –t 64 des.blood.net</code></p><p><strong>netstat命令</strong></p><ul><li>netstat命令的主要功能是了解Linux系统的网络情况。假设没有指定任何参数给netstat命令，则效果和指定-F参数相同。</li></ul><p>用法：</p><p>netstat (-选项)</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>显示所有连线中的Socket</td></tr><tr><td>F</td><td>显示FIB</td></tr><tr><td>a</td><td>全部列出，包括正在等待的程序</td></tr><tr><td>c</td><td>持续列出网络状态</td></tr><tr><td>i</td><td>显示网络界面信息</td></tr><tr><td>n</td><td>使用网络ip地址代替名称</td></tr><tr><td>o</td><td>显示计时器</td></tr><tr><td>r</td><td>显示网络路径表</td></tr><tr><td>t</td><td>显示TCP协议的连接情形</td></tr><tr><td>u</td><td>显示UDP协议的连接情形</td></tr><tr><td>v</td><td>显示版本信息</td></tr><tr><td>w</td><td>显示RAW传输协议的连接情形</td></tr></tbody></table><p><strong>参考博客</strong> ： <a href="https://blog.csdn.net/qq_23329167/article/details/83856430?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/qq_23329167/article/details/83856430?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.channel_param</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-command-manual.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-00-常用指令&quot;&gt;&lt;a href=&quot;#Linux-00-常用指令&quot; class=&quot;headerlink&quot; title=&quot;Linux-00-常用指令&quot;&gt;&lt;/a&gt;Linux-00-常用指令&lt;/h1&gt;&lt;h2 id=&quot;1-基本命令&quot;&gt;&lt;a href=&quot;#1-基本命令&quot; class=&quot;headerlink&quot; title=&quot;1. 基本命令&quot;&gt;&lt;/a&gt;1. 基本命令&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutdown -h now        立刻关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutdown -h 5        5分钟后关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    poweroff            立刻关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;重启&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutdown -r now        立刻重启&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutdown -r 5        5分钟后重启&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reboot                立刻重启&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ifconfig  --help：查看网卡信息&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;2-目录操作指令&quot;&gt;&lt;a href=&quot;#2-目录操作指令&quot; class=&quot;headerlink&quot; title=&quot;2. 目录操作指令&quot;&gt;&lt;/a&gt;2. 目录操作指令&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pwd命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;该命令的英文解释为print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;命令：cd 目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd &amp;#x2F;        切换到根目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd &amp;#x2F;usr        切换到根目录下的usr目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd ..&amp;#x2F;        切换到上一级目录 或者  cd ..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd ~        切换到home目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd -        切换到上次访问的目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;命令：ls [-al]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls                查看当前目录下的所有目录和文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls &amp;#x2F;dir            查看指定目录下的所有目录和文件   如：ls &amp;#x2F;usr&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;命令：mkdir 目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir    aaa            在当前目录下创建一个名为aaa的目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir    &amp;#x2F;usr&amp;#x2F;aaa    在指定目录下创建一个名为aaa的目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Linux常用指令" scheme="http://zhuuu.work/tags/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-String,StringBuilder,StringBuffer</title>
    <link href="http://zhuuu.work/2020/08/11/JavaInterview/Java-%E5%9F%BA%E7%A1%80-String,StringBuilder,StringBuffer/"/>
    <id>http://zhuuu.work/2020/08/11/JavaInterview/Java-%E5%9F%BA%E7%A1%80-String,StringBuilder,StringBuffer/</id>
    <published>2020-08-11T03:38:38.000Z</published>
    <updated>2020-09-10T08:08:17.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-String-StringBuilder-StringBuffer"><a href="#Java-基础-String-StringBuilder-StringBuffer" class="headerlink" title="Java-基础-String,StringBuilder,StringBuffer"></a>Java-基础-String,StringBuilder,StringBuffer</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>java中<code>String、StringBuffer、StringBuilder</code>是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-145020237.png" alt="mark"></p><a id="more"></a><h2 id="1-可变和不可变"><a href="#1-可变和不可变" class="headerlink" title="1. 可变和不可变"></a>1. 可变和不可变</h2><p><strong>1.可变与不可变</strong></p><p>　　<code>String</code>类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。</p><p>　　　　<strong>private final char value[];</strong></p><p>　　<code>StringBuilder与StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。</p><p>　　　　<strong>char[] value;</strong></p><h3 id="1-1-你见到的字符串被改变的？？？（这是一个假象）"><a href="#1-1-你见到的字符串被改变的？？？（这是一个假象）" class="headerlink" title="1.1 你见到的字符串被改变的？？？（这是一个假象）"></a>1.1 <strong>你见到的字符串被改变的？？？（这是一个假象）</strong></h3><ul><li>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 <strong>String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，这样不仅效率低下，而且大量浪费有限的内存空间，所以经常改变内容的字符串最好不要用 String 。</strong>因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-144909950.png" alt="mark"></p><ul><li>我们可以看到，初始String值为“hello”，然后在这个字符串后面加上新的字符串“world”，这个过程是需要重新在栈堆内存中开辟内存空间的，最终得到了“hello world”字符串也相应的需要开辟内存空间，这样短短的两个字符串，却需要开辟三次内存空间，不得不说这是对内存空间的极大浪费。为了应对经常性的字符串相关的操作，就需要使用Java提供的其他两个操作字符串的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。</li></ul><h2 id="2-多线程安全"><a href="#2-多线程安全" class="headerlink" title="2. 多线程安全"></a>2. 多线程安全</h2><ol><li><p><code>String</code>中的对象是不可变的，也就可以理解为常量，<strong>显然线程安全</strong>。</p></li><li><p><code>AbstractStringBuilder</code>是<code>StringBuilder</code>与<code>StringBuffer</code>的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。</p></li><li><p><code>StringBuffer</code>对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全的</strong>。看如下源码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);        <span class="comment">//存在 public synchronized int indexOf(String str, int fromIndex) 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>StringBuilder并没有对方法进行加同步锁，所以是<strong>非线程安全的</strong>。</li></ol><h2 id="3-StringBuilder和StringBuffer共同点"><a href="#3-StringBuilder和StringBuffer共同点" class="headerlink" title="3. StringBuilder和StringBuffer共同点"></a>3. StringBuilder和StringBuffer共同点</h2><ul><li>StringBuilder与StringBuffer有公共父类AbstractStringBuilder(<strong>抽象类</strong>)。</li><li><strong>抽象类与接口的其中一个区别</strong>是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。</li><li><code>StringBuilder、StringBuffer</code>的方法都会调用<code>AbstractStringBuilder</code>中的公共方法，如<code>super.append</code>(…)。只是StringBuffer会在方法上加synchronized关键字，进行同步。</li></ul><h2 id="4-字符串常量池"><a href="#4-字符串常量池" class="headerlink" title="4. 字符串常量池"></a>4. 字符串常量池</h2><ul><li>Java中的字符串常量池（<code>String Pool</code>）是存储在Java<strong>堆内存中的字符串池</strong>。我们知道String是java中比较特殊的类，我们可以使用new运算符创建String对象，也可以用双引号（”“）创建字串对象。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-151808077.png" alt="mark"></p><ul><li>之所以有字符串常量池，是因为String在Java中是不可变（immutable）的，它是String interning概念的实现。字符串常量池也是亨元模式（Flyweight）的实例。</li><li>字符串常量池有助于为Java运行时节省大量空间，虽然创建字符串时需要更多的时间。</li><li>当我们使用<strong>双引号创建一个字符串时</strong>，首<strong>先在字符串常量池中查找是否有相同值的字符串，如果发现则返回其引用，否则它会在池中创建一个新的字符串，然后返回新字符串的引用。</strong></li><li>如果使用<strong>new运算符创建字符串，则会强制String类在堆空间中创建一个新的String对象。</strong>我们可以使用intern()方法将其放入字符串常量池或从字符串常量池中查找具有相同的值字符串对象并返回其引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java String Pool example</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s2 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1 == s2 :"</span>+(s1==s2));</span><br><span class="line">        System.out.println(<span class="string">"s1 == s3 :"</span>+(s1==s3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-面试题"><a href="#4-1-面试题" class="headerlink" title="4.1 面试题"></a>4.1 面试题</h3><ul><li>下面语句创建了几个对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><ul><li>在上面的语句中，可能创建1或2个字符串对象。如果池中已经有一个字符串<em>“Cat”</em>，那么堆中只会创建一个字符串<em>“str”</em>。</li><li>如果池中没有字符串字面量<em>“Cat”</em>，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共2个字符串对象。</li></ul><h3 id="4-2-作用"><a href="#4-2-作用" class="headerlink" title="4.2 作用"></a>4.2 作用</h3><ul><li>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。</li><li><strong>为 了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串池，</strong>每当代码创建字符串常量时，JVM会首先检查字符串常量池。如果字符串已经存在池中， 就返回池中的实例引用。</li><li>如果字符串不在池中，就会实例化一个字符串并放到池中。Java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突 进行共享。</li></ul><p><strong>参考博客：</strong></p><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303" target="_blank" rel="noopener">https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-String-StringBuilder-StringBuffer&quot;&gt;&lt;a href=&quot;#Java-基础-String-StringBuilder-StringBuffer&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-String,StringBuilder,StringBuffer&quot;&gt;&lt;/a&gt;Java-基础-String,StringBuilder,StringBuffer&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;java中&lt;code&gt;String、StringBuffer、StringBuilder&lt;/code&gt;是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200811-145020237.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="String" scheme="http://zhuuu.work/tags/String/"/>
    
      <category term="SringBuilder" scheme="http://zhuuu.work/tags/SringBuilder/"/>
    
      <category term="StringBuffer" scheme="http://zhuuu.work/tags/StringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-并发详解</title>
    <link href="http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-08-10T09:38:38.000Z</published>
    <updated>2020-08-10T07:50:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-并发详解"><a href="#Java-基础-并发详解" class="headerlink" title="Java-基础-并发详解"></a>Java-基础-并发详解</h1><h1 id="一、使用线程"><a href="#一、使用线程" class="headerlink" title="一、使用线程"></a>一、使用线程</h1><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><ul><li><strong>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程</strong>，</li><li><strong>因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</strong></li></ul><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><ul><li>需要实现接口中的 run() 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><ul><li>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><ul><li>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</li><li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p><strong>实现接口会更好一些</strong>，因为：</p><ul><li>Java <strong>不支持多重继承，因此继承了 Thread 类就无法继承其它类</strong>，但是可以实现多个接口；</li><li>类可能只要求可执行就行，<strong>继承整个 Thread 类开销过大。</strong></li></ul><h1 id="二、中断"><a href="#二、中断" class="headerlink" title="二、中断"></a>二、中断</h1><ul><li>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</li></ul><h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的 <code>interrupt()</code> 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 <code>InterruptedException</code>，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p><strong>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure><h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><ul><li><strong>调用 Executor 的 shutdown() 方法</strong>会等待线程都执行完毕之后再关闭，</li><li>但是如果调<strong>用的是 shutdownNow() 方法</strong>，则相当于调用每个线程的 interrupt() 方法。</li></ul><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><ul><li>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h1 id="三、互斥同步"><a href="#三、互斥同步" class="headerlink" title="三、互斥同步"></a>三、互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>1. 同步一个代码块</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</strong></p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure><p><strong>2. 同步一个方法</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它和同步代码块一样，作用于同一个对象。</strong></p><p><strong>3. 同步一个类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p><strong>4. 同步一个静态方法</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用于整个类。</strong></p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><ul><li>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。<strong>(底层是AQS)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>1. 锁的实现</strong>  </p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong>  </p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong>  </p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong>  </p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong>  </p><ul><li><strong>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</strong></li></ul><h1 id="四、线程之间的协作"><a href="#四、线程之间的协作" class="headerlink" title="四、线程之间的协作"></a>四、线程之间的协作</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><ul><li><p><strong>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</strong></p></li><li><p>对于以下代码，虽然 b 线程先启动，<strong>但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><ul><li><p><strong>它们都属于 Object 的一部分，而不属于 Thread。</strong></p></li><li><p><strong>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</strong></p></li><li><p><strong>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</strong></p></li><li><p><strong>同时存在虚假唤醒的问题</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p><strong>wait() 和 sleep() 的区别</strong>  </p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><ul><li><p>java.util.concurrent 类库中提供了 <strong>Condition 类</strong>来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p></li><li><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p></li></ul><p><strong>使用 Lock 来获取一个 Condition 对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><h1 id="五、线程状态"><a href="#五、线程状态" class="headerlink" title="五、线程状态"></a>五、线程状态</h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p><h2 id="新建（NEW）"><a href="#新建（NEW）" class="headerlink" title="新建（NEW）"></a>新建（NEW）</h2><ul><li>创建后尚未启动。</li></ul><h2 id="可运行（RUNABLE）"><a href="#可运行（RUNABLE）" class="headerlink" title="可运行（RUNABLE）"></a>可运行（RUNABLE）</h2><ul><li>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要<strong>看底层操作系统的资源调度</strong>。</li></ul><h2 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h2><ul><li>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</li></ul><h2 id="无限期等待（WAITING）"><a href="#无限期等待（WAITING）" class="headerlink" title="无限期等待（WAITING）"></a>无限期等待（WAITING）</h2><p>等待其它线程显式地唤醒。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用  Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h2 id="限期等待（TIMED-WAITING）"><a href="#限期等待（TIMED-WAITING）" class="headerlink" title="限期等待（TIMED_WAITING）"></a>限期等待（TIMED_WAITING）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><h2 id="死亡（TERMINATED）"><a href="#死亡（TERMINATED）" class="headerlink" title="死亡（TERMINATED）"></a>死亡（TERMINATED）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h1 id="六-：-AQS-应用"><a href="#六-：-AQS-应用" class="headerlink" title="六 ： AQS 应用"></a>六 ： AQS 应用</h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><ul><li><p>用来控制一个或者多个线程等待多个线程。</p></li><li><p><strong>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</strong></p></li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><ul><li><strong>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</strong></p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七：其他组件"><a href="#七：其他组件" class="headerlink" title="七：其他组件"></a>七：其他组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future<V> 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future<V> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。<strong>当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">other task is running...</span><br><span class="line">4950</span><br></pre></td></tr></table></figure><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>java.util.concurrent.BlockingQueue</code> 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong>  ：<code>LinkedBlockingQueue、ArrayBlockingQueue</code>（固定长度）</li><li><strong>优先级队列</strong>  ：<code>PriorityBlockingQueue</code></li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><ul><li>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><ul><li>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" width="300px"> </div><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-基础-并发详解&quot;&gt;&lt;a href=&quot;#Java-基础-并发详解&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-并发详解&quot;&gt;&lt;/a&gt;Java-基础-并发详解&lt;/h1&gt;&lt;h1 id=&quot;一、使用线程&quot;&gt;&lt;a href=&quot;#一、使用线程&quot;
      
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="http://zhuuu.work/tags/%E9%94%81/"/>
    
      <category term="并发" scheme="http://zhuuu.work/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-接口和抽象类</title>
    <link href="http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://zhuuu.work/2020/08/10/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2020-08-10T09:38:38.000Z</published>
    <updated>2020-09-20T07:11:31.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-接口和抽象类"><a href="#Java-基础-接口和抽象类" class="headerlink" title="Java-基础-接口和抽象类"></a>Java-基础-接口和抽象类</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200810-134343284.png" alt="mark"></p><a id="more"></a><h2 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1. 抽象类"></a>1. 抽象类</h2><h4 id="（1）抽象类的含义"><a href="#（1）抽象类的含义" class="headerlink" title="（1）抽象类的含义"></a>（1）抽象类的含义</h4><p>  包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的（否则，编译器会报错）</p><h4 id="（2）抽象类的点"><a href="#（2）抽象类的点" class="headerlink" title="（2）抽象类的点"></a>（2）抽象类的点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.含有abstract修饰符的class即为抽象类，abstract类不能创建实例对象。</span><br><span class="line">2.含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。</span><br><span class="line">3.abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。</span><br><span class="line">4.如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</span><br></pre></td></tr></table></figure><h2 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h2><h4 id="（1）接口的含义"><a href="#（1）接口的含义" class="headerlink" title="（1）接口的含义"></a>（1）接口的含义</h4><p>  可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。能有的内容是：static final的静态成员变量、public abstract的抽象方法（可以使用abstract关键字也可以不使用）</p><h4 id="（2）接口的点"><a href="#（2）接口的点" class="headerlink" title="（2）接口的点"></a>（2）接口的点</h4><p>1.接口中的域隐式地是static和final的；<br> 2.接口可以嵌套在类或其他接口中；<br> 3.接口是实现多重继承的途径；<br> 4.接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。<br> 5.接口不能有构造器；<br> 6.接口中不能有main()方法；</p><h2 id="3、语法的区别"><a href="#3、语法的区别" class="headerlink" title="3、语法的区别"></a>3、语法的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.普通成员变量：抽象类中可以有普通成员变量，接口中没有普通成员变量（static final变量）；</span><br><span class="line">2.方法：抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法；</span><br><span class="line">3.静态成员变量：抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</span><br><span class="line">4.静态方法：抽象类中可以包含静态方法，但不能是抽象静态方法；接口中不能包含静态方法（静态的方法不能被覆写）</span><br><span class="line">5.构造方法（静态的）：抽象类可以有构造方法，接口中不能有构造方法；</span><br><span class="line">6.方法访问权限：抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</span><br><span class="line">7.子类实现和继承： 一个类可以实现多个接口，但只能继承一个抽象类。</span><br><span class="line">8.初始化过程：当一个类在初始化时，要求其父类全部都已经初始化过了；但是一个接口在初始化时，并不要求其父接口全部都完成初始化，只有在真正使用父接口的时候（如引用接口中定义的常量），才会初始化。</span><br></pre></td></tr></table></figure><h2 id="4、应用上的区别"><a href="#4、应用上的区别" class="headerlink" title="4、应用上的区别"></a>4、应用上的区别</h2><ul><li>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约；</li><li>而抽象类在代码实现方面发挥作用，可以实现代码的重用。  </li><li>例如，<strong>模板方法设计模式是抽象类的一个典型应用</strong>，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。</li></ul><h2 id="5-使用接口的原因"><a href="#5-使用接口的原因" class="headerlink" title="5. 使用接口的原因"></a>5. 使用接口的原因</h2><p>1）为了能够向上转型为多个基类型（由此而带来的灵活性）；<br> 2）与使用抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。</p><h2 id="6、问题：使用接口还是抽象类"><a href="#6、问题：使用接口还是抽象类" class="headerlink" title="6、问题：使用接口还是抽象类"></a>6、问题：使用接口还是抽象类</h2><p>答：如果要创建不带任何方法定义和成员变量的基类，就应该选择接口而不是抽象类。抽象类为了代码的复用，接口为了多态性。</p><p><strong>参考视频：</strong> <a href="https://www.bilibili.com/video/BV1Ak4y1o7y8?p=182" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ak4y1o7y8?p=182</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-接口和抽象类&quot;&gt;&lt;a href=&quot;#Java-基础-接口和抽象类&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-接口和抽象类&quot;&gt;&lt;/a&gt;Java-基础-接口和抽象类&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200810-134343284.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="接口" scheme="http://zhuuu.work/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="抽象类" scheme="http://zhuuu.work/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-泛型擦除</title>
    <link href="http://zhuuu.work/2020/08/05/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    <id>http://zhuuu.work/2020/08/05/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/</id>
    <published>2020-08-05T09:38:38.000Z</published>
    <updated>2020-09-04T08:31:01.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-泛型擦除"><a href="#Java-基础-泛型擦除" class="headerlink" title="Java-基础-泛型擦除"></a>Java-基础-泛型擦除</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>[参考博客][<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html]" target="_blank" rel="noopener">https://www.cnblogs.com/wuqinglong/p/9456193.html]</a></p><ul><li>大家都知道，Java的泛型是伪泛型，<strong>这是因为Java在编译期间，所有的泛型信息都会被擦掉</strong>，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，<strong>使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</strong></li><li><strong>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code></strong>，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，<strong>但是仍然无法在运行时刻出现的类型转换异常的情况</strong>，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</li></ul><a id="more"></a><h2 id="1-通过两个例子证明Java类型的类型擦除"><a href="#1-通过两个例子证明Java类型的类型擦除" class="headerlink" title="1. 通过两个例子证明Java类型的类型擦除"></a>1. 通过两个例子证明Java类型的类型擦除</h2><ol><li><h4 id="原始类型相等"><a href="#原始类型相等" class="headerlink" title="原始类型相等"></a>原始类型相等</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个<code>ArrayList</code>数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过<code>list1</code>对象和<code>list2</code>对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为<code>true</code>。说明泛型类型<code>String</code>和<code>Integer</code>都被擦除掉了，只剩下原始类型。</p><ol start="2"><li><h4 id="通过反射添加其它类型元素"><a href="#通过反射添加其它类型元素" class="headerlink" title="通过反射添加其它类型元素"></a>通过反射添加其它类型元素</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);  <span class="comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span></span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod("add", Object.class).invoke(list, "asd");</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p><h2 id="2-类型擦除后保留的原始类型"><a href="#2-类型擦除后保留的原始类型" class="headerlink" title="2. 类型擦除后保留的原始类型"></a>2. 类型擦除后保留的原始类型</h2><ul><li><p>在上面，两次提到了原始类型，什么是原始类型？</p><p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p></li></ul><p><strong>例3.原始类型Object</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair的原始类型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在<code>Pair&lt;T&gt;</code>中，T 是一个无限定的类型变量，所以用<code>Object</code>替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的<code>Pair</code>，如<code>Pair&lt;String&gt;</code>或<code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的<code>Pair</code>类型了，原始类型都是<code>Object</code>。</p><p><strong>从上面的例2中，我们也可以明白<code>ArrayList&lt;Integer&gt;</code>被擦除类型后，原始类型也变为<code>Object</code>，所以通过反射我们就可以存储字符串了。</strong></p><p>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>那么原始类型就是<code>Comparable</code>。</p><p>要区分原始类型和泛型变量的类型。</p><p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> i = Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        Number f = Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        Object o = Test.add(<span class="number">1</span>, <span class="string">"asd"</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> a = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="keyword">int</span> b = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        Number c = Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例4.Object泛型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">    list.add(<span class="number">1</span>);  </span><br><span class="line">    list.add(<span class="string">"121"</span>);  </span><br><span class="line">    list.add(<span class="keyword">new</span> Date());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-带来的问题和解决方法"><a href="#3-带来的问题和解决方法" class="headerlink" title="3. 带来的问题和解决方法"></a>3. 带来的问题和解决方法</h2><p>因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题，但是也引起来许多新问题，所以，SUN对这些问题做出了种种限制，避免我们发生各种错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-泛型擦除&quot;&gt;&lt;a href=&quot;#Java-基础-泛型擦除&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-泛型擦除&quot;&gt;&lt;/a&gt;Java-基础-泛型擦除&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;[参考博客][&lt;a href=&quot;https://www.cnblogs.com/wuqinglong/p/9456193.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wuqinglong/p/9456193.html]&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大家都知道，Java的泛型是伪泛型，&lt;strong&gt;这是因为Java在编译期间，所有的泛型信息都会被擦掉&lt;/strong&gt;，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，&lt;strong&gt;使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如在代码中定义&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;和&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;等类型，在编译后都会变成&lt;code&gt;List&lt;/code&gt;&lt;/strong&gt;，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，&lt;strong&gt;但是仍然无法在运行时刻出现的类型转换异常的情况&lt;/strong&gt;，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="泛型" scheme="http://zhuuu.work/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-146-LRU缓存机制</title>
    <link href="http://zhuuu.work/2020/08/05/Leetcode/Leetcode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/08/05/Leetcode/Leetcode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2020-08-05T07:52:22.000Z</published>
    <updated>2020-09-15T14:39:24.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-146-LRU缓存机制"><a href="#Leecode-146-LRU缓存机制" class="headerlink" title="Leecode-146. LRU缓存机制"></a>Leecode-<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h1><h2 id="思路：递归-迭代"><a href="#思路：递归-迭代" class="headerlink" title="思路：递归/迭代"></a>思路：递归/迭代</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><ul><li>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。</li><li>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><h2 id="方案：-哈希链表"><a href="#方案：-哈希链表" class="headerlink" title="方案： 哈希链表"></a>方案： 哈希链表</h2><ul><li>LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</li><li>注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 缓存容量为 2 *&#x2F;</span><br><span class="line">LRUCache cache &#x3D; new LRUCache(2);</span><br><span class="line">&#x2F;&#x2F; 你可以把 cache 理解成一个队列</span><br><span class="line">&#x2F;&#x2F; 假设左边是队头，右边是队尾</span><br><span class="line">&#x2F;&#x2F; 最近使用的排在队头，久未使用的排在队尾</span><br><span class="line">&#x2F;&#x2F; 圆括号表示键值对 (key, val)</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 1)]</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(2, 2), (1, 1)]</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 1</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 1), (2, 2)]</span><br><span class="line">&#x2F;&#x2F; 解释：因为最近访问了键 1，所以提前至队头</span><br><span class="line">&#x2F;&#x2F; 返回键 1 对应的值 1</span><br><span class="line">cache.put(3, 3);</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(3, 3), (1, 1)]</span><br><span class="line">&#x2F;&#x2F; 解释：缓存容量已满，需要删除内容空出位置</span><br><span class="line">&#x2F;&#x2F; 优先删除久未使用的数据，也就是队尾的数据</span><br><span class="line">&#x2F;&#x2F; 然后把新的数据插入队头</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(3, 3), (1, 1)]</span><br><span class="line">&#x2F;&#x2F; 解释：cache 中不存在键为 2 的数据</span><br><span class="line">cache.put(1, 4);    </span><br><span class="line">&#x2F;&#x2F; cache &#x3D; [(1, 4), (3, 3)]</span><br><span class="line">&#x2F;&#x2F; 解释：键 1 已存在，把原始值 1 覆盖为 4</span><br><span class="line">&#x2F;&#x2F; 不要忘了也要将键值对提前到队头</span><br></pre></td></tr></table></figure><ul><li>分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。</li><li>因为显然 cache <strong>必须有顺序之分</strong>，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；<strong>如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。</strong></li><li>那么，什么数据结构同时符合上述条件呢？<strong>哈希表查找快，但是数据无固定顺序</strong>；<strong>链表有顺序之分，插入删除快，但是查找慢。</strong>所以结合一下，形成一种新的数据结构：哈希链表。</li><li><strong>LRU 缓存算法的核心数据结构就是哈希链表</strong>，双向链表和哈希表的结合体。这个数据结构长这样：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200805-165923396.png" alt="mark"></p><p><strong>思想很简单，就是借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点。回想刚才的例子，这种数据结构是不是完美解决了 LRU 缓存的需求？</strong></p><p>也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存键值对呢，只存值不就行了？</p><p>想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个可不写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动实现版本</strong></p><ol><li><strong>Node结构</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">public</span> Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>双向链表</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head, tail; <span class="comment">// 头尾虚节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 链表元素数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头部添加节点 x</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.next = head.next;</span><br><span class="line">        x.prev = head;</span><br><span class="line">        head.next.prev = x;</span><br><span class="line">        head.next = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中的 x 节点（x 一定存在）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail.prev == head)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node last = tail.prev;</span><br><span class="line">        remove(last);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>缓存实现</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key -&gt; Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; map;</span><br><span class="line">    <span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).val;</span><br><span class="line">        <span class="comment">// 利用 put 方法把该数据提前</span></span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先把新节点 x new出来</span></span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key,value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前key存在</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">// 删除旧的节点，新的插入到头部</span></span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            cache.addFirst(x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新map对应的数据</span></span><br><span class="line">            map.put(key,x);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果之前key不存在</span></span><br><span class="line">            <span class="keyword">if</span> (cap == cache.size())&#123;</span><br><span class="line">                <span class="comment">// 删除链表的最后一个数据</span></span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接添加到头部</span></span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            map.put(key,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.map.keySet());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res1 = cache.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res2 = cache.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res3 = cache.get(<span class="number">3</span>);</span><br><span class="line">        System.out.println(res3);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(cache.map.keySet());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res4 = cache.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(res4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res5 = cache.get(<span class="number">3</span>);</span><br><span class="line">        System.out.println(res5);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res6 = cache.get(<span class="number">4</span>);</span><br><span class="line">        System.out.println(res6);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充一段伪代码逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key 映射到 Node(key, val)</span></span><br><span class="line">HashMap&lt;Integer, Node&gt; map;</span><br><span class="line"><span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">DoubleList cache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key 不存在) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        将数据 (key, val) 提到开头；</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">    <span class="keyword">if</span> (key 已存在) &#123;</span><br><span class="line">        把旧的数据删除；</span><br><span class="line">        将新节点 x 插入到开头；</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache 已满) &#123;</span><br><span class="line">            删除链表的最后一个数据腾位置；</span><br><span class="line">            删除 map 中映射到该数据的键；</span><br><span class="line">        &#125; </span><br><span class="line">        将新节点 x 插入到开头；</span><br><span class="line">        map 中新建 key 对新节点 x 的映射；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-146-LRU缓存机制&quot;&gt;&lt;a href=&quot;#Leecode-146-LRU缓存机制&quot; class=&quot;headerlink&quot; title=&quot;Leecode-146. LRU缓存机制&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;146. LRU缓存机制&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：递归-迭代&quot;&gt;&lt;a href=&quot;#思路：递归-迭代&quot; class=&quot;headerlink&quot; title=&quot;思路：递归/迭代&quot;&gt;&lt;/a&gt;思路：递归/迭代&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。&lt;/li&gt;
&lt;li&gt;写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;方案：-哈希链表&quot;&gt;&lt;a href=&quot;#方案：-哈希链表&quot; class=&quot;headerlink&quot; title=&quot;方案： 哈希链表&quot;&gt;&lt;/a&gt;方案： 哈希链表&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。&lt;/li&gt;
&lt;li&gt;注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="缓存机制" scheme="http://zhuuu.work/tags/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    
      <category term="LRU" scheme="http://zhuuu.work/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-10-乐观锁和悲观锁</title>
    <link href="http://zhuuu.work/2020/08/03/Mysql/Mysql-10-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://zhuuu.work/2020/08/03/Mysql/Mysql-10-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2020-08-03T08:02:27.000Z</published>
    <updated>2020-09-19T13:54:22.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-10-乐观锁和悲观锁"><a href="#Mysql-10-乐观锁和悲观锁" class="headerlink" title="Mysql-10-乐观锁和悲观锁"></a>Mysql-10-乐观锁和悲观锁</h1><h2 id="1-乐观锁和悲观锁"><a href="#1-乐观锁和悲观锁" class="headerlink" title="1. 乐观锁和悲观锁"></a>1. 乐观锁和悲观锁</h2><p><strong>首先说明，乐观锁和悲观锁都是针对读（select）来说的。</strong></p><p><strong>也就是一句话：读用乐观锁，写用悲观锁。</strong></p><a id="more"></a><h3 id="1-1-乐观锁"><a href="#1-1-乐观锁" class="headerlink" title="1.1 乐观锁"></a>1.1 乐观锁</h3><ul><li>总是认为不会产生并发问题，每次去<strong>取数据的时候总认为不会有其他线程对数据进行修改</strong>，因此不会上锁，但是在<strong>更新时会判断其他线程在这之前有没有对数据进行修改</strong>，</li><li>一般会使用<strong>版本号机制</strong>或<strong>CAS操作实现</strong>。</li><li>乐观锁适用于多读的应用类型，这样可以提高吞吐量</li></ul><ol><li><p><strong>version方式</strong>：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。</p><ul><li>当线程A要更新数据值时，在读取数据的同时也会读取version值，</li><li>在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li></ul></li></ol><p>   核心SQL代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> x=x+<span class="number">1</span>, <span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>CAS操作方式：</strong>即<code>compare and swap</code> 或者 <code>compare and set</code>，涉及到三个操作数，数据所在的内存值，预期值，新值。<ul><li>当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个<strong>自旋操作</strong>，即不断的重试。</li></ul></li></ol><h3 id="1-2-悲观锁"><a href="#1-2-悲观锁" class="headerlink" title="1.2 悲观锁"></a>1.2 悲观锁</h3><ul><li>悲观锁(<code>Pessimistic Lock</code>), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</li><li>传统的关系型数据库里边就用到了很多这种锁机制，比如<strong>行锁，表锁等，读锁，写锁</strong>等，都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往<strong>依靠数据库提供的锁机制</strong></li></ul><p><strong>首先说明，乐观锁和悲观锁都是针对读（select）来说的。</strong></p><p>案例：</p><p>某商品，用户购买后库存数应-1，而某两个或多个用户同时购买，此时三个执行程序均同时读得库存为“<strong>n</strong>”，之后进行了一些操作，最后将均执行<em>update table set 库存数=n-1</em>，那么，很显然这是错误的。</p><p>解决：</p><ol><li><p><strong>使用悲观锁</strong>（其实说白了也就是<strong>排他锁</strong>）</p><p>|– 程序A在查询库存数时使用排他锁（select * from table where id=10 for update）</p><p>|– 然后进行后续的操作，包括更新库存数，最后提交事务。</p><p>|– 程序B在查询库存数时，如果A还未释放排他锁，它将等待……</p><p>|– 程序C同B……</p></li><li><p><strong>使用乐观锁</strong>（靠表设计和代码来实现）</p><p>|– 一般是在该商品表添加<strong>version版本</strong>字段或者<strong>timestamp时间戳</strong>字段</p><p>|– 程序A查询后，执行更新变成了：<br><code>*update table set num=num-1 where id=10 and version=23*</code></p><p>这样，保证了修改的数据是和它查询出来的数据是一致的（其他执行程序肯定未进行修改）。当然，如果更新失败，表示在更新操作之前，有其他执行程序已经更新了该库存数，那么就可以尝试<strong>重试</strong>来保证更新成功。为了尽可能避免更新失败，可以合理调整重试次数（阿里巴巴开发手册规定重试次数不低于三次）。</p></li></ol><p><strong>总结：对于以上，可以看得出来乐观锁和悲观锁的区别：</strong></p><ul><li><p>悲观锁实际使用了排他锁来实现（<strong>select \</strong>** for update**）。文章开头说到，<code>innodb</code>加行锁的前提是：必须是通过索引条件来检索数据，否则会切换为表锁。</p><p>因此，悲观锁在未通过索引条件检索数据时，会锁定整张表。导致其他程序不允许“<strong>加锁的查询操作</strong>”，影响吞吐。故如果在查询居多的情况下，推荐使用乐观锁。</p><p>“<strong>加锁的查询操作</strong>”：加过排他锁的数据行在其他事务中是不能修改的，也不能通过<strong>for update</strong>或<strong>lock in share mode</strong>的加锁方式查询，但可以直接通过<code>select ...from...</code>查询数据，因为<strong>普通查询没有任何锁机制</strong>。</p></li><li><p>乐观锁更新有可能会失败，甚至是更新几次都失败，这是有风险的。所以如果写入居多，对吞吐要求不高，可使用悲观锁。</p></li></ul><p><strong>参考博客 ：</strong></p><p> <a href="https://blog.csdn.net/localhost01/article/details/78720727?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">https://blog.csdn.net/localhost01/article/details/78720727?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight</a></p><p>  <a href="https://blog.csdn.net/L_BestCoder/article/details/79298417" target="_blank" rel="noopener">https://blog.csdn.net/L_BestCoder/article/details/79298417</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-10-乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#Mysql-10-乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;Mysql-10-乐观锁和悲观锁&quot;&gt;&lt;/a&gt;Mysql-10-乐观锁和悲观锁&lt;/h1&gt;&lt;h2 id=&quot;1-乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#1-乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;1. 乐观锁和悲观锁&quot;&gt;&lt;/a&gt;1. 乐观锁和悲观锁&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;首先说明，乐观锁和悲观锁都是针对读（select）来说的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是一句话：读用乐观锁，写用悲观锁。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JUC-19-AQS</title>
    <link href="http://zhuuu.work/2020/08/03/JUC/JUC-19-AQS/"/>
    <id>http://zhuuu.work/2020/08/03/JUC/JUC-19-AQS/</id>
    <published>2020-08-03T08:02:24.000Z</published>
    <updated>2020-09-18T03:18:54.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-19-AQS"><a href="#JUC-19-AQS" class="headerlink" title="JUC-19-AQS"></a>JUC-19-AQS</h1><h2 id="1-AQS结构"><a href="#1-AQS结构" class="headerlink" title="1. AQS结构"></a>1. AQS结构</h2><ul><li>AQS（<code>AbstractQueuedSynchronizer</code>）是Java众多锁以及并发工具的基础类，底层采用乐观锁，大量采用CAS操作保证其原子性，并且在并发冲突时，采用自旋方法重试。实现了轻量高效的获取锁。</li></ul><h3 id="1-1-信号量"><a href="#1-1-信号量" class="headerlink" title="1.1 信号量"></a>1.1 信号量</h3><ul><li>在AQS中，状态是由<code>volatile state</code>来表示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><ul><li>该属性值表示锁的状态。<ul><li>state为0表示锁未被占用，</li><li>state为1表示锁被线程持有，</li><li>而state大于1表示锁被重入。</li></ul></li></ul><p>而本文分析的是独占锁，那么同一时刻，锁只能被一个线程持有。</p><p>不仅需要记录锁的状态，还需要记录当前获取锁的线程，实现重入。可以通过来记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2-等待队列"><a href="#1-2-等待队列" class="headerlink" title="1.2 等待队列"></a>1.2 等待队列</h3><ul><li>等待队列采用悲观锁的思想，表示当前所等待的资源，状态或条件短时间内可能无法满足，而调用<code>park</code>方法（借助操作系统）来完成线程的阻塞。</li><li>在AQS中，队列时一个双端链表，将当前线程包装成某种类型的数据结构扔到等待队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 节点所代表的线程  </span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;    </span><br><span class="line"><span class="comment">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用  </span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;  </span><br><span class="line"><span class="keyword">volatile</span> Node next;  </span><br><span class="line"><span class="comment">// 线程所处的等待锁的状态，初始化时，该值为0。  </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;  </span><br><span class="line"><span class="comment">//队列中节点线程被取消</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">//节点将其前驱节点设置为-1，当前驱节点释放锁后，会自动唤醒该节点。  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;  </span><br><span class="line"><span class="comment">//线程被重新包装为Node节点，并存入Condition队列中。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;  </span><br><span class="line"><span class="comment">//共享锁唤醒风暴时，将0-&gt;PROPAGATE，表示被传播唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;  </span><br><span class="line"><span class="comment">// 该属性用于条件队列或者共享锁 。在Condition队列中，使用其作为指针。</span></span><br><span class="line">Node nextWaiter;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在独占锁下，我们需要关注的就是下面几个参数：</p><ul><li><code>thread</code>：当前Node所代表的线程；</li><li><code>waitStatus</code>：表示节点所处的等待状态；</li><li><code>prev next</code>节点的前驱和后继</li></ul><h3 id="1-3-CAS操作"><a href="#1-3-CAS操作" class="headerlink" title="1.3 CAS操作"></a>1.3 CAS操作</h3><ul><li>CAS采用乐观锁机制，保证操作的原子性。一般是改变状态或改变指针（引用）指向。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-091408589.png" alt="mark"></p><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>在AQS源码中：</p><ol><li>锁属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//当前持有锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>sync queue</code>相关的属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread属性为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 队尾，新入队的节点</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>Node</code>相关属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点所代表的线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程所处的等待锁的状态，初始化时，该值为0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="2-lock-接口"><a href="#2-lock-接口" class="headerlink" title="2. lock 接口"></a>2. lock 接口</h2><p>Lock是一个接口，方法定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void lock() &#x2F;&#x2F; 如果锁可用就获得锁，如果锁不可用就阻塞直到锁释放</span><br><span class="line">void lockInterruptibly() &#x2F;&#x2F; 和 lock()方法相似, 但阻塞的线程可中断，抛出 java.lang.InterruptedException异常</span><br><span class="line">boolean tryLock() &#x2F;&#x2F; 非阻塞获取锁;尝试获取锁，如果成功返回true</span><br><span class="line">boolean tryLock(long timeout, TimeUnit timeUnit) &#x2F;&#x2F;带有超时时间的获取锁方法</span><br><span class="line">void unlock() &#x2F;&#x2F; 释放锁</span><br></pre></td></tr></table></figure><p>实现Lock接口的类有很多，以下为几个常见的锁实现</p><ul><li><strong>ReentrantLock：表示重入锁</strong>，它是唯一一个实现了Lock接口的类。重入锁指的是线程在获得锁之后，再次获取该锁不需要阻塞，而是直接关联一次计数器增加重入次数</li><li><strong>ReentrantReadWriteLock：重入读写锁，它实现了ReadWriteLock接口</strong>，在这个类中维护了两个锁，一个是ReadLock，一个是WriteLock，他们都分别实现了Lock接口。读写锁是一种适合读多写少的场景下解决线程安全问题的工具，基本原则是：<code>读和读不互斥、读和写互斥、写和写互斥</code>。也就是说涉及到影响数据变化的操作都会存在互斥。</li><li><strong>StampedLock： stampedLock是JDK8引入的新的锁机制，可以简单认为是读写锁的一个改进版本</strong>，读写锁虽然通过分离读和写的功能使得读和读之间可以完全并发，但是读和写是有冲突的，如果大量的读线程存在，可能会引起写线程的饥饿。stampedLock是一种乐观的读策略，使得乐观锁完全不会阻塞写线程</li></ul><h2 id="3-ReentrantLock实现"><a href="#3-ReentrantLock实现" class="headerlink" title="3. ReentrantLock实现"></a>3. ReentrantLock实现</h2><h3 id="3-1-加锁逻辑"><a href="#3-1-加锁逻辑" class="headerlink" title="3.1 加锁逻辑"></a>3.1 加锁逻辑</h3><p><code>ReentrantLock</code>有公平锁和非公平锁两种实现，<strong>默认实现非公平锁。但是可配置为公平锁</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock <span class="keyword">lock</span>=<span class="keyword">new</span> ReentrantLock(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>调用公平锁加锁逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//开始加锁，将state修改为1</span></span><br><span class="line">    acquire(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>真正的加锁方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;    </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))   </span><br><span class="line">        selfInterrupt();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. tryAcquire(arg)</strong><br> 该方法由继承AQS的子类实现，为获取锁的具体逻辑；</p><p><strong>2. addWaiter(Node.EXCLUSIVE)</strong><br> 该方法由AQS实现，负责在获取锁失败后调用，将当前请求锁的线程包装成Node并且放到<code>等待队列中</code>，并返回该Node。</p><p><strong>3. acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</strong><br> 该方法由AQS实现。针对上面加入到队列的Node不断尝试两种操作之一：</p><ul><li>若前驱节点是head节点的时候，尝试获取锁；</li><li>调用<code>park</code>将当前线程挂起，线程阻塞。</li></ul><p><strong>4. selfInterrupt</strong><br>该方法由AQS实现。<strong>恢复用户行为。</strong></p><ul><li><p>用户在外界调用<code>t1.interrupt()</code>进行中断。</p></li><li><p>线程在<code>parkAndCheckInterrupt</code>方法被唤醒之后。会调用<code>Thread.interrupted();</code>判断线程的中断标识，而该方法调用完毕会清除中断标识位。</p></li><li><p>而AQS为了不改变用户标识。再次调用<code>selfInterrupt</code>恢复用户行为。</p></li></ul><h3 id="3-2-构建等待队列-addWaiter"><a href="#3-2-构建等待队列-addWaiter" class="headerlink" title="3.2 构建等待队列 addWaiter"></a>3.2 构建等待队列 addWaiter</h3><ul><li>我们使用<code>ReentrantLock</code>独占锁时，等待队列是<code>延迟加载</code>的。</li><li>也就是说<strong>若是线程交替执行</strong>，那么借助<code>信号量（状态）</code>来保证。</li><li>若是<strong>线程并发执行</strong>，就需要将阻塞线程放入到队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个方法可能存在并发问题。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;  </span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);  </span><br><span class="line">    Node pred = tail;  </span><br><span class="line">    <span class="comment">//队列已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        node.prev = pred;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;  </span><br><span class="line">            pred.next = node;  </span><br><span class="line">            <span class="keyword">return</span> node;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//队列不存在</span></span><br><span class="line">    enq(node);  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>队列不存在的情况(初始化队列 enq(Node))</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094601871.png" alt="mark"></p><p>注意，该方法处理<code>CAS</code>操作是原子性的，其他操作都存在并发冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">         Node t = tail;  </span><br><span class="line">         <span class="comment">// 初始化队列 （一个Thread 为null的空node）</span></span><br><span class="line">         <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  </span></span><br><span class="line">             <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))  </span><br><span class="line">                 tail = head;  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">             <span class="comment">// (维护队列 CAS改变队尾)</span></span><br><span class="line">             node.prev = t;  </span><br><span class="line">             <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  </span><br><span class="line">                 t.next = node;  </span><br><span class="line">                 <span class="keyword">return</span> t;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法采用自旋+CAS。CAS是保证同一时刻只有一个线程能成功改变引用的指向。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094805424.png" alt="mark"></p><ul><li><p>根据上面的流程图，sync queue的创建过程。<strong>head节点是<code>new Node()</code>产生的，即其中的属性为默认值。</strong>也就是thread属性为null。也就是说<strong>正在执行的线程也会在<code>sync queue</code>中占据头节点，但是节点中不会保存线程信息。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094839510.png" alt="mark"></p></li></ul><p><strong>尾分叉问题：</strong></p><p>上面已经说了，该方法是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1：可能多个节点的prev指针都指向尾结点，导致尾分叉</span></span><br><span class="line">node.prev = t;  </span><br><span class="line"><span class="comment">//步骤2：但同一时刻，tail引用只会执行一个node。</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  </span><br><span class="line">   <span class="comment">//步骤3：现在环境是线程安全，旧尾结点的后继指针指向新尾结点。</span></span><br><span class="line">   t.next = node;  </span><br><span class="line">   <span class="keyword">return</span> t;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-094920922.png" alt="mark"></p><p>执行完<code>步骤2</code>，但<code>步骤3</code>还未执行时，恰好有线程从头节点开始往后遍历。<strong>此时（旧）尾结点中的next域还为null。</strong>它是遍历不到新加进来的尾结点的。这显然是不合理的。</p><p>但此时<code>步骤1</code>是执行成功的，所以<strong>若是tail节点往前遍历，实际上是可以遍历到所有节点的</strong>，这也是为什么在AQS源码中，有时候常常会出现<strong>从尾结点开始逆向遍历链表的情况</strong>。</p><p>那些“分叉”的节点，肯定会入队失败。那么继续自旋，等待所有的线程节点全部入队成功。</p><h3 id="3-3-尝试获取锁-tryAcquire"><a href="#3-3-尝试获取锁-tryAcquire" class="headerlink" title="3.3 尝试获取锁 tryAcquire"></a>3.3 尝试获取锁 tryAcquire</h3><ul><li><strong>根据标志位state，来判断锁是否被占用</strong>。此时可能锁未被占用，由于是公平锁，于是会去判断<code>sync queue</code>中是否有人在排队。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();  </span><br><span class="line">    <span class="comment">//获取Lock对象的上锁情况，0-表示无线程持有；1-表示被线程持有；大于1-表示锁被重入</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();  </span><br><span class="line">    <span class="comment">//若此刻无人占有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;    <span class="comment">//判断队列中是否有前辈。若返回false代表没有，开始尝试加锁</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//此刻队列中没有存在前辈，尝试加锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);   <span class="comment">//将当前线程修改为持有锁的线程（后续判断可重入）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//若是当前线程是持有锁的线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  </span><br><span class="line">        <span class="comment">//当前状态+1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;  </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);  </span><br><span class="line">        setState(nextc);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//否则，代表加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法不具有原子性，可能多个线程都觉得自己不需要排队，最终还是依靠外面</span></span><br><span class="line"><span class="comment">//条件上的CAS来保持其原子性。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Node t = tail;   </span><br><span class="line">    Node h = head;  </span><br><span class="line">    Node s;  </span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;  </span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是<code>判断队列中是否存在元素</code>。可能存在以下几种情况：</p><ul><li><strong>此时未维护队列</strong>，<code>h!=t</code>返回false，即无人排队；</li><li>此时队列<strong>只有头节点</strong>（哑结点），<code>h!=t</code>返回false，即无人排队；</li><li>此时队列中<strong>存在2个的节点</strong>。若线程是头结点的后继节点线程（即处理正在办理业务的线程，进来的线程是第一个排队的线程）。那么<code>s.thread != Thread.currentThread()</code>返回false，即可是尝试加锁。</li><li>队列存在<strong>2个以上节点</strong>，且进来的线程不是第一个排队的线程，那么该线程需要乖乖的排队</li></ul><p>当然该方法不是并发安全的方法，即可能存在多个线程觉得自己无需排队，最终还是依靠<code>CAS</code>来争夺锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">    <span class="comment">//线程安全   </span></span><br><span class="line">    setExclusiveOwnerThread(current);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一时刻，只有一个线程可以成功改变state的状态。记录该线程为独占锁线程，一般后续可以重入。</p><p>没成功获取锁那么会调用<code>2.2 中的方法，将该线程加入到阻塞队列中</code>。</p><h3 id="3-4-阻塞线程-acquireQueued"><a href="#3-4-阻塞线程-acquireQueued" class="headerlink" title="3.4 阻塞线程 acquireQueued"></a>3.4 阻塞线程 acquireQueued</h3><ul><li>若执行到该方法，说明<code>addWaiter</code>方法已经成功将该线程包装为Node节点放到了队尾。</li><li>在该方法中依旧尝试获取锁；</li><li>再次获取锁失败后，会将其阻塞；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="comment">//获取node的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  </span><br><span class="line">            <span class="comment">//若前驱节点在办理业务，那么它将再次获取一次锁。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  </span><br><span class="line">                <span class="comment">//获取锁成功，此处便是线程安全。</span></span><br><span class="line">                <span class="comment">//将自己设置为头节点，并将自己设置为哑节点</span></span><br><span class="line">                setHead(node);  </span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC  </span></span><br><span class="line">                failed = <span class="keyword">false</span>;  </span><br><span class="line">                <span class="keyword">return</span> interrupted;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//获取锁失败，将自己挂起。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                parkAndCheckInterrupt())  </span><br><span class="line">                interrupted = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            cancelAcquire(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法时<code>自旋方法</code>，而出口就是获取到锁。若线程获取不到锁，便会将自己阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法时node线程获取锁成功后执行的，故是线程安全的。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;  </span><br><span class="line">    head = node;  </span><br><span class="line">    node.thread = <span class="keyword">null</span>;  </span><br><span class="line">    node.prev = <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200817-103752407.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//上一个节点的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;  </span><br><span class="line">    <span class="comment">//  Node.SIGNAL==-1</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    <span class="comment">//ws大于0，则说明该节点已经被取消了。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            node.prev = pred = pred.prev;  </span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);  </span><br><span class="line">        pred.next = node;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//CAS变更ws的状态</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是加锁失败开始执行的。也就是一个线程决定挂起之前需要执行的操作。这里就用到了节点中的信号量<code>waitStatus</code>。</p><ol><li>判断前驱节点<code>waitStatus</code>的值，会做出如下操作：<br> 1.1 前驱节点<code>waitStatus</code>若是-1，直接返回true。<br> 1.2 前驱节点<code>waitStatus</code>若大于0，证明前驱节点已被取消，那么在链表中删除前驱节点，直到node的前驱节点的<code>waitStatus</code>不大于0为止。然后返回false<br> 1.3. 若前驱节点<code>waitStatus</code>等于0，使用CAS尝试改变前驱节点<code>waitStatus</code>状态，由0到-1，然后返回false。</li></ol><ol start="2"><li>若是返回true，那么去阻塞该节点，若是返回false，那么继续自旋，继续上述过程，直至该方法返回true为止，方法返回true，便会执行下列方法，阻塞线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//将线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);  </span><br><span class="line">    <span class="comment">//线程被唤起时，查看线程的中断标识（注意，查看完毕后，中断标识归位）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：当前节点在阻塞之前，会将前驱节点的<code>waitStatus</code>设置为-1，就可保证前驱节点在适当的时机唤醒自己。</strong></p><h2 id="4-附录"><a href="#4-附录" class="headerlink" title="4. 附录"></a>4. 附录</h2><h3 id="4-1-CAS对象"><a href="#4-1-CAS对象" class="headerlink" title="4.1 CAS对象"></a>4.1 CAS对象</h3><p>开始我认为对象的CAS算法，实际上会是B对象去覆盖堆内存上的A对象，其实不然。比较交换的是引用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法是获取引用。而非堆上的内存。</span></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        valueOffset = unsafe.objectFieldOffset  </span><br><span class="line">            (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ex); &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-加锁总结"><a href="#5-加锁总结" class="headerlink" title="5. 加锁总结"></a>5. 加锁总结</h2><ol><li>因为AQS的等待队列是延迟加载，只有多个线程并发访问时，才会开始维护队列。</li><li>因为head节点中不包含<code>thread</code>属性的值，又被称为<code>哑节点</code>。</li><li>head是正在办理业务的节点，而他的后继节点是第一个排队节点。</li></ol><blockquote><ol><li>尝试加锁过程</li></ol></blockquote><ol><li>根据status判断当前锁是否被持有，若被持有，直接<code>维护队列</code>；</li><li>若未被持有，判断当前队列是否有节点在排队，若有节点排队，直接<code>维护队列</code>；</li><li>若无节点排队，则通过CAS修改锁状态标识，修改成功代表线程持有该锁；</li><li>使用<code>exclusiveOwnerThread</code>来保存持有锁的线程（解决线程重入）；</li></ol><blockquote><ol start="2"><li>维护队列过程</li></ol></blockquote><p>最终线程的head节点为哑节点。后续线程被组装成node节点，维护在链表中。</p><blockquote><ol start="3"><li>线程阻塞过程</li></ol></blockquote><ol><li>判断node节点是否为head节点的后续节点（第一个排队节点），若是的话，尝试获取锁。若获取到，将其设置为head节点，并将其设置为哑节点；</li><li>在阻塞前，会将自己的前驱节点的<code>waitStatus</code>设置为<code>SIGNAL</code>。以便可以唤醒自己。</li></ol><h2 id="6-锁的释放"><a href="#6-锁的释放" class="headerlink" title="6. 锁的释放"></a>6. 锁的释放</h2><h3 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h3><p>加锁的过程分析完以后，再来分析一下释放锁的过程，调用release方法，这个方法里面做两件事，</p><p><strong>1，释放锁 ；</strong></p><p><strong>2，唤醒park的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><ul><li>这个动作可以认为就是一个设置锁状态的操作，而且是将状态减掉传入的参数值（参数是1），如果结果状态为0，就将排它锁的Owner设置为null，以使得其它的线程有机会进行执行。</li><li>在排它锁中，加锁的时候状态会增加1（当然可以自己修改这个值），在解锁的时候减掉1，同一个锁，在可以重入后，可能会被叠加为2、3、4这些值，只有unlock()的次数与lock()的次数对应才会将Owner线程设置为空，而且也只有这种情况下才会返回true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3><ul><li>在方法unparkSuccessor(Node)中，就意味着真正要释放锁了，它传入的是head节点（head节点是占用锁的节点），当前线程被释放之后，需要唤醒下一个节点的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//判断后继节点是否为空或者是否是取消状态,</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点, 至于为什么从尾部开始向前遍历，因为在doAcquireInterruptibly.cancelAcquire方法的处理过程中只设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除锁的节点图文解析</strong></p><ul><li>head节点表示获取锁成功的节点，当头结点在释放同步状态时，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头结点，节点的变化过程如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/103308919.png" alt="mark"></p><p>这个过程也是涉及到两个变化</p><ul><li>修改head节点指向下一个获得锁的节点</li><li>新的获得锁的节点，将prev的指针指向null</li></ul><p><strong>注意：</strong></p><ul><li><strong>这里有一个小的变化，就是设置head节点不需要用CAS，原因是设置head节点是由获得锁的线程来完成的，而同步锁只能由一个线程获得，所以不需要CAS保证</strong></li><li><strong>只需要把head节点设置为原首节点的后继节点，并且断开原head节点的next引用即可</strong></li></ul><p><strong>参考博客</strong></p><p><a href="https://www.jianshu.com/p/dcc608274b88" target="_blank" rel="noopener">https://www.jianshu.com/p/dcc608274b88</a></p><p><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017372067</a></p><p><a href="https://www.cnblogs.com/fsmly/p/11274572.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsmly/p/11274572.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-19-AQS&quot;&gt;&lt;a href=&quot;#JUC-19-AQS&quot; class=&quot;headerlink&quot; title=&quot;JUC-19-AQS&quot;&gt;&lt;/a&gt;JUC-19-AQS&lt;/h1&gt;&lt;h2 id=&quot;1-AQS结构&quot;&gt;&lt;a href=&quot;#1-AQS结构&quot; class=&quot;headerlink&quot; title=&quot;1. AQS结构&quot;&gt;&lt;/a&gt;1. AQS结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;AQS（&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;）是Java众多锁以及并发工具的基础类，底层采用乐观锁，大量采用CAS操作保证其原子性，并且在并发冲突时，采用自旋方法重试。实现了轻量高效的获取锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-信号量&quot;&gt;&lt;a href=&quot;#1-1-信号量&quot; class=&quot;headerlink&quot; title=&quot;1.1 信号量&quot;&gt;&lt;/a&gt;1.1 信号量&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在AQS中，状态是由&lt;code&gt;volatile state&lt;/code&gt;来表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; state;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;该属性值表示锁的状态。&lt;ul&gt;
&lt;li&gt;state为0表示锁未被占用，&lt;/li&gt;
&lt;li&gt;state为1表示锁被线程持有，&lt;/li&gt;
&lt;li&gt;而state大于1表示锁被重入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而本文分析的是独占锁，那么同一时刻，锁只能被一个线程持有。&lt;/p&gt;
&lt;p&gt;不仅需要记录锁的状态，还需要记录当前获取锁的线程，实现重入。可以通过来记录。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Thread exclusiveOwnerThread;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhuuu.work/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>JVM-12-四种引用类型</title>
    <link href="http://zhuuu.work/2020/08/01/JVM_Notes/JVM-12-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhuuu.work/2020/08/01/JVM_Notes/JVM-12-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-08-01T02:38:38.000Z</published>
    <updated>2020-09-14T14:39:43.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-12-四种引用类型"><a href="#JVM-12-四种引用类型" class="headerlink" title="JVM-12-四种引用类型"></a>JVM-12-四种引用类型</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200804-142140836.png" alt="mark"></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><ul><li><p><strong>在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象</strong>。也就是说，只有对象处于可触及状态，程序才能使用它。这 就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了。</p></li><li><p>但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因 为也许将来还会派用场。<strong>对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃 圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。</strong></p></li><li><p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。<strong>这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用</strong>。</p></li></ul><a id="more"></a><h2 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h2><ul><li><strong>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用</strong>。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。<strong>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Arraylist&lt;String&gt;();</span><br><span class="line">list.add(str);</span><br></pre></td></tr></table></figure><blockquote><p>在list集合里的数据不会释放，即使内存不足也不会</p></blockquote><h2 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h2><ul><li>如果一个对象只具有软引用，那就类似于可有可物的生活用品。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</strong>只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li><li>软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</li></ul><h2 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h2><ul><li>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。<strong>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</strong>不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</li><li>弱引用可以和一个<strong>引用队列</strong>（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object c = <span class="keyword">new</span> Car(); <span class="comment">//只要c还指向car object, car object就不会被回收</span></span><br><span class="line">WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> WeakReference(Car)(car);</span><br></pre></td></tr></table></figure><p>当要获得weak reference引用的object时, 首先需要判断它是否已经被回收:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weakCar.get();</span><br></pre></td></tr></table></figure><p>如果此方法为空, 那么说明weakCar指向的对象已经被回收了.</p><p>下面来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">private</span> String colour;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, String colour)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">    <span class="keyword">this</span>.colour = colour;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getColour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> colour;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColour</span><span class="params">(String colour)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colour = colour;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> colour +<span class="string">"car costs $"</span>+price;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWeakReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Car car = <span class="keyword">new</span> Car(<span class="number">22000</span>,<span class="string">"silver"</span>);</span><br><span class="line">    WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> WeakReference&lt;Car&gt;(car);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(weakCar.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"Object is alive for "</span>+i+<span class="string">" loops - "</span>+weakCar);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Object has been collected."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在上例中, 程序运行一段时间后, 程序打印出”Object has been collected.” 说明, weak reference指向的对象的被回收了.</span><br><span class="line"></span><br><span class="line">如果要想打出的是</span><br><span class="line">Object is alive for “+i+” loops - “+weakCar</span><br><span class="line"></span><br><span class="line">那么只要在这句话前面加上</span><br><span class="line">System.out.println(“car&#x3D;&#x3D;&#x3D;&#x3D; “+car);</span><br><span class="line">因为在此强引用了car对象</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。</strong></p><p>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p><p><strong>这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</strong></p></blockquote><h2 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h2><ul><li>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就<strong>和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</li><li>虚引用与软引用和弱引用的一个区别在于：<strong>虚引用必须和引用队列（ReferenceQueue）联合使用</strong>。</li><li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line"></span><br><span class="line">强引用：</span><br><span class="line">String str &#x3D; “abc”;</span><br><span class="line">list.add(str);</span><br><span class="line">软引用：</span><br><span class="line">如果弱引用对象回收完之后，内存还是报警，继续回收软引用对象</span><br><span class="line">弱引用：</span><br><span class="line">如果虚引用对象回收完之后，内存还是报警，继续回收弱引用对象</span><br><span class="line">虚引用：</span><br><span class="line">虚拟机的内存不够使用，开始报警，这时候垃圾回收机制开始执行System.gc(); String s &#x3D; “abc”;如果没有对象回收了， 就回收没虚引用的对象</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-12-四种引用类型&quot;&gt;&lt;a href=&quot;#JVM-12-四种引用类型&quot; class=&quot;headerlink&quot; title=&quot;JVM-12-四种引用类型&quot;&gt;&lt;/a&gt;JVM-12-四种引用类型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200804-142140836.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象&lt;/strong&gt;。也就是说，只有对象处于可触及状态，程序才能使用它。这 就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再 把它捡回来使用就不可能了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因 为也许将来还会派用场。&lt;strong&gt;对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃 圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。&lt;strong&gt;这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="http://zhuuu.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://zhuuu.work/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JUC-18-CAS</title>
    <link href="http://zhuuu.work/2020/07/31/JUC/JUC-18-CAS/"/>
    <id>http://zhuuu.work/2020/07/31/JUC/JUC-18-CAS/</id>
    <published>2020-07-31T08:02:24.000Z</published>
    <updated>2020-08-11T08:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-18-CAS"><a href="#JUC-18-CAS" class="headerlink" title="JUC-18-CAS"></a>JUC-18-CAS</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>CAS<strong>（Compare-and-Swap），即比较并替换</strong>，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题，本文将深入的介绍CAS的原理。</li></ul><p>[参考博客][<a href="https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]</a></p><h2 id="2-CAS"><a href="#2-CAS" class="headerlink" title="2. CAS"></a>2. CAS</h2><h3 id="2-1-一个例子"><a href="#2-1-一个例子" class="headerlink" title="2.1 一个例子"></a>2.1 一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREADS_COUNT);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。</p><p>通过<strong>分析字节码</strong>我们知道，这是因为volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示），在并发的情况下，putstatic指令可能把较小的race值同步回主内存之中，导致我们每次都无法获得想要的结果。那么，应该怎么解决这个问题了？</p><a id="more"></a><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-170802496.png" alt="mark"></p><p><strong>解决方案1：Synchronized</strong></p><ul><li>首先我们想到的是用synchronized来修饰increase方法。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-170849960.png" alt="mark"></p><p>使用synchronized修饰后，increase方法变成了一个原子操作，因此是肯定能得到正确的结果。但是，我们知道，每次自增都进行加锁，性能可能会稍微差了点，有更好的方案吗？</p><p><strong>解决方案2：Atomic</strong></p><ul><li><p>答案当然是有的，这个时候我们可以使用Java并发包原子操作类（Atomic开头），例如以下代码。</p></li><li><p>将例子中的代码稍做修改：race改成使用AtomicInteger定义，“race++”改成使用“<code>race.getAndIncrement()</code>”，<code>AtomicInteger.getAndIncrement()</code>是原子操作，因此我们可以确保每次都可以获得正确的结果，并且在性能上有不错的提升</p></li><li><p><strong>通过方法调用，我们可以发现，<code>getAndIncrement</code>方法调用<code>getAndAddInt</code>方法，最后调用的是compareAndSwapInt方法，即本文的主角CAS，接下来我们开始介绍CAS。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-171109399.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200803-171128020.png" alt="mark"></p><h3 id="2-2-JDK中的CAS实现"><a href="#2-2-JDK中的CAS实现" class="headerlink" title="2.2 JDK中的CAS实现"></a>2.2 JDK中的CAS实现</h3><ol><li>JDK中提供了CAS支持？</li></ol><ul><li><p>通过调用JNI(<code>java Native interface</code>)</p></li><li><p>java中提供了对CAS的支持，具体在<strong>sun.misc.unsafe类中</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数var1 : 要操作的对象</strong></p><p><strong>参数var2 : 要操作的对象属性地址的偏移量</strong></p><p><strong>参数var4 : 期望值</strong></p><p><strong>参数var6 : 需要更新的新值</strong></p><ul><li>并且<code>compareAndSwapLong</code> 是使用CPU底层指令来实现的。以常用的Intel x86平台，最后映射到cpu的 <code>cmpxchg</code> 来实现，这是一个原子指令。</li><li>系统底层进行CAS操作的时候，会判断当前系统是否是多核心，<strong>如果是就给 “ 总线加锁”</strong>，加锁之后，只有一个线程会对总线加锁成功，也就是说CAS的操作是平台级别的。</li></ul><h3 id="2-3-CAS带来的问题"><a href="#2-3-CAS带来的问题" class="headerlink" title="2.3 CAS带来的问题"></a>2.3 CAS带来的问题</h3><ul><li><p>循环时间长开销很大。</p></li><li><p><strong>只能保证一个变量的原子操作。</strong></p></li><li><p><strong>ABA 问题 ： 一句话总结，狸猫换太子</strong></p><ul><li><p>解决方案： <code>AtomicStampReference</code> （Pair对象）</p></li><li><pre><code class="java"><span class="comment">// 内部类：不但要提供数据引用，还要提供版本号    </span><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>{        <span class="keyword">final</span> T reference;        <span class="keyword">final</span> <span class="keyword">int</span> stamp;        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>{            <span class="keyword">this</span>.reference = reference;             <span class="keyword">this</span>.stamp = stamp;        }        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>{            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);        }    }    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair&lt;!--￼<span class="number">2</span>--&gt;</code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-18-CAS&quot;&gt;&lt;a href=&quot;#JUC-18-CAS&quot; class=&quot;headerlink&quot; title=&quot;JUC-18-CAS&quot;&gt;&lt;/a&gt;JUC-18-CAS&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CAS&lt;strong&gt;（Compare-and-Swap），即比较并替换&lt;/strong&gt;，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题，本文将深入的介绍CAS的原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[参考博客][&lt;a href=&quot;https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/v123411739/article/details/79561458?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight]&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-CAS&quot;&gt;&lt;a href=&quot;#2-CAS&quot; class=&quot;headerlink&quot; title=&quot;2. CAS&quot;&gt;&lt;/a&gt;2. CAS&lt;/h2&gt;&lt;h3 id=&quot;2-1-一个例子&quot;&gt;&lt;a href=&quot;#2-1-一个例子&quot; class=&quot;headerlink&quot; title=&quot;2.1 一个例子&quot;&gt;&lt;/a&gt;2.1 一个例子&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.CountDownLatch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;VolatileTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; race = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; THREADS_COUNT = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; CountDownLatch countDownLatch = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CountDownLatch(THREADS_COUNT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;increase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        race++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread[] threads = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread[THREADS_COUNT];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; THREADS_COUNT; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            threads[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        increase();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    countDownLatch.countDown();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            threads[i].start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        countDownLatch.await();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(race);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;我们知道，运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;分析字节码&lt;/strong&gt;我们知道，这是因为volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示），在并发的情况下，putstatic指令可能把较小的race值同步回主内存之中，导致我们每次都无法获得想要的结果。那么，应该怎么解决这个问题了？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>排序-03-快速排序</title>
    <link href="http://zhuuu.work/2020/07/27/Sort/%E6%8E%92%E5%BA%8F-03-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/07/27/Sort/%E6%8E%92%E5%BA%8F-03-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-27T10:33:24.000Z</published>
    <updated>2020-09-16T06:31:53.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-03-快速排序"><a href="#排序-03-快速排序" class="headerlink" title="排序-03-快速排序"></a>排序-03-快速排序</h1><h2 id="1-思想"><a href="#1-思想" class="headerlink" title="1. 思想"></a>1. 思想</h2><ul><li><strong>快速排序,说白了就是给基准数据找其正确索引位置的过程.</strong></li></ul><p>举个栗子：</p><ul><li>如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105141936.png" alt="mark"></p><a id="more"></a><ul><li>首先从后半部分开始，<strong>如果扫描到的值大于基准数据就让high减1</strong>,<strong><em>如果发现有元素比该基准数据的值小(如上图中18&lt;=tmp)，就将high位置的值赋值给low位置</em></strong> ,结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105611384.png" alt="mark"></p><ul><li>然后开始从前往后扫描,<strong>如果扫描到的值小于基准数据就让low加1</strong>,<strong><em>如果发现有元素大于基准数据的值(如上图46=&gt;tmp)，就再将low位置的值赋值给high位置的值</em></strong>,指针移动并且数据交换后的结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105635565.png" alt="mark"></p><ul><li>然后再开始从后向前扫描,原理同上,发现上图<code>11&lt;=tmp</code>,则将high位置的值赋值给low位置的值,结果如下:</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105749727.png" alt="mark"></p><ul><li><strong>这样一遍走下来,可以很清楚的知道,其实快速排序的本质就是把基准数大的都放在基准数的右边,把比基准数小的放在基准数的左边,这样就找到了该数据在数组中的正确位置.</strong></li><li><strong>以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。</strong></li></ul><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2. 结论"></a>2. 结论</h2><p>从上面的过程中可以看到:</p><p>  ①先从队尾开始向前扫描且当<code>low &lt; high</code>时,如果<code>a[high] &gt; tmp</code>则<code>high–</code>,但如果<code>a[high] &lt; tmp</code>,则将<code>high</code>的值赋值给<code>low</code>,即<code>arr[low] = a[high]</code>,同时要转换数组扫描的方式,即需要从队首开始向队尾进行扫描了<br>  ②同理,当从队首开始向队尾进行扫描时,如果<code>a[low] &lt; tmp</code>,则<code>low++</code>,但如果<code>a[low] &gt; tmp</code>了,则就需要将<code>low</code>位置的值赋值给<code>high</code>位置,即<code>arr[low] = arr[high]</code>,同时将数组扫描方式换为由队尾向队首进行扫描.</p><p>​    ③不断重复①和②,知道<code>low&gt;=high</code>时(其实是<code>low=high</code>),<code>low</code>或<code>high</code>的位置就是该基准数据在数组中的正确索引位置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">76</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">22</span> &#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"排序后:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 找寻基准数据的正确索引</span></span><br><span class="line">            <span class="keyword">int</span> index = getIndex(arr, low, high);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序</span></span><br><span class="line">            quickSort(arr, low, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基准数据</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 当队尾的元素大于等于基准数据时,向前挪动high指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果队尾元素小于tmp了,需要将其赋值给low</span></span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            <span class="comment">// 当队首元素小于等于tmp时,向前挪动low指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= tmp) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当队首元素大于tmp时,需要将其赋值给high</span></span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置</span></span><br><span class="line">        <span class="comment">// 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low]</span></span><br><span class="line">        arr[low] = tmp;</span><br><span class="line">        <span class="keyword">return</span> low; <span class="comment">// 返回tmp的正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-优化"><a href="#3-优化" class="headerlink" title="3. 优化"></a>3. 优化</h2><p>参考博客 ： <a href="https://blog.csdn.net/qq_19525389/article/details/81436838" target="_blank" rel="noopener">https://blog.csdn.net/qq_19525389/article/details/81436838</a></p><p><strong>1、快速排序的基本思想：</strong></p><ul><li>快速排序使用<strong>分治</strong>的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。</li><li>之后分别对这两部分记录继续进行排序，递归地以达到整个序列有序的目的。</li></ul><p><strong>2、快速排序的三个步骤：</strong></p><p>(1<strong>)选择基准</strong>：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</p><p>(2)<strong>分割操作</strong>：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p><p>(3)<strong>递归地</strong>对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><p><strong>优化一 ： 选择基准的方式</strong></p><ul><li><p>对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p></li><li><p>最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列</p></li></ul><p>我们介绍<strong>三种选择基准的方法</strong></p><ol><li>思想：取序列的第一个或最后一个元素作为基准</li></ol><p>基本的快速排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr[low];<span class="comment">//选择选取序列的第一个元素作为基准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：基本的快速排序选取第一个或最后一个元素作为基准。但不是一种好方法</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113020716.png" alt="mark"></p><p>测试数据分析：如果输入序列是随机的，处理时间可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为起泡排序，时间复杂度为Θ(n^2)。而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为枢纽元是非常糟糕的，为了避免这个情况，就引入了下面两个获取基准的方法。</p><p><strong>方法(2)：随机选取基准</strong></p><p>引入的原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴</p><p>思想：取待排序列中任意一个元素作为基准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/*随机选择枢轴的位置，区间在low和high之间*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivotRandom</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((unsigned)time(NULL));<span class="comment">//产生枢轴的位置</span></span><br><span class="line"><span class="keyword">int</span> pivotPos = rand()%(high - low) + low;</span><br><span class="line"> </span><br><span class="line">swap(arr[pivotPos],arr[low]);<span class="comment">//把枢轴位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数</span></span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113115935.png" alt="mark"></p><p><strong>方法三： 三数取中</strong></p><ul><li>引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取枢轴</li><li>具体思想：对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">举例：待排序序列为：8 1 4 9 6 3 5 2 7 0</span><br><span class="line"></span><br><span class="line">左边为：8，右边为0，中间为6.</span><br><span class="line"></span><br><span class="line">我们这里取三个数排序后，中间那个数作为枢轴，则枢轴为6</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivotMedianOfThree</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);<span class="comment">//计算数组中间的元素的下标</span></span><br><span class="line"><span class="comment">//使用三数取中法选择枢轴</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[high])<span class="comment">//目标: arr[mid] &lt;= arr[high]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[mid],arr[high]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; arr[high])<span class="comment">//目标: arr[low] &lt;= arr[high]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[low],arr[high]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[low]) <span class="comment">//目标: arr[low] &gt;= arr[mid]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[mid],arr[low]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此时，arr[mid] &lt;= arr[low] &lt;= arr[high]</span></span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line"><span class="comment">//low的位置上保存这三个位置中间的值</span></span><br><span class="line"><span class="comment">//分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113256817.png" alt="mark"></p><p><strong>优化二：当待排序序列长度分割到一定大小后，使用插入排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</span><br><span class="line"></span><br><span class="line">截止范围：待排序序列长度N &#x3D; 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。摘自《数据结构与算法分析》Mark Allen Weiness 著</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (high - low + <span class="number">1</span> &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">InsertSort(arr,low,high);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//else时，正常执行快排</span></span><br></pre></td></tr></table></figure><p>测试数据：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/113505110.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试数据分析：针对随机数组，使用三数取中选择枢轴+插排，效率还是可以提高一点，</span><br><span class="line">但是针对已排序的数组，是没有任何用处的。因为待排序序列是已经有序的，那么每次划分只能使待排序序列减一。</span><br><span class="line">此时，插排是发挥不了作用的。所以这里看不到时间的减少。另外，三数取中选择枢轴+插排还是不能处理重复数组</span><br></pre></td></tr></table></figure><p><strong>优化三：在一次分割结束后，可以把key相等的元素聚集在一起，不用在对key相等的元素分割</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line"></span><br><span class="line">待排序序列 <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">三数取中选取枢轴：下标为<span class="number">4</span>的数<span class="number">6</span></span><br><span class="line"></span><br><span class="line">转换后，待分割序列：<span class="number">6</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">             枢轴key：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">本次划分后，未对与key元素相等处理的结果：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">下次的两个子序列为：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> 和 <span class="number">7</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">本次划分后，对与key元素相等处理的结果：<span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">下次的两个子序列为：<span class="number">1</span> <span class="number">4</span> 和 <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">经过对比，我们可以看出，在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少</span><br><span class="line"></span><br><span class="line">具体过程：在处理过程中，会有两个步骤</span><br><span class="line"></span><br><span class="line">第一步，在划分过程中，把与key相等元素放入数组的两端</span><br><span class="line"></span><br><span class="line">第二步，划分结束后，把与key相等的元素移到枢轴周围</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br><span class="line">待排序序列 <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">三数取中选取枢轴：下标为<span class="number">4</span>的数<span class="number">6</span></span><br><span class="line"></span><br><span class="line">转换后，待分割序列：<span class="number">6</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">             枢轴key：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">第一步，在划分过程中，把与key相等元素放入数组的两端 </span><br><span class="line"></span><br><span class="line">结果为：<span class="number">6</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span>(枢轴) <span class="number">7</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">此时，与<span class="number">6</span>相等的元素全放入在两端了</span><br><span class="line"></span><br><span class="line">第二步，划分结束后，把与key相等的元素移到枢轴周围</span><br><span class="line"></span><br><span class="line">结果为：<span class="number">1</span> <span class="number">4</span> <span class="number">66</span>(枢轴)  <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">此时，与<span class="number">6</span>相等的元素全移到枢轴周围了</span><br><span class="line"></span><br><span class="line">之后，在<span class="number">1</span> <span class="number">4</span> 和 <span class="number">7</span> <span class="number">8</span> <span class="number">7</span>两个子序列进行快排</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gather</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> boundKey, <span class="keyword">int</span> *left, <span class="keyword">int</span> *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> count = boundKey - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = boundKey - <span class="number">1</span>; i &gt;= low; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[boundKey])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr, i, count);</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*left = count;</span><br><span class="line">count = boundKey + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = boundKey + <span class="number">1</span>; i &lt;= high; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[boundKey])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr, i, count);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*right = count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因：在数组中，如果有相等的元素，那么就可以减少不少冗余的划分。这点在重复数组中体现特别明显啊。</strong></p><p>其实这里，插排的作用还是不怎么大的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-03-快速排序&quot;&gt;&lt;a href=&quot;#排序-03-快速排序&quot; class=&quot;headerlink&quot; title=&quot;排序-03-快速排序&quot;&gt;&lt;/a&gt;排序-03-快速排序&lt;/h1&gt;&lt;h2 id=&quot;1-思想&quot;&gt;&lt;a href=&quot;#1-思想&quot; class=&quot;headerlink&quot; title=&quot;1. 思想&quot;&gt;&lt;/a&gt;1. 思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速排序,说白了就是给基准数据找其正确索引位置的过程.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200901/105141936.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="快速排序" scheme="http://zhuuu.work/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-03-传输层</title>
    <link href="http://zhuuu.work/2020/07/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-03-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/07/27/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-03-%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2020-07-27T04:02:24.000Z</published>
    <updated>2020-09-21T13:41:55.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-03-传输层"><a href="#计算机网络-03-传输层" class="headerlink" title="计算机网络-03-传输层"></a>计算机网络-03-传输层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>推荐博客：</strong> <a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p><h6 id="传输层和网络层的关系"><a href="#传输层和网络层的关系" class="headerlink" title="传输层和网络层的关系"></a>传输层和网络层的关系</h6><ul><li>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</li><li>传输层提供了进程中的逻辑通信，传输层向高层用户屏蔽了网络层的核心实现，使得应用进程看起来像是两个传输层实体之间一条端到端的逻辑通信信道。</li></ul><p>实际上，<strong>传输层和应用程序进程之间通过Socket（套接字）</strong>关联，这样通过Socket就可以区别同一主机上的不同应用进程，从而传输层提供服务变为可能；</p><p>实际上，每个套接字都有一个唯一的ID，被称为<strong>端口号</strong>；而在传输层接收到来自应用程序的分组并通过添加传输层首部而形成报文段的过程中，该端口号被写入；端口号大小在0-65535之间，其中0-1023属于周知端口号，它们为特定的Socket而拥有。</p><a id="more"></a><h2 id="1-UDP-和-TCP的特点"><a href="#1-UDP-和-TCP的特点" class="headerlink" title="1. UDP 和 TCP的特点"></a>1. UDP 和 TCP的特点</h2><ul><li><strong>用户数据报协议（UDP）</strong>（User Datagram Protocol）<ul><li>无连接的，尽最大努力交付</li><li>没有拥塞控制</li><li>面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）</li><li>支持一对一，一对多，多对一和多对多的交互通信。</li></ul></li><li><strong>传输控制协议 TCP</strong> （Transmission Control Protocol）<ul><li>面向连接的，提供可靠交付</li><li>有流量控制，拥塞避免，提供全双工通信</li><li>面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</li><li>每一条 TCP 连接只能是点对点的（一对一）。</li></ul></li></ul><h2 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h2><h3 id="2-1-UDP首部格式"><a href="#2-1-UDP首部格式" class="headerlink" title="2.1 UDP首部格式"></a>2.1 UDP首部格式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-102741716.png" alt="mark"></p><ul><li>首部字段只有8个字节，包括源端口，目的端口，长度，检验和。12字节的伪首部是为了计算检验和临时添加的</li></ul><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h2><h3 id="3-1-TCP-首部格式"><a href="#3-1-TCP-首部格式" class="headerlink" title="3.1 TCP 首部格式"></a>3.1 TCP 首部格式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-105028905.png" alt="mark"></p><ul><li><p><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong>：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认ACK :</strong> 当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步SYN</strong> : 在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止FIN :</strong> 用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p><strong>窗口</strong> ： 窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h3 id="3-2-TCP-的-三次握手（面试必问）"><a href="#3-2-TCP-的-三次握手（面试必问）" class="headerlink" title="3.2 TCP 的 三次握手（面试必问）"></a>3.2 TCP 的 三次握手（面试必问）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-110028209.png" alt="mark"></p><p>假设A是客户端，B是服务器端。</p><ul><li>首先B处于Listen(监听)状态，等待客户的连接请求。</li><li>A向B发送连接请求报文，SYN = 1 ，ACK = 0，选择一个初始的序号x</li><li>B收到连接请求报文，如果同意建立连接，则向A发送连接确认报文，SYN = 1，ACK = 1,确认号是 x + 1,同时也选择一个初始序号y</li><li>A收到B的连接确认报文后，还要向B发出确认，确认号为 y + 1,序号是 x +  1</li><li>B收到A的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><ul><li>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误的打开连接。</li><li><strong>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发送回的连接确认。</strong>客户端等待一个<strong>超时重传时间</strong>之后，就会重新请求连接。但是这个滞留的连接最后还是到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端就会忽略服务器之后发送的滞留连接请求的连接确认，不进行第三次握手，所以不会再次重复的打开连接。</li></ul><h3 id="3-3-TCP的四次挥手（面试必问）"><a href="#3-3-TCP的四次挥手（面试必问）" class="headerlink" title="3.3 TCP的四次挥手（面试必问）"></a>3.3 TCP的四次挥手（面试必问）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-111815380.png" alt="mark"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论ACK，因为ACK在连接建立之后都是1.</p><ul><li>A发送连接释放报文，FIN = 1</li><li>B 收到之后发出确认，此时TCP处于半关闭状态，B 能向A  发送数据但是 A 不能向 B 发送数据。</li><li>当B 不再不要连接的时候，发出连接释放报文， FIN = 1；</li><li>A 收到后发出确认，进入TIME-WAIT状态，等待2MSL (最大报文存活时间)后释放连接。</li><li>B 收到 A  的 确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><ul><li>客户端发送了FIN 连接释放报文之后，服务器收到了这个报文，就进入了CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。</li></ul><p><strong>TIME_WAIT</strong> </p><p>客户端接收到服务器段的FIN报文后进入此状态，此时并不是直接进入CLOSED状态，还需要等待一个<strong>时间计时器设置的时间2MSL</strong> 。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h3 id="3-4-TCP-的-可靠传输"><a href="#3-4-TCP-的-可靠传输" class="headerlink" title="3.4 TCP 的 可靠传输"></a>3.4 TCP 的 可靠传输</h3><ul><li><strong>TCP使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么 就重传这个报文段。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-133408214.png" alt="mark"></p><ul><li><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><ul><li>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</li></ul></li><li><p>超时时间 RTO 应该略大于 RTTs，<strong>TCP 使用的超时时间计算如下：</strong></p><ul><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-133514339.png" alt="mark"></li><li>其中 RTT<sub>d</sub> 为偏差的加权平均值。</li></ul></li></ul><h3 id="3-5-TCP-滑动窗口"><a href="#3-5-TCP-滑动窗口" class="headerlink" title="3.5 TCP 滑动窗口"></a>3.5 TCP 滑动窗口</h3><ul><li><p>窗口是缓存的一部分，用来暂时存放字节流。<strong>发送方和接收方各有一个窗口</strong>，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</strong></p></li><li><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。</p><ul><li>如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；</li><li>接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-134644530.png" alt="mark"></p><h3 id="3-6-TCP-流量控制"><a href="#3-6-TCP-流量控制" class="headerlink" title="3.6 TCP 流量控制"></a>3.6 TCP 流量控制</h3><ul><li><strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收</strong></li><li>接收方发送的确认报文中的窗口字段可以用来控制发送方的窗口大小，从而影响发送方的发送速率。将窗口字段设置成0，则发送方不能发送数据。</li></ul><h3 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a>3.7 TCP 拥塞控制</h3><ul><li><strong>如果网络出现拥塞</strong>，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。</li><li>因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。</li><li><strong>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-135235298.png" alt="mark"></p><p>TCP 主要通过四种算法来进行拥塞控制：<strong>慢开始，拥塞避免，快重传，快恢复。</strong></p><ul><li>发送方需要维护一个叫做<strong>拥塞窗口（cwnd）的状态变量</strong>，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</li></ul><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><h4 id="3-7-1-慢开始和拥塞避免"><a href="#3-7-1-慢开始和拥塞避免" class="headerlink" title="3.7.1 慢开始和拥塞避免"></a>3.7.1 慢开始和拥塞避免</h4><ul><li><p>发送的最初执行<strong>慢开始，令 cwnd = 1，发送方只能发送 1 个报文段</strong>；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p></li><li><p>注意到慢开始<strong>每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快</strong>，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。<strong>设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</strong></p></li><li><p><strong>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</strong></p></li></ul><h4 id="3-7-2-快重传和快恢复"><a href="#3-7-2-快重传和快恢复" class="headerlink" title="3.7.2 快重传和快恢复"></a>3.7.2 快重传和快恢复</h4><ul><li><p><strong>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。</strong>例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p></li><li><p><strong>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传</strong>，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p></li><li><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。<strong>因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</strong></p></li><li><p><strong>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-140417321.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-03-传输层&quot;&gt;&lt;a href=&quot;#计算机网络-03-传输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-03-传输层&quot;&gt;&lt;/a&gt;计算机网络-03-传输层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;推荐博客：&lt;/strong&gt; &lt;a href=&quot;https://blog.csdn.net/qq_39326472/article/details/88089747&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_39326472/article/details/88089747&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;传输层和网络层的关系&quot;&gt;&lt;a href=&quot;#传输层和网络层的关系&quot; class=&quot;headerlink&quot; title=&quot;传输层和网络层的关系&quot;&gt;&lt;/a&gt;传输层和网络层的关系&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。&lt;/li&gt;
&lt;li&gt;传输层提供了进程中的逻辑通信，传输层向高层用户屏蔽了网络层的核心实现，使得应用进程看起来像是两个传输层实体之间一条端到端的逻辑通信信道。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，&lt;strong&gt;传输层和应用程序进程之间通过Socket（套接字）&lt;/strong&gt;关联，这样通过Socket就可以区别同一主机上的不同应用进程，从而传输层提供服务变为可能；&lt;/p&gt;
&lt;p&gt;实际上，每个套接字都有一个唯一的ID，被称为&lt;strong&gt;端口号&lt;/strong&gt;；而在传输层接收到来自应用程序的分组并通过添加传输层首部而形成报文段的过程中，该端口号被写入；端口号大小在0-65535之间，其中0-1023属于周知端口号，它们为特定的Socket而拥有。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-02-应用层</title>
    <link href="http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-02-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-02-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-07-26T04:02:24.000Z</published>
    <updated>2020-08-12T03:02:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-02-应用层"><a href="#计算机网络-02-应用层" class="headerlink" title="计算机网络-02-应用层"></a>计算机网络-02-应用层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>一图胜千言</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172919828.png" alt="mark"></p><a id="more"></a><h2 id="1-DNS-域名系统"><a href="#1-DNS-域名系统" class="headerlink" title="1. DNS : 域名系统"></a>1. DNS : 域名系统</h2><ul><li>DNS 是一个由分层DNS服务器组成的<strong>分布式数据库</strong>，使得主机可以查询主机名和ip相互转换的规则。</li><li><strong>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174020503.png" alt="mark"></p><ul><li>DNS 可以<strong>使用UDP或者TCP进行传输，使用的端口号都是53</strong>，大多数情况DNS使用UDP进行传输，这就要求域名解析器和域名服务器有自己处理超时和重传从而保证可靠性。</li></ul><h3 id="1-1-实现原理"><a href="#1-1-实现原理" class="headerlink" title="1.1 实现原理"></a>1.1 实现原理</h3><ul><li><p><strong>首先，DNS使用UDP作为传输协议，DNS使用53号端口</strong>。</p></li><li><p>当主机上的DNS客户端收到一个转换请求的时候，<strong>客户端将向网络发送一个DNS查询报文</strong>，然后客户端将收到一个包含相关信息的DNS回答报文，这个报文里有客户端想要的内容</p></li><li><p><strong>之后DNS服务器将IP地址返回给请求的提出者即可</strong></p></li><li><p>DNS查询有两种，一种是<strong>递归查询</strong>一种是<strong>迭代查询</strong>；实践中，查询通常满足这样的模式：<strong>从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的</strong>。</p></li><li><p><strong>DNS缓存</strong>原理十分简单，每当DNS服务器发出请求后收到回答时，就<strong>将回答的内容缓存在它自己的主机空间上</strong>。这样，如果有相同的请求到达时，就不需要再去发出请求，直接使用缓存即可；因为有了缓存，本地DNS就可以直接提供一些经常被访问的主机名所对应的IP地址，而不需要询问根DNS服务器了。</p></li></ul><h2 id="2-文件传送协议：FTP"><a href="#2-文件传送协议：FTP" class="headerlink" title="2. 文件传送协议：FTP"></a>2. 文件传送协议：FTP</h2><ul><li>FTP 使用 TCP 建立链接，他需要两个链接来传送一个文件<ul><li><strong>控制连接</strong>：<strong>服务器打开端口号21等待客户端连接</strong>，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并返回服务器的应答</li><li><strong>数据连接</strong>：<strong>用来传送一个数据文件</strong>。</li></ul></li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><ul><li>主动模式：<strong>服务器端主动</strong>建立数据连接，其中服务器的端口号是20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174711960.png" alt="mark"></p><ul><li>被动模式：客户端主动和<strong>服务器建立数据连接</strong>，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-174747930.png" alt="mark"></p><p>注意：</p><ul><li><strong>主动模式要求客户端开放端口号给服务器，需要配置客户端的防火墙。</strong></li><li>被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</li></ul><h2 id="3-动态主机配置协议（DHCP）"><a href="#3-动态主机配置协议（DHCP）" class="headerlink" title="3. 动态主机配置协议（DHCP）"></a>3. 动态主机配置协议（DHCP）</h2><ul><li>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</li><li>DHCP 配置的内容<strong>不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</strong></li></ul><h3 id="3-1-DHCP工作工程"><a href="#3-1-DHCP工作工程" class="headerlink" title="3.1 DHCP工作工程"></a>3.1 DHCP工作工程</h3><ol><li><p>客户端发送Discover 报文，该报文的目的地址是 255.255.255.255:<strong>67</strong>,源地址是0.0.0.0：<strong>68</strong>.</p></li><li><p>放入UDP中，该报文被广播到同一个子网的所有主机上，如果客户端和DHCP服务器不在同一个子网，就需要使用中继代理。</p></li><li><p>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</p></li><li><p>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</p></li><li><p>DHCP服务器发送Ack 报文，表示该客户端此时可以使用提供给它的信息。</p></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-085949476.png" alt="mark"></p><h2 id="4-远程登录协议"><a href="#4-远程登录协议" class="headerlink" title="4. 远程登录协议"></a>4. 远程登录协议</h2><ul><li>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</li><li>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</li></ul><h2 id="5-电子邮件协议"><a href="#5-电子邮件协议" class="headerlink" title="5. 电子邮件协议"></a>5. 电子邮件协议</h2><ul><li>一个电子邮件由三部分组成：用户代理，邮件服务器和邮件协议。</li><li>邮件协议包含发送协议和读取协议：<ul><li>发送协议：SMTP</li><li>读取协议： POP3 和 IMAP</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-091118003.png" alt="mark"></p><h3 id="5-1-SMTP"><a href="#5-1-SMTP" class="headerlink" title="5.1 SMTP"></a>5.1 SMTP</h3><ul><li>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</li><li>端口号25</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200727-091207208.png" alt="mark"></p><h3 id="5-2-POP3"><a href="#5-2-POP3" class="headerlink" title="5.2 POP3"></a>5.2 POP3</h3><ul><li>端口号110</li><li>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</li></ul><h3 id="5-3-IMAP"><a href="#5-3-IMAP" class="headerlink" title="5.3 IMAP"></a>5.3 IMAP</h3><ul><li>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</li><li>端口号143</li></ul><h2 id="6-常用端口号"><a href="#6-常用端口号" class="headerlink" title="6. 常用端口号"></a>6. 常用端口号</h2><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">端口号</th><th align="center">传输层协议</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">域名解析</td><td align="center">DNS</td><td align="center">53</td><td align="center">UDP/TCP</td><td align="center">长度超过 512 字节时使用 TCP</td></tr><tr><td align="center">动态主机配置协议</td><td align="center">DHCP</td><td align="center">67/68</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">简单网络管理协议</td><td align="center">SNMP</td><td align="center">161/162</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">文件传送协议</td><td align="center">FTP</td><td align="center">20/21</td><td align="center">TCP</td><td align="center">控制连接 21，数据连接 20</td></tr><tr><td align="center">远程终端协议</td><td align="center">TELNET</td><td align="center">23</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传送协议</td><td align="center">HTTP</td><td align="center">80</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">简单邮件传送协议</td><td align="center">SMTP</td><td align="center">25</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">邮件读取协议</td><td align="center">POP3</td><td align="center">110</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">网际报文存取协议</td><td align="center">IMAP</td><td align="center">143</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传送协议+SSL</td><td align="center">HTTPS</td><td align="center">443</td><td align="center">TCP</td><td align="center"></td></tr></tbody></table><h2 id="7-Web-请求页面的过程"><a href="#7-Web-请求页面的过程" class="headerlink" title="7.  Web 请求页面的过程"></a>7.  Web 请求页面的过程</h2><h3 id="7-1-DHCP配置主机信息"><a href="#7-1-DHCP配置主机信息" class="headerlink" title="7.1 DHCP配置主机信息"></a>7.1 DHCP配置主机信息</h3><ul><li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li><li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li><li>该数据报则被放置在MAC 帧中，该帧的目的地址 <code>FF FF FF FF FF FF</code>,广播到与交换机连接的所有设备。</li><li>连接到交换机的<strong>DHCP的服务器</strong>收到广播帧之后，不断向上分解得到IP数据报，UDP报文段，DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址，DNS服务器的IP地址，默认路由网关的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段又被放入IP数据报中，最后放入MAC帧中。</li><li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地s址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li><li><strong>主机</strong>收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li></ul><h3 id="7-2-ARP-解析MAC地址"><a href="#7-2-ARP-解析MAC地址" class="headerlink" title="7.2 ARP 解析MAC地址"></a>7.2 ARP 解析MAC地址</h3><ul><li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li><li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li><li>该DNS查询报文被放入目的地址为DNS服务器的IP地址的IP数据报中。</li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li><li><strong>DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议。</strong></li><li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（<code>FF FF FF FF FF FF</code>）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li><li><strong>网关路由器收到该帧后，不断向上分解得到ARP报文，发现其中IP地址和其接口IP地址匹配，因此就发送一个ARP回答报文，包含了他的MAC地址，发送回主机。</strong></li></ul><h3 id="7-3-DNS解析域名"><a href="#7-3-DNS解析域名" class="headerlink" title="7.3 DNS解析域名"></a>7.3 DNS解析域名</h3><ul><li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p></li><li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p></li><li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p></li><li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p></li><li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p></li></ul><h3 id="7-4-HTTP请求页面"><a href="#7-4-HTTP请求页面" class="headerlink" title="7.4 HTTP请求页面"></a>7.4 HTTP请求页面</h3><ul><li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p></li><li><p>在<strong>生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接</strong>。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p></li><li><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p></li><li><p><strong>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</strong></p></li><li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p></li><li><p><strong>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</strong></p></li></ul><p><strong>参考博客：</strong><a href="https://blog.csdn.net/JAck_chen0309/article/details/105020259![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-110232883.png)" target="_blank" rel="noopener">https://blog.csdn.net/JAck_chen0309/article/details/105020259![mark](http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200812-110232883.png)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-02-应用层&quot;&gt;&lt;a href=&quot;#计算机网络-02-应用层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-02-应用层&quot;&gt;&lt;/a&gt;计算机网络-02-应用层&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一图胜千言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172919828.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-01-概述</title>
    <link href="http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/07/26/NetworkCoding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-07-26T03:02:24.000Z</published>
    <updated>2020-07-26T09:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-01-概述"><a href="#计算机网络-01-概述" class="headerlink" title="计算机网络-01-概述"></a>计算机网络-01-概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-164551248.jpg" alt="mark"></p><ul><li>本教程是秋招面试复习用计算机网络知识点(意味着书上的“废话” 不会在本系列学习笔记中出现)</li><li>配套教材《计算机网络-自顶向下的方法》</li></ul><a id="more"></a><h2 id="1-网络中的网络"><a href="#1-网络中的网络" class="headerlink" title="1. 网络中的网络"></a>1. 网络中的网络</h2><ul><li>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165259125.png" alt="mark"></p><h2 id="2-ISP"><a href="#2-ISP" class="headerlink" title="2. ISP"></a>2. ISP</h2><ul><li>互联网提供商ISP可以从互联网管理机构获取许多IP地址</li><li>同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165342332.png" alt="mark"></p><ul><li>目前互联网是一种多层次的ISP结构，ISP根据覆盖面积的大小分为<ul><li>第一层ISP</li><li>区域ISP</li><li>接入ISP</li></ul></li><li>互联网交换节点IXP 允许两个ISP直接相连而不用经过第三个ISP</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165517216.png" alt="mark"></p><h2 id="3-主机之间的通信方式"><a href="#3-主机之间的通信方式" class="headerlink" title="3. 主机之间的通信方式"></a>3. 主机之间的通信方式</h2><ul><li><strong>客户端-服务器（C/S）</strong>:客户是服务的请求方，服务器是服务的提供方。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165625304.png" alt="mark"></p><ul><li><strong>对等（P2P）</strong>:不区分客户和服务器。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-165638288.png" alt="mark"></p><h2 id="4-电路交换和分组交换"><a href="#4-电路交换和分组交换" class="headerlink" title="4. 电路交换和分组交换"></a>4. 电路交换和分组交换</h2><h3 id="4-1-电路交换"><a href="#4-1-电路交换" class="headerlink" title="4.1 电路交换"></a>4.1 电路交换</h3><ul><li>电路交换用于电话通信系统，两个用户通信之前需要建立一条专用的物理链路，并且整个通信过程中始终占用该链路。</li><li>由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</li></ul><h3 id="4-2-分组交换"><a href="#4-2-分组交换" class="headerlink" title="4.2 分组交换"></a>4.2 分组交换</h3><ul><li>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一条传输线路上同时传输多个分组互相不回影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</li><li>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，<strong>分组交换也使用了存储转发过程。</strong></li></ul><h2 id="5-时延"><a href="#5-时延" class="headerlink" title="5. 时延"></a>5. 时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170041265.png" alt="mark"></p><h3 id="5-1-排队时延"><a href="#5-1-排队时延" class="headerlink" title="5.1 排队时延"></a>5.1 排队时延</h3><ul><li>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li></ul><h3 id="5-2-处理时延"><a href="#5-2-处理时延" class="headerlink" title="5.2 处理时延"></a>5.2 处理时延</h3><ul><li>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</li></ul><h3 id="5-3-传输时延"><a href="#5-3-传输时延" class="headerlink" title="5.3 传输时延"></a>5.3 传输时延</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170144654.png" alt="mark"></p><p>其中 l 表示数据帧的长度，v 表示传输速率。</p><h3 id="5-4-传播时延"><a href="#5-4-传播时延" class="headerlink" title="5.4 传播时延"></a>5.4 传播时延</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170258454.png" alt="mark"></p><p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p><h2 id="6-计算机网络体系结构（重点）"><a href="#6-计算机网络体系结构（重点）" class="headerlink" title="6. 计算机网络体系结构（重点）"></a>6. 计算机网络体系结构（重点）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-170612601.png" alt="mark"></p><h3 id="6-1-五层协议（面试答这个）"><a href="#6-1-五层协议（面试答这个）" class="headerlink" title="6.1 五层协议（面试答这个）"></a>6.1 五层协议（面试答这个）</h3><ul><li><p><strong>应用层：</strong> 为了特定的<strong>应用程序</strong>提供数据传输服务（例如HTTP,DNS协议）。<strong>数据单位是报文</strong></p></li><li><p><strong>传输层：</strong> 为进程提供<strong>通用数据传输服务</strong>。用于应用层协议很多，定义通用传输协议就可以支持不断的增多应用层协议。运输层包括两种协议：</p><ul><li><strong>传输控制协议TCP:</strong>提供面向链接，可靠的数据传输服务，数据单位是报文段。（TCPt提供完整性服务）</li><li><strong>用户数据报协议UDP</strong> ： 提供无连接，尽最大努力的数据传输服务，数据单位是用户数据报。（UDP 主要提供及时性服务。）</li></ul></li><li><p><strong>网络层</strong>：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。<strong>网络层把传输层传递下来的报文段或者用户数据报封装成分组。</strong></p></li><li><p><strong>数据链路层</strong>：<strong>网络层针对的还是主机之间的数据传输服务</strong>。而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。<strong>数据链路层把网络层传下来的分组封装成帧。</strong></p></li><li><p><strong>物理层：</strong>考虑的是怎么样在传输媒体或者介质上传输数据比特流，而不是具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使得数据链路层感觉不到这些差异。</p></li></ul><h3 id="6-2-OSI"><a href="#6-2-OSI" class="headerlink" title="6.2 OSI"></a>6.2 OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><p><strong>表示层</strong>  ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p></li><li><p><strong>会话层</strong>  ：建立及管理会话。</p></li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="6-3-TCP-IP"><a href="#6-3-TCP-IP" class="headerlink" title="6.3 TCP / IP"></a>6.3 TCP / IP</h3><ul><li>它只有四层，相当于五层协议中的数据链路层和物理层合并为接口层</li><li>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-172620266.png" alt="mark"></p><h2 id="7-数据在各层之间的传递过程"><a href="#7-数据在各层之间的传递过程" class="headerlink" title="7. 数据在各层之间的传递过程"></a>7. 数据在各层之间的传递过程</h2><ul><li><strong>在向下的过程中，需要添加下层协议所需要的首部或者尾部</strong></li><li><strong>在向上的过程中，需要不断拆开首部和尾部</strong></li></ul><p><strong>需要注意的是：</strong></p><ul><li><strong>路由器</strong>只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-01-概述&quot;&gt;&lt;a href=&quot;#计算机网络-01-概述&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-01-概述&quot;&gt;&lt;/a&gt;计算机网络-01-概述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-164551248.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本教程是秋招面试复习用计算机网络知识点(意味着书上的“废话” 不会在本系列学习笔记中出现)&lt;/li&gt;
&lt;li&gt;配套教材《计算机网络-自顶向下的方法》&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JUC-16-Future</title>
    <link href="http://zhuuu.work/2020/07/25/JUC/JUC-16-Future/"/>
    <id>http://zhuuu.work/2020/07/25/JUC/JUC-16-Future/</id>
    <published>2020-07-25T14:02:24.000Z</published>
    <updated>2020-07-25T09:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-16-Future"><a href="#JUC-16-Future" class="headerlink" title="JUC-16-Future"></a>JUC-16-Future</h1><h2 id="1-Future-接口"><a href="#1-Future-接口" class="headerlink" title="1. Future 接口"></a>1. Future 接口</h2><ul><li><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。</p></li><li><p>必要时通过get 方法获取执行结果，该方法会阻塞直到任务返回结果。</p></li><li><p><strong>当一个线程需要等待另外一个线程把某个任务执行完成后它才能继续执行，此时可以似乎用FutureTask</strong></p></li><li><p>Future类位于java.util.concurrent包下，它是一个接口：</p></li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> FutureTask </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Executor </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; The result type returned by this Future's &lt;tt&gt;get&lt;/tt&gt; method </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Attempts to cancel execution of this task.  This attempt will </span></span><br><span class="line"><span class="comment">     * fail if the task has already completed, has already been cancelled, </span></span><br><span class="line"><span class="comment">     * or could not be cancelled for some other reason. If successful, </span></span><br><span class="line"><span class="comment">     * and this task has not started when &lt;tt&gt;cancel&lt;/tt&gt; is called, </span></span><br><span class="line"><span class="comment">     * this task should never run.  If the task has already started, </span></span><br><span class="line"><span class="comment">     * then the &lt;tt&gt;mayInterruptIfRunning&lt;/tt&gt; parameter determines </span></span><br><span class="line"><span class="comment">     * whether the thread executing this task should be interrupted in </span></span><br><span class="line"><span class="comment">     * an attempt to stop the task.     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this task was cancelled before it completed </span></span><br><span class="line"><span class="comment">     * normally. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this task completed. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Waits if necessary for the computation to complete, and then </span></span><br><span class="line"><span class="comment">     * retrieves its result. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Waits if necessary for at most the given time for the computation </span></span><br><span class="line"><span class="comment">     * to complete, and then retrieves its result, if available. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p><ul><li><strong>cancel（</strong>）<ul><li>用来取消任务，如果取消成功返回true,取消失败返回false.</li><li>参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li></ul></li><li><strong>isCancelled（）</strong><ul><li>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li></ul></li><li><strong>isDone（）</strong><ul><li>方法表示任务是否已经完成，若任务完成，则返回true；</li></ul></li><li><strong>get()</strong><ul><li>用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回。</li></ul></li><li><strong>get(long timeout, TimeUnit unit)</strong><ul><li>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul></li></ul><p><strong>总结：</strong></p><ul><li>Future 提供以下三种功能<ul><li>判断任务是否完成。</li><li>能够中断任务。</li><li>能够获取任务执行的结果。</li></ul></li><li>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</li></ul><h2 id="2-FutureTask-类"><a href="#2-FutureTask-类" class="headerlink" title="2. FutureTask 类"></a>2. FutureTask 类</h2><p><strong>概述</strong></p><ul><li><strong>FutureTask 类的实现基于 AQS</strong> ， <strong>JUC 中很多可阻塞的类都是基于AQS实现的。</strong></li><li><strong>AQS是一个同步框架，它提供通用机制来控制原子性管理同步状态，阻塞和唤醒线程，以及维护被阻塞线程的队列。</strong><ul><li><strong>JDK6 中被广泛使用</strong></li><li><strong>基于AQS的实现同步器包括 ： （ReetrantLock , Semaphore,CountDownLatch,ReetrantReadWriteLock,FutureTask）</strong></li></ul></li></ul><ul><li>首先是介绍下FutureTask类中的变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示当前task的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//表示当前task尚未执行</span></span><br><span class="line"><span class="comment">//场景：1、任务刚新建还未入队列</span></span><br><span class="line"><span class="comment">//     2、任务刚新建已入队列，还未被线程执行</span></span><br><span class="line"><span class="comment">//     3、任务刚新建已入队列，正在被线程执行run() 注意：当执行任务有结果后才会修改当前任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//表示当前task正在结束，但是还未完全结束的一种临界状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//表示当前task正常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//表示当前task执行过程中发生异常，内部封装的callable.run() 向上抛出了异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//表示当前task被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//表示当前task正在中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//表示当前task已中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//submit(runnable/callable)     runnable 使用装饰者模式装饰为 callable</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">//正常情况下：任务执行结束，outcome保存执行结果。 即callable的返回值</span></span><br><span class="line"><span class="comment">//异常情况下：callable向上抛出异常信息，outcome保存异常信息</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"><span class="comment">//当前任务被执行时，保存执行当前任务的当前线程的对象引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">//因为会有很多线程去get当前任务的结果。所以，这里使用 链表 这种数据结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    <span class="comment">//thread变量 保存线程对象引用</span></span><br><span class="line">    <span class="comment">//next变量 保存当前节点的下一个节点</span></span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器（2个构造器）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">this</span>.callable = callable;  </span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);  </span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Runnable注入会被Executors.callable()函数转换为Callable类型，即FutureTask最终都是执行Callable类型的任务。</p><p>这里使用到了适配器模式：将Runnable 接口 的任务 转换成 Callable接口的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * A callable that runs given task and returns given result </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Runnable task;  </span><br><span class="line">    <span class="keyword">final</span> T result;  </span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.task = task;  </span><br><span class="line">        <span class="keyword">this</span>.result = result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        task.run();  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行一个task的步骤是：<ul><li>submit(runnable/callable) -&gt; 调用 sumbit()提交我们自定义的工作单元 </li><li>newTaskFor(runnable/callable) -&gt;  调用newTaskFor将runnable/callable 封装成FutureTask</li><li>execute(task) -&gt;  执行execute()将传入的task放到线程池中</li><li>threadpool  -&gt; 当线程池中有空闲线程，就会执行任务的run()。否则，就会进入任务队列等待被执行</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit(runnable/callable) -&gt; newTaskFor(runnable/callable) -&gt; execute(task) -&gt; threadpool</span></span><br><span class="line"><span class="comment">//当线程池中没有空闲线程来执行当前任务，则会先进入任务队列中，等待空闲线程调用；如果有就直接执行。</span></span><br><span class="line"><span class="comment">//任务执行入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//条件1：true -&gt; 当前任务的状态不是新建状态。(可能已经被执行或者取消)</span></span><br><span class="line">    <span class="comment">//条件2：true -&gt; cas失败，表示当前有其它线程抢占了这个任务</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前线程开始执行当前任务</span></span><br><span class="line">    <span class="comment">//前置条件：1、当前任务的状态是新建状态 2、当前线程抢占到当前任务的执行权</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//表示外部传入的自定义的业务程序。 是callable或者是用runnable装饰后的callable</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">//条件1：防止空指针异常</span></span><br><span class="line">        <span class="comment">//条件2：防止有外部线程将任务cancel了</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            <span class="comment">//要返回的结果</span></span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">//true -&gt; callable程序执行成功，未抛出异常</span></span><br><span class="line">            <span class="comment">//false -&gt; callable程序执行失败，抛出异常</span></span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">//说明当前任务正常结束</span></span><br><span class="line">                <span class="comment">//设置result给outcome</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//只会在当前任务被cancel时执行</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用cas把任务当前状态设置成完成中</span></span><br><span class="line">    <span class="comment">//执行失败的情况：外部线程在当前线程执行set之前把当前任务cancel(很小概率事件)</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//将callable</span></span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用cas把任务当前状态设置成完成中</span></span><br><span class="line">    <span class="comment">//执行失败的情况：外部线程在当前线程执行set之前把当前任务cancel(很小概率事件)</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">//将结果赋值给outcome后，将当前任务的状态直接修改为NORMAL(正常完成)状态</span></span><br><span class="line">        <span class="comment">//putOrderedInt(Object obj, long offset, int value) obj:包含要修改field的对象 offset:obj中整型field的偏移量 value:field将被设置的新值</span></span><br><span class="line">        <span class="comment">//设置obj对象中offset偏移地址对应的整型field的值为指定值。</span></span><br><span class="line">        <span class="comment">//这是一个有序或者有延迟的putIntVolatile方法，并且不保证值的改变被其他线程立即看到。</span></span><br><span class="line">        <span class="comment">//只有在field被 volatile 修饰并且期望被意外修改的时候使用才有用。</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">    <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            <span class="comment">//释放cpu资源</span></span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get () 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景：多个线程等待当前任务执行完成后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前任务状态</span></span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">//true -&gt; 任务状态可能为 未执行、正在执行、完成中</span></span><br><span class="line">    <span class="comment">//当任务状态为以上情况时，调用get()的外部线程会被阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">//返回线程当前状态</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//System.nanoTime() 返回的是纳秒，nanoTime返回的可能是任意时间，甚至可能是负数</span></span><br><span class="line">    <span class="comment">//timed true -&gt; 表示带超时时间，deadline = System.nanoTime()</span></span><br><span class="line">    <span class="comment">//      false -&gt; 表示不带超时时间，deadline = 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//引用当前线程封装成WaitNode对象</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//表示是否入队</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//ture -&gt; 说明当前线程是被其它线程中断而唤醒的</span></span><br><span class="line">        <span class="comment">//interrupted() 返回true后 会将Thread的中断标记重置为false</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//当前线程node出队</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="comment">//向get()抛出中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前线程被其它线程正常唤醒(使用了unpark(thread))的场景，继续执行自旋逻辑</span></span><br><span class="line">        <span class="comment">//获取当前任务最新状态</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//true -&gt; 表示当前任务已经有结果了</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="comment">//true -&gt; 说明已经为当前线程创建node节点，需要执行 node.thread = null (helpGC)</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//返回任务状态</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//true -&gt; 表示当前任务正在完成中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            <span class="comment">//将当前cpu的资源释放，进行下次抢占cpu资源</span></span><br><span class="line">            <span class="comment">//注意：yield()会释放CPU资源，但是是与其它线程一起重新抢占资源。当前线程可能还会获取到执行权，也有可能被其他线程获取到</span></span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//场景：第一次自旋</span></span><br><span class="line">        <span class="comment">//true -&gt; 当前线程还未创建WaitNode对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//为当前线程创建WaitNode对象，并把当前线程赋值到thread全局变量中</span></span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="comment">//场景：第二次自旋</span></span><br><span class="line">        <span class="comment">//true -&gt; 当前线程已经创建WaitNode对象，但是还未入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)&#123;</span><br><span class="line">            <span class="comment">//把当前线程node节点的next指针 指向到原队列的头结点</span></span><br><span class="line">            <span class="comment">//waiters 表示队列头指针</span></span><br><span class="line">            q.next = waiters;</span><br><span class="line">            <span class="comment">//用cas方式设置waiters指针指向当前线程的node节点(头插法)</span></span><br><span class="line">            <span class="comment">//true -&gt; 入队成功</span></span><br><span class="line">            <span class="comment">//false -&gt; 有其它线程抢先入队，进入下次自旋</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, waiters, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//场景：第三次自旋</span></span><br><span class="line">        <span class="comment">//判断是否有带入超时时间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;<span class="comment">//有超时时间的场景</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">//true -&gt; 表示等待超时了</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">//当前线程node出队</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="comment">//无论完成与否，直接返回当前状态</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程进入有时间限制的休眠状态，有其它线程将其 唤醒 或者 中断 或者 时间到了 就会重新激活</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//无超时时间的场景</span></span><br><span class="line">            <span class="comment">//park() 会将当前线程状态变为waitting(休眠)</span></span><br><span class="line">            <span class="comment">//当前线程进入休眠状态， 有其它线程将其 唤醒 或者 中断 就会重新激活</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//正常情况下：outcome保存的是callable运行出来的结果</span></span><br><span class="line">    <span class="comment">//非正常情况下：outcome保存的是callable运行时抛出的异常信息</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="comment">//true -&gt; 表示当前任务正常完成</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="comment">//直接返回callable运行结果</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="comment">//true -&gt; 表示当前任务被取消</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="comment">//抛出取消中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">//抛出自定义的callable程序执行时产生的异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 ： </p><ol><li>get任务执行结果的线程并不只有一个，而是有很多个在同一链表中的线程竞争获取。</li><li>当任务还未执行完毕，线程就会进行休眠，等待其它线程唤醒(可能是正常唤醒，也可能是任务中断)</li></ol><ul><li><strong>cancel()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mayInterruptIfRunning 设成false话，不允许在线程运行时中断，设成true的话就允许。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//state == NEW：true -&gt; 表示当前任务处于运行中 或者 处于线程池队列中</span></span><br><span class="line">        <span class="comment">//UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)</span></span><br><span class="line">        <span class="comment">//  true -&gt; 表示cas成功，将当前任务状态修改为 中断中 或者 取消</span></span><br><span class="line">        <span class="comment">//注意，这里的if取反，上述条件都为true才会执行下面的逻辑。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取执行当前task的线程</span></span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="comment">//可能会为null，因为可能当前task还在任务队列中排队</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//如果不为null，则给runner线程一个中断信号</span></span><br><span class="line">                        <span class="comment">//只是会给任务一个中断标志，能否中断要看task中是否有响应中断的程序</span></span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    <span class="comment">//执行完中断后将任务的状态改为已中断</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//唤醒waiters中的所有线程</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>最后要讲下finishCompletion()这个方法，看了上面的源码可以发现，有3个地方都执行了这个方法，分别是cancel()、set()、setException()。<br>其作用就是当任务执行有结果了(无论好坏)都会唤醒waiters链表中的 所有 线程继续执行自旋逻辑。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒所有waiters中的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">//将waiters头结点赋值给q</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">//用cas将头结点置为null，防止该任务被其它线程取消 且 help gc</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">                <span class="comment">//获取当前节点的thread对象</span></span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="comment">//true -&gt; thread对象存在防止空指针</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//清空当前节点引用的thread对象 help gc</span></span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//唤醒该线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前节点的下一个节点</span></span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="comment">//true -&gt; 已经处于队列末尾</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//退出自旋</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//清空当前节点的next指针指向的对象引用 help gc</span></span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                <span class="comment">//当前节点指针指向下一个节点</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所有waiters队列中的线程唤醒完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义扩展的操作</span></span><br><span class="line">    done();</span><br><span class="line">    <span class="comment">//释放资源 help gc</span></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-16-Future&quot;&gt;&lt;a href=&quot;#JUC-16-Future&quot; class=&quot;headerlink&quot; title=&quot;JUC-16-Future&quot;&gt;&lt;/a&gt;JUC-16-Future&lt;/h1&gt;&lt;h2 id=&quot;1-Future-接口&quot;&gt;&lt;a href=&quot;#1-Future-接口&quot; class=&quot;headerlink&quot; title=&quot;1. Future 接口&quot;&gt;&lt;/a&gt;1. Future 接口&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;必要时通过get 方法获取执行结果，该方法会阻塞直到任务返回结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;当一个线程需要等待另外一个线程把某个任务执行完成后它才能继续执行，此时可以似乎用FutureTask&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Future类位于java.util.concurrent包下，它是一个接口：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="异步计算" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring-11-设计模式</title>
    <link href="http://zhuuu.work/2020/07/25/Spring/Spring-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/07/25/Spring/Spring-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-25T07:11:24.000Z</published>
    <updated>2020-09-20T12:03:36.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-11-设计模式"><a href="#Spring-11-设计模式" class="headerlink" title="Spring-11-设计模式"></a>Spring-11-设计模式</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。</p></li><li><p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p></li></ul><a id="more"></a><h2 id="1-IOC"><a href="#1-IOC" class="headerlink" title="1. IOC"></a>1. IOC</h2><ul><li><strong>IoC(Inversion of Control,控制翻转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想</li><li>它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。</li><li><strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-112218699.png" alt="mark"></p><ul><li><p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> </p></li><li><p>IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p></li><li><p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：<a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener">https://www.zhihu.com/question/23277575/answer/169698662</a> ，非常不错。</p></li></ul><h3 id="1-1-控制反转的理解"><a href="#1-1-控制反转的理解" class="headerlink" title="1.1 控制反转的理解"></a>1.1 控制反转的理解</h3><ul><li>举个例子：“对象a 依赖了对象 b，<strong>当对象 a 需要使用 对象 b的时候必须自己去创建。</strong></li><li>但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以<strong>指定 IOC 容器去创建一个对象b注入到对象 a 中</strong>”。</li><li>对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。</li></ul><p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><ul><li>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</li></ul><p><strong>两者对比：</strong></p><ul><li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code> 来说会占用更少的内存，程序启动速度更快。</li><li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li></ul><p><strong>ApplicationContext的三个实现类：</strong></p><ol><li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li><li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li><li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line"><span class="string">"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml"</span>);</span><br><span class="line"> </span><br><span class="line">HelloApplicationContext obj = (HelloApplicationContext) context.getBean(<span class="string">"helloApplicationContext"</span>);</span><br><span class="line">obj.getMsg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3. 单例模式"></a>3. 单例模式</h2><ul><li>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。</li><li>事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</li></ul><p><strong>使用单例模式的好处:</strong></p><ul><li><strong>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言</strong>，是非常可观的一笔系统开销；</li><li><strong>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力</strong>，缩短 GC 停顿时间。</li></ul><p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p><ul><li><code>prototype</code> : 每次请求都会创建一个新的 bean 实例。</li><li><code>request</code> : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前<code>HTTP request</code>内有效。</li><li><code>session</code> : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 <code>HTTP session</code> 内有效。</li><li><code>global-session</code>： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><h3 id="3-1-Spring实现单例模式的方法"><a href="#3-1-Spring实现单例模式的方法" class="headerlink" title="3.1 Spring实现单例模式的方法"></a>3.1 Spring实现单例模式的方法</h3><ul><li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li><li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li></ul><p><strong>底层实现</strong></p><ul><li><strong>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-代理模式"><a href="#4-代理模式" class="headerlink" title="4. 代理模式"></a>4. 代理模式</h2><ul><li>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong></li><li>便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</li></ul><p><strong>Spring AOP 就是基于动态代理的</strong>，</p><ul><li>如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，</li><li>而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> <strong>生成一个被代理对象的子类来作为代理</strong>，如下图所示</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-115307397.png" alt="mark"></p><ul><li>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</li><li>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。<strong>日志功能</strong>、<strong>事务管理</strong>等等场景都用到了 AOP 。</li></ul><h3 id="4-1-Spring-AOP-和-AspectJ-AOP有什么区别？"><a href="#4-1-Spring-AOP-和-AspectJ-AOP有什么区别？" class="headerlink" title="4.1 Spring AOP 和 AspectJ AOP有什么区别？"></a>4.1 Spring AOP 和 AspectJ AOP有什么区别？</h3><ul><li><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</li><li>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</li><li>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</li></ul><h2 id="5-模板方式模式"><a href="#5-模板方式模式" class="headerlink" title="5. 模板方式模式"></a>5. 模板方式模式</h2><ul><li>模板方法模式是一种行为设计模式，它<strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。</strong> </li><li>模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-115654822.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是我们的模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PrimitiveOperation1();  </span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">        PrimitiveOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span>  <span class="title">PrimitiveOperation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//被子类实现的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateImpl</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>一般情况下，我们都是使用<strong>继承的方式来实现模板模式</strong>，但是 Spring 并没有使用这种方式，而是使用<code>Callback</code> 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</li></ul><h2 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6. 观察者模式"></a>6. 观察者模式</h2><ul><li>观察者模式是一种对象行为型模式。它<strong>表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。</strong></li><li><strong>Spring 事件驱动模型就是观察者模式很经典的一个应用。</strong></li><li>Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</li></ul><h4 id="6-1-Spring-事件驱动模型中的三种角色"><a href="#6-1-Spring-事件驱动模型中的三种角色" class="headerlink" title="6.1 Spring 事件驱动模型中的三种角色"></a>6.1 Spring 事件驱动模型中的三种角色</h4><ol><li><strong>事件角色</strong></li></ol><p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p><p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p><ul><li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li><li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li><li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li><li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-120618675.png" alt="mark"></p><ol start="2"><li><strong>监听器角色</strong></li></ol><ul><li><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。</li><li>所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口实现 <code>onApplicationEvent()</code> 方法即可完成监听事件</li></ul><ol start="3"><li><strong>事件发布者角色</strong></li></ol><ul><li><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，</li><li>阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</li></ul><h4 id="6-2-Spring-事件总结"><a href="#6-2-Spring-事件总结" class="headerlink" title="6.2 Spring 事件总结"></a>6.2 Spring 事件总结</h4><ul><li><strong>定义一个事件:</strong> 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li><li><strong>定义一个事件监听者</strong>：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li><li><strong>使用事件发布者发布消息</strong>: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source,String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用onApplicationEvent接收消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;</span><br><span class="line">        String msg = event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">"接收到的信息是："</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</li></ul><h2 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7. 适配器模式"></a>7. 适配器模式</h2><h3 id="7-1-Spring中适配器模式"><a href="#7-1-Spring中适配器模式" class="headerlink" title="7.1 Spring中适配器模式"></a>7.1 Spring中适配器模式</h3><ul><li>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</li></ul><ul><li>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code> 。</li><li>Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。</li><li>每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。</li><li>Spring预定义的<strong>通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象</strong>（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</li></ul><h3 id="7-2-SpringMVC-适配器"><a href="#7-2-SpringMVC-适配器" class="headerlink" title="7.2 SpringMVC 适配器"></a>7.2 SpringMVC 适配器</h3><ul><li>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</li><li><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</li></ul><h2 id="8-装饰者模式"><a href="#8-装饰者模式" class="headerlink" title="8. 装饰者模式"></a>8. 装饰者模式</h2><ul><li>装饰者模式可以<strong>动态地给对象添加一些额外的属性或行为</strong>。</li><li>相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，<strong>设计一个Decorator套在原有代码外面。</strong></li><li>其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200911-121636150.png" alt="mark"></p><p>比如：</p><ul><li><strong>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。</strong>我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？</li><li><strong>这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。</strong>这些类基本上都是动态地给一个对象添加一些额外的职责</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>Spring 框架中用到了哪些设计模式？</p><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li><li>…</li></ul><p>参考博客 ： <a href="https://blog.csdn.net/qq_34337272/article/details/90487768" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/90487768</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-11-设计模式&quot;&gt;&lt;a href=&quot;#Spring-11-设计模式&quot; class=&quot;headerlink&quot; title=&quot;Spring-11-设计模式&quot;&gt;&lt;/a&gt;Spring-11-设计模式&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-14-ThreadLocal</title>
    <link href="http://zhuuu.work/2020/07/22/jdk_SourceCode/JDK1.8-14-ThreadLocal/"/>
    <id>http://zhuuu.work/2020/07/22/jdk_SourceCode/JDK1.8-14-ThreadLocal/</id>
    <published>2020-07-22T05:33:53.000Z</published>
    <updated>2020-08-13T02:41:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8-14-ThreadLocal"><a href="#JDK1-8-14-ThreadLocal" class="headerlink" title="JDK1.8-14-ThreadLocal"></a>JDK1.8-14-ThreadLocal</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>参考博客： <a href="https://www.cnblogs.com/fsmly/p/11020641.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsmly/p/11020641.html</a></p><p><strong>总结几个字：线程自己的本地变量</strong></p><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>多线程访问同一个共享变量时候容易出现并发问题，特别是多个线程对同一个变量进行写入的时候，为了确保线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程的安全性。</li><li><strong>ThreadLocal 是除了加锁这种同步方式以外的一种保证一种规避多线程访问出现线程不安全的方法，当我们创建一个共享变量后，如果每个线程对其进行访问的时候访问都是线程自己的变量就不会存在线程不安全的问题。</strong></li><li>ThreadLocal 是 JDK包提供的，它提供<strong>线程的本地变量</strong>，如果创建一个ThreadLocal变量，那么访问这个变量的每一个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而避免了线程安全性问题。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/132845616.png" alt="mark"></p><!--more--><h2 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2.简单使用"></a>2.简单使用</h2><ul><li>在下面的例子中，在每个线程的内部都设置了本地变量的值，然后调用print 方法打印当前本地变量的值。</li><li>如果在打印之后调用本地变量的remove方法后会删除把本地内存中的变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">" :"</span> + localVar.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        localVar.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">                localVar.set(<span class="string">"localVar1"</span>);</span><br><span class="line">                <span class="comment">//调用打印方法</span></span><br><span class="line">                print(<span class="string">"thread1"</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">"after remove : "</span> + localVar.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">                localVar.set(<span class="string">"localVar2"</span>);</span><br><span class="line">                <span class="comment">//调用打印方法</span></span><br><span class="line">                print(<span class="string">"thread2"</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">"after remove : "</span> + localVar.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行后的结果：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/133208433.png" alt="mark"></p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><ul><li>下面是ThreadLocal的类图结构，从图中可知，<code>java.lang.Thread</code>中有两个变量<code>threadLocals</code> 和 <code>inheritableThreadLocals</code> 。两者都是<code>ThreadLocal</code>内部类 <code>ThreadLocalMap</code> 类型的变量。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/090201253.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/090208752.png" alt="mark"></p><ul><li>在默认情况下，每个线程中这两个变量都是<code>null</code>,之后我们通过原码后可以看到 <code>ThreadLocalMap</code> 实际上类似于一个 <code>HashMap</code>. 这两个变量只有当线程第一次调用ThreadLocal的 set和 get方法的时候才会创建它们。</li><li>需要注意的是：<strong>每个线程的本地变量</strong>不是存放在 new 出来的<code>TheadLocal</code> 实例中，而是存放在调用线程的<code>ThreadLocals</code> 变量中。（前面说过，这个变量在 <code>java.lang.Thread</code>类中）</li><li>也就是说，<code>ThreadLocal</code> 类型的本地变量实际是存放在具体的线程空间上，其本身相当于装在本地变量的工具壳，通过 set 方法将value 添加到 <code>threadlocals</code> 变量中，当调用线程的时候能够将它从 <code>threadLocals</code>变量中取出。</li><li>如果调用的线程一直不终止，那么这个本地变量将会一直存放在他的<code>threadLocals</code> 中，所以不使用本地变量的时候需要从它的<code>threadLocals</code> 取出变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment"> * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200722/134134649.png" alt="mark"></p><h3 id="3-1-set-方法"><a href="#3-1-set-方法" class="headerlink" title="3.1  set 方法"></a>3.1  set 方法</h3><ul><li>源码分析<strong>(重点是类似与Hashmap 的 ThreadlocalMap)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1) 获取当前线程（调用者线程）</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2) 以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//(3) 如果map不为null，就直接添加本地变量，key为当前线程的引用，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//(4) 如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，(2)处调用getMap方法<strong>获得当前线程对应的threadLocals变量</strong>(参照上面的图示和文字说明)，该方法代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals; <span class="comment">//获取线程自己的变量threadLocals，并绑定到当前调用线程的成员变量threadLocals上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果调用getMap 的返回值不为null,就直接将 value 设置到 threadLocals变量中<strong>（此时 key 是当前线程的引用，值是本地变量）</strong></li><li>如果调用 getMap 方法返回null 说明是第一次调用 set 方法(前面说到过,threadLocals默认值是 Null , 只有调用 set 方法的时候才会创建map),这个时候就需要调用 createMap方法来创建<code>ThreadLocalMap</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createMap 方法不仅创建了 <code>threadLocals</code>变量 ,通过是也将本地变量的值放到了 <code>threadLocals</code> 中.</li></ul><h3 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2 get 方法"></a>3.2 get 方法</h3><ul><li><p>在get 方法的实现中，首先获取当前调用者线程</p><ul><li>如果当前线程的<code>threadLocals</code> 不为 <code>null</code> ,就直接返回当前线程绑定的本地变量值，</li><li>否则执行 <code>setInitialValue</code>的方法初始化 <code>threadLocals</code> 变量。</li></ul></li><li><p>在 <code>setInitialValue</code> 方法中，类似于 <code>set</code> 方法的实现，都是判断当前线程的<code>threadLocals</code> 变量是否为null,是则添加本地变量（这个时候由于是初始化，所以添加的值是null）,否则创建的是<code>threadLocals变量</code>，同样添加的是null</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2)获取当前线程的threadLocals变量</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//(3)如果threadLocals变量不为null，就可以在map中查找到本地变量的值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(4)执行到此处，threadLocals为null，调用该更改初始化当前线程的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//protected T initialValue() &#123;return null;&#125;</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-remove-方法"><a href="#3-3-remove-方法" class="headerlink" title="3.3 remove 方法"></a>3.3 remove 方法</h3><ul><li>remove 方法判断该当前线程对应的threadLocals变量是否是null,不是 null 的话就直接删除当前线程中的threadLocals变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程绑定的threadLocals</span></span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="comment">//如果map不为null，就移除当前线程中指定ThreadLocal实例的本地变量</span></span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意  ： 这里可能有内存泄露问题</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/095307158.png" alt="mark"></p><ul><li>如上图所示，每个线程内部都有一个名为<code>threadLocals</code> 的成员变量，该变量的类型是<code>ThreadLocal.ThreadLocalMap</code>的类型（类似于一个HashMap） ,其中<strong>key是当前定义的<code>ThreadLocal</code> 变量 this的引用， value 是 使用 set 方法设置的值。</strong></li><li>每个线程的本地变量存放在自己的本地变量 <code>threadLocals</code>中，如果<strong>当前线程一直不消亡，那么这些本地变量会一直存在（所以会内存溢出），因此使用完毕需要remove 掉。</strong></li></ul><h2 id="4-ThreadLocal-不支持继承性"><a href="#4-ThreadLocal-不支持继承性" class="headerlink" title="4. ThreadLocal 不支持继承性"></a>4. ThreadLocal 不支持继承性</h2><ul><li>同一个<code>Threadlocal</code> 变量在父线程中被设置后，在子线程中是获取不到的</li><li>threadLocals 中为当前调用线程对应的本地变量，所以二者自然是不能共享的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)创建ThreadLocal变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在main线程中添加main线程的本地变量</span></span><br><span class="line">        threadLocal.set(<span class="string">"mainVal"</span>);</span><br><span class="line">        <span class="comment">//新创建一个子线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程中的本地变量值:"</span>+threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//输出main线程中的本地变量值</span></span><br><span class="line">        System.out.println(<span class="string">"mainx线程中的本地变量值:"</span>+threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-InheritableThreadLocal类"><a href="#5-InheritableThreadLocal类" class="headerlink" title="5. InheritableThreadLocal类"></a>5. InheritableThreadLocal类</h2><ul><li>在上面说到的ThreadLocal类是不能提供子线程访问父线程的本地变量的，而InheritableThreadLocal类则可以做到这个功能，下面是该类的源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从上面代码可以看出，InheritableThreadLocal类继承了ThreadLocal类，并重写了childValue、getMap、createMap三个方法。</li><li>其中createMap方法在被调用（当前线程调用set方法时得到的map为null的时候需要调用该方法）的时候，创建的是inheritableThreadLocal而不是threadLocals。同理，getMap方法在当前调用者线程调用get方法的时候返回的也不是threadLocals而是inheritableThreadLocal。</li></ul><p>下面我们看看重写的childValue方法在什么时候执行，怎样让子线程访问父线程的本地变量值。我们首先从Thread类开始说起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断名字的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">//(1)获取当前线程(父线程)</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="comment">//安全校验</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123; <span class="comment">//g:当前线程组</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g; <span class="comment">//设置为当前线程组</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();<span class="comment">//守护线程与否(同父线程)</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();<span class="comment">//优先级同父线程</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">//(2)如果父线程的inheritableThreadLocal不为null</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//（3）设置子线程中的inheritableThreadLocals为父线程的inheritableThreadLocals</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在init方法中，首先(1)处获取了当前线程(父线程)，然后（2）处判断当前父线程的inheritableThreadLocals是否为null，</li><li>然后调用createInheritedMap将父线程的inheritableThreadLocals作为构造函数参数创建了一个新的ThreadLocalMap变量，然后赋值给子线程。</li><li>下面是createInheritedMap方法和ThreadLocalMap的构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用重写的方法</span></span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在构造函数中将父线程的inheritableThreadLocals成员变量的值赋值到新的ThreadLocalMap对象中。</li><li>返回之后赋值给子线程的inheritableThreadLocals。</li><li>总之，InheritableThreadLocals类通过重写getMap和createMap两个方法将本地变量保存到了具体线程的inheritableThreadLocals变量中，当线程通过InheritableThreadLocals实例的set或者get方法设置变量的时候，就会创建当前线程的inheritableThreadLocals变量。</li><li>而父线程创建子线程的时候，ThreadLocalMap中的构造函数会将父线程的inheritableThreadLocals中的变量复制一份到子线程的inheritableThreadLocals变量中</li></ul><h2 id="6-从ThreadLocalMap-看-ThreadLocal-的内存泄露问题"><a href="#6-从ThreadLocalMap-看-ThreadLocal-的内存泄露问题" class="headerlink" title="6. 从ThreadLocalMap 看 ThreadLocal 的内存泄露问题"></a>6. 从ThreadLocalMap 看 ThreadLocal 的内存泄露问题</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><ul><li>首先我们看看<code>ThreadLocalMap</code>的类图，在前面的介绍中，我们知道ThreadLocal 是一个工具类，它为用户提供了 <code>set,get,remove</code> 接口操作实际存放本地变量的<code>threadLocals</code> （调用线程的成员变量）， 也知道<code>threadLocals</code>  是一个 <code>ThreadLocalMap</code> 类型的变量</li><li>下面我们来看看<code>ThreadLocalMap</code> 这个内部类，在此之前，我们先回忆以下<code>Java</code>中的四种引用类型，以及相关GC的工作机制</li></ul><p>①<strong>强引用</strong>：Java中默认的引用类型，一个对象如果具有强引用那么只要这种引用还存在就不会被GC。</p><p>②<strong>软引用</strong>：简言之，如果一个对象具有软引用，在JVM发生OOM之前（即内存充足够使用），是不会GC这个对象的；只有到JVM内存不足的时候才会GC掉这个对象。软引用和一个引用队列联合使用，如果软引用所引用的对象被回收之后，该引用就会加入到与之关联的引用队列中</p><p>③<strong>弱引用</strong>（这里讨论ThreadLocalMap中的Entry类的重点） ：如果一个对象只有弱引用，那么这个对象就会被垃圾回收器GC(弱引用的引用的对象只能到下一次之前，无论当前内存是否足够，弱引用所引用的对象都会被GC回收掉)。 弱引用也是和一个引用队列联合使用，如果弱引用的对象被垃圾回收掉，JVM会将这个引用加入到与之关联的弱引用队列中。若引用的对象可以通过弱引用的get方法得到，当引用对象被回收掉之后，在调用get方法就会返回null.</p><p>④<strong>虚引用</strong> : 虚引用是所有引用中最弱的一种引用，目的就是将关联虚引用对象在GC回收掉之后得到一个通知（不能通过get方法获得指引对象。）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/131415452.png" alt="mark"></p><h3 id="6-2-ThreadLocalMap的内部实现"><a href="#6-2-ThreadLocalMap的内部实现" class="headerlink" title="6.2 ThreadLocalMap的内部实现"></a>6.2 ThreadLocalMap的内部实现</h3><ul><li><code>ThreadLocalMap</code> 其实就是一个Entry 数组</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200723/132245248.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是继承自WeakReference的一个类，该类中实际存放的key是</span></span><br><span class="line"><span class="comment"> * 指向ThreadLocal的弱引用和与之对应的value值(该value值</span></span><br><span class="line"><span class="comment"> * 就是通过ThreadLocal的set方法传递过来的值)</span></span><br><span class="line"><span class="comment"> * 由于是弱引用，当get方法返回null的时候意味着坑能引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** value就是和ThreadLocal绑定的 */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：ThreadLocal的引用，被传递给WeakReference的构造方法</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//WeakReference构造方法(public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent); <span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reference构造方法</span></span><br><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);<span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从上面给的代码中可以看出，当前<code>threadLocal</code> 的引用k被传递给了<code>WeakReference</code>,所以ThreadLocalMap中的key为ThreadLocal的弱引用。</p></li><li><p>当一个线程调用<code>ThreadLocal</code> 的 set 方法设置变量的时候，当前线程<code>ThreadLocalMap</code> 中会存放一个记录，这个记录的key值就是<code>ThreadLocalMap</code> 的弱引用，<code>value</code>就是 set进去的值，这个值可以是任意的对象。</p></li><li><p>如果当前线程一直存在且没有调用<code>ThreadLocal</code>的remove方法，如果这个时候别的地方还有<code>ThreadLocal</code>的引用，那么当前线程的<code>ThreadLocalMap</code> 中会存在对<code>ThreadLocal</code>变量的引用和<code>value</code> 对象的引用，这个弱引用是不会被释放的，就会造成内存泄漏。</p></li><li><p>考虑这个<code>ThreadLocal</code>变量没有其他强依赖，如果当前线程还存在，由于<code>ThreadLocalMap</code> 中的key是弱引用，所以当前线程<code>ThreadLocalMap</code>里面的<code>ThreadLocal</code>变量的弱引用在gc时候就被回收，但是对应的value 还是存在这就可能导致内存泄漏(因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)。</p></li></ul><p><strong>总结：</strong></p><ul><li><code>ThreadLocalMap</code> 中的<strong>Entry数组</strong> 的 key 使用的是 <code>ThreadLocal</code>对象的弱引用，在没有其他地方对ThreadLoca依赖，ThreadLocalMap中的ThreadLocal对象就会被回收掉</li><li>但是对应的不会被回收，这个时候Map中就可能存在key为null但是value不为null的项</li><li>这需要实际的时候使用完毕及时调用remove方法避免内存泄漏。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8-14-ThreadLocal&quot;&gt;&lt;a href=&quot;#JDK1-8-14-ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8-14-ThreadLocal&quot;&gt;&lt;/a&gt;JDK1.8-14-ThreadLocal&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;参考博客： &lt;a href=&quot;https://www.cnblogs.com/fsmly/p/11020641.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/fsmly/p/11020641.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结几个字：线程自己的本地变量&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="面试必备" scheme="http://zhuuu.work/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>各种反转-合集</title>
    <link href="http://zhuuu.work/2020/07/20/LeetcodeExplore/%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/07/20/LeetcodeExplore/%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC-%E5%90%88%E9%9B%86/</id>
    <published>2020-07-20T07:52:53.000Z</published>
    <updated>2020-08-17T08:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种反转-合集"><a href="#各种反转-合集" class="headerlink" title="各种反转-合集"></a>各种反转-合集</h1><p>（本系列是针对Leetcode上常见的反转进行总结。）</p><a id="more"></a><h2 id="1-Leetcode-007-整数反转"><a href="#1-Leetcode-007-整数反转" class="headerlink" title="1. Leetcode 007 整数反转"></a>1. Leetcode 007 整数反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 反转后的结果</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 拿到每一个个位</span></span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 溢出处理</span></span><br><span class="line">        <span class="comment">// ans * 10 + pop &gt; Integer.MAXVAlUE</span></span><br><span class="line">        <span class="comment">// ans * 10 + pop &lt; Integer.MINVALUE</span></span><br><span class="line">        <span class="keyword">if</span> ((ans &gt; Integer.MAX_VALUE/<span class="number">10</span>) </span><br><span class="line">                || (ans == Integer.MAX_VALUE/<span class="number">10</span>) &amp;&amp; pop &gt; <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((ans &lt; Integer.MIN_VALUE/<span class="number">10</span>)</span><br><span class="line">                || (ans == Integer.MIN_VALUE/<span class="number">10</span>) &amp;&amp; pop &lt; -<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Leetcode-415-字符串相加"><a href="#2-Leetcode-415-字符串相加" class="headerlink" title="2. Leetcode   415. 字符串相加"></a>2. Leetcode   <a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 和num2 的长度都小于 5100</span><br><span class="line">num1 和num2 都只包含数字 0-9</span><br><span class="line">num1 和num2 都不包含任何前导零</span><br></pre></td></tr></table></figure><p><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 对溢出进行处理，超过就补一个0</span></span><br><span class="line">            <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 计算总和</span></span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            <span class="comment">// 计算进位</span></span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 拿个位结果</span></span><br><span class="line">            sb.append(tmp % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 继续向前遍历</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完如果有进位再加一个1</span></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)&#123;</span><br><span class="line">            sb.append(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将StringBuilder转为字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;各种反转-合集&quot;&gt;&lt;a href=&quot;#各种反转-合集&quot; class=&quot;headerlink&quot; title=&quot;各种反转-合集&quot;&gt;&lt;/a&gt;各种反转-合集&lt;/h1&gt;&lt;p&gt;（本系列是针对Leetcode上常见的反转进行总结。）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="反转" scheme="http://zhuuu.work/tags/%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>队列和栈-合集</title>
    <link href="http://zhuuu.work/2020/07/20/LeetcodeExplore/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/07/20/LeetcodeExplore/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88-%E5%90%88%E9%9B%86/</id>
    <published>2020-07-20T07:52:53.000Z</published>
    <updated>2020-08-09T13:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列和栈-合集"><a href="#队列和栈-合集" class="headerlink" title="队列和栈-合集"></a>队列和栈-合集</h1><p>（本系列是针对Leetcode上常见的队列和栈进行总结。）</p><a id="more"></a><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><ul><li><p>在数组中，我们可以通过<strong>索引</strong>随机访问元素。但是，在某些情况下，我们可以想要限制处理的顺序。</p></li><li><p>这两种不同的顺序就是 ， <code>先入先出</code> <code>先入后出</code> 。以及两个相应的线性数据结构，<strong>队列和栈</strong></p></li><li><p>在做到算法题的时候，<strong>队列一般用于BFS，而系统栈用于DFS</strong></p></li></ul><h2 id="1-1-队列（先入先出）"><a href="#1-1-队列（先入先出）" class="headerlink" title="1.1 队列（先入先出）"></a>1.1 队列（先入先出）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/134217670.png" alt="mark"></p><!--more--><ul><li>在FIFO 数据结构中，将首先处理添加到队列的第一个元素。</li><li>如上图所示，队列是典型的FIFO的数据结构。<strong>插入</strong>(insert) 操作也称为入队（enqueue），<strong>新元素始终被添加到队列的末尾</strong>。<strong>删除</strong>（delete） 操作也被称为出队(dequeue) 。 你<strong>只能移除第一个元素</strong>。</li><li><strong>总结：队尾入队，队首出队。</strong></li></ul><p><strong>出队：</strong><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/135940985.jpg" alt="mark"></p><p>*<em>入队 : *</em><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/140053661.png" alt="mark"></p><h3 id="1-1-1-数组实现队列"><a href="#1-1-1-数组实现队列" class="headerlink" title="1.1.1 数组实现队列"></a>1.1.1 数组实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实现队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 数组存放元素</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指向开始位置的指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> p_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        p_start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 出队相当于开始索引后移</span></span><br><span class="line">        p_start ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.get(p_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p_start &gt;= data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue q = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        q.enQueue(<span class="number">5</span>);</span><br><span class="line">        q.enQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.getFront());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/145353792.png" alt="mark"></p><ul><li>让我们考虑一种情况，即我们只能分配一个最大长度为 5 的数组。当我们只添加少于 5 个元素时，我们的解决方案很有效。 例如，如果我们只调用入队函数四次后还想要将元素 10 入队，那么我们可以成功。</li><li>但是我们不能接受更多的入队请求，这是合理的，因为现在队列已经满了。但是如果我们将一个元素出队呢？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/145423708.png" alt="mark"></p><h3 id="1-1-2-剑指-Offer-09-用两个栈实现队列"><a href="#1-1-2-剑指-Offer-09-用两个栈实现队列" class="headerlink" title="1.1.2 剑指 Offer 09. 用两个栈实现队列"></a>1.1.2 <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h3><p><strong>题目描述：</strong></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>遇到的问题</strong></p><ul><li><strong>栈无法实现队列的功能：</strong>栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈</li><li><strong>双栈可以实现列表的倒序</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设有含三个元素的栈 </span><br><span class="line">A &#x3D; [1,2,3] 和空栈 B &#x3D; []。</span><br><span class="line">若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A &#x3D; [] , B &#x3D; [3,2,1]，即 栈 B 元素实现栈 A 元素倒序 。</span><br></pre></td></tr></table></figure><ul><li><strong>利用栈B删除队首元素：倒序后，B执行出栈就相当于删除了A的栈底元素，即对应队首元素</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/141348516.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. B不为空，说明已经完成了倒叙，直接返回B栈顶元素即可</span></span><br><span class="line">        <span class="keyword">if</span> (!B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> B.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (A.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 2. 如果A为空,说明两个栈都为空</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 说明两个栈都存在元素</span></span><br><span class="line">            <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">                B.add(A.remove());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> B.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的解析：在我的Leetcode专题里面有，所以这里不再过度阐述。</strong></p><h3 id="1-1-3-622-设计循环队列"><a href="#1-1-3-622-设计循环队列" class="headerlink" title="1.1.3 622. 设计循环队列"></a>1.1.3 <a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></h3><ul><li>此前，我们提供了一种简单但低效的队列实现。（数组实现）</li><li>更有效的方法是使用循环队列，具体来说，我们可以使用固定大小的数组和两个指针来指示起始位置和结束位置。目的是重复使用被浪费的存储空间。</li></ul><p><strong>题目描述：</strong></p><ul><li><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p></li><li><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p></li><li><p>你的实现应该支持如下操作：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue(k): 构造器，设置队列长度为 k 。</span><br><span class="line">Front: 从队首获取元素。如果队列为空，返回 -1 。</span><br><span class="line">Rear: 获取队尾元素。如果队列为空，返回 -1 。</span><br><span class="line">enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</span><br><span class="line">deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</span><br><span class="line">isEmpty(): 检查循环队列是否为空。</span><br><span class="line">isFull(): 检查循环队列是否已满。</span><br></pre></td></tr></table></figure><p><strong>算法思路</strong></p><ul><li>这道题说“循环”的意思是要求我们在数组里实现。</li><li>在数组的操作中，我们参考“动态数组”的实现来完成。主要是为了让每一步操作的复杂度都降到最低。只不过我们自己实现动态扩容和缩容</li></ul><p>注意：</p><ol><li><p>定义循环变量 <code>front</code> 和 <code>rear</code> 。一直保持这个定义，到底是先赋值还是先移动指针就很容易想清楚了。</p><ul><li><code>front</code> 队列头部第一个有效的位置</li><li><code>rear</code>：指向队列尾部（即最后 1 个有效数据）的下一个位置，即下一个从队尾入队元素的位置。</li></ul></li><li><p><strong>为了避免“队列为空”和“队列为满”的判别条件冲突，我们有意浪费了一个位置。</strong></p><ul><li>浪费一个位置是指：循环数组中任何时刻一定至少有一个位置不存放元素。</li><li>判断队列为空的条件 <code>front == rear</code></li><li>判断队列为满的条件 <code>front == (rear + 1) % capacity</code> (可以这样理解，当 <code>rear</code> 循环到数组的前面，要从后面追上 <code>front</code>，还差一格的时候，判定队列为满。)</li></ul></li><li><p>因为有循环的出现，要<strong>特别注意处理数组下标可能越界的情况</strong>。指针后移的时候，索引 + 1，并且要注意取模。</p></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 浪费一个位置</span></span><br><span class="line">        capacity = k + <span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">        front = <span class="number">0</span>; <span class="comment">// 删除元素的时候，只索引 +1（注意取模）</span></span><br><span class="line">        rear  = <span class="number">0</span>; <span class="comment">// 插入元素的时候，先赋值，后索引 +1（注意取模）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先赋值，然后索引 + 1</span></span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先索引 + 1即可</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[(rear - <span class="number">1</span> + capacity) % capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经典设计</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % capacity == front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4-641-设计循环双端队列"><a href="#1-1-4-641-设计循环双端队列" class="headerlink" title="1.1.4 641. 设计循环双端队列"></a>1.1.4 <a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></h3><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span> </span>&#123;</span><br><span class="line">    <span class="comment">// front == rear 队列为空</span></span><br><span class="line">    <span class="comment">// (rear + 1) == front 队列为满</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularDeque</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        capacity = k + <span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertFront</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 索引 + 1 然后赋值</span></span><br><span class="line">        front = (front - <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        arr[front] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertLast</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// front 是在数组的开头，同时防止数组越界</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear = (rear - <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 rear 为0的时候防止数组越界</span></span><br><span class="line">        <span class="comment">// 因为真正的最后有效的元素是 rear - 1</span></span><br><span class="line">        <span class="keyword">return</span> arr[(rear - <span class="number">1</span> + capacity) % capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经典设计</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % capacity == front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-栈（后入先出）"><a href="#2-1-栈（后入先出）" class="headerlink" title="2.1 栈（后入先出）"></a>2.1 栈（后入先出）</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200724-160713163.png" alt="mark"></p><ul><li>在 LIFO 数据结构中，将<code>首先处理添加到队列</code>中的<code>最新元素</code>。</li><li>与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 <code>push</code> 。与队列类似，总是<code>在堆栈的末尾添加一个新元素</code>。但是，删除操作，退栈 <code>pop</code> ，将始终<code>删除</code>队列中相对于它的<code>最后一个元素</code>。</li></ul><h3 id="2-1-1-栈的实现"><a href="#2-1-1-栈的实现" class="headerlink" title="2.1.1 栈的实现"></a>2.1.1 栈的实现</h3><ul><li>栈的实现比队列容易。<code>动态数组</code>足以实现堆栈结构。这里我们提供了一个简单的实现供你参考：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        list.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-155-最小栈"><a href="#2-1-2-155-最小栈" class="headerlink" title="2.1.2  155. 最小栈"></a>2.1.2  <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h3><p>题目描述：</p><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(x) ——   将元素 x 推入栈中。</span><br><span class="line">pop() ——     删除栈顶的元素。</span><br><span class="line">top() ——     获取栈顶元素。</span><br><span class="line">getMin() —— 检索栈中的最小元素。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MinStack"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"getMin"</span>,<span class="string">"pop"</span>,<span class="string">"top"</span>,<span class="string">"getMin"</span>]</span><br><span class="line">[[],[-<span class="number">2</span>],[<span class="number">0</span>],[-<span class="number">3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,-<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">0</span>,-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2</span>.</span><br></pre></td></tr></table></figure><p><strong>Solution：辅助栈和数据栈同步</strong></p><ul><li>特点：编写简单，不需要考虑一些边界情况（缺点：可能会存储一些多余的元素）</li><li>规则如下：<ul><li><strong>辅助栈为空的时候，必须放进来新的数字</strong></li><li>新来的数小于等于辅助栈栈顶元素的时候，才放入（<strong>这里“等于要考虑进去”，因为出栈的时候，相等的并且是最小值的元素要同步出栈</strong>），要不然就放入辅助栈栈顶自己</li><li><strong>出栈的时候，辅助栈的栈顶元素要等于数据栈栈顶的元素才出栈</strong></li></ul></li></ul><p><strong>总结：</strong></p><ul><li><strong>出栈的时候，最小值出栈才同步</strong></li><li><strong>入栈的时候，最小值入栈才同步</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data =   <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 思路1：数据栈和辅助栈在任何时候都要同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="keyword">if</span> (helper.isEmpty() || helper.peek() &gt;= x)&#123;</span><br><span class="line">            helper.add(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            helper.add(helper.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个栈都需要pop操作</span></span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty())&#123;</span><br><span class="line">            helper.pop();</span><br><span class="line">            data.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据栈的栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> data.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈元素为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小栈的栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!helper.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> helper.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈元素为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(1) 栈的操作</li><li><strong>空间复杂度</strong>：O(n) 需要一个辅助栈的空间</li></ul><h3 id="2-1-3-20-有效的括号"><a href="#2-1-3-20-有效的括号" class="headerlink" title="2.1.3 20. 有效的括号"></a>2.1.3 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h3><p><strong>题目描述</strong></p><p>给定一个只包括<code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code>的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br><strong>注意空字符串可被认为是有效字符串。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>算法思路</strong></p><ul><li>栈的先入后出的特点和括号排序一致，即遇到左括号入栈，遇到右括号时将对应的栈顶元素左括号出栈，则遍历完所有括号之后<code>stack</code> 仍然为空。</li><li>建立哈希表存储所有左右括号的对应关系，（key 左括号， value 右括号）。这样查询2个括号是否对应只要O(1) 的时间复杂度；<ul><li>建立栈<code>stack</code> ，遍历字符串s并按照算法流程就行判断</li></ul></li></ul><p><strong>算法流程</strong></p><ul><li>如果c 是左括号，则入栈push<ul><li>否则通过哈希表来判断对应关系，若<code>stack</code> 栈顶出栈的括号<code>stack.pop()</code> 与当前括号c不对应，则提前返回false</li></ul></li></ul><p><strong>提前返回false</strong></p><ul><li><strong>提前返回优点：</strong> 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。<ul><li><strong>栈 stack 为空</strong> ： 此时 stack.pop()会报错，因此使用一个取巧的办法，<strong>给stack 赋一个初值 ？</strong> ， <strong>并在哈希表中建立 ？ 和 ？ 的对应关系。</strong>此时当<code>stack</code> 为空且<code>c</code> 是右括号的时候，可以正常提前返回false.</li><li><strong>字符串s 以左括号结尾：</strong> 这种情况下，可以正常的遍历完字符串，但是最后的左括号遗留了下来，这时候要判断最后栈的长度是不是等于1，如果等于，说明多出来一个左括号，不是有效的括号组合。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195452276.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195501520.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195513439.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195521791.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-195532859.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// map来预存括号以及辅助判断字符</span></span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'&#123;'</span>,<span class="string">'&#125;'</span>);</span><br><span class="line">        map.put(<span class="string">'['</span>,<span class="string">']'</span>);</span><br><span class="line">        map.put(<span class="string">'('</span>,<span class="string">')'</span>);</span><br><span class="line">        map.put(<span class="string">'?'</span>,<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有左括号直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span> &amp;&amp; !map.containsKey(s.charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈</span></span><br><span class="line">        LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，检查括号符不符合要求</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="comment">// 左括号放入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line">                list.add(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(list.removeLast()) != c)&#123;</span><br><span class="line">                <span class="comment">// 栈顶左括号和右括号是否匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断有没有遗留左括号</span></span><br><span class="line">        <span class="keyword">return</span> list.size() ==  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>复杂度分析</strong><ul><li>时间复杂度 O(N)：正确的括号组合需要遍历 1 遍 <code>s</code>；</li><li>空间复杂度 O(N)：哈希表和栈使用线性的空间大小。</li></ul></li></ul><h3 id="2-1-4-739-每日温度"><a href="#2-1-4-739-每日温度" class="headerlink" title="2.1.4  739. 每日温度"></a>2.1.4  <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h3><p><strong>题目描述：</strong></p><p><strong>本质</strong> ： 找到数组中第一个大于该元素数字的索引 ，并返回索引差值</p><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温 列表长度的范围是<code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在<code>[30, 100]</code>范围内的整数。</p><p><strong>解法思路：单调递减栈</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205146576.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205229904.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205245835.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205259273.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205320457.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205337913.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200726-205344516.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 单调递减栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">                ret[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈为空的话</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)，</strong>其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</li><li><strong>空间复杂度：O(n)，</strong>其中 n是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</li></ul><h3 id="2-1-5-150-逆波兰表达式求值"><a href="#2-1-5-150-逆波兰表达式求值" class="headerlink" title="2.1.5 150. 逆波兰表达式求值"></a>2.1.5 <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h3><p><strong>题目描述</strong></p><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener"> 逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">逆波兰表达式：</span><br><span class="line"></span><br><span class="line">逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</span><br><span class="line"></span><br><span class="line">平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</span><br><span class="line">该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</span><br><span class="line">逆波兰表达式主要有以下两个优点：</span><br><span class="line"></span><br><span class="line">去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</span><br><span class="line">适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><p><strong>方法：单调栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 减少自动装箱拆箱的负担</span></span><br><span class="line">        Integer op1,op2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，进行运算</span></span><br><span class="line">        <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span> :</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 + op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 - op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 * op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                    op2 = stack.pop();</span><br><span class="line">                    op1 = stack.pop();</span><br><span class="line">                    stack.push(op1 / op2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(Integer.valueOf(s));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最后栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-队列和BFS"><a href="#2-队列和BFS" class="headerlink" title="2. 队列和BFS"></a>2. 队列和BFS</h1><h2 id="2-1-BFS"><a href="#2-1-BFS" class="headerlink" title="2.1 BFS"></a>2.1 BFS</h2><ul><li><p>广度优先搜索（BFS）是一个常见应用是从根节点到目标节点的最短路径。</p></li><li><p>在本文中，我们提供了一个示例来解释在 BFS 算法中是如何逐步应用队列的。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200720/162240980.gif" alt="mark"></p><p><strong>分析</strong></p><ol><li>节点的处理顺序是什么？</li></ol><ul><li>在第一轮中，我们处理根节点。</li><li>在第二轮中，我们处理第二层节点。</li><li>第三轮中，我们处理第三层节点。</li><li>。。。。</li></ul><ul><li>与树的<strong>层序遍历</strong>类似，<code>越是接近根结点的结点将越早地遍历</code>。</li></ul><ol start="2"><li>队列的入队和出队顺序是什么？</li></ol><ul><li>首先将根节点入队，逐个处理已经在队列中的节点，并将所有的邻居添加到队列中。值得注意的是，新添加的节点并不会立即遍历，而是在下一轮搜索中处理。</li><li>节点处理的顺序和添加到队列的顺序是完全相同的，即先进先出（FIFO）,这就是我们为什么使用队列的原因。</li></ul><h2 id="2-2-BFS两种模板"><a href="#2-2-BFS两种模板" class="headerlink" title="2.2 BFS两种模板"></a>2.2 BFS两种模板</h2><ul><li>之前，我们已经介绍了使用 BFS 的两个主要方案：<code>遍历</code>或<code>找出最短路径</code>。通常，这发生在树或图中。正如我们在章节描述中提到的，BFS 也可以用于更抽象的场景中。</li></ul><p><strong>模板一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一轮中，<strong>队列的节点是等待处理的节点</strong></li><li>在每个更外的一层<code>while</code> 循环之后，我们举例根节点更远一步。变量<code>step</code> 从根节点到我们正在访问的节点的距离。</li></ul><p><strong>模板二</strong></p><ul><li>有时候，确保我们永远不会访问同一个节点两次很重要。</li><li>否则的话，我们可能会陷入无限死循环，如果是这样，我们可以添加一个哈希set来解决这样的问题，下面是修改后的伪代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>队列q 就不用说了，BFS核心的数据结构；</strong></li><li><code>cur.adj()</code> 表示 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 的上下左右位置就是相邻的节点；</li><li><code>visited()</code> 节点的作用就是防止走回头路<ul><li><strong>大部分情况下，<code>visited</code> 数组或者说 哈希表 是必须的</strong></li><li><strong>但是像二叉树一般的结构，没有子节点到父节点的指针，不会走回头路就不需要<code>visited</code></strong></li></ul></li></ul><h2 id="2-3-BFS-题目1：-102-二叉树的层序遍历"><a href="#2-3-BFS-题目1：-102-二叉树的层序遍历" class="headerlink" title="2.3 BFS 题目1： 102. 二叉树的层序遍历"></a>2.3 BFS 题目1： <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>思路：BFS</strong></p><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="comment">// res 记录最后结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列（LinkedList实现）</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点放入队列</span></span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出队列首元素并删除</span></span><br><span class="line">                TreeNode curr = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 队首元素放到结果中</span></span><br><span class="line">                    subList.add(curr.val);</span><br><span class="line">                    <span class="comment">// 对子节点进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(curr.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(curr.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200809-163226648.gif" alt="mark"></p><ul><li>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</li></ul><p><strong>复杂度分析</strong></p><p>记树上所有节点的个数为 nn。</p><ul><li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li><li>空间复杂度：队列中元素的个数不超过 nn 个，故渐进空间复杂度为 O(n)。</li></ul><h2 id="2-4-BFS-题目2：111-二叉树的最小深度"><a href="#2-4-BFS-题目2：111-二叉树的最小深度" class="headerlink" title="2.4 BFS 题目2：111. 二叉树的最小深度"></a>2.4 BFS 题目2：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h2><p><strong>题目描述</strong></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>思路：BFS</strong></p><ul><li>首先来看看DFS和BFS的区别</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200728-150819598.gif" alt="mark"></p><ul><li><p>这个遍历顺序也是 BFS 能够用来解「层序遍历」、「最短路径」问题的根本原因。</p></li><li></li></ul><h2 id="2-5-BFS-题目3-：-279-完全平方数"><a href="#2-5-BFS-题目3-：-279-完全平方数" class="headerlink" title="2.5 BFS  题目3 ： 279-完全平方数"></a>2.5 BFS  题目3 ： 279-<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</span><br></pre></td></tr></table></figure><p><strong>解法：BFS（下面一图胜千言）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200809-170946859.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        queue.add(n);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            level++; <span class="comment">// 开始生成下一层</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                <span class="comment">//依次减 1, 4, 9... 生成下一层的节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= cur; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> next = cur - j * j;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">                        queue.offer(next);</span><br><span class="line">                        visited.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-栈和DFS"><a href="#3-栈和DFS" class="headerlink" title="3. 栈和DFS"></a>3. 栈和DFS</h1><ul><li><p>正如我们在本章的描述中提到的，在大多数情况下，我们在能使用 BFS 时也可以使用 DFS。但是有一个重要的区别：遍历顺序。</p></li><li><p>与 BFS 不同，更早访问的结点可能不是更靠近根结点的结点。因此，你在 DFS 中找到的第一条路径可能不是最短路径。</p></li><li><p>在本文中，我们将为你提供一个 DFS 的递归模板，并向你展示栈是如何帮助这个过程的。</p></li></ul><p><strong>模板</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Return true if there is a path from cur to target.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) &#123;</span><br><span class="line">    return true if cur is target;</span><br><span class="line">    for (next : each neighbor of cur) &#123;</span><br><span class="line">        if (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            return true if DFS(next, target, visited) &#x3D;&#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-94-二叉树的中序遍历"><a href="#3-1-94-二叉树的中序遍历" class="headerlink" title="3.1 94. 二叉树的中序遍历"></a>3.1 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h2><p>给定一根二叉树，返回它的中序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否是null</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 1. 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.left,res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 打印</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="comment">// 3. 右子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.right,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前序遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        DFS(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;DFS(root.left,res);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;DFS(root.right,res);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        DFS(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;DFS(root.left,res);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;DFS(root.right,res);&#125;</span><br><span class="line"></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-329-矩阵中的最长递增路径"><a href="#3-3-329-矩阵中的最长递增路径" class="headerlink" title="3.3 329. 矩阵中的最长递增路径"></a>3.3 <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;队列和栈-合集&quot;&gt;&lt;a href=&quot;#队列和栈-合集&quot; class=&quot;headerlink&quot; title=&quot;队列和栈-合集&quot;&gt;&lt;/a&gt;队列和栈-合集&lt;/h1&gt;&lt;p&gt;（本系列是针对Leetcode上常见的队列和栈进行总结。）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://zhuuu.work/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>汇编-07-内存</title>
    <link href="http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-07-%E5%86%85%E5%AD%98/"/>
    <id>http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-07-%E5%86%85%E5%AD%98/</id>
    <published>2020-07-17T03:47:41.000Z</published>
    <updated>2020-07-17T04:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-07-内存"><a href="#汇编-07-内存" class="headerlink" title="汇编-07-内存"></a>汇编-07-内存</h1><ul><li>寄存器很小，不够用，所以说，数据放到了内存中。</li><li>每个应用程序（进程）都有4GB的内存空间（空头支票）</li></ul><p>1 B = 8bit</p><p>1 KB = 1024B</p><p>1 MB = 1024KB</p><p>1 GB = 1024MB</p><h2 id="1-内存地址"><a href="#1-内存地址" class="headerlink" title="1. 内存地址"></a>1. 内存地址</h2><ul><li>给计算机中每个空间分配一个地址（名字） </li><li>32位 ： 寻址能力 ！ （4GB） </li><li></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-07-内存&quot;&gt;&lt;a href=&quot;#汇编-07-内存&quot; class=&quot;headerlink&quot; title=&quot;汇编-07-内存&quot;&gt;&lt;/a&gt;汇编-07-内存&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;寄存器很小，不够用，所以说，数据放到了内存中。&lt;/li&gt;
&lt;li&gt;每个应用程序（进程）都有4GB的内存空间（空头支票）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1 B = 8bit&lt;/p&gt;
&lt;p&gt;1 KB = 1024B&lt;/p&gt;
&lt;p&gt;1 MB = 1024KB&lt;/p&gt;
&lt;p&gt;1 GB = 1024MB&lt;/p&gt;
&lt;h2 id=&quot;1-内存地址&quot;&gt;&lt;a href=&quot;#1-内存地址&quot; class=&quot;headerlink&quot; title=&quot;1. 内存地址&quot;&gt;&lt;/a&gt;1. 内存地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给计算机中每个空间分配一个地址（名字） &lt;/li&gt;
&lt;li&gt;32位 ： 寻址能力 ！ （4GB） &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编-06-寄存器</title>
    <link href="http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-06-%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://zhuuu.work/2020/07/17/assembly/%E6%B1%87%E7%BC%96-06-%E5%AF%84%E5%AD%98%E5%99%A8/</id>
    <published>2020-07-17T03:40:41.000Z</published>
    <updated>2020-07-17T03:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-06-寄存器"><a href="#汇编-06-寄存器" class="headerlink" title="汇编-06-寄存器"></a>汇编-06-寄存器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>寄存器是CPU的组成部分，因为在CPU中，CPU对其读写速度是最快的，不需要IO传输</li><li>但是同时寄存器的数量是有限的，优先到几乎每个寄存器都有自己的名字，而且有些还有多个名字。</li></ul><p> IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类:</p><ul><li>通用寄存器</li><li>段寄存器</li><li>状态和控制寄存器</li><li>指令寄存器</li></ul><h2 id="1-32位通用寄存器"><a href="#1-32位通用寄存器" class="headerlink" title="1. 32位通用寄存器"></a>1. 32位通用寄存器</h2><ul><li>32位通用寄存器有八个<ul><li>eax : 累加和结果寄存器</li><li>ebx：数据指针寄存器</li><li>ecx：循环计数器</li><li>edx：i/o指针</li><li>esi：源地址寄存器</li><li>edi：目标地址寄存器</li><li>ebp：堆栈指针</li><li>esp：栈指针寄存器</li></ul></li></ul><a id="more"></a><p>[参考博客：][<a href="https://blog.csdn.net/lidonghat/article/details/70244288?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight]" target="_blank" rel="noopener">https://blog.csdn.net/lidonghat/article/details/70244288?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight]</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-06-寄存器&quot;&gt;&lt;a href=&quot;#汇编-06-寄存器&quot; class=&quot;headerlink&quot; title=&quot;汇编-06-寄存器&quot;&gt;&lt;/a&gt;汇编-06-寄存器&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;寄存器是CPU的组成部分，因为在CPU中，CPU对其读写速度是最快的，不需要IO传输&lt;/li&gt;
&lt;li&gt;但是同时寄存器的数量是有限的，优先到几乎每个寄存器都有自己的名字，而且有些还有多个名字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;li&gt;段寄存器&lt;/li&gt;
&lt;li&gt;状态和控制寄存器&lt;/li&gt;
&lt;li&gt;指令寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-32位通用寄存器&quot;&gt;&lt;a href=&quot;#1-32位通用寄存器&quot; class=&quot;headerlink&quot; title=&quot;1. 32位通用寄存器&quot;&gt;&lt;/a&gt;1. 32位通用寄存器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;32位通用寄存器有八个&lt;ul&gt;
&lt;li&gt;eax : 累加和结果寄存器&lt;/li&gt;
&lt;li&gt;ebx：数据指针寄存器&lt;/li&gt;
&lt;li&gt;ecx：循环计数器&lt;/li&gt;
&lt;li&gt;edx：i/o指针&lt;/li&gt;
&lt;li&gt;esi：源地址寄存器&lt;/li&gt;
&lt;li&gt;edi：目标地址寄存器&lt;/li&gt;
&lt;li&gt;ebp：堆栈指针&lt;/li&gt;
&lt;li&gt;esp：栈指针寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>汇编-05-位运算</title>
    <link href="http://zhuuu.work/2020/07/16/assembly/%E6%B1%87%E7%BC%96-05-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://zhuuu.work/2020/07/16/assembly/%E6%B1%87%E7%BC%96-05-%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2020-07-16T07:40:41.000Z</published>
    <updated>2020-07-17T02:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-05-位运算"><a href="#汇编-05-位运算" class="headerlink" title="汇编-05-位运算"></a>汇编-05-位运算</h1><p>参考博客链接：<a href="https://www.cnblogs.com/findbetterme/p/10787118.html" target="_blank" rel="noopener">https://www.cnblogs.com/findbetterme/p/10787118.html</a></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量的减少运行的开销，优化算法。</li><li>举个例子，翻转的操作比较常见，比如初始值是1，操作一次变成0，再操作一次变成1。 可能的做法是使用三木运算符，判断原始值是1还是0，如果是1，设置位0。否则设置位0，但是使用位运算，不用判断原始值，直接改变值就可以。<code>1^num //num</code> 为原始值。</li><li>当然，一句代码可能对性能没有什么影响，到那时在高并发，大数据量的情况下可以节省很多开销。</li><li>以下是整理的关于java位运算的部分内容，如有错误，还请指出，以共同进步，先行致谢。</li></ul><h2 id="1-位运算符"><a href="#1-位运算符" class="headerlink" title="1. 位运算符"></a>1. 位运算符</h2><h3 id="1-1-java支持的位运算符"><a href="#1-1-java支持的位运算符" class="headerlink" title="1.1 java支持的位运算符"></a>1.1 java支持的位运算符</h3><ul><li>&amp; ： 按位与</li><li>|  ：按位或</li><li>~  ： 按位非</li><li>^   :   按位异或</li><li>&lt;&lt; :  左位移运算符</li><li><code>&gt;&gt;</code> : 右位移运算符</li><li><code>&gt;&gt;&gt;</code> 无符号右移运算符</li><li><strong>注意：任何语言都没有无符号左移运算符</strong></li></ul><ul><li>位运算符中：除 ~ 以外，其余均为二元运算符。<strong>操作数只能是整型和字符型数据。</strong></li></ul><p>Java使用补码来表示二进制数，在补码表示中，最高位是符号位，正数的符号位为0，负数为1。</p><ul><li>补码的规定如下：<strong>对于正数来说</strong>，最高位是0，其余各位代表数值本身的二进制表示，如 <code>+ 42 的 补码  是  0010 1010</code></li><li><strong>补码对于负数来说，</strong>最高位是 1 ，把其余的位按位取反变成反码，然后对整个数+1，就是该数字的补码 ， <strong>如<code>-1 的补码是 1111 1111</code> （在java中 -1 的 补码 是 <code>1111 1111 1111 1111</code> ,因为java中的int是32位的）</strong></li></ul><h3 id="1-2-按位与（-amp-）"><a href="#1-2-按位与（-amp-）" class="headerlink" title="1.2 按位与（&amp;）"></a>1.2 按位与（&amp;）</h3><p>按位与的运算规则</p><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>&amp;</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p><strong>总结</strong></p><ul><li>两个数同时位1的时候，结果为1</li><li>其余全为0（只要有一个操作数为0，结果就为0）</li></ul><p><strong>举例：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084818815.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084849124.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/084853301.png" alt="mark"></p><h3 id="1-3-按位或（-）"><a href="#1-3-按位或（-）" class="headerlink" title="1.3 按位或（|）"></a>1.3 按位或（|）</h3><p>按位或的运算规则</p><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位或</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p><strong>总结</strong></p><ul><li>只有两个操作数对应位同时为0，结果才是0</li><li>其余全是1（只要有一个1，那么结果就是1）</li></ul><h3 id="1-4-按位非（-）"><a href="#1-4-按位非（-）" class="headerlink" title="1.4 按位非（~）"></a>1.4 按位非（~）</h3><table><thead><tr><th>操作数</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>按位或</td><td>1</td><td>0</td></tr></tbody></table><p>在求负数的源码中使用过。</p><h3 id="1-5-按位异或（-）"><a href="#1-5-按位异或（-）" class="headerlink" title="1.5 按位异或（^）"></a>1.5 按位异或（^）</h3><ul><li>按位异或的运算规则</li></ul><table><thead><tr><th>操作数1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位异或</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>不一样就是1，一样就是0</li></ul><h3 id="1-6-左位移（-lt-lt-）"><a href="#1-6-左位移（-lt-lt-）" class="headerlink" title="1.6 左位移（&lt;&lt;）"></a>1.6 左位移（&lt;&lt;）</h3><ul><li>算数左移（<code>&lt;&lt;</code>） : 符号位不变，<strong>低位补0.</strong>  </li><li>如 <code>2 &lt;&lt; 2</code> 的结果是8.</li></ul><p><strong>举例：<code>2 &lt;&lt; 2</code> 的结果是8.</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/092343752.png" alt="mark"></p><p><strong>总结：</strong></p><ul><li>当移动的位数超过数字本身位数的时候，那么不就全部需要补0的操作吗？</li><li>实际上不是的，<strong>java不可能做这么浪费资源的事情。</strong>在真正执行位移前，其对要移动的位数做了一些预处理，如32处理为0，-1处理为31</li></ul><h3 id="1-7-右位移（-gt-gt-）"><a href="#1-7-右位移（-gt-gt-）" class="headerlink" title="1.7 右位移（&gt;&gt;）"></a>1.7 右位移（&gt;&gt;）</h3><ul><li>低位溢出，符号位不变，<strong>并用符号位补溢出的高位。</strong></li><li>如 <code>-6 &gt;&gt; 2</code> 结果是 <code>-2</code> (相当于除3)</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/093302064.png" alt="mark"></p><h3 id="1-8-无符号右移（-gt-gt-gt-）"><a href="#1-8-无符号右移（-gt-gt-gt-）" class="headerlink" title="1.8 无符号右移（&gt;&gt;&gt;）"></a>1.8 无符号右移（&gt;&gt;&gt;）</h3><ul><li><strong>低位溢出，高位补0</strong></li><li><strong>注意，无符号右移(&gt;&gt;&gt;) 中的符号位（最高位）也跟着在变。</strong></li><li>无符号的意思是将符号位当作数字位来看待。</li><li>如 <code>-1 &gt;&gt;&gt; 1</code> 的结果是<code>2141483647</code></li></ul><p>这个数字应该比较熟悉，看两个输出语句就知道是什么了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(-<span class="number">1</span>&gt;&gt;&gt;<span class="number">1</span>));</span><br><span class="line">System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">1111111111111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111111111111</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/101857332.png" alt="mark"></p><p>除了使用-1&gt;&gt;&gt;1能得到Integer.MAX_VALUE，以下的也能得到同样的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;maxInt</span><br><span class="line">System.out.println(~(1 &lt;&lt; 31));</span><br><span class="line">System.out.println((1 &lt;&lt; -1) -1);</span><br><span class="line">System.out.println(~(1 &lt;&lt; -1));</span><br></pre></td></tr></table></figure><p>使用位运算往往能很巧妙的实现某些算法完成一些复杂的功能。</p><h2 id="2-常见使用"><a href="#2-常见使用" class="headerlink" title="2. 常见使用"></a>2. 常见使用</h2><h3 id="2-1-m-2-n"><a href="#2-1-m-2-n" class="headerlink" title="2.1 m*2 ^n"></a>2.1 m*2 ^n</h3><ul><li><p>可以使用 m &lt;&lt; n 求得结果：</p><ul><li>如 <code>System.*out*.println(&quot;2^3=&quot; + (1&lt;&lt;3));//2^3=8</code></li><li><code>System.*out*.println(&quot;3*2^3=&quot; + (3&lt;&lt;3));//3*2^3=24</code></li></ul></li><li><p>计算结果是不是很正确呢？ <strong>如果非要说 <code>2 &lt;&lt; -1</code> 为什么不等于0.5？ 前面说过，位运算的操作数只能是整型和字符型</strong>。再求int所能表示的最小值的时候，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># minInt</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li>可以发现左移31位和-1位所得的结果是一样的。同理，左移30位和左移-2所得的结果也是一样的。移动一个负数为，是不是等于右移该负数位的绝对值呢？输出一下发现结果不是的。</li><li><strong>java中 Int 所能表示的最大值是31位，加上符号位共32位。在这里有如下的位移法则：</strong><ul><li><strong>法则1： 任何数左移（右移）32的倍数位等于该数本身</strong></li><li><strong>法则2：在位移运算 m &lt;&lt; n 的计算中，若n 是正数，则实际移动的位数是 n % 32；若 n是负数，则实际移动的位数是 （32 + n % 32） ，右移同理</strong></li><li>左移是乘以2的幂，右移是除以2的幂。</li></ul></li></ul><h3 id="2-2-判断一个数的奇偶性"><a href="#2-2-判断一个数的奇偶性" class="headerlink" title="2.2 判断一个数的奇偶性"></a>2.2 判断一个数的奇偶性</h3><p><code>n &amp; 1 == 1? 奇数：偶数</code> </p><ul><li><strong>为什么与1能判断奇偶？</strong></li><li><strong>所谓的二进制就是满2进1，那么好了，偶数的最低位肯定是0（恰好满2，对不对？）</strong></li><li><strong>同理，奇数的最低为肯定是1，<code>对于int类型的1，前31位都是0，无论是1&amp;0 还是 0 &amp; 0结果都是0</code></strong></li><li><strong>那么有区别的肯定就是最低为上的 1 了，若 n 的二进制最低位为是1（奇数），反则就是结果就是0（偶数）</strong></li></ul><h3 id="2-3-不使用临时变量交换两个数字"><a href="#2-3-不使用临时变量交换两个数字" class="headerlink" title="2.3 不使用临时变量交换两个数字"></a>2.3 不使用临时变量交换两个数字</h3><p><strong>在int[]数组首尾互换中，是不看到过这样的代码：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-05-位运算&quot;&gt;&lt;a href=&quot;#汇编-05-位运算&quot; class=&quot;headerlink&quot; title=&quot;汇编-05-位运算&quot;&gt;&lt;/a&gt;汇编-05-位运算&lt;/h1&gt;&lt;p&gt;参考博客链接：&lt;a href=&quot;https://www.cnblogs.com/findbetterme/p/10787118.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/findbetterme/p/10787118.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-088-合并两个有序数组</title>
    <link href="http://zhuuu.work/2020/07/15/Leetcode/Leetcode-088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2020/07/15/Leetcode/Leetcode-088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-15T08:52:53.000Z</published>
    <updated>2020-07-17T07:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-088-合并两个有序数组"><a href="#Leecode-088-合并两个有序数组" class="headerlink" title="Leecode-088-合并两个有序数组"></a>Leecode-088-<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2*，请你将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p><p>说明:</p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</li><li><strong>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一：从头到后双指针"><a href="#方法一：从头到后双指针" class="headerlink" title="方法一：从头到后双指针"></a><strong>方法一：从头到后双指针</strong></h2><ul><li><p>跟合并两个链表很类似，这里也用两个指针指向数组的1的开头，数组2的开头</p></li><li><p>跟链表合并不同的是，如果往数组中插入一个元素，为了保证整体的顺序性，需要挪动前后的元素，所以我们<strong>要再创建一个数组来保存指针指向的元素。</strong></p></li><li><p>之后比较两个数组中的元素<code>nums1[i]</code>和<code>nums2[j]</code>，将其放到新数组中。</p></li><li><p>这种两两合并的好处是可以免掉排序了，比较完之后再放到新数组中，元素都是有序的了。</p></li><li><p>但题目要求是在数组1的基础上进行修改，而不是返回一个新数组，所以我们还得把排序好的新数组内容，再重新赋给数组1。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/152420791.jpg" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代新开的数组</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; m || k &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 两个边界条件 j = m  和 k = n</span></span><br><span class="line">            <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">                <span class="comment">// nums1走完了</span></span><br><span class="line">                arr[i++] = nums2[k++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (k == n)&#123;</span><br><span class="line">                <span class="comment">// nums2走完了</span></span><br><span class="line">                arr[i++] = nums1[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[j] &lt;= nums2[k])&#123;</span><br><span class="line">                arr[i++] = nums1[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i++] = nums2[k++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再把数组重新赋值给nums1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arr.length; l++) &#123;</span><br><span class="line">            nums1[l] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(m + n) 遍历两个数组需要的时间</li><li>空间复杂度： O(m + n) 新开了一个数组大小</li></ul><h2 id="方法二：从后向前迭代数组（空间优化）"><a href="#方法二：从后向前迭代数组（空间优化）" class="headerlink" title="方法二：从后向前迭代数组（空间优化）"></a>方法二：从后向前迭代数组（空间优化）</h2><ul><li><p>虽然方法一已经很ok了，<strong>但是仔细想想，nums1后面那些个0我们是不是没有用呢？</strong></p></li><li><p>另外题目中也说明了，数组1的空间是足够的，它可以完全容纳下数组1的m个元素和数组2的n个元素。</p></li><li><p>这两个条件拼在一起，我们就有了新的比较方式，即：反着比较。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/152800269.jpg" alt="mark"></p><p><strong>思路：</strong></p><ul><li>反向比较<code>nums1[m - 1] 和 nums2[n - 1]</code></li><li>注意:这样我们就不需要额外的空间了，数组1后面空着的我们都可以直接用</li><li><strong>关键：把两个数组后面最大的数放到数组1的最后一位</strong></li><li>依次类推直到两个数组的元素全部比较完。<br>最后数组1就是有序的，这种比较方式不需要再占用额外的空间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于修改元素的指针</span></span><br><span class="line">        <span class="keyword">int</span> k = m + n -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意边界条件， i &lt; 0以及 j &lt; 0,这表示一个数组已经使用完了</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 反向比较的话，拷贝的是较大的元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(m + n) 遍历两个数组需要的时间</li><li><strong>空间复杂度</strong>： O(1) </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-088-合并两个有序数组&quot;&gt;&lt;a href=&quot;#Leecode-088-合并两个有序数组&quot; class=&quot;headerlink&quot; title=&quot;Leecode-088-合并两个有序数组&quot;&gt;&lt;/a&gt;Leecode-088-&lt;a href=&quot;https://leetcode-cn.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并两个有序数组&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两个有序整数数组 &lt;em&gt;nums1&lt;/em&gt; 和 &lt;em&gt;nums2*，请你将 *nums2&lt;/em&gt; 合并到 &lt;em&gt;nums1&lt;/em&gt; 中&lt;em&gt;，&lt;/em&gt;使 &lt;em&gt;nums1&lt;/em&gt; 成为一个有序数组。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums1 &amp;#x3D; [1,2,3,0,0,0], m &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums2 &amp;#x3D; [2,5,6],       n &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2,2,3,5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-120-三角形最小路径和</title>
    <link href="http://zhuuu.work/2020/07/15/Leetcode/Leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/07/15/Leetcode/Leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2020-07-15T05:45:53.000Z</published>
    <updated>2020-07-15T08:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-120-三角形最小路径和"><a href="#Leetcode-120-三角形最小路径和" class="headerlink" title="Leetcode-120-三角形最小路径和"></a>Leetcode-120-三角形最小路径和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定三角形，每次智能移动到下一行的相邻节点，求从顶点到底边的最小路径和。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[2],</span><br><span class="line">[3,4],</span><br><span class="line">[6,5,7],</span><br><span class="line">[4,1,8,3]</span><br><span class="line">]</span><br><span class="line">相邻结点：与(i, j) 点相邻的结点为 (i + 1, j) 和 (i + 1, j + 1)。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h2><p><strong>分析</strong>： 若定义 <em>f(i, j)</em> 为 <em>(i, j)</em> 点到底边的最小路径和，则易知递归求解式为:</p><p><code>f(i,j) = min(f(i + 1,j) + f(i + 1,j + 1)) + trangle[i][j]</code></p><p>由此，我们将任一点到底边的最小路径和，转化成了与该点相邻两点到底边的最小路径和中的较小值，再加上该点本身的值。这样本题的 <strong>递归解法（解法一）</strong> 就完成了。</p><p><strong>代码实现</strong></p><p>解法一：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  dfs(triangle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == triangle.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dfs(triangle, i + <span class="number">1</span>, j), dfs(triangle, i + <span class="number">1</span>, j + <span class="number">1</span>)) + triangle.get(i).get(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力搜索会大量重复计算，导致超时，因此会在解法二中结合记忆化数组进行优化。</p><p>解法二：递归+记忆化</p><p>在解法一的基础上，定义了二维数组进行记忆化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一： 记忆化搜索 + 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Integer[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> Integer[triangle.size()][triangle.size()];</span><br><span class="line">        <span class="keyword">return</span> dfs(triangle,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == triangle.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归保存</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存每一个memo[i][j]</span></span><br><span class="line">        <span class="keyword">return</span> memo[i][j] = Math.min(dfs(triangle,i + <span class="number">1</span>,j),dfs(triangle,i + <span class="number">1</span>,j + <span class="number">1</span>)) + triangle.get(i).get(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。 </li><li>空间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。</li></ul><p><strong>解法三：动态规划</strong></p><ul><li>定义二维 dp 数组，将解法二中「自顶向下的G递归」改为「自底向上的递推」。</li></ul><ol><li>状态定义</li></ol><p><code>dp[i][j] 表示从点(i,j) 到 底边的最小路径和</code></p><ol start="2"><li>状态转移</li></ol><p><code>dp[i][j]</code>  = <code>min(dp[i + 1][j],dp[i + 1,j + 1]) + triangle[i][j]</code></p><ol start="3"><li>初始化</li></ol><p><code>dp[i][j] = 0</code></p><ol start="4"><li>代码实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示从点 (i, j) 到底边的最小路径和。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从三角形的最后一行开始递推。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。 空间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。</p><p><strong>空间优化的动态规划</strong></p><ul><li>在上述代码中，我们定义了一个N行N列的dp数组（N是三角形的行数）。</li><li>但是在实际计算中我们发现，计算<code>dp[i][j]</code> 时候，只用到了下一行的<code>dp[i + 1][j] 和 dp[i + 1][j + 1]</code>.</li><li>因此dp数组不需要定义N行，只要定义一行就可以了，所以我们稍微修改一下上述代码，将 i 所在的维度去掉（如下），就可以将 O(N^2) 的空间复杂度优化成O(N)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 状态定义</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示从点 (i, j) 到底边的最小路径和。</span></span><br><span class="line"><span class="comment">//        int[][] dp = new int[n + 1][n + 1];</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 状态转移</span></span><br><span class="line">        <span class="comment">// 从最后一行向上递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i ; j++) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)<em>，</em>N</em> 为三角形的行数。 </li><li>空间复杂度：<em>O(N)<em>，</em>N</em> 为三角形的行数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-120-三角形最小路径和&quot;&gt;&lt;a href=&quot;#Leetcode-120-三角形最小路径和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-120-三角形最小路径和&quot;&gt;&lt;/a&gt;Leetcode-120-三角形最小路径和&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定三角形，每次智能移动到下一行的相邻节点，求从顶点到底边的最小路径和。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[3,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[6,5,7],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,1,8,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;相邻结点：与(i, j) 点相邻的结点为 (i + 1, j) 和 (i + 1, j + 1)。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>汇编-03-二进制和十六进制</title>
    <link href="http://zhuuu.work/2020/07/14/assembly/%E6%B1%87%E7%BC%96-03-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/07/14/assembly/%E6%B1%87%E7%BC%96-03-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/</id>
    <published>2020-07-14T11:40:41.000Z</published>
    <updated>2020-07-14T13:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-03-二进制和十六进制"><a href="#汇编-03-二进制和十六进制" class="headerlink" title="汇编-03-二进制和十六进制"></a>汇编-03-二进制和十六进制</h1><p>[参考博客链接:进制转换][<a href="https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]" target="_blank" rel="noopener">https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]</a></p><h2 id="1-二进制和十六进制联系"><a href="#1-二进制和十六进制联系" class="headerlink" title="1. 二进制和十六进制联系"></a>1. 二进制和十六进制联系</h2><p>举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0 - 1111</span><br><span class="line">二进制</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">1000 十六进制</span><br><span class="line">1001  a</span><br><span class="line">1010  b</span><br><span class="line">1100  c </span><br><span class="line">1101  d </span><br><span class="line">1111  e</span><br></pre></td></tr></table></figure><h2 id="2-计算机基础进制转换（二进制、八进制、十进制、十六进制）"><a href="#2-计算机基础进制转换（二进制、八进制、十进制、十六进制）" class="headerlink" title="2. 计算机基础进制转换（二进制、八进制、十进制、十六进制）"></a>2. 计算机基础进制转换（二进制、八进制、十进制、十六进制）</h2><h3 id="2-1-十进制转R进制"><a href="#2-1-十进制转R进制" class="headerlink" title="2.1 十进制转R进制"></a>2.1 十进制转R进制</h3><h4 id="2-1-1-十进制转2进制"><a href="#2-1-1-十进制转2进制" class="headerlink" title="2.1.1 十进制转2进制"></a>2.1.1 十进制转2进制</h4><p><strong>例题：</strong> 135D = <strong>__</strong> B</p><p>十进制整数转换成二进制采用“除2倒取余”，十进制小数转换成二进制小数采用“乘2取整”。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205252067.png" alt="mark"></p><p>​                                图1.十进制整数转二进制</p><a id="more"></a><p><strong>解析：</strong>如下图所示，将135除以2，得余数，直到不能整除，然后再将余数从下至上倒取。得到结果：1000 0111B.</p><p><strong>十进制小数转二进制</strong></p><p>十进制小数转换成二进制小数采用 <strong>“乘2取整，顺序排列”</strong> 法。</p><p>用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。</p><p><strong>例题：</strong> 0.68D = <strong>__</strong> B（精确到小数点后5位）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205616022.png" alt="mark"></p><h4 id="2-2-十进制转8进制"><a href="#2-2-十进制转8进制" class="headerlink" title="2.2 十进制转8进制"></a>2.2 十进制转8进制</h4><p>思路和十进制转二进制一样，参考如下例题：</p><p><strong>例题：</strong> 10.68D = <strong>__</strong> Q（精确到小数点后3位）</p><p><strong>解析：</strong>如下图所示，整数部分除以8取余数，直到无法整除。小数部分0.68乘以8，取整，然后再将小数乘以8，取整，直到达到题目要求精度。得到结果：12.534Q.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205652243.png" alt="mark"></p><h4 id="2-3-十进制转十六进制"><a href="#2-3-十进制转十六进制" class="headerlink" title="2.3 十进制转十六进制"></a>2.3 十进制转十六进制</h4><p>思路和十进制转二进制一样，参考如下例题：</p><p><strong>例题：</strong> 25.68D = <strong>__</strong> H（精确到小数点后3位）</p><p><strong>解析：</strong>如下图所示，整数部分除以16取余数，直到无法整除。小数部分0.68乘以16，取整，然后再将小数乘以16，取整，直到达到题目要求精度。得到结果：19.ae1H.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205836688.png" alt="mark"></p><h3 id="3-R进制转十进制"><a href="#3-R进制转十进制" class="headerlink" title="3. R进制转十进制"></a>3. R进制转十进制</h3><h4 id="3-1-二进制转十进制"><a href="#3-1-二进制转十进制" class="headerlink" title="3.1 二进制转十进制"></a>3.1 二进制转十进制</h4><p><strong>例题：</strong> 1001 0110B = <strong>__</strong> D</p><p><strong>解析：</strong>如下图所示。得到结果：150D.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210001556.png" alt="mark"></p><h4 id="3-2-八进制转十进制"><a href="#3-2-八进制转十进制" class="headerlink" title="3.2 八进制转十进制"></a>3.2 八进制转十进制</h4><p>八进制转十进制的方法和二进制转十进制一样。</p><p><strong>例题：</strong> 26Q = <strong>__</strong> D</p><p><strong>解析：</strong>如下图所示。得到结果：22D.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210039039.png" alt="mark"></p><h4 id="3-3-十六进制转十进制"><a href="#3-3-十六进制转十进制" class="headerlink" title="3.3 十六进制转十进制"></a>3.3 十六进制转十进制</h4><p><strong>例题：</strong> 23daH = <strong>__</strong> D</p><p><strong>解析：</strong>如下图所示。得到结果：9178D.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210113899.png" alt="mark"></p><h2 id="4-二进制转八进制"><a href="#4-二进制转八进制" class="headerlink" title="4. 二进制转八进制"></a>4. 二进制转八进制</h2><p>二进制转八进制的方法是：<strong>取三合一法</strong>，即从二进制的小数点为分界点，向左或者向右每三位取成一位。</p><p><strong>例题：</strong> 1010 0100B = ____Q</p><p><strong>解析：</strong>计算过程如下图所示。得到结果：244Q.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210324217.png" alt="mark"></p><h2 id="5-二进制转十六进制"><a href="#5-二进制转十六进制" class="headerlink" title="5. 二进制转十六进制"></a>5. 二进制转十六进制</h2><p>二进制转十六进制的方法是：<strong>取四合一法</strong>，即从二进制的小数点为分界点，向左或者向右每四位取成一位。</p><p><strong>例题：</strong> 1010 0100B = ____H</p><p><strong>解析：</strong>计算过程如下图所示。得到结果：a4H.</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/210449390.png" alt="mark"></p><h2 id="6-助记"><a href="#6-助记" class="headerlink" title="6. 助记"></a>6. 助记</h2><p>下面的表格是8位二进制所对应的十进制数值，对进制转换以及类似题目的理解非常有用：</p><table><thead><tr><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>B</th></tr></thead><tbody><tr><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>D</td></tr></tbody></table><p>注：B：二进制<br>        D：十进制</p><p><strong>例题：</strong> 135D = <strong>__</strong> B</p><p><strong>解析：</strong>有了上面二进制对应十进制数值的表格，我们就可以将题目给的十进制135拆分为：128+7，再从表格中找到对应的数值，拼凑即可得到答案。</p><p>135D = 128D + 7D = 1000 0000 + 0000 0111 = 1000 0111B</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-03-二进制和十六进制&quot;&gt;&lt;a href=&quot;#汇编-03-二进制和十六进制&quot; class=&quot;headerlink&quot; title=&quot;汇编-03-二进制和十六进制&quot;&gt;&lt;/a&gt;汇编-03-二进制和十六进制&lt;/h1&gt;&lt;p&gt;[参考博客链接:进制转换][&lt;a href=&quot;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-二进制和十六进制联系&quot;&gt;&lt;a href=&quot;#1-二进制和十六进制联系&quot; class=&quot;headerlink&quot; title=&quot;1. 二进制和十六进制联系&quot;&gt;&lt;/a&gt;1. 二进制和十六进制联系&lt;/h2&gt;&lt;p&gt;举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 - 1111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二进制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1000 十六进制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1001  a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1010  b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1100  c &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1101  d &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1111  e&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;2-计算机基础进制转换（二进制、八进制、十进制、十六进制）&quot;&gt;&lt;a href=&quot;#2-计算机基础进制转换（二进制、八进制、十进制、十六进制）&quot; class=&quot;headerlink&quot; title=&quot;2. 计算机基础进制转换（二进制、八进制、十进制、十六进制）&quot;&gt;&lt;/a&gt;2. 计算机基础进制转换（二进制、八进制、十进制、十六进制）&lt;/h2&gt;&lt;h3 id=&quot;2-1-十进制转R进制&quot;&gt;&lt;a href=&quot;#2-1-十进制转R进制&quot; class=&quot;headerlink&quot; title=&quot;2.1 十进制转R进制&quot;&gt;&lt;/a&gt;2.1 十进制转R进制&lt;/h3&gt;&lt;h4 id=&quot;2-1-1-十进制转2进制&quot;&gt;&lt;a href=&quot;#2-1-1-十进制转2进制&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 十进制转2进制&quot;&gt;&lt;/a&gt;2.1.1 十进制转2进制&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;例题：&lt;/strong&gt; 135D = &lt;strong&gt;__&lt;/strong&gt; B&lt;/p&gt;
&lt;p&gt;十进制整数转换成二进制采用“除2倒取余”，十进制小数转换成二进制小数采用“乘2取整”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/205252067.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;​                                图1.十进制整数转二进制&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>汇编-04-数据格式</title>
    <link href="http://zhuuu.work/2020/07/14/assembly/%E6%B1%87%E7%BC%96-04-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/07/14/assembly/%E6%B1%87%E7%BC%96-04-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</id>
    <published>2020-07-14T11:40:41.000Z</published>
    <updated>2020-08-12T01:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-04-数据格式"><a href="#汇编-04-数据格式" class="headerlink" title="汇编-04-数据格式"></a>汇编-04-数据格式</h1><h2 id="1-数据宽度"><a href="#1-数据宽度" class="headerlink" title="1. 数据宽度"></a>1. 数据宽度</h2><ul><li>bit ： 1位</li><li>Byte ： 8 位</li><li>Word  ： 16 位</li><li>DWord : 32 位</li></ul><p><strong>java需要定义数据的类型</strong></p><ul><li>位： 0    1 （1位）</li><li>字节：0 - 0xFF （8位）</li><li>字 : 0 - 0xFFFF  （16位）</li><li>双字：0 - 0xFFFF FFFF （32位）</li></ul><h2 id="2-有符号数和无符号数"><a href="#2-有符号数和无符号数" class="headerlink" title="2. 有符号数和无符号数"></a>2. 有符号数和无符号数</h2><p><strong>本质是为了数据的正负号</strong></p><ul><li><p><strong>无符号数</strong></p><ul><li><p>举个例子</p><p><code>1 0 0 1   1 0 1 0</code></p><ul><li><p>十六进制    0x9A</p></li><li><p>十进制   154</p></li></ul></li></ul></li></ul><ul><li><p><strong>有符号数（最高位1：负数  最高位0：负数）</strong></p><ul><li><p>最高位是符号位</p></li><li><p>举个例子</p><p><code>1 0 0 1  1 0 1 0</code></p><ul><li>十六进制：？？？</li><li>十进制：？？？</li><li>这里？？？是为了引出<strong>（源码，反码和补码的概念）</strong></li></ul></li></ul></li></ul><h2 id="3-原码，反码，补码"><a href="#3-原码，反码，补码" class="headerlink" title="3. 原码，反码，补码"></a>3. 原码，反码，补码</h2><ul><li>编码规则<ul><li><strong>有符号的编码规则</strong></li><li><strong>原码</strong>：最高位是符号位，其他位就是自己的绝对值</li><li><strong>反码</strong>：<ul><li>正数：反码和原码一样的</li><li><strong>负数：符号位一定是1，其他位对原码取反。</strong></li></ul></li><li><strong>补码</strong>：<ul><li>正数：反码和补码相同</li><li><strong>负数：符号位一定是1，其他位对原码取反后 + 1（也就是对反码加1）</strong></li></ul></li></ul></li></ul><a id="more"></a><p><strong>测试：这都是二进制的规则</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">8位举例</span><br><span class="line"></span><br><span class="line">1. 如果是正数，都是一样的</span><br><span class="line">写出 1 的原码，反码，补码</span><br><span class="line">原码：0000 0001</span><br><span class="line">反码：0000 0001</span><br><span class="line">补码：0000 0001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 如果是负数 -1</span><br><span class="line">写出 -1 的原码，反码，补码</span><br><span class="line">原码：1000 0001</span><br><span class="line">反码：1111 1110</span><br><span class="line">补码：1111 1111</span><br><span class="line"></span><br><span class="line">3. 再来一个例子 -7</span><br><span class="line">写出 -7 的原码，反码，补码</span><br><span class="line">原码：1000 0111</span><br><span class="line">反码：1111 1000</span><br><span class="line">补码：1111 1001</span><br><span class="line"></span><br><span class="line">4. ff（有符号）</span><br><span class="line">原码 ： 1111 1111</span><br><span class="line">反码 ： 1000 0000</span><br><span class="line">补码 ： 1000 0001</span><br></pre></td></tr></table></figure><p><strong>这些知识都是为了后面的位运算。</strong></p><h2 id="4-为什么要使用原码-反码和补码"><a href="#4-为什么要使用原码-反码和补码" class="headerlink" title="4. 为什么要使用原码, 反码和补码"></a>4. 为什么要使用原码, 反码和补码</h2><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 &#x3D; [00000001]补</span><br></pre></td></tr></table></figure><p>所以不需要过多解释. 但是对于负数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-<span class="number">1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反 = [<span class="number">11111111</span>]补</span><br></pre></td></tr></table></figure><p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p><p>对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p><ol><li><strong>如果使用原码进行计算</strong></li></ol><p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算十进制表达式 1 - 1&#x3D; 0</span><br><span class="line">1 - 1 &#x3D; 1 + (-1) &#x3D; [00000001]原 + [10000001]原 &#x3D; [10000010]原 &#x3D; -2</span><br></pre></td></tr></table></figure><p><strong>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</strong></p><ol start="2"><li><strong>使用反码的话</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算十进制的表达式: 1-1&#x3D;0</span><br><span class="line"> 1 - 1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原 + [1000 0001]原&#x3D; [0000 0001]反 + [1111 1110]反 &#x3D; [1111 1111]反 &#x3D; [1000 0000]原 &#x3D; -0</span><br></pre></td></tr></table></figure><p><strong>发现如果使用反码进行计算，结果的真值部分是正确的。而唯一的问题其实就出现在”0” 这个特殊的数值上，虽然人们理解的<code>+0 和 -0</code> 是一样的，但是0带有符号是没有意义的，而且会出现[0000 0000]原和[1000 0000]原两个编码表示0.</strong></p><ol start="3"><li><strong>于是补码的出现解决了0的符号和两个编码的问题</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原 + [1000 0001]原 &#x3D; [0000 0001]补 + [1111 1111]补 &#x3D; [0000 0000]补&#x3D;[0000 0000]原</span><br></pre></td></tr></table></figure><p>这样的话 <code>+ 0和 -0</code>的问题就不存在了，而且可以使用[1000 0000] 表示 -128</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1) + (-127) &#x3D; [1000 0001]原 + [1111 1111]原 &#x3D; [1111 1111]补 + [1000 0001]补 &#x3D; [1000 0000]补</span><br></pre></td></tr></table></figure><ul><li><p><strong>-1 - 127的结果应该是-128 ， 在用补码运算的结果中, [1000 0000]补 就是-128.</strong></p></li><li><p><strong>但是注意因为实际上是使用以前的 - 0 来表示 -128 ，所以 -128 没有原码和反码的表示。（对 -128的补码表示[1000 0000]补  算出来的原码[0000 0000]原，这是不正确的）</strong></p></li><li><p><strong>使用补码的话，不仅仅修复了 0 的符号存在的两个编码的表示，而且还能多表示一个最低数字，这就是为什么8位二进制，使用原码或者反码的表示范围是[-127,127]。但是使用补码表示的范围就是[-128,127]</strong></p></li><li><p><strong>因为计算机使用补码，所以对于编程中常用的<code>32位int类型</code>，可以表示的范围的范围是<code>[-2^31,2^31-1]</code> 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</strong></p></li></ul><h2 id="5-原码，反码，补码再深入"><a href="#5-原码，反码，补码再深入" class="headerlink" title="5. 原码，反码，补码再深入"></a>5. 原码，反码，补码再深入</h2><ul><li>计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?</li><li>将钟表想象成一个1位的12进制数，如果当前时间是6点，我希望时间设置为4点，需要怎么做？<ul><li><ol><li>往回拨2个小时 6 -2 = 4</li><li>往前拨10个小时 （6+10）mod 12 = 4</li><li>往前拨10 + 12 = 12 个小时 (6+22) % 12 = 4</li></ol></li><li>2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4.</li><li>所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!</li><li>现在问题的焦点是如何用一个正数，来替代一个负数，上面的例子我们能感觉出来一些端倪, 发现一些规律. 但是数学是严谨的. 不能靠感觉.</li></ul></li></ul><ul><li><p><strong>首先介绍一个数学中的概念：同余</strong></p><ul><li>两个正数a,b 若它们整除m所得的余数相等，则称 a, b 对于模m同余</li><li>记作  <code>a ≡ b (mod m)</code></li><li>读作 a 与 b 关于模 m 同余。</li></ul><p>举例说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 mod 12 &#x3D; 4</span><br><span class="line"></span><br><span class="line">16 mod 12 &#x3D; 4</span><br><span class="line"></span><br><span class="line">28 mod 12 &#x3D; 4</span><br></pre></td></tr></table></figure><p>所以4, 16, 28关于模 12 同余.</p></li></ul><ul><li><p><strong>负数取模</strong></p><ul><li><p>正数进行mod运算是很简单的. 但是负数呢?</p></li><li><p><strong>下面是关于mod运算的数学定义：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200716/195329829.jpg" alt="mark"></p><ul><li><p><code>x mod y = x - yL x/y J</code>(上面是截图, “取下界”符号找不到如何输入(word中粘贴过来后乱码). 下面是使用”L”和”J”替换上图的”取下界”符号:)</p></li><li><p>x mod y等于 x 减去 y 乘上 x与y的商的下界.</p></li><li><p>以 -3 mod 2 举例:</p><blockquote><p>-3 mod 2</p><p>= -3 - 2xL -3/2 J</p><p>= -3 - 2xL-1.5J</p><p>= -3 - 2x(-2)</p><p>= -3 + 4 = 1</p></blockquote></li><li><blockquote><p>(-2) mod 12 = 12-2=10</p><p>(-4) mod 12 = 12-4 = 8</p><p>(-5) mod 12 = 12 - 5 = 7</p></blockquote></li></ul></li></ul></li></ul><ul><li><p><strong>再回到时钟问题</strong></p><ul><li><blockquote><p>回拨2小时 = 前拨10小时</p><p>回拨4小时 = 前拨8小时</p><p>回拨5小时= 前拨7小时</p></blockquote></li><li><p>注意, 这里发现的规律!</p><p>结合上面学到的同余的概念.实际上:</p></li><li><blockquote><p>(-2 ) mod 12 = 10</p><p>10 mod 12 = 10</p><p>所以说 -2 和 10 是同余的</p></blockquote></li><li><blockquote><p>同时， -4 和 8 也是同余的</p><p>（-4 ）mod 12 = 8</p><p>8    mod 12  = 8</p></blockquote></li></ul></li></ul><ul><li><p>要实现用正数替代负数, 只需要运用同余数的两个定理:</p><ul><li><p>反身性:这个定理是很显而易见的.</p><blockquote><p>a ≡ a (mod m)</p></blockquote></li><li><p>线性运算定理</p><blockquote><p>如果a ≡ b (mod m)，c ≡ d (mod m) 那么:</p><p>(1)a ± c ≡ b ± d (mod m)</p><p>(2)a * c ≡ b * d (mod m)</p><p>如果想看这个定理的证明, 请看:<a href="http://baike.baidu.com/view/79282.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/79282.htm</a></p></blockquote></li><li><blockquote><p>所以说：</p><p>7 ≡ 7 (mod 12)</p><p>(-2) ≡ 10 (mod 12)</p><p>7 -2 ≡ 7 + 10 (mod 12)</p></blockquote></li><li><p><strong>现在我们为一个负数，找到了它的正数的同余数，但是并不是 <code>7 -2 = 7 + 10</code> ，而是 <code>7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等.</code></strong></p></li></ul></li></ul><ul><li>接下来回到二进制的问题上, 看一下: 2-1=1的问题.<ul><li><code>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反</code></li><li>先走到这一步， <code>-1 的反码表示 是 1111 1110</code> ,如果这里将<code>[1111 1110]</code>认为是原码,那么<code>[1111 1110]</code> = <code>-126</code> ，这里将符号位除去，即认为是 126</li><li>发现如下规律<ul><li><code>(-1) mod 127 =126</code></li><li><code>126 mod 127 = 126</code></li></ul></li><li>即有如下表达式<ul><li><code>(-1) ≡ 126 (mod 127)</code></li><li><code>2 - 1 ≡ 2 + 126(mod 127)</code></li><li><strong>2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1</strong></li></ul></li></ul></li></ul><ul><li><p><strong>所以说一个数的反码，实际上是这个书对于一个数模的同余数，而这个模并不是我们的二进制，而是所能表达的最大值。</strong></p></li><li><p>这就和钟表是一样的了，转了一个圈之后，总能在可表达范围内找打一个正确的数值。</p></li><li><p>而 <code>2 + 126</code> 很明显先当与钟表过了一轮，而符号位是参与计算的，正好和溢出的最高位形成正确的结果</p></li><li><p><strong>既然反码可以将减法变成加法。那么现在计算机使用的补码呢？为什么在反码的基础上加1 ，还能得到正确的结果？</strong></p><ul><li><blockquote><p>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补</p><p>如果将 [1111 1111] 当作原码，去除符号位，则 [0111 1111] = 127</p><p>其实 在反码的基础上 + 1 就相当于增加了模的值</p><p>(-1) mod 128 = 127</p><p>127 mod 128 = 127</p><p>2-1 ≡ 2+127 (mod 128)</p></blockquote></li></ul></li><li><p>此时，表盘相当于每128个刻度转一轮，所以用补码表示的结果最大值和最小值[-128, 128].</p></li><li><p>但是由于0的特殊情况，没有办法表达128，所以补码的范围是[-128,127]</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-04-数据格式&quot;&gt;&lt;a href=&quot;#汇编-04-数据格式&quot; class=&quot;headerlink&quot; title=&quot;汇编-04-数据格式&quot;&gt;&lt;/a&gt;汇编-04-数据格式&lt;/h1&gt;&lt;h2 id=&quot;1-数据宽度&quot;&gt;&lt;a href=&quot;#1-数据宽度&quot; class=&quot;headerlink&quot; title=&quot;1. 数据宽度&quot;&gt;&lt;/a&gt;1. 数据宽度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;bit ： 1位&lt;/li&gt;
&lt;li&gt;Byte ： 8 位&lt;/li&gt;
&lt;li&gt;Word  ： 16 位&lt;/li&gt;
&lt;li&gt;DWord : 32 位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;java需要定义数据的类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位： 0    1 （1位）&lt;/li&gt;
&lt;li&gt;字节：0 - 0xFF （8位）&lt;/li&gt;
&lt;li&gt;字 : 0 - 0xFFFF  （16位）&lt;/li&gt;
&lt;li&gt;双字：0 - 0xFFFF FFFF （32位）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-有符号数和无符号数&quot;&gt;&lt;a href=&quot;#2-有符号数和无符号数&quot; class=&quot;headerlink&quot; title=&quot;2. 有符号数和无符号数&quot;&gt;&lt;/a&gt;2. 有符号数和无符号数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本质是为了数据的正负号&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;无符号数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;举个例子&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 0 0 1   1 0 1 0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;十六进制    0x9A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;十进制   154&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;有符号数（最高位1：负数  最高位0：负数）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最高位是符号位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举个例子&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 0 0 1  1 0 1 0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十六进制：？？？&lt;/li&gt;
&lt;li&gt;十进制：？？？&lt;/li&gt;
&lt;li&gt;这里？？？是为了引出&lt;strong&gt;（源码，反码和补码的概念）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-原码，反码，补码&quot;&gt;&lt;a href=&quot;#3-原码，反码，补码&quot; class=&quot;headerlink&quot; title=&quot;3. 原码，反码，补码&quot;&gt;&lt;/a&gt;3. 原码，反码，补码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编码规则&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有符号的编码规则&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原码&lt;/strong&gt;：最高位是符号位，其他位就是自己的绝对值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反码&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;正数：反码和原码一样的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负数：符号位一定是1，其他位对原码取反。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;补码&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;正数：反码和补码相同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负数：符号位一定是1，其他位对原码取反后 + 1（也就是对反码加1）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-面试题29-顺时针打印矩阵</title>
    <link href="http://zhuuu.work/2020/07/13/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://zhuuu.work/2020/07/13/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</id>
    <published>2020-07-13T07:52:53.000Z</published>
    <updated>2020-07-14T00:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-面试题29-顺时针打印矩阵"><a href="#Leetcode-面试题29-顺时针打印矩阵" class="headerlink" title="Leetcode-面试题29- 顺时针打印矩阵"></a>Leetcode-面试题29-<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener"> 顺时针打印矩阵</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><a id="more"></a><h2 id="方法：边界模拟"><a href="#方法：边界模拟" class="headerlink" title="方法：边界模拟"></a>方法：边界模拟</h2><blockquote><p>根据题目示例 matrix = [[1,2,3],[4,5,6],[7,8,9]] 的对应输出 [1,2,3,6,9,8,7,4,5] 可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。</p></blockquote><ul><li>在考虑设定矩阵的 “左 上 右 下” 四个边界，模拟矩阵的遍历顺序。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/082353859.png" alt="mark"></p><p><strong>算法思想</strong></p><ol><li>处理空值：当<code>matrix</code> 为空的时候，直接返回空列表[] 即可</li><li>初始化：矩阵的四个边界 <code>l r t b</code> 用于打印结果列表 <code>res</code></li><li>循环打印： “从左到右 从上到下 从右到左 从下到上” 四个方法循环，每个方向打印做以下三件事情（各个方法具体信息见下表）<ul><li>根据边界打印，将元素添加到res的尾部</li><li>边界向内收缩1（代表已被打印）</li><li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li></ul></li></ol><ol start="4"><li>返回值：返回<code>res</code> 即可</li></ol><table><thead><tr><th>打印方向</th><th>1. 根据边界打印</th><th>2. 边界向内收缩</th><th>3. 是否打印完毕</th></tr></thead><tbody><tr><td>从左向右</td><td>左边界<code>l</code> ，右边界 <code>r</code></td><td>上边界 t  加 1</td><td>是否 t &gt; b</td></tr><tr><td>从上到下</td><td>上边界<code>t</code> ,   下边界<code>b</code></td><td>右边界 r  减 1</td><td>是否 l &gt; r</td></tr><tr><td>从右到左</td><td>右边界<code>r</code> ,    左边界<code>l</code></td><td>下边界 b 减 1</td><td>是否 t &gt; b</td></tr><tr><td>从下到上</td><td>下边界<code>b</code> ,    上边界<code>t</code></td><td>左边界 l  加  1</td><td>是否 l &gt; r</td></tr></tbody></table><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083602650.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083658901.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083708848.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083717288.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083725658.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200714/083732833.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顺时针方向</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = matrix.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// left to right</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r ; i++) &#123;</span><br><span class="line">                res[index] = matrix[t][i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ++t ：先给t加1，然后用t的新值</span></span><br><span class="line">            <span class="comment">// t++ : 先用t的原值，然后t加1；</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// top to bottom</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b ; i++) &#123;</span><br><span class="line">                res[index] = matrix[i][r];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// right to left</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l ; i--) &#123;</span><br><span class="line">                res[index] = matrix[b][i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// bottom to top</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t ; i--) &#123;</span><br><span class="line">                res[index] = matrix[i][l];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java 代码利用了 ++ 操作的便利性，详情可见 ++i 和 i++ 的区别 ；</span><br><span class="line"></span><br><span class="line">res[x++] 等价于先给 res[x] 赋值，再给 x 自增 <span class="number">1</span>；</span><br><span class="line">++t &gt; b 等价于先给 t 自增 <span class="number">1</span> ，再判断 t &gt; b 逻辑表达式</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度 O(MN)</strong> ： M, N分别为矩阵行数和列数。</li><li><strong>空间复杂度 O(1)</strong> ： 四个边界 l , r , t , b 使用常数大小的 额外 空间（ res 为必须使用的空间）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-面试题29-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#Leetcode-面试题29-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-面试题29- 顺时针打印矩阵&quot;&gt;&lt;/a&gt;Leetcode-面试题29-&lt;a href=&quot;https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 顺时针打印矩阵&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= matrix.length &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= matrix[i].length &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>长连接-短连接</title>
    <link href="http://zhuuu.work/2020/07/11/NetworkCoding/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>http://zhuuu.work/2020/07/11/NetworkCoding/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5/</id>
    <published>2020-07-11T03:02:24.000Z</published>
    <updated>2020-09-15T08:35:21.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="长连接-短连接"><a href="#长连接-短连接" class="headerlink" title="长连接-短连接"></a>长连接-短连接</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>先看网络上文章都是怎么写的</strong></p><ul><li>http长连接和短连接</li><li>HTTP1.0协议不支持长连接，从HTTP1.1协议以后，<strong>连接默认都是长连接</strong></li></ul><p><strong>解</strong></p><ul><li><p>网络上很多文章都是误人子弟，根本没有说明白这个概念。这里要强调一下，HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。</p></li><li><p>之所以<strong>网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接</strong>。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。</p></li><li><p>HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。</p></li><li><p>实际上，说HTTP请求和HTTP响应会更准确一些，而HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的。</p></li></ul><a id="more"></a><h2 id="1-TCP长连接的实现"><a href="#1-TCP长连接的实现" class="headerlink" title="1. TCP长连接的实现"></a>1. TCP长连接的实现</h2><ul><li><p>第一个问题是，是不是只要设置<code>Connection</code>为<code>keep-alive</code>就算是长连接了？</p><ul><li>当然是的，但要服务器和客户端都设置</li></ul></li><li><p>第二个问题是，我们平时用的是不是长连接？</p><ul><li>这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。</li><li>而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）</li></ul></li><li><p>第三个问题，也是LZ之前最想不明白的问题，那就是我们这种普通的Web应用（比如我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？</p><ul><li>问题的答案是好处还是有的。</li><li><strong>首先，刚才已经说了，长连接是为了复用</strong>，这个在之前LZ就明白。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，<strong>多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。</strong><ul><li>比如你请求了一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源就不用LZ去说了吧。</li><li>但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。</li></ul></li></ul></li><li><p><strong>另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的</strong>。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。</p><ul><li>这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。</li><li>现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？</li></ul></li></ul><h2 id="2-长轮询和短轮询"><a href="#2-长轮询和短轮询" class="headerlink" title="2. 长轮询和短轮询"></a>2. 长轮询和短轮询</h2><ul><li><strong>短轮询</strong>相信大家都不难理解，比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量（相信这个大家都不陌生，随便打开淘宝或者京东都能找到这种页面）。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。<ul><li>最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。</li><li>这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。</li></ul></li></ul><ul><li><strong>长轮询</strong>这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。</li></ul><p><strong>长轮询的优点</strong></p><ul><li>而对于客户端来说，不管是长轮询还是短轮询，<strong>客户端的动作都是一样的，就是不停的去请求</strong>，<strong>不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果</strong>，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。</li><li>这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。</li></ul><p><strong>长轮询的缺点</strong></p><ul><li>但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。</li></ul><p><strong>总结</strong></p><ul><li>因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。</li></ul><h2 id="3-长短轮询和长短连接的区别"><a href="#3-长短轮询和长短连接的区别" class="headerlink" title="3. 长短轮询和长短连接的区别"></a>3. 长短轮询和长短连接的区别</h2><p><strong>第一个区别是决定的方式</strong></p><ul><li>一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。</li><li>而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。</li></ul><p><strong>第二个区别是实现的方式</strong></p><ul><li><p>连接的长短是通过协议来规定和实现的</p></li><li><p>而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。</p></li></ul><p><strong>参考博客 ：</strong> <a href="https://www.jianshu.com/p/3fc3646fad80" target="_blank" rel="noopener">https://www.jianshu.com/p/3fc3646fad80</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;长连接-短连接&quot;&gt;&lt;a href=&quot;#长连接-短连接&quot; class=&quot;headerlink&quot; title=&quot;长连接-短连接&quot;&gt;&lt;/a&gt;长连接-短连接&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;先看网络上文章都是怎么写的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http长连接和短连接&lt;/li&gt;
&lt;li&gt;HTTP1.0协议不支持长连接，从HTTP1.1协议以后，&lt;strong&gt;连接默认都是长连接&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网络上很多文章都是误人子弟，根本没有说明白这个概念。这里要强调一下，HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;之所以&lt;strong&gt;网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接&lt;/strong&gt;。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实际上，说HTTP请求和HTTP响应会更准确一些，而HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-面试题16.11-跳水板</title>
    <link href="http://zhuuu.work/2020/07/10/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9816.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/"/>
    <id>http://zhuuu.work/2020/07/10/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9816.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/</id>
    <published>2020-07-10T07:52:53.000Z</published>
    <updated>2020-07-10T06:49:49.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-面试题-16-11-跳水板"><a href="#Leetcode-面试题-16-11-跳水板" class="headerlink" title="Leetcode-面试题 16.11. 跳水板"></a>Leetcode-<a href="https://leetcode-cn.com/problems/diving-board-lcci/" target="_blank" rel="noopener">面试题 16.11. 跳水板</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p><p>返回的长度需要从小到大排列。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter = <span class="number">1</span></span><br><span class="line">longer = <span class="number">2</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">输出： &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt; shorter &lt;= longer</li><li>0 &lt;= k &lt;= 100000</li></ul><a id="more"></a><h2 id="方法：数学"><a href="#方法：数学" class="headerlink" title="方法：数学"></a>方法：数学</h2><ul><li><strong>首先考虑两种边界情况</strong><ul><li>如果K = 0 ,那么不能创建任何水板，因此返回空数组。</li><li>如果 shorter 和 longer相等，则建造的跳水板的长度是唯一的，都等于 shorter∗k，因此返回长度为 1 的数组，数组中的元素为 shorter*k。</li></ul></li></ul><ul><li><strong>然后考虑一般情况</strong>，即 <code>shorter &lt; longer</code> 且 <code>k &gt; 0</code> ，由于短木板和长木板一共使用 k 块 ，所以一共有<code>K + 1</code>中组合，也就是 <code>k + 1</code>种长度<ul><li><strong>先说结论，假设使用了 i 块 长木板，那么使用了短木板就是 (k - i )块。表达式如下</strong></li><li>对于<code>i</code> 属于<code>[0,k]</code>  <code>length[i] = shorter * (k - i) + longer * i</code></li><li><strong>为什么每种组合下建造的跳水板长度都是不一样的？</strong>证明如下：<ul><li>第一种情况，有i 块 长木板，那么长度是<code>shorter * (k - i) + longer * i</code></li><li>第二种情况，有 j 块长木板，那么长度是<code>shorter * (k - j) + longer * j</code></li><li>两式相减，得：</li><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200710/144501891.png" alt="mark"></li><li>其中(longer &gt; shorter ) 并且 （i &lt; j ），所以乘积小于0，所以任何两种组合下的跳水板长度都是不一样的，使用的长木板越多，跳水板的长度越大。</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200710/144933674.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200710/144946336.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 长木板和短木板长度相等</span></span><br><span class="line">        <span class="keyword">if</span> (shorter == longer)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;shorter * k&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一共有 k + 1种不同长度</span></span><br><span class="line">        <span class="comment">// 假设有i块长板子,短板子就是k - i块</span></span><br><span class="line">        <span class="keyword">int</span>[] lengths = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            lengths[i] = shorter*(k - i) + longer * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lengths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(k)，其中 k 是木板数量。短木板和长木板一共使用 k块，一共有k+1 种组合，对于每种组合都要计算跳水板的长度。</p></li><li><p>空间复杂度：O(1)。除了返回值以外，额外使用的空间复杂度为常数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-面试题-16-11-跳水板&quot;&gt;&lt;a href=&quot;#Leetcode-面试题-16-11-跳水板&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-面试题 16.11. 跳水板&quot;&gt;&lt;/a&gt;Leetcode-&lt;a href=&quot;https://leetcode-cn.com/problems/diving-board-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 16.11. 跳水板&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。&lt;/p&gt;
&lt;p&gt;返回的长度需要从小到大排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shorter = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;longer = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt; shorter &amp;lt;= longer&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= k &amp;lt;= 100000&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://zhuuu.work/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-内存泄漏</title>
    <link href="http://zhuuu.work/2020/07/08/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://zhuuu.work/2020/07/08/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2020-07-08T09:34:38.000Z</published>
    <updated>2020-09-19T14:30:16.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-内存泄漏"><a href="#Java-基础-内存泄漏" class="headerlink" title="Java-基础-内存泄漏"></a>Java-基础-内存泄漏</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-基础-内存泄漏&quot;&gt;&lt;a href=&quot;#Java-基础-内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-内存泄漏&quot;&gt;&lt;/a&gt;Java-基础-内存泄漏&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="内存泄漏" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JUC-15-线程和进程总结</title>
    <link href="http://zhuuu.work/2020/07/05/JUC/JUC-15-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/07/05/JUC/JUC-15-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-07-05T14:02:24.000Z</published>
    <updated>2020-07-21T06:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-15-线程和进程总结"><a href="#JUC-15-线程和进程总结" class="headerlink" title="JUC-15-线程和进程总结"></a>JUC-15-线程和进程总结</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><p>根本区别：<strong>进程</strong>是<strong>操作系统资源分配</strong>的基本单位，而<strong>线程</strong>是<strong>任务调度和执行的基本单位</strong>。</p><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><ul><li>一个在内存中应用的程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200706/143558022.png" alt="mark"></p><a id="more"></a><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><ul><li>线程也叫做轻量级进程，在一个进程中可以创建多个线程。（进程中的一个执行单元，一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。）</li><li>与进程不同的是同类的<strong>多个线程共享进程的堆和方法区（JDK1.8之后是元空间）资源</strong>，每个线程有自己的<strong>程序计数器，虚拟机栈和本地方法栈</strong>。所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><h3 id="1-3-进程和线程区别总结"><a href="#1-3-进程和线程区别总结" class="headerlink" title="1.3 进程和线程区别总结"></a>1.3 进程和线程区别总结</h3><ul><li><strong>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</strong></li><li><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>内存分配</strong>：同一个进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</li><li><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li><li><strong>执行过程</strong>：每个独立的进程都有程序运行的入口，执行顺序和程序出口。但是线程不能单独执行，必须依存在应用程序之中，由引用程序提供多个线程的执行控制。</li></ul><h2 id="2-从-JVM-角度说进程和线程之间的关系（重要）"><a href="#2-从-JVM-角度说进程和线程之间的关系（重要）" class="headerlink" title="2. 从 JVM 角度说进程和线程之间的关系（重要）"></a>2. 从 JVM 角度说进程和线程之间的关系（重要）</h2><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200706/144649712.png" alt="mark"></p><p>从上图可以明显的看出：</p><ul><li><strong>一个进程中可以有多个线程</strong>，</li><li><strong>多个线程共享进程的堆和方法区</strong></li><li><strong>但是每个线程有自己独立的程序计数器，虚拟机栈和本地方法栈</strong></li></ul><h3 id="2-2-程序计数器为什么是私有的？"><a href="#2-2-程序计数器为什么是私有的？" class="headerlink" title="2.2 程序计数器为什么是私有的？"></a>2.2 程序计数器为什么是私有的？</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，<strong>从而实现代码的流程控制</strong>，如：顺序执行，选择，循环，异常处理。</li><li>在<strong>多线程的场景下，程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪里了。</li></ol><p>需要注意的是，如果运行的是native方法，那么程序计数器记录的是undefined地址，只有执行java代码才能知道下一条指令的地址。</p><p><strong>所以，程序计数器的私有主要是为了线程切换后能够恢复到正确的执行位置</strong></p><h3 id="2-3-虚拟机栈和本地方法栈为什么是私有的？"><a href="#2-3-虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="2.3 虚拟机栈和本地方法栈为什么是私有的？"></a>2.3 虚拟机栈和本地方法栈为什么是私有的？</h3><ul><li><strong>虚拟机栈</strong>： 每个java方法在执行的同时会创建一个栈<strong>帧用于存储局部变量表，操作数栈，常量池的引用，方法返回地址。</strong>从方法调用直至执行完成的过程，对应着一个栈帧在java虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈</strong>：和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p><strong>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</strong></p><h3 id="2-4-一句话了解堆和方法区"><a href="#2-4-一句话了解堆和方法区" class="headerlink" title="2.4 一句话了解堆和方法区"></a>2.4 一句话了解堆和方法区</h3><ul><li>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象(所有对象都在这里分配内存)，</li><li><strong>方法区</strong>主要存放<strong>已被加载的类信息</strong>，<strong>常量</strong>，<strong>静态变量</strong>（常量和静态变量统称为常量池），<strong>即时编译后的代码数据</strong></li></ul><h2 id="3-多线程和多进程的区别"><a href="#3-多线程和多进程的区别" class="headerlink" title="3. 多线程和多进程的区别"></a>3. 多线程和多进程的区别</h2><ul><li>多进程：操作系统中同时运行的多个程序</li><li>多线程：在同一个进程中同时运行的多个任务。</li></ul><p>举个例子，多线程下载软件，可以同时运行多个线程，但是通过程序运行的结果发现，每一次结果都不一致。 因为多线程存在一个特性：<strong>随机性</strong>。造成的原因：<strong>CPU在瞬间不断切换去处理各个线程而导致的，可以理解成多个线程在抢CPU资源。</strong></p><p><strong>多线程提高CPU使用率</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200706/145943289.jpg" alt="mark"></p><p>注意的是：</p><ul><li>多线程并不能提高运行速度，但是可以提高运行效率，因为让CPU的使用率更高</li><li>但是如果多线程有安全访问问题或者出现频繁的上下文切换的时候，运行的速率可能反而会降低。</li></ul><h2 id="4-Java中的多线程"><a href="#4-Java中的多线程" class="headerlink" title="4. Java中的多线程"></a>4. Java中的多线程</h2><ul><li>Java程序中的线程<ul><li><strong>main线程</strong></li><li><strong>GC(垃圾回收线程)（是一个守护线程）</strong></li></ul></li><li><strong>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，</strong>而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li><li><strong>Java支持多线程，当Java程序执行main方法的时候，就是在执行一个名字叫做main的线程，可以在main方法执行时，开启多个线程A,B,C，多个线程 main,A,B,C同时执行，相互抢夺CPU</strong></li><li><strong>Thread类是java.lang包下的一个常用类，每一个Thread类的对象，都代表一个处理某种状态的线程。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-15-线程和进程总结&quot;&gt;&lt;a href=&quot;#JUC-15-线程和进程总结&quot; class=&quot;headerlink&quot; title=&quot;JUC-15-线程和进程总结&quot;&gt;&lt;/a&gt;JUC-15-线程和进程总结&lt;/h1&gt;&lt;h2 id=&quot;1-进程和线程&quot;&gt;&lt;a href=&quot;#1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;1. 进程和线程&quot;&gt;&lt;/a&gt;1. 进程和线程&lt;/h2&gt;&lt;p&gt;根本区别：&lt;strong&gt;进程&lt;/strong&gt;是&lt;strong&gt;操作系统资源分配&lt;/strong&gt;的基本单位，而&lt;strong&gt;线程&lt;/strong&gt;是&lt;strong&gt;任务调度和执行的基本单位&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-1-进程&quot;&gt;&lt;a href=&quot;#1-1-进程&quot; class=&quot;headerlink&quot; title=&quot;1.1 进程&quot;&gt;&lt;/a&gt;1.1 进程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个在内存中应用的程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200706/143558022.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程和线程" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二分查找-合集总结</title>
    <link href="http://zhuuu.work/2020/07/02/LeetcodeExplore/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/07/02/LeetcodeExplore/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%90%88%E9%9B%86/</id>
    <published>2020-07-02T07:52:53.000Z</published>
    <updated>2020-07-22T07:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找-合集总结"><a href="#二分查找-合集总结" class="headerlink" title="二分查找-合集总结"></a>二分查找-合集总结</h1><p>（本系列是针对Leetcode上常见的二分查找题目进行总结。）</p><p><strong>总体思想：把待搜索的目标值留在最后判断，在循环体内不断地把不符合题目要求的子区间排除掉，在退出循环以后，因为只剩下 1 个数没有看到，它要么是目标元素，要么不是目标元素，单独判断即可。</strong></p><p>用这种思路写二分<strong>不容易出错，需要考虑的细节最少</strong>。</p><ul><li>这种思路也非常符合“二分”这个名字，就是把【待搜索的区间】分为【有目标元素的区间】和【不包含目标元素的区间】，排除掉【不包含目标元素的区间】，剩下的就是有【目标元素的区间】。</li></ul><ul><li>初学写二分查找的问题是：跳步厉害，写下 left = mid 或者 right = mid - 1 等代码的时候，一定要搞清楚是什么意思，必要的时候写上注释，帮助自己思考和以后复查代码。</li></ul><ul><li>算法问题建议更多地理解思想，思考为什么这样写，而不建议背代码，背模板。即使要用代码和模板，例如并查集、线段树这种，也应该先把它们保存到自己的 github 代码仓库里，要用的时候去复制粘贴。</li></ul><p><strong>PS：分类是liweiwei老哥总结好的，在他的分类下，下文将以自己的思想将题目串通总结起来。</strong></p><p><strong>二分总结链接</strong>：<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/</a></p><h1 id="1-题目分类"><a href="#1-题目分类" class="headerlink" title="1. 题目分类"></a>1. 题目分类</h1><p><strong>「力扣」上的二分查找问题主要有这三类题型。</strong></p><p><strong>一、在数组中查找符合条件的元素的索引</strong></p><p>一般而言这个数组是有序的，也可能是半有序的，但不大可能是无序的。</p><table><thead><tr><th><strong>题目</strong></th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></td><td>二分查找的模板问题，使用本题解介绍的方法就要注意，需要“后处理”。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></td><td>查找边界问题，<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/" target="_blank" rel="noopener">题解（有视频讲解）</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></td><td>二分查找的思路需要理解，代码很像第 35 题，<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">275. H指数 II</a></td><td><a href="https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></td><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">852. 山脉数组的峰顶索引（简单）</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素（中等）</a></td><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">题解</a>，这个问题二分的写法需要做复杂的分类讨论，可以放在以后做。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a></td><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/" target="_blank" rel="noopener">官方题解（有视频讲解）</a>，<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><p><strong>二、在一个有上下界的区间里搜索一个整数</strong></p><table><thead><tr><th><strong>题目</strong></th><th><strong>提示与题解</strong></th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. 平方根</a></td><td>在一个整数范围里查找一个整数，也是二分查找法的应用场景，<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">题解</a>。在一个整数范围里查找一个整数。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><p><strong>三. 判别条件是一个函数</strong></p><table><thead><tr><th><strong>题目</strong></th><th><strong>提示与题解</strong></th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></td><td>经典问题，判别函数的写法很有技巧，<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a></td><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></td><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><a id="more"></a><h1 id="2-分类1：在数组中查找符合条件的元素的索引"><a href="#2-分类1：在数组中查找符合条件的元素的索引" class="headerlink" title="2. 分类1：在数组中查找符合条件的元素的索引"></a>2. 分类1：在数组中查找符合条件的元素的索引</h1><h2 id="题目1：704-二分查找"><a href="#题目1：704-二分查找" class="headerlink" title="题目1：704. 二分查找"></a>题目1：<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></h2><p><strong>1. 题目描述：</strong></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><p><strong>2.算法思路</strong></p><ul><li>经典的二分查找法（暂时不在这里详细叙述，各位有算法基础的大佬应该闭着眼睛都能写）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log<em>N</em>) &lt; O(N) </li><li>空间复杂度：O(1)</li></ul><p>上述的做法实际上是将<strong>待搜索的区间分为了三个区间</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/164445962.png" alt="mark"></p><p><strong>这种写法的弊端是：返回的边界问题（读者可以想一想弊端具体发生的情况）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/164615121.png" alt="mark"></p><p><strong>接下来提供另外一种：二分查找的思想（排除法）</strong></p><ul><li><strong>mid被分到左边区间</strong></li><li><strong>mid被分到右边区间</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/164822418.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/165100657.png" alt="mark"></p><p><strong>死循环可能产生的原因：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200705/165635068.png" alt="mark"></p><h2 id="题目2：35-搜索插入位置"><a href="#题目2：35-搜索插入位置" class="headerlink" title="题目2：35. 搜索插入位置"></a>题目2：<a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &lt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 什么时候不是解</span></span><br><span class="line">            <span class="comment">// 如果严格小于不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是[mid + 1,right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 相反的区间[left,mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(logN)，这里 N 是数组的长度，每一次都将问题的规模缩减为原来的一半，因此时间复杂度是对数级别的；</li><li>空间复杂度：O(1)。</li></ul><h2 id="题目3：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#题目3：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="题目3：34. 在排序数组中查找元素的第一个和最后一个位置"></a>题目3：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>题目描述：</p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: [-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>算法思想</strong></p><ul><li><code>nums[mid] &lt; target</code> 一定不是开始位置的解</li><li><code>nums[mid] &gt; target</code> 一定不是结束位置的解 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始位置</span></span><br><span class="line">        <span class="keyword">int</span> firstPosition = findFirstPosition(nums,target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果开始位置都没找到这个元素</span></span><br><span class="line">        <span class="keyword">if</span> (firstPosition == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束位置</span></span><br><span class="line">        <span class="keyword">int</span> lastPosition = findLastPosition(nums,target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstPosition,lastPosition&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 下取整</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 什么时候不是解</span></span><br><span class="line">            <span class="comment">// 严格小于不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮 搜索区间[mid + 1,right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nums[mid] &gt;= target</span></span><br><span class="line">                <span class="comment">// 搜索区间是[left,mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对查找的数进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这时候如果向下取整会有死循环的产生</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 上取整</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 大于一定不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是[left,mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是[mid,right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><strong>时间复杂度</strong>：O(log N)，这里 N 是数组的长度，两个子问题都是二分查找，因此时间复杂度为对数级别。</li><li><strong>空间复杂度</strong>：O(1)，只使用了常数个数的辅助变量、指针。</li></ul><h2 id="题目4：33-搜索旋转排序数组"><a href="#题目4：33-搜索旋转排序数组" class="headerlink" title="题目4：33. 搜索旋转排序数组"></a>题目4：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h2><p><strong>题目描述</strong></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>算法思路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法</span></span><br><span class="line"><span class="comment">// 讨论中间元素和有边界的关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="comment">// 使用上取整的中间数，必须在上面的 mid 表达式的括号里 + 1</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                    <span class="comment">// 下一轮搜索区间是[mid,right]</span></span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 只要上面对了，这个区间是上面区间的反面区间，下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt;= nums[right]</span></span><br><span class="line">                <span class="comment">// [left, mid] 有序，但是为了和上一个 if 有同样的收缩行为，</span></span><br><span class="line">                <span class="comment">// 故意强行认为[left, mid - 1]有序</span></span><br><span class="line">                <span class="comment">// 当区间只剩下2个元素的时候 int mid = (left + right + 1) &gt;&gt;&gt; 1 ;一定会取到右边</span></span><br><span class="line">                <span class="comment">// 此时mid - 1不会越界</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid - <span class="number">1</span>])&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 下一轮搜索区间是[mid,right]</span></span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有可能不存在目标元素，因此还需要做一次判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目-5-：-153-寻找旋转排序数组中的最小值"><a href="#题目-5-：-153-寻找旋转排序数组中的最小值" class="headerlink" title="题目 5 ： 153. 寻找旋转排序数组中的最小值"></a>题目 5 ： <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><ul><li>旋转排序数组，几乎都是有序的数组，也可以通过比较特定位置的元素判断达到”减治“的效果（逐渐缩小区间）</li><li>很自然地，我们会看<strong>中间数（</strong>位于待搜索区间中间位置的元素，由于不是有序数组，因此不能称之为<strong>中位数</strong>）。</li></ul><p>这时候有两个思路：</p><ul><li>思路一：看看搜索区间<strong>左边界</strong>和 ”<strong>中间数</strong>“（注意这里不是中位数），是不是可以缩小搜索区间的范围；</li><li>思路 2：看看当前搜索区间的<strong>右边界</strong>和“<strong>中间数</strong>”（注意这里不是中位数），是不是可以缩小搜索区间的范围；</li></ul><p>要想清楚这个问题，我们不妨举几个例子。</p><p><strong>针对思路1：</strong></p><p>例 1：<code>[1, 2, 3, 4, 5]</code></p><p>例 2：<code>[2, 3, 4, 5, 1]</code></p><ul><li>这两个例子中 ”中间数“都比左边界大，但是旋转排序数组的最小值一个在中间数的左边，一个在中间数的右边，因此思路1是不可行的。</li></ul><p><strong>针对思路2</strong></p><p>例 3：<code>[7, 8, 9, 10, 11, 12, 1, 2, 3]</code></p><p>例 4：<code>[7, 8, 1, 2, 3]</code></p><ul><li>中间数 11 比 3 大，因此中间数左边的数字都不可能是旋转排序数组的最小值，因此下一轮搜索的区间是 [mid + 1,right]</li><li>再看例4 ， 中间数到右边界是递增的， 1 比 3 小，那么中间数右边的数一定不是旋转排序数组的最小值，因此可以把中间数右边的数字排除，但是中间数有可能是整个数组的最小值，就如本例子，因此下一轮搜索区间是[left,mid] ,于是右边界 <code>right = mid</code></li></ul><p>从例 3 和例 4 可以看出，<strong>不论中间数比右边界大，还是中间数比右边界小，我们都可以排除掉将近一半的元素，把原始问题转换成一个规模更小的子问题，这正是“减而治之”思想的体现</strong>，<strong>因此思路 2 可行。</strong></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组为空，无最小元素"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nums[mid] &lt; nums[right](不存在重复的数字)</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一定存在最小元素，因此无需再做判断</span></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O（1）</li></ul><h2 id="题目6-：-154-寻找旋转排序数组中的最小值-II"><a href="#题目6-：-154-寻找旋转排序数组中的最小值-II" class="headerlink" title="题目6 ： 154. 寻找旋转排序数组中的最小值 II"></a>题目6 ： <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h2><p><strong>题目描述</strong></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟153题相比</span></span><br><span class="line"><span class="comment">// 数组中可能存在重复的元素。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组为空，无最小元素"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                <span class="comment">// 说明左侧是升序序列</span></span><br><span class="line">                <span class="comment">// 下一轮搜索区间[mid,right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间[left,mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nums[mid] == nums[right]</span></span><br><span class="line">                <span class="comment">// 例 5：[0, 1, 1, 1, 1, 1, 1]</span></span><br><span class="line">                <span class="comment">// 例 6：[1, 1, 1, 1, 0, 1, 1]</span></span><br><span class="line">                <span class="comment">// 目标值可能在中间数的左边，也有可能在中间数的右边</span></span><br><span class="line">                <span class="comment">// 此时看到了右边界，就把右边界排除掉就好了</span></span><br><span class="line">                <span class="comment">// 正是因为右边界和中间数相等，你去掉了右边界，中间数还在，就让中间数在后面的循环中再起效果</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(logn) ,这里不太确定，因为right– 的操作。</li><li>空间复杂度：O（1）</li></ul><h2 id="题目7-：-H指数-II"><a href="#题目7-：-H指数-II" class="headerlink" title="题目7 ： H指数 II"></a>题目7 ： <a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">H指数 II</a></h2><p><strong>题目描述</strong></p><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: citations = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 给定数组表示研究者总共有 <span class="number">5</span> 篇论文，每篇论文相应的被引用了 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span> 次。</span><br><span class="line">     由于研究者有 <span class="number">3</span> 篇论文每篇至少被引用了 <span class="number">3</span> 次，其余两篇论文每篇被引用不多于 <span class="number">3</span> 次，所以她的 h 指数是 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p>说明:</p><p>如果 h 有多有种可能的值 ，h 指数是其中最大的那个。</p><p>进阶：</p><p>这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。<br>你可以优化你的算法到<strong>对数时间复杂度吗？</strong></p><p><strong>方法：二分查找</strong></p><p>题目中说到：</p><blockquote><p>本题中的 citations 数组是保证有序的。</p></blockquote><p>并且还暗示</p><blockquote><p>你可以优化你的算法到对数时间复杂度吗？</p></blockquote><ul><li><p>因此，可以使用二分查找，二分查找这种非对即错的问题，个人觉得根据示例分析是一种不错的方法。</p><ul><li>就根据示例<code>citations = [0, 1, 3, 5, 6]</code>。</li><li>中位数是3，<code>citations[2]</code> 恰好也等于 3，这个 3 正好是边界，不太好分析 ，我把中位数改成了 2。</li><li>即： <code>citiations = [0,1,2,5,6]</code> 此时根据题目的意思，<strong>此时索引位2的那篇论文不能计入 h 指数（因为，如果算进去，则有3篇论文，但是这篇最小引用的文章才被引用两次）</strong></li></ul></li><li><p>因此，分析出 <code>h</code> 指数和以下两个指标有关：</p><ul><li><strong>某个索引 i 的  citiations 的取值</strong></li><li><strong>某个索引 i 到 citiations 末尾的长度，即区间<code>[i, len - 1]</code> 的长度，即 <code>len - 1 -i + 1 = len - i</code>。</strong></li></ul></li><li><p>如果<code>nums[i] &lt; len - i</code> 索引 <code>i</code> 必须后移一位，因此候选区间是<code>[i + 1,len - 1]</code> </p><ul><li>所以二分查找的下一轮区间是<code>left = i + 1</code> </li></ul></li><li><p>如果 <code>nums[i] &gt; len - i</code>的反面一定就是 <code>right = mid</code> ,看到 <code>left = i + 1</code>,可以知道分支排除了中位数，所以不会有死循环。</p></li><li><p>最后，返回的是区间的长度，区间长度是 <code>len - i</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="comment">// 思路：看nums[mid] 和 区间[mid,len - 1] 的长度</span></span><br><span class="line"><span class="comment">// 即 len - 1 - mid + 1 = len - mid</span></span><br><span class="line"><span class="comment">// [0, 1, 2, 5, 6] 为例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = citations.length;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || citations[len - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前的h指数比长度小就去掉这个值</span></span><br><span class="line">            <span class="keyword">if</span> (citations[mid] &lt; len - mid)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// citations[mid] &gt;= len - mid</span></span><br><span class="line">                <span class="comment">// 比长度大是满足的，应该让mid 往左走尝试看有没有更小的mid值</span></span><br><span class="line">                <span class="comment">// 可以满足mid 对应值大于等于从[mid,len - 1]的长度</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logN) N是数组的长度</li><li>空间复杂度：O(1)</li></ul><h2 id="题目8-：-H-指数"><a href="#题目8-：-H-指数" class="headerlink" title="题目8 ：  H 指数"></a>题目8 ： <a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener"> H 指数</a></h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数 不超过 h 次。）</p><p>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：citations &#x3D; [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure><p><strong>提示：本题和上述的区别是不是升序的数组</strong></p><p><strong>算法思路</strong></p><ol><li><strong>和上题一样，二分查找前加一个排序即可</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = citations.length;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || citations[len - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = citations.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比后面的长度小就去掉这个值</span></span><br><span class="line">            <span class="comment">// 区间长度[mid,len - 1]</span></span><br><span class="line">            <span class="comment">// len - 1 - mid + 1</span></span><br><span class="line">            <span class="keyword">if</span> (citations[mid] &lt; len - mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 比后面的长度大，满足条件，下一轮搜索区间[left,right]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回的是这个区间的长度(h指数)</span></span><br><span class="line">        <span class="keyword">return</span> len - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(nlogn)</li><li><strong>空间复杂度</strong>： O（1）</li></ul><h2 id="题目9-：-山脉数组中查找目标值-（困难）"><a href="#题目9-：-山脉数组中查找目标值-（困难）" class="headerlink" title="题目9 ： 山脉数组中查找目标值 （困难）"></a>题目9 ： <a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">山脉数组中查找目标值</a> （困难）</h2><p><strong>题目描述</strong></p><p>（这是一个 交互式问题 ）</p><p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p><p>如果不存在这样的下标 index，就请返回 -1。</p><p>你将 不能直接访问该山脉数组，<strong>必须通过 MountainArray 接口来获取数据</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）</span><br><span class="line">MountainArray.length() - 会返回该数组的长度</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案</strong>。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “答案”：<a href="https://leetcode-cn.com/playground/RKhe3ave，请注意这" target="_blank" rel="noopener">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> 不是一个正确答案。</p><p><strong>方法：三次二分查找</strong></p><ul><li>理解什么是山脉数组，山脉数组可以分为两部分，一部分是<strong>前有序数组</strong>，一部分是<strong>后有序数组</strong></li><li>“前有序数组” 是升序数组，后有序数组是降序数组。</li><li>题目还告诉我们 “对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案” ，就在疯狂暗示你使用时间复杂度低的算法，对于有序数组当然使用 “二分查找法” 。</li></ul><p><strong>算法思路</strong></p><ul><li>求解这道题分为三部分<ul><li>第一步：先找到<code>mountaintop</code> 所在的索引</li><li>第二步：在前有序数组中找target所在的索引，如果找到了就返回，没有找到执行步骤3</li><li>第三步：如果步骤2 找不到，就在后有序降序数组中找<code>target</code> 所在的索引</li></ul></li></ul><ul><li>写出来的 3 个辅助方法的分支逻辑出奇地一样，在取中位数的时候，都取左中位数，才不会发生死循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is MountainArray's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MountainArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MountainArrayImpl</span> <span class="keyword">implements</span> <span class="title">MountainArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MountainArrayImpl</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">this</span>.arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特别注意：3 个辅助方法的分支出奇地一样，因此选中位数均选左中位数，才不会发生死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = mountainArr.length();</span><br><span class="line">        <span class="comment">// 步骤 1：先找到山顶元素所在的索引</span></span><br><span class="line">        <span class="keyword">int</span> mountaintop = findMountaintop(mountainArr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 步骤 2：在前有序且升序数组中找 target 所在的索引</span></span><br><span class="line">        <span class="keyword">int</span> res = findFromSortedArr(mountainArr, <span class="number">0</span>, mountaintop, target);</span><br><span class="line">        <span class="keyword">if</span> (res != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 步骤 3：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引</span></span><br><span class="line">        <span class="keyword">return</span> findFromInversedArr(mountainArr, mountaintop + <span class="number">1</span>, size - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMountaintop</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回山顶元素</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 取左中位数，因为进入循环，数组一定至少有 2 个元素</span></span><br><span class="line">            <span class="comment">// 因此，左中位数一定有右边元素，数组下标不会发生越界</span></span><br><span class="line">            <span class="keyword">if</span> (mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果当前的数比右边的数小，它一定不是山顶</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据题意，山顶元素一定存在，因此退出 while 循环的时候，不用再单独作判断</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFromSortedArr</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在前有序且升序数组中找 target 所在的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.get(mid) &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为不确定区间收缩成 1个数以后，这个数是不是要找的数，因此单独做一次判断</span></span><br><span class="line">        <span class="keyword">if</span> (mountainArr.get(l) == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFromInversedArr</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在后有序且降序数组中找 target 所在的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 与 findFromSortedArr 方法不同的地方仅仅在于由原来的小于号改成大于好</span></span><br><span class="line">            <span class="keyword">if</span> (mountainArr.get(mid) &gt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为不确定区间收缩成 1个数以后，这个数是不是要找的数，因此单独做一次判断</span></span><br><span class="line">        <span class="keyword">if</span> (mountainArr.get(l) == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">3</span>;</span><br><span class="line">        MountainArray mountainArray = <span class="keyword">new</span> MountainArrayImpl(arr);</span><br><span class="line"></span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> res = solution.findInMountainArray(target, mountainArray);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度（OlogN）二分查找法的时间复杂度是对数级别的，这里使用了 3 次二分查找法，是常数倍数，因此可以忽略这个常数系数。</li><li>空间复杂度：O(1) 里使用的额外的辅助空间仅仅是 <code>mountaintop</code>、中位数索引 <code>mid</code> 等，是常数级别，因此空间复杂度为 O(1)。</li></ul><h1 id="3-分类2：在一个有范围的区间内找到一个整数"><a href="#3-分类2：在一个有范围的区间内找到一个整数" class="headerlink" title="3. 分类2：在一个有范围的区间内找到一个整数"></a>3. 分类2：在一个有范围的区间内找到一个整数</h1><h2 id="题目1-：-69：x-的平方根"><a href="#题目1-：-69：x-的平方根" class="headerlink" title="题目1 ： 69：x 的平方根"></a>题目1 ： <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69：x 的平方根</a></h2><p><strong>题目描述</strong></p><ul><li>实现 <code>int sqrt(int x)</code> 函数。</li><li>计算并返回 x 的平方根，其中 x 是非负整数。</li><li>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><p><strong>算法思路:二分查找</strong></p><ul><li><strong>二分查找法要找到左右边界</strong></li><li>一个数的平方根肯定不会超过它自己，还有比较细节的划分，那就是一个数的平方根不会超过它的一半。（比如8的平方根，一半是4，4的平方是16，大于8）</li><li><strong>因此我们要计算一下，这个右边界是多少</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200717/174153415.png" alt="mark"></p><p>意思就是：如果一个数的一般平方大于自己，那么这个数的取值范围。解以上不等式得 <code>a &gt;= 4 或者 a &lt; 0</code></p><ul><li>于是右边界的值就是4，因为边界值要大于0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对0的特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要把搜索的区间设置成长整型</span></span><br><span class="line">        <span class="comment">// 注意：针对特殊测试用例，例如 2147395599</span></span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> right = x/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> square = mid * mid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排除大于不是解</span></span><br><span class="line">            <span class="keyword">if</span> (square &gt; x)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意返回的是整型</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(logN),二分查找的时间复杂度是对数级别的</li><li><strong>空间复杂度</strong>：O(1) 使用了常数个数的辅助空间用于存储</li></ul><h2 id="题目2：-287-寻找重复数"><a href="#题目2：-287-寻找重复数" class="headerlink" title="题目2：  287. 寻找重复数"></a>题目2：  <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h2><p><strong>题目描述</strong></p><ul><li>给定一个包含 <code>n + 1</code>个整数的数组 <code>nums</code>，其数字都在 <code>1 到 n 之间</code>（包括 1 和 n），可知至少存在一个重复的整数。假设<strong>只有一个重复的整数</strong>，找出这个重复的数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><strong>不能更改原数组（假设数组是只读的）。</strong></li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n^2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul><p><strong>Solution：二分法</strong></p><ul><li><p><strong>如果测试数据不在这个范围里，二分法失效</strong>。</p></li><li><p><strong>二分法的常见作用：可以用来确定一个有范围的整数</strong></p></li></ul><ul><li>预备知识：</li></ul><p><strong>抽屉原理</strong>：假设要把10个苹果放进9个柜子，那么一定有一个柜子放了不止一个。</p><p>容易想到的方法有：</p><ul><li>使用哈希表判重，这违反了限制 2；</li><li>将原始数组排序，排序以后，重复的数相邻，即找到了重复数，这违反了限制 1；</li><li>使用类似「力扣」第 41 题：缺失的第一个正数 （原地哈希）的思路，当两个数发现要放在同一个地方的时候，就发现了这个重的元素，这违反了限制 1；</li><li>既然要定位数，这个数恰好是一个整数，可以在「整数的有效范围内」做二分查找，但是比较烦的一点是得反复看整个数组好几次，本题解就介绍通过二分法定位一个有范围的整数；</li><li>还可以使用「快慢指针」来完成，不过这种做法太有技巧性了，不是通用的做法，可以查看官方题解。</li></ul><p><strong>思路：</strong></p><ul><li><p>二分法的思路是先猜一个数（有效范围 <code>[left, right]</code>里的中间数 <code>mid</code>）</p></li><li><p>然后统计原始数组中<strong>小于等于</strong>这个中间数的元素的个数 count , 如果count <strong>严格大于</strong> mid ，注意我加了着重号的部分「小于等于」、「严格大于」）。</p></li><li><p>根据抽屉原理，重复的元素就在区间 <code>[left, mid]</code> 里；</p></li></ul><p><strong>举个例子：</strong></p><ul><li>以<code>[2,4,5,2,3,1,6,7]</code> 为例，一共 8 个数，<code>n + 1 = 8</code>  那么 n = 7 并且根据题目的意思，每个数都在[1,7]之间</li><li>例如：区间[1,7]的中位数是4<ul><li>之后遍历整个数组，统计小于等于4的整数的个数，如果不存在重复元素，最后就是4个。</li><li>等于4的时候区间[1,4]内也可能有重复的元素，比如 [1,2,2,4] 。</li><li>但是,如果整个数组里小于等于4的正数的个数严格大于4 的时候，根据抽屉原理，一定说明重复的数字在[1,4]之间。</li></ul></li></ul><p><strong>Solution : 算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//在 Java 里可以这么用，</span></span><br><span class="line">            <span class="comment">// 当 left + right 溢出的时候，无符号右移保证结果依然正确</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次更新 count 会被重置为0</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计原始数组中小于等于这个中间数元素的个数count</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid)&#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据抽屉原理，count如果严格大于mid个</span></span><br><span class="line">            <span class="comment">// 此时重复元素一定在[1,mid]之间</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid)&#123;</span><br><span class="line">                <span class="comment">// 重复元素位于[left,mid]之间</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重复元素位于[mid + 1, right] 之间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left = right 的时候推出循环，结果就是重复的数字</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(nlogn)</strong> - 二分法的时间复杂度是O(logn) ,并且在二分法内部执行了一次 for 循环 ，时间复杂度是O(n), 所以总的复杂度是O(nlogn)。</li><li><strong>空间复杂度O(1)</strong> : 使用了一个count变量</li></ul><h2 id="题目3-：-374-猜数字大小"><a href="#题目3-：-374-猜数字大小" class="headerlink" title="题目3 ： 374. 猜数字大小"></a>题目3 ： <a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></h2><p><strong>题目描述</strong></p><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 : 我的数字比较小</span><br><span class="line"> 1 : 我的数字比较大</span><br><span class="line"> 0 : 恭喜！你猜对了！</span><br></pre></td></tr></table></figure><p><strong>示例 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10, pick &#x3D; 6</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>算法思想：</strong></p><ol><li><strong>首先得先把guessnum接口先写出来</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuessGame</span></span>&#123;</span><br><span class="line">    <span class="comment">// 比如我猜的数字是6</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guess</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 你和我猜的一样</span></span><br><span class="line">        <span class="keyword">if</span> (num == NUM)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num &lt; NUM)&#123;</span><br><span class="line">            <span class="comment">// 你猜的比我猜的小</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 你猜的比我猜的大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>接下来的思路就很显然了</strong><ul><li>排除猜错的区间 <code>guessNum = -1</code> 的情况，那么下一轮搜索区间是<code>[left,mid - 1]</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> guessNum = guess(mid);</span><br><span class="line">            <span class="keyword">if</span> (guessNum == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 中位数比猜的数大</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一定会猜对</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(logn)</strong></li><li><strong>空间复杂度： O(1)</strong> </li></ul><h2 id="题目4-：-1300-转变数组后最接近目标值的数组和"><a href="#题目4-：-1300-转变数组后最接近目标值的数组和" class="headerlink" title="题目4 ： 1300. 转变数组后最接近目标值的数组和"></a>题目4 ： <a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></h2><p><strong>题目描述</strong></p><p>给你一个整数数组 <code>arr</code> 和一个目标值 <code>target</code> ，请你返回一个<code>整数 value</code> ，<strong>使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。</strong></p><p>如果有多种使得和最接近 <code>target</code> 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 <code>arr</code> 中的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [4,9,3], target &#x3D; 10</span><br><span class="line">输出：3</span><br><span class="line">解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [2,3,5], target &#x3D; 10</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [60864,25176,27249,21296,20204], target &#x3D; 56803</span><br><span class="line">输出：11361</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^4</code></li><li><code>1 &lt;= arr[i], target &lt;= 10^5</code></li></ul><p><strong>方法：二分查找</strong></p><p><strong>思路：</strong></p><ul><li>使用二分法确定一个正数<code>threshold</code>,使得这个<code>threshold</code>下，转变后的数组的和最接近目标值<code>target</code><ul><li>转变的规则是严格大于<code>threshold</code>元素变成<code>threshold</code>，那么也就意味着<code>threshold</code>越大，数组的和越大（注意这里是单调的，也有可能<code>threshold</code>扩大之后，和可能不变，也就是<strong>大于等于的关系</strong>）</li></ul></li></ul><ul><li>正是因为题目说 <code>value</code> 是整数，并且「答案不一定是 <code>arr</code> 中的数字」，因此依然可以使用二分查找法确定这个整数值。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200719/144801332.png" alt="mark"></p><ul><li><strong>做题的时候，发现最难写的其实是判断的条件，因为「怎么衡量接近」，度量这个「最接近」的量不好选。因此需要考虑别的方案；</strong></li></ul><ul><li><strong>这里问题就是：选定了一个value求和之后，</strong><ul><li>如果恰恰好等于 <code>target</code> ，那就万事大吉</li><li>不过更可能出现的情况是， value 取小了，接近程度变大</li><li>而value 取大了之后，接近程度变小了</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200719/145036767.png" alt="mark"></p><ul><li><strong>解决方案</strong><ul><li><strong>先用二分法确定value的可能的值</strong></li><li><strong>然后把value的上下边界都拿出来进行一次比较</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>  right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取最大的数置为right</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            right = Math.max(num,right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = calculateSum(arr,mid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算第一个使得转变后数组的和大于等于target的阈值</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断到底返回的是哪个阈值</span></span><br><span class="line">        <span class="comment">// 比较阈值线分别在left - 1 和 left的时候与target的接近程度</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = calculateSum(arr,left - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum2 = calculateSum(arr,left);</span><br><span class="line">        <span class="comment">// 判断接近程度</span></span><br><span class="line">        <span class="keyword">if</span> (target - sum1 &lt;= sum2 - target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left -  <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 计算数组中threshold以下数字的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            sum += Math.min(num,threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(solution.findBestValue(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(NlogN)，这里 N 是输入数组的长度，二分的时间复杂度是 O(logN)，每一次 calculateSum 的时间复杂度是 O(N)；</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h2 id="题目5-：-1283-使结果不超过阈值的最小除数"><a href="#题目5-：-1283-使结果不超过阈值的最小除数" class="headerlink" title="题目5 ： 1283. 使结果不超过阈值的最小除数"></a>题目5 ： <a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/" target="_blank" rel="noopener">1283. 使结果不超过阈值的最小除数</a></h2><p><strong>题目描述</strong></p><ul><li>给你一个整数数组 <code>nums</code> 和一个正整数 <code>threshold</code>，选择一个正整数作为除数，然后将数组里的每个数都除以它，并对除法结果求和。</li><li>请你找出能够使得上述结果小于等于阈值 <code>threshold</code> 的除数<strong>最小</strong>的那个</li><li>每个数除以除数之后都会向上取整，比方说 7/3 = 3 ， 10/2 = 5 。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,5,9], threshold = 6</span><br><span class="line">输出：5</span><br><span class="line">解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。</span><br><span class="line">如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,3,5,7,11], threshold = 11</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [19], threshold = 5</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>方法思路</strong></p><ol><li>找出小于等于阈值 <code>threshold</code> 中<strong>最小</strong>的那个，明显可以使用二分查找</li><li>于是可以思考除数最大可以是多少，最小是多少<ul><li><strong>最大是数组中最大的那个数</strong>，因为除数如果再大，整除以后每个数都得 1（上取整的缘故）；</li><li><strong>最小可以是 1。</strong></li></ul></li></ol><ol start="3"><li>写 if  分支的时候，根据题目的意思选<ul><li>选择一个正整数作为除数，然后将数组重的每个数都除以它，并对除法结果求和</li></ul></li><li><strong>这时候开始思考二分查找的关键  ： 排除什么时候不是解</strong><ul><li>因此 ： 和<strong>严格</strong>大于 阈值<code>threshold</code> 的整数，一定不是解。根据减而治之的思想， 定位这个除数。</li></ul></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDivisor</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先找数组中的最大值，用最大值作为除数，除完以后和最小</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            maxVal = Math.max(maxVal, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：最小值是 1，因为 threshold 可以很大</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = maxVal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (calculateSum(nums, mid) &gt; threshold) &#123;</span><br><span class="line">                <span class="comment">// sum 大于阈值一定不是解，说明除数选得太小了</span></span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">                <span class="comment">// （把下一轮搜索区间写出来，边界选择就不会错）</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 边界是 left = mid + 1 ，中间数不用上取整</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divisor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组中各个元素与 divisor 相除的结果（向上取整）之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num / divisor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：不能整除的时候，需要向上取整</span></span><br><span class="line">            <span class="keyword">if</span> (num % divisor != <span class="number">0</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<img src="file:///C:/Users/Zhuuu/AppData/Local/Temp/leetcode/editor/cn/doc/p__O_N_log_max_nums___.png" alt="ONlogmaxnums "> ，这里 <em>N</em> 是数组的长度，每一次二分都执行了边界判断函数，都得遍历一遍数组；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><h2 id="题目6-：-875-爱吃香蕉的珂珂"><a href="#题目6-：-875-爱吃香蕉的珂珂" class="headerlink" title="题目6 ： 875. 爱吃香蕉的珂珂"></a>题目6 ： <a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></h2><p><strong>题目描述</strong></p><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂<strong>喜欢慢慢吃</strong>，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <strong>H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</strong></p><p><strong>思路</strong></p><ul><li>最小速度是1，最大速度是数组重的最大值。</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到速度的最大值</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">            maxVal = Math.max(maxVal,pile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 速度的最小值</span></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 速度的最大值</span></span><br><span class="line">        <span class="keyword">int</span> right = maxVal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排除：吃的太慢的情况</span></span><br><span class="line">            <span class="keyword">if</span> (calculateSum(piles,mid) &gt; H)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间[mid + 1,right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span>[] piles,<span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">            <span class="comment">// 除不尽向上取整</span></span><br><span class="line">            sum += pile / speed;</span><br><span class="line">            <span class="keyword">if</span>(pile % speed != <span class="number">0</span>)&#123;</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<img src="file:///C:/Users/Zhuuu/AppData/Local/Temp/leetcode/editor/cn/doc/p__O_N_log_max_nums___.png" alt="ONlogmaxnums "> ，这里 <em>N</em> 是数组的长度，每一次二分都执行了边界判断函数，都得遍历一遍数组；</li><li>空间复杂度：<em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分查找-合集总结&quot;&gt;&lt;a href=&quot;#二分查找-合集总结&quot; class=&quot;headerlink&quot; title=&quot;二分查找-合集总结&quot;&gt;&lt;/a&gt;二分查找-合集总结&lt;/h1&gt;&lt;p&gt;（本系列是针对Leetcode上常见的二分查找题目进行总结。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总体思想：把待搜索的目标值留在最后判断，在循环体内不断地把不符合题目要求的子区间排除掉，在退出循环以后，因为只剩下 1 个数没有看到，它要么是目标元素，要么不是目标元素，单独判断即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用这种思路写二分&lt;strong&gt;不容易出错，需要考虑的细节最少&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种思路也非常符合“二分”这个名字，就是把【待搜索的区间】分为【有目标元素的区间】和【不包含目标元素的区间】，排除掉【不包含目标元素的区间】，剩下的就是有【目标元素的区间】。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;初学写二分查找的问题是：跳步厉害，写下 left = mid 或者 right = mid - 1 等代码的时候，一定要搞清楚是什么意思，必要的时候写上注释，帮助自己思考和以后复查代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;算法问题建议更多地理解思想，思考为什么这样写，而不建议背代码，背模板。即使要用代码和模板，例如并查集、线段树这种，也应该先把它们保存到自己的 github 代码仓库里，要用的时候去复制粘贴。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：分类是liweiwei老哥总结好的，在他的分类下，下文将以自己的思想将题目串通总结起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分总结链接&lt;/strong&gt;：&lt;a href=&quot;https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-题目分类&quot;&gt;&lt;a href=&quot;#1-题目分类&quot; class=&quot;headerlink&quot; title=&quot;1. 题目分类&quot;&gt;&lt;/a&gt;1. 题目分类&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;「力扣」上的二分查找问题主要有这三类题型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、在数组中查找符合条件的元素的索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般而言这个数组是有序的，也可能是半有序的，但不大可能是无序的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;提示与题解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-search/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;704. 二分查找&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;二分查找的模板问题，使用本题解介绍的方法就要注意，需要“后处理”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;查找边界问题，&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解（有视频讲解）&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;33. 搜索旋转排序数组&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;81. 搜索旋转排序数组 II&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;153. 寻找旋转排序数组中的最小值&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;154. 寻找旋转排序数组中的最小值 II&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;300. 最长上升子序列&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;二分查找的思路需要理解，代码很像第 35 题，&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/h-index-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;275. H指数 II&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-in-mountain-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1095. 山脉数组中查找目标值&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;852. 山脉数组的峰顶索引（简单）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-k-closest-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;658. 找到 K 个最接近的元素（中等）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;，这个问题二分的写法需要做复杂的分类讨论，可以放在以后做。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;4. 寻找两个有序数组的中位数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方题解（有视频讲解）&lt;/a&gt;，&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;二、在一个有上下界的区间里搜索一个整数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;提示与题解&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sqrtx/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;69. 平方根&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在一个整数范围里查找一个整数，也是二分查找法的应用场景，&lt;a href=&quot;https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;287. 寻找重复数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;。在一个整数范围里查找一个整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/guess-number-higher-or-lower/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;374. 猜数字大小&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1300. 转变数组后最接近目标值的数组和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;三. 判别条件是一个函数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;提示与题解&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/first-bad-version/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;278. 第一个错误的版本&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/split-array-largest-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;410. 分割数组的最大值&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;经典问题，判别函数的写法很有技巧，&lt;a href=&quot;https://leetcode-cn.com/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-k-closest-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;658. 找到 K 个最接近的元素&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/koko-eating-bananas/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;875. 爱吃香蕉的珂珂&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1300. 转变数组后最接近目标值的数组和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题解&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="算法总结" scheme="http://zhuuu.work/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="二分查找" scheme="http://zhuuu.work/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>笔试题-01-有限制的跳台阶</title>
    <link href="http://zhuuu.work/2020/07/01/Leetcode/%E7%AC%94%E8%AF%95%E9%A2%98-01-%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://zhuuu.work/2020/07/01/Leetcode/%E7%AC%94%E8%AF%95%E9%A2%98-01-%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2020-07-01T07:12:53.000Z</published>
    <updated>2020-09-06T14:59:55.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔试题-01-有限制的跳台阶"><a href="#笔试题-01-有限制的跳台阶" class="headerlink" title="笔试题-01-有限制的跳台阶"></a>笔试题-01-有限制的跳台阶</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目来源：字节2020.09.06笔试第一题</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200906/225708979.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200906/225735259.png" alt="mark"></p><a id="more"></a><h2 id="思想-dp"><a href="#思想-dp" class="headerlink" title="思想:dp"></a>思想:dp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>]+dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n][<span class="number">0</span>]+dp[n][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>状态定义</strong><ul><li><code>dp[i][0]</code> 表示跳一步到达台阶</li><li><code>dp[i][1]</code>表示跳两步到达台阶 </li></ul></li></ul><p><strong>复杂度分析</strong></p><ul><li>空间复杂度：O(N^2)  dp表的空间复杂度</li><li>时间复杂度：O(N^2)  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;笔试题-01-有限制的跳台阶&quot;&gt;&lt;a href=&quot;#笔试题-01-有限制的跳台阶&quot; class=&quot;headerlink&quot; title=&quot;笔试题-01-有限制的跳台阶&quot;&gt;&lt;/a&gt;笔试题-01-有限制的跳台阶&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目来源：字节2020.09.06笔试第一题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200906/225708979.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200906/225735259.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-046-全排列</title>
    <link href="http://zhuuu.work/2020/06/30/Leetcode/Leetcode-046-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://zhuuu.work/2020/06/30/Leetcode/Leetcode-046-%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2020-06-30T08:44:53.000Z</published>
    <updated>2020-07-03T09:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-046-全排列"><a href="#Leetcode-046-全排列" class="headerlink" title="Leetcode-046-全排列"></a>Leetcode-046-<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：回溯算法（DFS）"><a href="#方法：回溯算法（DFS）" class="headerlink" title="方法：回溯算法（DFS）"></a>方法：回溯算法（DFS）</h2><ul><li>“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧</li><li>同时回溯其实就是“深度优先遍历”特有的一种现象</li><li>“全排列”就是一个非常经典的“回溯”算法的应用。我们知道，<code>N</code> 个数字的全排列一共有 N!这么多个。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以数组 [1, 2, 3] 的全排列为例。</span><br><span class="line"></span><br><span class="line">我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；</span><br><span class="line">再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；</span><br><span class="line">最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。</span><br></pre></td></tr></table></figure><ul><li>我们只需要按顺序枚举每一位可能出现的情况，已经选择的数字在接下来要确定的数字中不能出现。按照这种策略选取就能够做到不重不漏，把可能的全排列都枚举出来。<ul><li>在枚举第一位的时候，有三种情况。</li><li>在枚举第二位的时候，前面已经出现过的数字就不能再选择了。</li><li>在枚举第三位的时候，前面两个出现过的数字已经不能再选择了。</li></ul></li></ul><p>我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；<br>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；<br>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。</p><p>使用编程的方法得到全排列，就是在这样的一个树形结构中进行编程，具体来说，就是<strong>执行一次深度优先遍历，从树的根结点到叶子结点形成的路径就是一个全排列</strong>。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/165513074.png" alt="mark"></p><ol><li>每一个节点表示了全排列问题求解不同的阶段，这些<strong>阶段</strong>通过变量的不同值体现。</li><li>这些变量不同的值，也叫做<strong>状态</strong></li><li>使用深度优先遍历，可以借助系统的栈空间，为我们保存所需要的状态变量，具体做法是：<ul><li>往下走一层，将新的变量追加在尾部，</li><li>而往回走的时候，需要撤销上一次的选择，也就是在尾部删除之前的操作</li></ul></li><li>这里我们需要用到<strong>两个变量数组</strong><ul><li>已经选取了哪些数字，用path数组来记录</li><li>一个布尔数组used,初始化的时候都为false,表示这些数字没有被选择，如果被选择值为true</li></ul></li></ol><p><strong>废话不多说：show me the code(第一种：有错误的版本 )</strong></p><p>（注意：这个代码是错误的，希望读者能自己运行一下测试用例自己发现原因，然后再阅读后面的内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 首先是特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(nums, len, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line">                <span class="comment">// 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的</span></span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);</span><br><span class="line">        System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在运行的时候输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[], [], [], [], [], []]</span><br></pre></td></tr></table></figure><p>错误的原因出现在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">    res.add(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>path</code> <strong>这个变量指向的变量在全局递归过程中只有一份存在，深度优先遍历完成之后，因为回到了根节点（撤销了之前的操作），因此path回到根节点以后就是空</strong>。</p><p><strong>在java中，传递的对象的内存地址，这些地址实际上是同一块内存区域，所以说我们要做一次深拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确的版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="comment">// 首先是特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组来保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，</span></span><br><span class="line">        <span class="comment">// 当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，</span></span><br><span class="line">        <span class="comment">// 这样在考虑下一个位置的时候，就能够以 O(1） 的时间复杂度判断这个数是否被选择过，</span></span><br><span class="line">        <span class="comment">// 这是一种“以空间换时间”的思想。</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path 这个变量所指向的对象在递归的过程中只有一份，</span></span><br><span class="line">        <span class="comment">// 深度优先遍历完成以后，因为回到了根结点（因为我们之前说了，从深层结点回到浅层结点的时候，需要撤销之前的选择），</span></span><br><span class="line">        <span class="comment">// 因此 path 这个变量回到根结点以后都为空。</span></span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums,len,<span class="number">0</span>,path,used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// depth 用来记录递归到了第几层</span></span><br><span class="line">        <span class="comment">// 用来结束递归，拿到当前的结果之后再撤销回上一层</span></span><br><span class="line">        <span class="keyword">if</span> (depth == len)&#123;</span><br><span class="line"><span class="comment">//            res.add(path);</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// else进行递归</span></span><br><span class="line">        <span class="comment">// 遍历所有nums中的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 是否这个数字之前已经用过</span></span><br><span class="line">            <span class="keyword">if</span> (!used[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不断往下一层走</span></span><br><span class="line">                dfs(nums, len, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line"></span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(N * N!)   N个节点，每个都要计算N！次</li><li>空间复杂度：O(N * N!)  N个节点，每个都要存储N！次</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-046-全排列&quot;&gt;&lt;a href=&quot;#Leetcode-046-全排列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-046-全排列&quot;&gt;&lt;/a&gt;Leetcode-046-&lt;a href=&quot;https://leetcode-cn.com/problems/permutations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全排列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个 &lt;strong&gt;没有重复&lt;/strong&gt; 数字的序列，返回其所有可能的全排列。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,3,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,1,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,3,1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,1,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="回溯算法" scheme="http://zhuuu.work/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-047-全排列II</title>
    <link href="http://zhuuu.work/2020/06/29/Leetcode/Leetcode-047-%E5%85%A8%E6%8E%92%E5%88%97II/"/>
    <id>http://zhuuu.work/2020/06/29/Leetcode/Leetcode-047-%E5%85%A8%E6%8E%92%E5%88%97II/</id>
    <published>2020-06-29T09:59:53.000Z</published>
    <updated>2020-07-03T10:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-047-全排列-II"><a href="#Leetcode-047-全排列-II" class="headerlink" title="Leetcode-047-全排列 II"></a>Leetcode-047-<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个<strong>可包含重复数字</strong>的序列，返回所有不重复的全排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：回溯-剪枝"><a href="#方法：回溯-剪枝" class="headerlink" title="方法：回溯+剪枝"></a>方法：回溯+剪枝</h2><ul><li><p>这一题是在「力扣」第 46 题： <a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">“全排列”</a> 的基础上增加了“序列中的元素可重复”这一条件，但要求返回的结果又不能有重复元素。</p></li><li><p><strong>思路：在一定会产生重复的地方进行剪枝</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/181206422.png" alt="mark"></p><ul><li><strong>剪枝的方法</strong><ul><li><strong>一个比较容易想到的方法就是在结果集里面去重，但是问题来了，这里的结果集里面是一个列表，对列表的去重可没有HashSet那么容易</strong></li><li>如果要比较两个列表是否一样，<strong>一个很显然的办法就是排序，而且是一开始就进行排序，去除重复的选项</strong>。 一旦发现这一支搜索下去可能搜索到重复的元素就停止搜索，这样结果集中不会包含重复元素。</li></ul></li></ul><ul><li><p>产生重复结点的地方，正是图中标注了“剪刀”，且被绿色框框住的地方。</p></li><li><p>大家也可以把第 2 个 <code>1</code> 加上 <code>&#39;</code> ，即 <code>[1, 1&#39;, 2]</code> 去想象这个搜索的过程。只要遇到起点一样，就有可能产生重复。</p><ul><li><strong>这里有一个特别细节的地方</strong></li><li><strong>在图中 ② 处，搜索的数也和上一次一样，但是上一次的 <code>1</code> 还在使用中；</strong></li><li><strong>在图中 ① 处，搜索的数也和上一次一样，但是上一次的 <code>1</code> 刚刚被撤销，正是因为刚被撤销，下面的搜索中还会使用到，因此会产生重复，剪掉的就应该是这样的分支</strong>。</li></ul></li></ul><p>代码实现：在第 46 题的基础上，要加上这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想：在一定会产生重复结果集的地方剪枝</span></span><br><span class="line"><span class="comment">// 一个比较容易想到的办法是在结果集中去重。</span></span><br><span class="line"><span class="comment">// 但是问题又来了，这些结果集的元素是一个又一个列表，对列表去重不像用哈希表对基本元素去重那样容易。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在搜索之前就要对元素进行排序：排序是剪枝的前提</span></span><br><span class="line">        <span class="comment">// 一旦发现这一支搜索下去可能会遇到重复的元素就停止搜索</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局唯一的辅助结果集</span></span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(nums,<span class="number">0</span>,used,temp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> depth, <span class="keyword">boolean</span>[] used, ArrayList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for循环进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 如果当前数已经使用过</span></span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 剪枝条件 ： i &gt; 0 是为了保证 nums[i - 1] 有意义</span></span><br><span class="line">            <span class="comment">// 写！user[i] 是因为nums[i-1]在回溯的时候刚刚被撤销的选择的情况</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 做出选择</span></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. backtrack</span></span><br><span class="line">            backtrack(nums,depth + <span class="number">1</span>,used,temp,res);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 撤销选择</span></span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：（理由同第 46 题，重复元素越多，剪枝越多。但是计算复杂度的时候需要<strong>考虑最差情况</strong>。）</p><ul><li>时间复杂度： O(N*N!)</li><li>空间复杂度： O(N*N!)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-047-全排列-II&quot;&gt;&lt;a href=&quot;#Leetcode-047-全排列-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-047-全排列 II&quot;&gt;&lt;/a&gt;Leetcode-047-&lt;a href=&quot;https://leetcode-cn.com/problems/permutations-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全排列 II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个&lt;strong&gt;可包含重复数字&lt;/strong&gt;的序列，返回所有不重复的全排列。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,1,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="回溯算法" scheme="http://zhuuu.work/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JUC-17-ConcurrentHashMap</title>
    <link href="http://zhuuu.work/2020/06/29/JUC/JUC-17-ConcurrentHashMap/"/>
    <id>http://zhuuu.work/2020/06/29/JUC/JUC-17-ConcurrentHashMap/</id>
    <published>2020-06-29T03:02:24.000Z</published>
    <updated>2020-09-21T13:21:21.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-17-ConcurrentHashMap"><a href="#JUC-17-ConcurrentHashMap" class="headerlink" title="JUC-17-ConcurrentHashMap"></a>JUC-17-ConcurrentHashMap</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>ConcurrentHashMap</code> 是一个并发散列映射表，它允许完全并发的读取，并且支持给定数量的并发更新。</li><li>而<code>HashTable</code>和同步包装器包装的 <code>HashMap</code>，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</li></ul><a id="more"></a><p><a href="https://blog.csdn.net/weixin_44460333/article/details/86770169" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44460333/article/details/86770169</a></p><p><a href="https://www.jianshu.com/p/d0b37b927c48" target="_blank" rel="noopener">https://www.jianshu.com/p/d0b37b927c48</a></p><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></p><p><a href="https://www.jianshu.com/p/865c813f2726" target="_blank" rel="noopener">https://www.jianshu.com/p/865c813f2726</a></p><h2 id="1-JDK-1-7-概述"><a href="#1-JDK-1-7-概述" class="headerlink" title="1. JDK 1.7 概述"></a>1. JDK 1.7 概述</h2><ul><li>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200921/203834721.png" alt="mark"></p><ul><li>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是<code>HashEntry</code>数组+链表，这个和HashMap的数据存储结构一样</li></ul><h2 id="2-JDK-1-8-实现"><a href="#2-JDK-1-8-实现" class="headerlink" title="2. JDK 1.8 实现"></a>2. JDK 1.8 实现</h2><ul><li>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现</li><li><strong>并发控制使用Synchronized和CAS来操作</strong>， 整个看起来就像是优化过且线程安全的HashMap</li><li>虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200921/211002824.png" alt="mark"></p><p>说明：ConcurrentHashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率。</p><ul><li>在深入JDK1.8的put和get实现之前要知道一些常量设计和数据结构，这些是构成ConcurrentHashMap实现结构的基础，<strong>下面看一下基本属性：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; node数组最大容量：2^30&#x3D;1073741824  </span><br><span class="line"></span><br><span class="line">  private  static  final  int  MAXIMUM_CAPACITY &#x3D;  1  &lt;&lt;  30    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 默认初始值，必须是2的幂数  </span><br><span class="line"></span><br><span class="line">  private  static  final  int  DEFAULT_CAPACITY &#x3D;  16    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;数组可能最大值，需要与toArray（）相关方法关联  </span><br><span class="line"></span><br><span class="line">  static  final  int  MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE -  8    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;并发级别，遗留下来的，为兼容以前的版本  </span><br><span class="line"></span><br><span class="line">  private  static  final  int  DEFAULT_CONCURRENCY_LEVEL &#x3D;  16    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 负载因子  </span><br><span class="line"></span><br><span class="line">  private  static  final  float  LOAD_FACTOR &#x3D;  0    .75f;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 链表转红黑树阀值,&gt; 8 链表转换为红黑树  </span><br><span class="line"></span><br><span class="line">  static  final  int  TREEIFY_THRESHOLD &#x3D;  8    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;树转链表阀值，小于等于6（tranfer时，lc、hc&#x3D;0两个计数器分别++记录原bin、新binTreeNode数量，&lt;&#x3D;UNTREEIFY_THRESHOLD 则untreeify(lo)）  </span><br><span class="line"></span><br><span class="line">  static  final  int  UNTREEIFY_THRESHOLD &#x3D;  6    ;  </span><br><span class="line"></span><br><span class="line">  static  final  int  MIN_TREEIFY_CAPACITY &#x3D;  64    ;  </span><br><span class="line"></span><br><span class="line">  private  static  final  int  MIN_TRANSFER_STRIDE &#x3D;  16    ;  </span><br><span class="line"></span><br><span class="line">  private  static  int  RESIZE_STAMP_BITS &#x3D;  16    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2^15-1，help resize的最大线程数  </span><br><span class="line"></span><br><span class="line">  private  static  final  int  MAX_RESIZERS &#x3D; (    1  &lt;&lt; (    32  - RESIZE_STAMP_BITS)) -  1    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 32-16&#x3D;16，sizeCtl中记录size大小的偏移量  </span><br><span class="line"></span><br><span class="line">  private  static  final  int  RESIZE_STAMP_SHIFT &#x3D;  32  - RESIZE_STAMP_BITS;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; forwarding nodes的hash值  </span><br><span class="line"></span><br><span class="line">  static  final  int  MOVED     &#x3D; -    1    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 树根节点的hash值  </span><br><span class="line"></span><br><span class="line">  static  final  int  TREEBIN   &#x3D; -    2    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ReservationNode的hash值  </span><br><span class="line"></span><br><span class="line">  static  final  int  RESERVED  &#x3D; -    3    ;  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 可用处理器数量  </span><br><span class="line"></span><br><span class="line">  static  final  int  NCPU &#x3D; Runtime.getRuntime().availableProcessors();  </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;存放node的数组  </span><br><span class="line"></span><br><span class="line">  transient  volatile  Node&lt;K,V&gt;[] table;  </span><br><span class="line"></span><br><span class="line">  &#x2F;*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义  </span><br><span class="line"></span><br><span class="line">  *当为负数时：-    1    代表正在初始化，-N代表有N-    1    个线程正在 进行扩容  </span><br><span class="line"></span><br><span class="line">  *当为    0    时：代表当时的table还没有被初始化  </span><br><span class="line"></span><br><span class="line">  *当为正数时：表示初始化或者下一次进行扩容的大小  </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">  private  transient  volatile  int  sizeCtl;</span><br></pre></td></tr></table></figure><p>基本属性定义了ConcurrentHashMap的一些边界以及操作时的一些控制，下面看一些内部的一些结构组成，这些是整个ConcurrentHashMap整个数据结构的核心</p><h3 id="2-1-Node"><a href="#2-1-Node" class="headerlink" title="2.1 Node"></a>2.1 Node</h3><ul><li>Node是ConcurrentHashMap存储结构的基本单元，继承于HashMap中的Entry，用于存储数据，源代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Node数据结构很简单，从上可知，就是一个链表，但是只允许对数据进行查找，不允许进行修改</li></ul><h3 id="2-2-TreeNode"><a href="#2-2-TreeNode" class="headerlink" title="2.2 TreeNode"></a>2.2 TreeNode</h3><ul><li>TreeNode继承与Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，他就是通过TreeNode作为存储结构代替Node来转换成黑红树源代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-TreeBin"><a href="#2-3-TreeBin" class="headerlink" title="2.3 TreeBin"></a>2.3 TreeBin</h3><ul><li>TreeBin从字面含义中可以理解为存储树形结构的容器，而树形结构就是指TreeNode，所以TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制，部分源码结构如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/865c813f2726" target="_blank" rel="noopener">https://www.jianshu.com/p/865c813f2726</a></p><p><strong>未完待续 ： 等我有空接着写。</strong></p><p><strong>参考博客</strong> ：  <a href="https://www.jianshu.com/p/865c813f2726" target="_blank" rel="noopener">https://www.jianshu.com/p/865c813f2726</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-17-ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#JUC-17-ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;JUC-17-ConcurrentHashMap&quot;&gt;&lt;/a&gt;JUC-17-ConcurrentHashMap&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 是一个并发散列映射表，它允许完全并发的读取，并且支持给定数量的并发更新。&lt;/li&gt;
&lt;li&gt;而&lt;code&gt;HashTable&lt;/code&gt;和同步包装器包装的 &lt;code&gt;HashMap&lt;/code&gt;，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>汇编-02-进制</title>
    <link href="http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-02-%E8%BF%9B%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-02-%E8%BF%9B%E5%88%B6/</id>
    <published>2020-06-28T11:40:41.000Z</published>
    <updated>2020-07-14T12:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-02-进制"><a href="#汇编-02-进制" class="headerlink" title="汇编-02-进制"></a>汇编-02-进制</h1><p>[参考博客链接:进制转换][<a href="https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]" target="_blank" rel="noopener">https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]</a></p><a id="more"></a><h2 id="1-为什么要使用进制数字？"><a href="#1-为什么要使用进制数字？" class="headerlink" title="1. 为什么要使用进制数字？"></a>1. 为什么要使用进制数字？</h2><p>如果我们直接操作二进制的话 , 面对这么长的数进行思考或操作，没有人会喜欢。</p><p>C，C++ 语言 没有提供在代码直接写二进制数的方法。<br>用16进制或8进制可以解决这个问题。<br><strong>因为，进制越大，数的表达长度也就越短。</strong></p><p><strong>之所以 使用 16或8进制，而不其它的，诸如9或20进制 .</strong></p><p><strong>是因为2、8、16，分别是2的1次方、3次方、4次方。这一点使得三种进制之间可以非常直接地互相转换 ;</strong></p><p>8进制或16进制 既 缩短了二进制数，还能 保持了二进制数的表达特点。转换还方便 .</p><h2 id="2-进制的介绍"><a href="#2-进制的介绍" class="headerlink" title="2. 进制的介绍"></a>2. 进制的介绍</h2><blockquote><p>进制 : 是计算机中数据的一种表示方法。 N进制的数可以用0~(N-1) 的数表示, 超过9的用字母A-F 表示 .</p></blockquote><ul><li>10进制</li></ul><blockquote><p>先说 我们最 熟悉的 10进制 , 就是 用 0~9 的数表示 , 逢 10 进 1 .</p></blockquote><ul><li>16进制</li></ul><blockquote><p>如果是 16 进制 , 它就是 由 0-9，A-F组成， 与10进制的对应关系是：0-9 对应 0-9；A-F对应10-15；<br>字母不区分大小写。</p></blockquote><ul><li>2进制 和 8进制</li></ul><blockquote><p>2进制 由 0-1组成</p><p>8进制 由 0-7组成</p></blockquote><p>再看几个特别的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写出各个进制1-20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一进制 </span></span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三进制</span></span><br><span class="line">0 1 2</span><br><span class="line">101112</span><br><span class="line">202122</span><br><span class="line">100101102</span><br><span class="line">110111112</span><br><span class="line">120121122</span><br><span class="line">1000 .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 七进制</span></span><br><span class="line">0123456</span><br><span class="line">10111213141516</span><br><span class="line">20212223242526</span><br><span class="line">30313233343536</span><br></pre></td></tr></table></figure><p><strong>现在有个问题，用进制问题解释1 + 1 = 3？</strong></p><ul><li>如果你想清楚了，进制你就没问题了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 十进制</span><br><span class="line">0 1 2 3 4 5 6 7 8 9        10  11 12</span><br><span class="line">0 2 4 6 8 9 a c d f    20  22 24</span><br></pre></td></tr></table></figure><h2 id="3-进制的计算"><a href="#3-进制的计算" class="headerlink" title="3. 进制的计算"></a>3. 进制的计算</h2><ul><li>八进制为例子</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 八进制计算下面结果</span></span><br><span class="line"></span><br><span class="line">2 + 3 = 5</span><br><span class="line">2 * 3 = 6</span><br><span class="line">4 + 5 = 11</span><br><span class="line">4 * 5 = 24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算的本质就是查数</span></span><br><span class="line">0 1 2 3 4 5 6 7 </span><br><span class="line">10 11 12 13 14 15 16 17</span><br><span class="line">20 21 22 23 24 25 26 27</span><br><span class="line"></span><br><span class="line">八进制计算  (进位和计算)</span><br><span class="line">277 + 333 = </span><br><span class="line">276 * 54 = </span><br><span class="line">237 - 54 = </span><br><span class="line">234 / 4 =</span><br></pre></td></tr></table></figure><p>各种进制的乘法表：<a href="https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html</a></p><ul><li>下面以八进制为例子</li></ul><p><strong>八进制乘法表</strong></p><table><thead><tr><th>1*1 = 1</th><th>1*2 = 2</th><th>1*3 = 3</th><th>1*4 =4</th><th>1*5 =5</th><th>1*6 = 6</th><th>1*7 = 7</th></tr></thead><tbody><tr><td>2*2 = 2</td><td>2*3 = 6</td><td>2*4 = 10</td><td>2*5 = 12</td><td>2*6 = 14</td><td>2*7 = 16</td><td></td></tr><tr><td>3*3 = 11</td><td>3*4 = 14</td><td>3*5 = 17</td><td>3* 6 = 22</td><td>3*7 = 25</td><td></td><td></td></tr><tr><td>4*4 = 20</td><td>4 * 5= 24</td><td>4*6 = 30</td><td>4*7 = 34</td><td></td><td></td><td></td></tr><tr><td>5*5 = 31</td><td>5*6 = 36</td><td>5*7 = 43</td><td></td><td></td><td></td><td></td></tr><tr><td>6*6 = 44</td><td>6*7 = 52</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7*7 = 61</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>八进制加法表</strong></p><table><thead><tr><th>1 + 1= 2</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1 + 2 = 3</td><td>2+ 2 = 4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1 + 3 = 4</td><td>2+ 3 = 5</td><td>3+ 3 = 6</td><td></td><td></td><td></td><td></td></tr><tr><td>1 + 4 = 5</td><td>2 + 4 = 6</td><td>3+4 = 7</td><td>4+ 4 = 10</td><td></td><td></td><td></td></tr><tr><td>1 + 5 = 6</td><td>2 + 5  = 7</td><td>3+ 5 = 104+</td><td>4+ 5 = 10</td><td>5 + 5 =12</td><td></td><td></td></tr><tr><td>1 + 6 = 7</td><td>2 + 6 = 10</td><td>3+ 6 =11</td><td>4+ 6 = 12</td><td>5+ 6 =13</td><td>6 + 6 =14</td><td></td></tr><tr><td>1 + 7 = 10</td><td>2 + 7 = 11</td><td>3+ 7 =12</td><td>4 + 7 = 13</td><td>5 + 7 =14</td><td>6+ 7 = 15</td><td>7 + 7 =16</td></tr></tbody></table><p><strong>结论：无论是什么进制，本身都有一套完美的体系</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-02-进制&quot;&gt;&lt;a href=&quot;#汇编-02-进制&quot; class=&quot;headerlink&quot; title=&quot;汇编-02-进制&quot;&gt;&lt;/a&gt;汇编-02-进制&lt;/h1&gt;&lt;p&gt;[参考博客链接:进制转换][&lt;a href=&quot;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-139-单词拆分</title>
    <link href="http://zhuuu.work/2020/06/28/Leetcode/Leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://zhuuu.work/2020/06/28/Leetcode/Leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2020-06-28T09:44:53.000Z</published>
    <updated>2020-06-30T06:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-139-单词拆分"><a href="#Leecode-139-单词拆分" class="headerlink" title="Leecode-139-单词拆分"></a>Leecode-139-<a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-139-单词拆分&quot;&gt;&lt;a href=&quot;#Leecode-139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;Leecode-139-单词拆分&quot;&gt;&lt;/a&gt;Leecode-139-&lt;a href=&quot;https://leetcode-cn.com/problems/word-break/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词拆分&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-316-去除重复的字母</title>
    <link href="http://zhuuu.work/2020/06/28/Leetcode/Leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E6%AF%8D/"/>
    <id>http://zhuuu.work/2020/06/28/Leetcode/Leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E6%AF%8D/</id>
    <published>2020-06-28T07:44:53.000Z</published>
    <updated>2020-06-29T09:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-316-去除重复字母"><a href="#Leetcode-316-去除重复字母" class="headerlink" title="Leetcode-316-去除重复字母"></a>Leetcode-316-<a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">去除重复字母</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个<strong>仅包含小写字母</strong>的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。</li><li><strong>保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;bcabc&quot;</span><br><span class="line">输出: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;cbacdcbc&quot;</span><br><span class="line">输出: &quot;acdb&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：栈-哨兵"><a href="#方法：栈-哨兵" class="headerlink" title="方法：栈+哨兵"></a>方法：栈+哨兵</h2><p>思路分析：</p><ul><li><strong>首先解释一下什么是字典序。</strong><ul><li>字典序是指从前到后比较两个字符串的大小</li><li>首先比较第一个字符，如果不同则第一个字符较小的字符串更小</li><li>如果相同则继续比较第二个字符…. 如果比到最后都一样的话，那么两个字符串相等</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">观察示例 1：bcabc。</span><br><span class="line"></span><br><span class="line">字符 a 在字符串中只出现一次，根据题目要求，字符 a 必须被选取；</span><br><span class="line">字符 b 出现了两次，显然选择 a后面的那个，因为字典序 ab 在 ba 前面。同理，有两个相同的字符 c ，我们选择后一个。因此，输出就是 abc。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">再观察示例 2：cbacdcbc。</span><br><span class="line"></span><br><span class="line">有 4 个字符：</span><br><span class="line">a、b、c、d。其中 a 和 d 只出现一次，必须被选取；</span><br><span class="line">b 出现 2 次，一个在 a 前面，一个在 a 后面，显然保留在 a 后面的；</span><br><span class="line">c 出现 4 次，我们把几种可能都列出来观察一下：</span><br><span class="line">情况 1：cadb</span><br><span class="line">情况 2：acdb（字典序最小）</span><br><span class="line">情况 3：adcb</span><br><span class="line">情况 4：adbc</span><br></pre></td></tr></table></figure><ul><li>下面我们就要思考，当遍历到字符串<strong>ASCII 值减少的时候</strong>，应该如何处理。（一种最理想的情况是：<code>abcd</code>，在遍历的时候，遇到的字符串的 <strong>ASCII 值逐渐增大</strong>。）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">还看示例 1：</span><br><span class="line">已经读到了 bc，已经是字典序最小的排列。</span><br><span class="line">即将读到的 a 比 c 的 ASCII 值小。如果 a 能排在 c 之前，就能得到一个比 ca 更小的字典序 ac。</span><br><span class="line">那么 a 能不能排在 c 之前，就看 a 的后面还会不会出现字符 c，显然会。同理，由于字符 b 在将来还会出现，构成的字典序更小，因此舍弃之前的字符 b。</span><br><span class="line">到此为止，应该想到我们需要借助栈帮助我们完成这题。</span><br></pre></td></tr></table></figure><ul><li>然后根据这个思路，我们再看一下示例 2：<code>cbacdcbc</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200629/143955298.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第 1 步：读到 c，入栈，此时栈中元素 [c]；</span><br><span class="line"></span><br><span class="line">第 2 步：读到 b，b 比之前 a 小，c 在以后还会出现，因此 c 出栈，b 入栈，此时栈中元素 [b]；</span><br><span class="line"></span><br><span class="line">第 3 步：读到 a，a 比之前 b 小，b 在以后还会出现，因此 b 出栈，a 入栈，此时栈中元素 [a]；</span><br><span class="line"></span><br><span class="line">第 4 步：读到 c，c 比之前 a 大，直接让 c 入栈，此时栈中元素 [a, c]；</span><br><span class="line"></span><br><span class="line">第 5 步：读到 d，d 比之前 d 大，直接让 d 入栈，此时栈中元素 [a, c, d]；</span><br><span class="line"></span><br><span class="line">第 6 步：读到 c，这里要注意：此时栈中已经有 c 了，此时栈中元素构成的字符顺序就是最小的字典序，不可能舍弃之前的 c，而用现在的读到的 c，因此这个 c 不需要，直接跳过；</span><br><span class="line"></span><br><span class="line">第 7 步：读到 b，b 比之前的 d 小，但是，后面不会再出现 d 了，因此 b 就应该放在这个位置，因此让 b 入栈，此时栈中元素 [a, c, d, b]；</span><br><span class="line"></span><br><span class="line">第 8 步：读到 c，同第 6 步，这个 c 我们不需要。</span><br></pre></td></tr></table></figure><ul><li><p>于是：我们可以设计如下算法：</p><ul><li>遍历字符串里的字符，<strong>如果读到的字符的 ASCII 值是升序</strong>，依次存到一个栈中；</li><li>如果读到的栈中已经存在，那么这个字符我们不需要。</li><li>如果<strong>读到的ASCII 值比栈顶元素严格小，看看栈顶后面的是否还会再出现</strong>，如果还会出现，则舍弃栈顶元素，而选择后面出现的那个元素，这样得到的字典序更小。</li></ul></li><li><p>因为需要判断读到的字符在栈中是否已经存在，因此可以使用哈希表，又因为题目说，字符只会出现小写字母，<strong>用一个布尔数组也是可以的，注意在出栈入栈的时候，需要同步更新一下这个布尔数组。</strong></p></li><li><p>又因为要<strong>判断栈顶元素在后面是否会被遍历到，因此我们需要首先遍历一次字符，存一下这个字符最后出现的位置，就能判断栈顶元素在后面是否会被遍历到</strong></p></li></ul><p><strong>未使用哨兵的版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助栈来帮助我们完成这道题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 不会有重复的情况</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于记录字符串中已经出现的字符</span></span><br><span class="line">        <span class="keyword">boolean</span>[] set = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个字符出现的最后一个位置</span></span><br><span class="line">        <span class="keyword">int</span>[] lastIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            lastIndex[s.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈：判断栈顶元素和入栈元素的ASCII大小</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curr = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (set[curr - <span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lastIndex[stack.peek() -'a'] &gt;= i 说明后面还会出现</span></span><br><span class="line">            <span class="comment">// stack.peek() &gt; curr说明当前入栈元素比栈顶小</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; curr &amp;&amp; lastIndex[stack.peek() -<span class="string">'a'</span>] &gt;= i)&#123;</span><br><span class="line">                <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">                set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入栈并记录</span></span><br><span class="line">            stack.push(curr);</span><br><span class="line">            set[curr - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈顶元素依次出栈并返回字符串形式</span></span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            buffer.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用哨兵原因</strong>：里面判断语句太长，每一次都要判断栈是否为空。这里使用一个哨兵的技巧，一开始就在栈里面放一个最小字符’a’ 。因为后面判断语句<code>stack.peek() &gt; currentChar</code> 这里是严格符号，因此这个 <code>a</code> 一定不会被弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; currentChar &amp;&amp; lastAppearIndex[stack.peek() - <span class="string">'a'</span>] &gt;= i) &#123;</span><br><span class="line">    <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">    set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用哨兵：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哨兵+栈</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个字符出现的最后一个位置</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] lastIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            lastIndex[charArray[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录字符是否已经出现在字符串中</span></span><br><span class="line">        <span class="keyword">boolean</span>[] set = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时 `a` 作为哨兵，这个 `a` 永远不会被弹出</span></span><br><span class="line">        <span class="comment">// 如此一来，在遍历的时候，就不用判断栈是否为空了</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.addLast(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符已经出现过了，跳出循环</span></span><br><span class="line">            <span class="keyword">char</span> currentChar = charArray[i];</span><br><span class="line">            <span class="keyword">if</span> (set[currentChar - <span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (stack.peekLast() &gt; currentChar &amp;&amp; lastIndex[stack.peekLast() - <span class="string">'a'</span>] &gt;= i)&#123;</span><br><span class="line">                <span class="comment">// 弹出并且将该字符改为未出现过</span></span><br><span class="line">                <span class="keyword">char</span> top = stack.removeLast();</span><br><span class="line">                set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说明ASCII是升序的，直接加入</span></span><br><span class="line">            stack.addLast(currentChar);</span><br><span class="line">            set[currentChar - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转为字符串返回结果</span></span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            buffer.insert(<span class="number">0</span>,stack.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-316-去除重复字母&quot;&gt;&lt;a href=&quot;#Leetcode-316-去除重复字母&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-316-去除重复字母&quot;&gt;&lt;/a&gt;Leetcode-316-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;去除重复字母&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个&lt;strong&gt;仅包含小写字母&lt;/strong&gt;的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;bcabc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;cbacdcbc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;acdb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>汇编-01-概述</title>
    <link href="http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-06-28T07:40:41.000Z</published>
    <updated>2020-06-28T14:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-01-概述"><a href="#汇编-01-概述" class="headerlink" title="汇编-01-概述"></a>汇编-01-概述</h1><ul><li><p>CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p></li><li><p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。</p></li><li><p><strong>编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</strong></p></li><li><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。</p></li><li><p>为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p></li></ul><p>一张程序猿的鄙视链：（哈哈哈 看看就好！！）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/220922706.png" alt="mark"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-01-概述&quot;&gt;&lt;a href=&quot;#汇编-01-概述&quot; class=&quot;headerlink&quot; title=&quot;汇编-01-概述&quot;&gt;&lt;/a&gt;汇编-01-概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一张程序猿的鄙视链：（哈哈哈 看看就好！！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/220922706.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-13-Scanner</title>
    <link href="http://zhuuu.work/2020/06/28/jdk_SourceCode/JDK1.8-13-Scanner/"/>
    <id>http://zhuuu.work/2020/06/28/jdk_SourceCode/JDK1.8-13-Scanner/</id>
    <published>2020-06-28T05:33:53.000Z</published>
    <updated>2020-06-28T13:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8使用-13-Scanner"><a href="#JDK1-8使用-13-Scanner" class="headerlink" title="JDK1.8使用-13-Scanner"></a>JDK1.8使用-13-Scanner</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>在笔试编程过程中，关于数据的读取如果迷迷糊糊，那后来的编程即使想法很对，实现很好，也是徒劳，于是在这里认真总结了Java Scanner 类的使用</p><a id="more"></a><h2 id="常用方法：next-和nextline"><a href="#常用方法：next-和nextline" class="headerlink" title="常用方法：next()和nextline()"></a>常用方法：next()和nextline()</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/201806538.png" alt="mark"></p><ul><li>上图的方法：只读取对应数据类型的数据，如果输入了非对应数据类型的数据就是报错。</li><li>比如：<code>nextlnt():只读取int值</code>，就是只能读取整数类型的数据，如果输入了非整型的数据（浮点型字符串等）就会报错。<br><code>nextFloat（）、nextDouble（）</code>这些也是以此类推，只能读取符合该类型的数据。</li><li><strong>next() :  只读取输入直到空格，它不能读取两个由空格或者符号隔开的单词。此外next() 在读取输入后将光标放入到同一行中</strong></li><li><strong>nextLine():读取输入，包括单词之间的空格和除回车意外的所有符号（即它会读到行尾）。读取输入后，nextLine()会将光标定位在下一行。</strong></li></ul><p><strong>废话不多说：show me the code</strong></p><ul><li><strong>源码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextInt(defaultRadix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scans the next token of the input as an &lt;tt&gt;int&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * if the next token cannot be translated into a valid int value as</span></span><br><span class="line"><span class="comment"> * described below. If the translation is successful, the scanner advances</span></span><br><span class="line"><span class="comment"> * past the input that matched.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If the next token matches the &lt;a</span></span><br><span class="line"><span class="comment"> * href="#Integer-regex"&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined</span></span><br><span class="line"><span class="comment"> * above then the token is converted into an &lt;tt&gt;int&lt;/tt&gt; value as if by</span></span><br><span class="line"><span class="comment"> * removing all locale specific prefixes, group separators, and locale</span></span><br><span class="line"><span class="comment"> * specific suffixes, then mapping non-ASCII digits into ASCII</span></span><br><span class="line"><span class="comment"> * digits via &#123;<span class="doctag">@link</span> Character#digit Character.digit&#125;, prepending a</span></span><br><span class="line"><span class="comment"> * negative sign (-) if the locale specific negative prefixes and suffixes</span></span><br><span class="line"><span class="comment"> * were present, and passing the resulting string to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#parseInt(String, int) Integer.parseInt&#125; with the</span></span><br><span class="line"><span class="comment"> * specified radix.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> radix the radix used to interpret the token as an int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the &lt;tt&gt;int&lt;/tt&gt; scanned from the input</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InputMismatchException</span></span><br><span class="line"><span class="comment"> *         if the next token does not match the &lt;i&gt;Integer&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *         regular expression, or is out of range</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if input is exhausted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this scanner is closed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check cached result</span></span><br><span class="line">    <span class="keyword">if</span> ((typeCache != <span class="keyword">null</span>) &amp;&amp; (typeCache <span class="keyword">instanceof</span> Integer)</span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.radix == radix) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = ((Integer)typeCache).intValue();</span><br><span class="line">        useTypeCache();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    setRadix(radix);</span><br><span class="line">    clearCaches();</span><br><span class="line">    <span class="comment">// Search for next int</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = next(integerPattern());</span><br><span class="line">        <span class="keyword">if</span> (matcher.group(SIMPLE_GROUP_INDEX) == <span class="keyword">null</span>)</span><br><span class="line">            s = processIntegerToken(s);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(s, radix);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">        position = matcher.start(); <span class="comment">// don't skip bad token</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException(nfe.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入一个字符串(中间能加空格或符号)"</span>);</span><br><span class="line">    String a = input.nextLine();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个字符串(中间不能加空格或符号)"</span>);</span><br><span class="line">    String b = input.next();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个整数"</span>);</span><br><span class="line">    <span class="keyword">int</span> c = input.nextInt(); <span class="comment">// 只能读取Int</span></span><br><span class="line">    System.out.println(<span class="string">"请输入一个double类型的小数"</span>);</span><br><span class="line">    <span class="keyword">double</span> d= input.nextFloat();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个float类型的小数"</span>);</span><br><span class="line">    <span class="keyword">float</span>  f = input.nextFloat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"按顺序输出abcdf的值："</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>运行输入：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">请输入一个字符串(中间能加空格或符号)</span><br><span class="line">我爱祖国！</span><br><span class="line">请输入一个字符串(中间不能加空格或符号)</span><br><span class="line">ILoveChina</span><br><span class="line">请输入一个整数</span><br><span class="line"><span class="number">520</span></span><br><span class="line">请输入一个<span class="keyword">double</span>类型的小数</span><br><span class="line"><span class="number">12.26e3</span></span><br><span class="line">请输入一个<span class="keyword">float</span>类型的小数</span><br><span class="line"><span class="number">3.1415926</span></span><br><span class="line">按顺序输出abcdf的值：</span><br><span class="line">我爱祖国！</span><br><span class="line">ILoveChina</span><br><span class="line"><span class="number">520</span></span><br><span class="line"><span class="number">12260.0</span></span><br><span class="line"><span class="number">3.1415925</span></span><br></pre></td></tr></table></figure><h2 id="常用用法：hasNext"><a href="#常用用法：hasNext" class="headerlink" title="常用用法：hasNext()"></a>常用用法：hasNext()</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/203935994.png" alt="mark"></p><ul><li><strong>源码：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasNextInt(defaultRadix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if the next token in this scanner's input can be</span></span><br><span class="line"><span class="comment"> * interpreted as an int value in the specified radix using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #nextInt&#125; method. The scanner does not advance past any input.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> radix the radix used to interpret the token as an int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if and only if this scanner's next token is a valid</span></span><br><span class="line"><span class="comment"> *         int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this scanner is closed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">(<span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    setRadix(radix);</span><br><span class="line">    <span class="keyword">boolean</span> result = hasNext(integerPattern());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123; <span class="comment">// Cache it</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String s = (matcher.group(SIMPLE_GROUP_INDEX) == <span class="keyword">null</span>) ?</span><br><span class="line">                processIntegerToken(hasNextResult) :</span><br><span class="line">                hasNextResult;</span><br><span class="line">            typeCache = Integer.parseInt(s, radix);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个boolean的值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试用例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过Scanner构造函数接收控制台输入的信息</span></span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入你的姓名"</span>);</span><br><span class="line">    <span class="comment">// 接收一个字符串，可以加出回车键意外所有的信息，包括空格和Tab</span></span><br><span class="line">    String name = scanner.nextLine();</span><br><span class="line">    System.out.println(<span class="string">"请输入你的ID"</span>);</span><br><span class="line">    String ID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环判断hasNextLine()方法是否有输入（返回true或false）</span></span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">        <span class="comment">// 如果输入的是整型类型，当为整型类型执行循环</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextInt())&#123;</span><br><span class="line">            ID = scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"你输入的姓名为："</span>+name);</span><br><span class="line">            System.out.println(<span class="string">"你输入的ID为："</span>+ID);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入数字哦！"</span>);</span><br><span class="line">            ID = scanner.nextLine();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">请输入你的姓名</span><br><span class="line">朱酱酱</span><br><span class="line">请输入你的ID</span><br><span class="line">qq353446503</span><br><span class="line">请输入数字哦！</span><br><span class="line"><span class="number">353446503</span></span><br><span class="line">你输入的姓名为：朱酱酱</span><br><span class="line">你输入的ID为：<span class="number">353446503</span></span><br></pre></td></tr></table></figure><h2 id="Demo-键盘输入求平均数"><a href="#Demo-键盘输入求平均数" class="headerlink" title="Demo:键盘输入求平均数"></a>Demo:键盘输入求平均数</h2><ul><li>注意：如果要输入int 或者 float … 之类的数据，在Scanner中输入之前最好先使用<code>hasNextXxx()</code> 方法进行验证，再使用<code>nextXxx()</code>进行读取接收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNextDouble())&#123;</span><br><span class="line">        <span class="comment">// 接收dobule的值</span></span><br><span class="line">        <span class="keyword">double</span> x = scanner.nextDouble();</span><br><span class="line">        m = m + <span class="number">1</span>;</span><br><span class="line">        sum = sum + x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(m + <span class="string">"个数的和为"</span> + sum);</span><br><span class="line">    System.out.println(m + <span class="string">"个数的平均值是"</span> + (sum / m));</span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试用例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入数字：</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="number">30.0</span></span><br><span class="line"><span class="number">40.0</span></span><br><span class="line">end</span><br><span class="line"><span class="number">3</span>个数的和为<span class="number">90.0</span></span><br><span class="line"><span class="number">3</span>个数的平均值是<span class="number">30.0</span>s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8使用-13-Scanner&quot;&gt;&lt;a href=&quot;#JDK1-8使用-13-Scanner&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8使用-13-Scanner&quot;&gt;&lt;/a&gt;JDK1.8使用-13-Scanner&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;在笔试编程过程中，关于数据的读取如果迷迷糊糊，那后来的编程即使想法很对，实现很好，也是徒劳，于是在这里认真总结了Java Scanner 类的使用&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="面试必备" scheme="http://zhuuu.work/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>排序-02-桶排序</title>
    <link href="http://zhuuu.work/2020/06/27/Sort/%E6%8E%92%E5%BA%8F-02-%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/06/27/Sort/%E6%8E%92%E5%BA%8F-02-%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-06-27T10:32:24.000Z</published>
    <updated>2020-08-12T12:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-02-桶排序"><a href="#排序-02-桶排序" class="headerlink" title="排序-02-桶排序"></a>排序-02-桶排序</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175321622.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175306350.png" alt="mark"></p><h2 id="1-桶排序思想"><a href="#1-桶排序思想" class="headerlink" title="1. 桶排序思想"></a>1. 桶排序思想</h2><ul><li><strong>一句话总结：划分多个范围相同的区间，每个子区间进行自排序，最后合并</strong></li><li>桶排序是计数排序的扩展版本<ul><li>计数排序可以看成每个桶只存储相同的元素</li><li>而桶排序每个桶存储的是一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/173153414.png" alt="mark"></p><a id="more"></a><h2 id="2-Java实现代码"><a href="#2-Java实现代码" class="headerlink" title="2. Java实现代码"></a>2. Java实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最大值与最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算桶的数量</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个元素放入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">            bucketArr.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将桶中的元素赋值到原序列</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)&#123;</span><br><span class="line">                arr[index++] = bucketArr.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BucketSort.bucketSort(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">18</span>,<span class="number">11</span>,<span class="number">28</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">50</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li><strong>时间复杂度：O(N+K)</strong><ul><li>N 次循环，将每个元素装入对应的桶中</li><li>M 次循环，对每个桶中的数据进行排序（平均每个桶有 N/M 个元素）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175714244.png" alt="mark"></p><ul><li><strong>空间复杂度： O( N + M )</strong></li></ul><ul><li><strong>稳定性分析</strong><ul><li><strong>桶排序的稳定性取决于桶内排序使用的算法</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-02-桶排序&quot;&gt;&lt;a href=&quot;#排序-02-桶排序&quot; class=&quot;headerlink&quot; title=&quot;排序-02-桶排序&quot;&gt;&lt;/a&gt;排序-02-桶排序&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175321622.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175306350.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-桶排序思想&quot;&gt;&lt;a href=&quot;#1-桶排序思想&quot; class=&quot;headerlink&quot; title=&quot;1. 桶排序思想&quot;&gt;&lt;/a&gt;1. 桶排序思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一句话总结：划分多个范围相同的区间，每个子区间进行自排序，最后合并&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;桶排序是计数排序的扩展版本&lt;ul&gt;
&lt;li&gt;计数排序可以看成每个桶只存储相同的元素&lt;/li&gt;
&lt;li&gt;而桶排序每个桶存储的是一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/173153414.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-02-二叉查找树</title>
    <link href="http://zhuuu.work/2020/06/26/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/06/26/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2020-06-26T10:32:24.000Z</published>
    <updated>2020-06-28T08:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-02-二叉查找树"><a href="#数据结构-02-二叉查找树" class="headerlink" title="数据结构-02-二叉查找树"></a>数据结构-02-二叉查找树</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p>数据结构在线生成工具 ： <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><a id="more"></a><h2 id="1-二叉查找树简介"><a href="#1-二叉查找树简介" class="headerlink" title="1. 二叉查找树简介"></a>1. 二叉查找树简介</h2><ul><li><p><strong>二叉查找树(Binary Search Tree)，又被称为二叉搜索树。</strong></p></li><li><p>它是<strong>特殊的二叉树</strong></p><ul><li>对于二叉树，假设x为二叉树中的任意一个节点，x节点中包含关键字key,节点x的key值记位key[x] 。</li><li>如果 y 是 x 的左子树中的一个节点，则key[y] &lt;= key[x] ; </li><li>如果 y 是  x的右子树中的一个节点，则key[y] &gt;= key[x];</li></ul></li></ul><p>那么，这棵树就是二叉查找树。如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/151835002.png" alt="mark"></p><p><strong>性质：在二叉查找树中</strong></p><ul><li><strong>如果任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值</strong></li><li><strong>任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值</strong></li><li><strong>任意节点的左，右子树也分别为二叉查找树。（递归的思想）</strong></li><li>没有键值相等的节点（no duplicate nodes）。</li></ul><h2 id="2-二叉查找树的Java实现"><a href="#2-二叉查找树的Java实现" class="headerlink" title="2. 二叉查找树的Java实现"></a>2. 二叉查找树的Java实现</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T extends Comparable&lt;T&gt; 说明泛型T必须实现了Comparable接口</span></span><br><span class="line"><span class="comment">// &lt;T extends Comparable&lt;? super T&gt;&gt;　说明泛型T或者其父类必须实现了Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BSTNode&lt;T&gt; mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        BSTNode&lt;T&gt; left;      <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; right;     <span class="comment">// 右孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; parent;    <span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BSTNode</span><span class="params">(T key, BSTNode&lt;T&gt; parent, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>BSTree是二叉树，它保护了二叉树的根节点mRoot;</li><li>mRoot是BSTNode类型，而BSTNode是而二叉查找树的节点，它是BSTree的内部类。</li><li>BSTNode 包含了以下几个基本信息：<ul><li>(01) key – 它是关键字，是用来对二叉查找树的节点进行排序的。<br>(02) left – 它指向当前节点的左孩子。<br>(03) right – 它指向当前节点的右孩子。<br>(04) parent – 它指向当前节点的父结点。</li></ul></li></ul><h3 id="2-2-遍历"><a href="#2-2-遍历" class="headerlink" title="2.2 遍历"></a>2.2 遍历</h3><ul><li>这里讲解前序遍历、中序遍历、后序遍历3种方式。</li></ul><p><strong>前序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 访问根结点；<br>(02) 先序遍历左子树；<br>(03) 先序遍历右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">        preOrder(tree.left);</span><br><span class="line">        preOrder(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 中序遍历左子树；<br>(02) 访问根结点；<br>(03) 中序遍历右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrder(tree.left);</span><br><span class="line">        System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">        inOrder(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 后序遍历左子树；<br>(02) 后序遍历右子树；<br>(03) 访问根结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder(tree.left);</span><br><span class="line">        postOrder(tree.right);</span><br><span class="line">        System.out.print(tree.key+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看下面这颗树的各种遍历方式：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/155914685.png" alt="mark"></p><p>对于上面的二叉树而言，<br>(01) 前序遍历结果： 3 1 2 5 4 6<br>(02) 中序遍历结果： 1 2 3 4 5 6<br>(03) 后序遍历结果： 2 1 4 6 5 3</p><h3 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h3><ul><li>递归版本的查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> search(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> search(x.right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> search(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非递归实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            x = x.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            x = x.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iterativeSearch(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-02-二叉查找树&quot;&gt;&lt;a href=&quot;#数据结构-02-二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;数据结构-02-二叉查找树&quot;&gt;&lt;/a&gt;数据结构-02-二叉查找树&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据结构在线生成工具 ： &lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://zhuuu.work/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-HTTPS详解</title>
    <link href="http://zhuuu.work/2020/06/26/NetworkCoding/HTTP-HTTPS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/06/26/NetworkCoding/HTTP-HTTPS%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-06-26T03:32:24.000Z</published>
    <updated>2020-09-18T13:14:08.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-HTTPS详解"><a href="#HTTP-HTTPS详解" class="headerlink" title="HTTP-HTTPS详解"></a>HTTP-HTTPS详解</h1><h2 id="一：-基础概念"><a href="#一：-基础概念" class="headerlink" title="一： 基础概念"></a>一： 基础概念</h2><h3 id="1-1-URI"><a href="#1-1-URI" class="headerlink" title="1.1 URI"></a>1.1 URI</h3><ul><li>URI 包含 URL 和 URN。</li><li>我们通常所说的<strong>URL（统一资源定位符）是URI的子集</strong></li><li>URI还有一个自己URN , URN只命名资源但是不指定如何定位资源.</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120156077.png" alt="mark"></p><a id="more"></a><h3 id="1-2-请求报文"><a href="#1-2-请求报文" class="headerlink" title="1.2 请求报文"></a>1.2 请求报文</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120719185.png" alt="mark"></p><h3 id="1-3-响应报文"><a href="#1-3-响应报文" class="headerlink" title="1.3 响应报文"></a>1.3 响应报文</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120739566.png" alt="mark"></p><h2 id="二-HTTP-请求方法"><a href="#二-HTTP-请求方法" class="headerlink" title="二: HTTP 请求方法"></a>二: HTTP 请求方法</h2><p>客户端发送的   <strong>请求报文</strong>   第一行为请求行，包含了方法字段。</p><p><strong>举例:</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120845030.png" alt="mark"></p><h3 id="1-1-GET"><a href="#1-1-GET" class="headerlink" title="1.1 GET"></a>1.1 GET</h3><ul><li><strong>获取资源的请求</strong>(绝大部分的请求都是GET方法)</li></ul><h3 id="1-2-HEAD"><a href="#1-2-HEAD" class="headerlink" title="1.2 HEAD"></a>1.2 HEAD</h3><ul><li><strong>获取报文的首部,但是不返回报文实体主体部分</strong></li><li>主要用于确认URL的有效性以及资源更新的日期时间等.</li></ul><h3 id="1-3-POST"><a href="#1-3-POST" class="headerlink" title="1.3 POST"></a>1.3 POST</h3><ul><li><strong>传输实体主体</strong></li><li>POST用于传输表单数据,具体和GET的区别会在下文进行阐述</li></ul><h3 id="1-4-PUT"><a href="#1-4-PUT" class="headerlink" title="1.4 PUT"></a>1.4 PUT</h3><ul><li><strong>上传文件</strong></li><li>由于自身不带验证机制,任何人都可以上传文件,因此存在安全性问题,一般不使用这个方法.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-PATCH"><a href="#1-5-PATCH" class="headerlink" title="1.5 PATCH"></a>1.5 PATCH</h3><ul><li><strong>类似与PUT,但是PATCH用于资源的部分修改</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: "e0023aa4e"</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure><h3 id="1-6-DELTETE"><a href="#1-6-DELTETE" class="headerlink" title="1.6 DELTETE"></a>1.6 DELTETE</h3><ul><li><p>删除文件</p></li><li><p>与PUT功能相反,并且同样不携带验证机制.</p></li></ul><h3 id="1-7-OPTIONS"><a href="#1-7-OPTIONS" class="headerlink" title="1.7 OPTIONS"></a>1.7 OPTIONS</h3><ul><li>支持查询的方法</li><li>作用:查询指定的URL能够支持的方法(会返回 <code>Allow GET POST HEAD OPTIONS</code>) 这样的内容</li></ul><h3 id="1-8-Connect"><a href="#1-8-Connect" class="headerlink" title="1.8 Connect"></a>1.8 Connect</h3><ul><li>要求在与代理服务器通信时建立隧道</li><li>使用SSL(Secure Sockets Layer，安全套接层) 和 TLS (Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/122102520.png" alt="mark"></p><h3 id="1-9-TRACE"><a href="#1-9-TRACE" class="headerlink" title="1.9 TRACE"></a>1.9 TRACE</h3><ul><li>追踪路径</li><li>服务器会将通信路径返回给客户端(在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。)</li><li>通常不会使用TRACE,并且它容易受到XST攻击(Cross-Site Tracing ,跨站追踪)</li></ul><h2 id="三-HTTP-状态码"><a href="#三-HTTP-状态码" class="headerlink" title="三:  HTTP 状态码"></a>三:  HTTP 状态码</h2><ul><li>服务器返回的   <strong>响应报文</strong>   中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</li></ul><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息状态码)</td><td>接收的请求正现在处理</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求发生错误</td></tr></tbody></table><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/122512956.png" alt="mark"></p><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue</strong> : 表示到目前为止数据都很正常,客户端可以继续发送请求或者忽略这个响应.</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200  OK</strong></li><li><strong>204  No Content</strong>: 请求已经成功处理,但是返回的响应报文不包含实体的主体部分.一般在只需要从客户端向服务器发送信息,而不需要返回数据的时候使用.</li><li><strong>206  Partial Content</strong>: 表示客户端进行的范围请求,响应报文包含由Content-Range 指定范围的实体内容.</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><p><strong>301 Moved Permanently</strong> : 永久性重定向</p></li><li><p><strong>302 Found</strong>: 临时性重定向</p></li><li><p><strong>303 See Other</strong> : 和302 有着相同的功能,但是303明确要求客户端应该采用GET方法请求资源</p><ul><li>注：虽然 <strong>HTTP 协议规定</strong> 301、302 状态下<strong>重定向时不允许把 POST 方法改成 GET 方法</strong>，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li></ul></li><li><p><strong>304 Not Modified</strong> : 如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since,如果不满足以上条件,则服务器会返回304状态码.</p></li><li><p><strong>307 Temporary Redirect :</strong>  临时重定向,与302的含义类似,但是307要求浏览器不会把重定向请求的POST方法修改成GET 方法.</p></li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><strong>400  Bad Request :</strong>: 请求报文中存在语法错误</li><li><strong>401  Unauthorizd</strong> : 该状态码表示发送的请求去需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden :</strong> 请求被拒绝</li><li><strong>404  Not found</strong></li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong>  ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong>: 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h2 id="四-：-HTTP-首部"><a href="#四-：-HTTP-首部" class="headerlink" title="四 ： HTTP 首部"></a>四 ： HTTP 首部</h2><ul><li>有四种类型的首部字段<ul><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ul></li></ul><h3 id="4-1-通用首部字段"><a href="#4-1-通用首部字段" class="headerlink" title="4.1 通用首部字段"></a>4.1 通用首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="center">Date</td><td align="center">创建报文的日期时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Trailer</td><td align="center">报文末端的首部一览</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">升级为其他协议</td></tr><tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr><tr><td align="center">Warning</td><td align="center">错误通知</td></tr></tbody></table><h3 id="4-2-请求首部字段"><a href="#4-2-请求首部字段" class="headerlink" title="4.2 请求首部字段"></a>4.2 请求首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr><tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr><tr><td align="center">Authorization</td><td align="center">Web 认证信息</td></tr><tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr><tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">请求资源所在服务器</td></tr><tr><td align="center">If-Match</td><td align="center">比较实体标记（ETag）</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr><tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与 If-Match 相反）</td></tr><tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td align="center">If-Unmodified-Since</td><td align="center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr><tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr><tr><td align="center">Referer</td><td align="center">对请求中 URI 的原始获取方</td></tr><tr><td align="center">TE</td><td align="center">传输编码的优先级</td></tr><tr><td align="center">User-Agent</td><td align="center">HTTP 客户端程序的信息</td></tr></tbody></table><h3 id="4-3-响应首部字段"><a href="#4-3-响应首部字段" class="headerlink" title="4.3 响应首部字段"></a>4.3 响应首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr><tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr><tr><td align="center">ETag</td><td align="center">资源的匹配信息</td></tr><tr><td align="center">Location</td><td align="center">令客户端重定向至指定 URI</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr><tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr><tr><td align="center">Server</td><td align="center">HTTP 服务器的安装信息</td></tr><tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr></tbody></table><h3 id="4-4-实体首部字段"><a href="#4-4-实体首部字段" class="headerlink" title="4.4 实体首部字段"></a>4.4 实体首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源可支持的 HTTP 方法</td></tr><tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr><tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr><tr><td align="center">Content-Length</td><td align="center">实体主体的大小</td></tr><tr><td align="center">Content-Location</td><td align="center">替代对应资源的 URI</td></tr><tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr><tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr><tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">资源的最后修改日期时间</td></tr></tbody></table><h2 id="五：具体应用"><a href="#五：具体应用" class="headerlink" title="五：具体应用"></a>五：具体应用</h2><h3 id="5-1-连接管理"><a href="#5-1-连接管理" class="headerlink" title="5.1 连接管理"></a>5.1 连接管理</h3><h4 id="5-1-1-短链接和长连接"><a href="#5-1-1-短链接和长连接" class="headerlink" title="5.1.1 短链接和长连接"></a>5.1.1 <strong>短链接和长连接</strong></h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" width="800"/> </div><br><ul><li>当浏览器访问一个包含多张图片的html 的时候，除了请求访问的HTML资源，还会请求图片的资源。如果每进行一次HTTP通信就要新建一个TCP连接，那么开销会很大。<ul><li><strong>长连接只需要建立一次TCP链接就能就行多次HTTP通信。</strong><ul><li>从 HTTP/1.1 <strong>开始默认是长连接</strong>的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 <strong>之前默认是短连接</strong>的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul></li></ul></li></ul><h4 id="5-1-2-流水线"><a href="#5-1-2-流水线" class="headerlink" title="5.1.2 流水线"></a>5.1.2 流水线</h4><ul><li><p><strong>默认情况下，HTTP请求时按顺序发出的，下一个请求只有在当前请求收到响应后才会被发出</strong>。</p></li><li><p>由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p></li><li><p><strong>流水线时在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</strong></p></li></ul><h3 id="5-2-Cookie"><a href="#5-2-Cookie" class="headerlink" title="5.2 Cookie"></a>5.2 Cookie</h3><ul><li><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p></li><li><p><strong>Cookie 是服务器发送到用户浏览器并在本地保存的一小块数据，他会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。</strong></p></li><li><p>于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p></li><li><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，<strong>Cookie 渐渐被淘汰。</strong></p><ul><li><strong>新的浏览器API 已经允许开发者直接将数据存储到本地，如使用Web Storage API(本地存储和会话存储)或者 IndexedDB.</strong></li></ul></li></ul><ol><li><strong>Cookie的用途</strong></li></ol><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><ol start="2"><li><strong>创建过程</strong></li></ol><ul><li>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 <strong>Cookie 内容保存到浏览器中。</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><ul><li>客户端之后对同一个服务器发起请求的时候，会<strong>从浏览器中取出Cookie 信息并通过Cookie 请求首部字段发送给服务器。</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>分类</strong></li></ol><ul><li><strong>会话期 Cookie</strong>：<strong>浏览器关闭之后它会被自动删除</strong>，也就是说它仅在会话期内有效。</li><li><strong>持久性 Cookie</strong>：<strong>指定过期时间（Expires）或有效期（max-age）</strong>之后就成为了持久性的 Cookie。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>作用域</strong></li></ol><ul><li><p>Domain 标识指定了哪些主机可以接受 Cookie。</p><ul><li>如果不指定，默认为当前文档的主机（不包含子域名）。</li><li>如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</li></ul></li><li><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul></li></ul><ol start="5"><li><strong>javaScript</strong></li></ol><ul><li>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "yummy_cookie=choco";</span><br><span class="line">document.cookie = "tasty_cookie=strawberry";</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>HttpOnly</strong></li></ol><ul><li>标志为httpOnly 的 Cookie 不能被 javaScript 脚本调用，跨站脚本（XSS）常常使用JavaScript 的 <code>document.cookie</code> API来窃取用户的 Cookie 信息，因此 HTTPONLY 标志可以一定程序上避免XSS攻击。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>Secure</strong></li></ol><ul><li><strong>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。</strong></li><li>但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</li></ul><ol start="8"><li><strong>Session</strong></li></ol><ul><li><p>除了可以将用户信息通过 <strong>Cookie 存储在用户浏览器中</strong>，也可以利用 <strong>Session 存储在服务器端</strong>，存储在服务器端的信息更加安全。</p></li><li><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p></li></ul><p>使用Session维护用户登录状态过程如下：</p><ul><li>用户进行登录的时候，用户提交包含用户名和密码的表单，放入HTTP请求报文中。</li><li><strong>服务器验证用户名和密码</strong>，如果正确就把用户信息存储到Redis中，他在Redis中的key 叫做Session ID;</li><li><strong>服务器返回响应报文的Set - Cookie 首部字段包含了 Session ID</strong> , 客<strong>户端收到响应报文之后将Cookie 值存入浏览器中。</strong></li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，<strong>服务器收到之后提取出 Session ID</strong>，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><ol start="9"><li><strong>禁用Cookie</strong></li></ol><ul><li>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</li></ul><ol start="10"><li><strong>Cookie 和 Session 的选择</strong></li></ol><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 可以存储任何类型的数据，因此考虑数据复杂性首选Session.</li><li>Cookie 存在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果所有用户信息都存储在Session中，那么开销是十分大的，因此不建议将所有信息都存储在Session中。</li></ul><h3 id="5-3-缓存"><a href="#5-3-缓存" class="headerlink" title="5.3 缓存"></a>5.3 缓存</h3><p><strong>优点：</strong></p><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h4 id="5-3-1-实现方式"><a href="#5-3-1-实现方式" class="headerlink" title="5.3.1 实现方式"></a>5.3.1 实现方式</h4><ul><li>让代理服务器进行缓存</li><li>让客户端进行缓存</li></ul><h4 id="5-3-2-Cache-Control"><a href="#5-3-2-Cache-Control" class="headerlink" title="5.3.2 Cache-Control"></a>5.3.2 Cache-Control</h4><ul><li>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</li></ul><p>禁止使用缓存</p><ul><li>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p>强制确认缓存</p><ul><li>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>私有缓存和公共缓存</p><ul><li>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure><ul><li>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure><h4 id="5-3-3-缓存过期机制"><a href="#5-3-3-缓存过期机制" class="headerlink" title="5.3.3 缓存过期机制"></a>5.3.3 缓存过期机制</h4><ul><li><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><ul><li>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h4 id="5-3-4-缓存验证"><a href="#5-3-4-缓存验证" class="headerlink" title="5.3.4 缓存验证"></a>5.3.4 缓存验证</h4><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><h3 id="5-4-内容协商"><a href="#5-4-内容协商" class="headerlink" title="5.4 内容协商"></a>5.4 内容协商</h3><ul><li>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</li></ul><ol><li><strong>类型</strong></li></ol><p><strong>1.1 服务端驱动型</strong>  </p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><p><strong>1.2 代理驱动型</strong>  </p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p><ol start="2"><li><strong>Vary</strong></li></ol><ul><li>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</li><li>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</li></ul><h3 id="5-6-内容编码"><a href="#5-6-内容编码" class="headerlink" title="5.6 内容编码"></a>5.6 内容编码</h3><ul><li>内容编码将实体主体进行压缩，从而减少传输的数据量。</li><li>常用的内容编码有：gzip、compress、deflate、identity。</li><li>浏览器发送 <strong>Accept-Encoding 首部</strong>，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</li></ul><h3 id="5-7-范围请求"><a href="#5-7-范围请求" class="headerlink" title="5.7 范围请求"></a>5.7 范围请求</h3><ul><li>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</li></ul><ol><li><strong>Range</strong></li></ol><ul><li>在请求报文中添加 Range 首部字段指定请求的范围。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></table></figure><ul><li>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Accpet- Ranges</strong></li></ol><ul><li>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>响应状态码</strong></li></ol><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul><h3 id="5-8-分块传输编码"><a href="#5-8-分块传输编码" class="headerlink" title="5.8 分块传输编码"></a>5.8 分块传输编码</h3><ul><li>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</li></ul><h3 id="5-9-多部份对象集合"><a href="#5-9-多部份对象集合" class="headerlink" title="5.9 多部份对象集合"></a>5.9 多部份对象集合</h3><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="submit-name"</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="files"; filename="file1.txt"</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><h3 id="5-10-虚拟主机"><a href="#5-10-虚拟主机" class="headerlink" title="5.10 虚拟主机"></a>5.10 虚拟主机</h3><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h3 id="5-11-通信数据转发"><a href="#5-11-通信数据转发" class="headerlink" title="5.11 通信数据转发"></a>5.11 通信数据转发</h3><h4 id="5-11-1-代理"><a href="#5-11-1-代理" class="headerlink" title="5.11.1 代理"></a>5.11.1 代理</h4><ul><li><p>代理服务器接受客户端的请求，并转发给其他服务器(Nginx)</p></li><li><p>使用代理的主要目的是：</p><ul><li><strong>缓存</strong></li><li><strong>负载均衡</strong></li><li><strong>网络访问控制</strong></li><li><strong>访问日志记录</strong></li></ul></li><li><p>代理服务器分为<strong>正向代理</strong>和<strong>反向代理</strong>两种</p><ul><li>用户察觉得到正向代理的存在。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png" width=""/> </div><br>- 反向代理一般位于内部网络中，用户察觉不到<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png" width=""/> </div><br></li></ul><h4 id="5-11-2-网关"><a href="#5-11-2-网关" class="headerlink" title="5.11.2 网关"></a>5.11.2 网关</h4><ul><li>与代理服务器不同的是，<strong>网关服务器会将HTTP转换成其他协议进行通信，从而实现其他非HTTP请求</strong> （RPC）</li></ul><h4 id="5-11-3-隧道"><a href="#5-11-3-隧道" class="headerlink" title="5.11.3 隧道"></a>5.11.3 隧道</h4><ul><li>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</li></ul><h2 id="六-HTTPS"><a href="#六-HTTPS" class="headerlink" title="六. HTTPS"></a>六. HTTPS</h2><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的<strong>身份有可能遭遇伪装；</strong></li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p><strong>HTTPS 并不是新的协议，而是让HTTP 先和 SSL(Secure Sockets Layer )通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信。</strong></p><p><strong>通过SSL ,HTTPS具有了加密（防窃听），认证（防伪装）和 完整性保护（防篡改）</strong></p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg" width="700"/> </div><br><h3 id="6-1-加密"><a href="#6-1-加密" class="headerlink" title="6.1 加密"></a>6.1 加密</h3><h4 id="6-1-1-对称密钥加密"><a href="#6-1-1-对称密钥加密" class="headerlink" title="6.1.1 对称密钥加密"></a>6.1.1 对称密钥加密</h4><ul><li>对称密钥加密（Symmetric-Key Encryption），加密和解密使用的是同一个密钥。<ul><li>优点：运算速度快。</li><li>缺点：无法安全的将密钥传输给通信方。</li></ul></li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600"/> </div><br><h4 id="6-1-2-非对称加密"><a href="#6-1-2-非对称加密" class="headerlink" title="6.1.2 非对称加密"></a>6.1.2 非对称加密</h4><ul><li>非对称加密，又叫做公开密钥加密（Public-Key Encryption）,加密和解密使用不同的密钥</li></ul><ul><li>公开密钥所有人都可以获得，通信发送发获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥进行解密。</li><li>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方无法使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</li></ul><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600"/> </div><br><h3 id="6-2-HTTPS采用的加密方式"><a href="#6-2-HTTPS采用的加密方式" class="headerlink" title="6.2 HTTPS采用的加密方式"></a>6.2 HTTPS采用的加密方式</h3><ul><li>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方</li><li>而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key  传输给通信方。</li></ul><p>HTTPS采用了混合加密的方式，正式利用了上面提到的方案：：</p><ul><li>使用非对称加密的方式，传输对称密钥加密所需要的 Secret Key ，从而保证安全性</li><li>获取到Secret Key 之后，在使用对称密钥方法进行通信，从而保证效率</li></ul><p>（下图中的 <code>Session Key</code> 就是 <code>Secret Key</code>）</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png" width="600"/> </div><br><h3 id="6-3-认证"><a href="#6-3-认证" class="headerlink" title="6.3 认证"></a>6.3 认证</h3><ul><li><p>通过使用 <strong>证书</strong> 来对通信放进行认证</p></li><li><p>数字证书认证机构（<strong>CA</strong>,Certificate Authority）是<strong>客户端和服务器双方都信赖的第三方机构</strong>。</p></li><li><p>服务器的运营人员向<strong>CA提出公开密钥的申请，CA再判明提出申请的身份之后，会对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将公开密钥证书后绑定在一起。</p></li><li><p><strong>进行HTTPS通信的时候，服务器会把证书发送给客户端。客户端取得其公开密钥之后，先使用数字签名进行验证，如果通过，才能开始通信。</strong></p></li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png" width=""/> </div><br><h3 id="6-4-完整性保护"><a href="#6-4-完整性保护" class="headerlink" title="6.4 完整性保护"></a>6.4 完整性保护</h3><ul><li>SSL 提供报文摘要功能来对完整性进行保护。</li><li>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</li><li><strong>HTTPS 的报文摘要功能</strong>之所以安全，是因为它结合了<strong>加密和认证这两个操作</strong>。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</li></ul><p><strong>HTTPS的缺点：</strong></p><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2 id="七-：-HTTP-2-0"><a href="#七-：-HTTP-2-0" class="headerlink" title="七 ： HTTP/2.0"></a>七 ： HTTP/2.0</h2><p>参考博客 ： <a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">https://www.zhihu.com/question/34074946</a></p><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><p><strong>1.0 短连接：请求完了即关闭</strong></p><p><strong>1.1 长连接：设置了<code>keep- alive time</code> 来保证TCP连接不关闭</strong></p><p><strong>2.0 多路复用</strong>：<strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。</strong></p><ul><li>目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。</li></ul><h4 id="7-1-二进制分帧层"><a href="#7-1-二进制分帧层" class="headerlink" title="7.1 二进制分帧层"></a>7.1 二进制分帧层</h4><ul><li>HTTP/2.0 将报文分成 <code>HEADERS</code> 帧和 <code>DATA</code> 帧，它们都是二进制格式的。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png" width="400"/> </div><br><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png" width="600"/> </div><br><h4 id="7-2-服务端推送"><a href="#7-2-服务端推送" class="headerlink" title="7.2 服务端推送"></a>7.2 服务端推送</h4><ul><li>HTTP 2.0 在客户端请求一个资源的时候，会把相关的资源一起发送给客户端，这样客户端就不用再次发起请求。</li><li>例如客户端请求 page.html 页面，服务端就把<code>script.js</code> 和<code>style.css</code>等与之相关的资源一起发给客户端。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" width="800"/> </div><br><h4 id="7-3-首部压缩"><a href="#7-3-首部压缩" class="headerlink" title="7.3 首部压缩"></a>7.3 首部压缩</h4><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png" width="600"/> </div><br><h2 id="八：-HTTP-1-1新特性"><a href="#八：-HTTP-1-1新特性" class="headerlink" title="八： HTTP/1.1新特性"></a>八： HTTP/1.1新特性</h2><ul><li>默认是长连接</li><li>支持流水线</li><li>同时可以打开多个TCP连接</li><li>支持虚拟主机</li><li>新增状态码100</li><li>支持分块传输编码</li><li>新增缓存处理指令  max - age</li></ul><h2 id="九：-GET-和-POST-比较"><a href="#九：-GET-和-POST-比较" class="headerlink" title="九： GET 和 POST 比较"></a>九： GET 和 POST 比较</h2><ol><li><strong>作用上的比较</strong></li></ol><ul><li>get用于请求获取资源</li><li>POST传递传递要给表单，这个表单可以是数据的主体</li></ul><ol start="2"><li><strong>参数</strong></li></ol><ul><li>GET 和 POST 的请求都能使用额外的参数，但是 <strong>GET 的参数是以查询字符串出现在 URL 中，</strong></li><li>而 <strong>POST 的参数存储在实体主体</strong>中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些<strong>抓包工具（Fiddler）查看</strong>。</li></ul><ol start="3"><li><strong>字符集</strong></li></ol><ul><li>因为 URL 只支持 <strong>ASCII 码</strong>，因此 <strong>GET 的参数中如果存在中文等字符就需要先进行编码</strong></li><li>POST支持 UTF-8</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</span><br><span class="line"></span><br><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>安全</strong></li></ol><ul><li>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</li><li>POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</li></ul><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><ol start="5"><li><strong>幂等性</strong></li></ol><ul><li>幂等的HTTP请求，<strong>同样的请求被执行一次或者执行多次的效果是一样的，因此服务器的状态也是一样的。</strong>换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</li><li>所有的安全方法也都是幂等的。</li><li>所以说：GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。<ul><li>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</li><li>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</li><li>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</li></ul></li></ul><ol start="6"><li><strong>可缓存</strong></li></ol><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><ol start="7"><li><strong>XMLHttpRequest</strong></li></ol><ul><li>为了阐述POST和 GET的另一个区别，需要先了解一个类 <strong>XMLHttpRequest(ajax)</strong>- </li><li>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。<strong>XMLHttpRequest 在 AJAX 中被大量使用。</strong></li></ul><p><strong>在使用XMLHttpRequest 的POST方法的时候 ， 浏览器会先发送Header 再发送 Data。</strong></p><p><strong>而Get方法会把Header和 Data一起发送。</strong></p><h2 id="十：-HTTP无状态无链接"><a href="#十：-HTTP无状态无链接" class="headerlink" title="十： HTTP无状态无链接"></a>十： HTTP无状态无链接</h2><p><strong>正文：http协议无状态中的【状态】到底指的是什么？！</strong></p><p>先来看这句话的另外两个概念：（标准的http协议是<strong>无状态的，无连接</strong>的）</p><ol><li>标准的http协议指的是不包括<code>cookies, session，application</code>的http协议，他们都不属于标准协议，虽然各种网络应用提供商，实现语言、web容器等，都默认支持它</li><li><strong>无连接指的是什么</strong><ol><li>每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的</li><li><strong>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接</strong></li></ol></li></ol><p><strong>对于【无状态】</strong>，我看到很多隔着一层磨砂玻璃一样的模糊说法（官方或者教程里的说法），看着非常难受（但其实算是对的）（后来我发现我为什么觉得它看着难受了，因为他们引入了很多新的，而且明显是一个可能用在很多地方的广义名词，这些词最大的作用就是，混淆概念，下面我标注了）</p><ol><li>协议对于事务处理<strong>没有记忆能力</strong>【事物处理】【记忆能力】</li><li>对同一个url请求没有上下文关系【上下文关系】</li><li><strong>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的</strong>，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器【状态】</li></ol><p>这几点给了我下一步思考的方向：</p><ol><li>【服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 】这里的客户端的状态是不是确切地指服务器没有保存客户的信息呢？但显然不是啊</li><li>【HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品】我对此质疑为什么无状态就不能实现购物车呢？服务器就不能存储东西了么？</li><li>【 每次的请求都是独立的，&lt;它的执行情况和结果&gt;与&lt;前面的请求&gt;和&lt;之后的请求&gt;是无直接关系的】我觉得这个说法比较靠谱，但是所谓的不同请求间的没有关系，是指的请求内容没有关系，还是只是指请求本身没有关系？<ol><li>请求内容没有关系只可能是服务器上不存有用户数据才可能啊，但是显然是存有的啊</li><li>请求本身没有关系，这又有什么意义呢，每一次的请求有什么价值？</li></ol></li></ol><p>根据这个方向我做了一个模拟访问实验：假如没有cookie没有session，只有http的时候，那当一个注册用户访问这个购物网站的时候，会发生这些事情：</p><ol><li>前提情况：<ol><li>服务器肯定为每个注册用户建立了数据表，记录用户的数据</li><li>http是无连接的</li></ol></li><li>第一步需要登录<ol><li>用户通过http把用户的用户名和密码发送给服务器，服务器把他们跟自己存有的用户资料对比，如果一致，则返回信息登录成功</li></ol></li><li>然后用户点击某一商品页<ol><li>这个动作相当于输入一个商品页的网址</li><li>假如商品页比较机密不对外公开，需要是用户才能访问</li><li>而虽然http能传送用户名和密码，而且刚才也输入了，还验证成功了，但是因为服务器既不会记得你登录的状态，你的客户端也不会存储你刚才输入的用户名和密码</li><li>所以因为这一次访问因为无法确定你的身份，只能访问失败<ol><li>这时候如果要解决这个问题，而且没有cookie没有session，那就只能你在访问网址的同时继续带上你的用户名和密码（继续输入咯）其实就像我现在的APP一样</li></ol></li></ol></li><li>假设上一步的问题解决了，就是每次访问的时候都会手动输入用户名和密码，然后现在的情况是：你已经选了几件商品在你的购物车中，你想再添加一件商品，于是你点击某个商品旁边的加号<ol><li>这个动作也相当于输入一个网址，网址的内容是发送一个请求，往你的购物车中加入这个商品</li><li>系统首先用你传来的用户名和密码验证你的身份，然后访问你的数据库，在其中的购物车属性下加一条数据，就是这个商品的数据</li><li>操作结束后，返回操作成功，并结束访问</li></ol></li><li>OK，实验结束，看似没有cookie没有session也能凑合解决问题，其实两个操作都有很大的问题<ol><li>你每访问一次需要权限的内容都需要在客户端输入用户名和密码，这一项的繁琐就不必赘述了</li><li>你的每一次操作都要与系统底层的数据库进行交互<ol><li>多次少量的访问存在非常大的性能浪费。非常容易就能想到肯定是一次大量的操作更加有效率，于是就想到了缓存区</li></ol></li><li>你的非重要琐碎数据也被写进数据库中，跟你的主要数据放在一起<ol><li>一次次添加和删除购物车其实只是跟你这次浏览，或者叫这次会话有关，是临时的数据，跟用户的主要信息无关，它们没什么价值，纯粹的冗余数据（不排除现在有的公司觉得这种数据也有非常大的价值可以让它们巧妙的利用），用什么存放这些临时的数据，我们也很容易想到缓存区</li></ol></li></ol></li></ol><p>经过这个模拟访问实验，结合前面的思考方向，我们知道了三点：</p><ol><li>服务器上肯定存有用户的数据，你提交的增删改查它也能够处理，所以这句话中【服务器中没有保存客户端的状态】的状态并不是指用户的数据，我们的猜测不对</li><li>我们的质疑对了，无状态能实现购物车，可以通过服务器上存有的用户数据来实现</li><li>但是，使用上面这种方式实现购物车，存在三个比较大的问题。由此，我们不禁会想，这三个问题的解决是不是跟我们不确切了解的【状态】一词有关？于是，接下来我们来通过解决这三个问题来把【状态】的意义探寻下去</li></ol><p>由上所述，我们可以在http的基础上增加一些机制来解决上面出现的三个问题</p><ol><li>在用户端增加一个记录本是非常有必要的，正好官方加入的cookie机制跟这个一样，它的用处也确实是上面讨论的那样，一般就是用来标识访问者的身份</li><li>在服务器增加一个缓存区能同时解决后两个问题<ol><li>有了这个缓存区作为一个数据缓冲，就不用一次次地访问数据库，浪费大量计算机资源，而是在最后统一归入数据库</li><li>有了这个缓存区，你就不用把临时的数据放到数据库中了，只需要在你们交流告一段落之后，再把数据整理，把有用的数据归入数据库</li></ol></li><li>这里就自然引申出了一个重要的概念：会话，它作为一个缓冲存储区被从数据库中分离出来，理由并不生硬，它有其独特的重要且不可替代的作用。这个东西恰好跟官方加入的session机制一样<ol><li>另外说一个非常具有迷惑性的容易让人对session的主要作用产生偏离的理解：认为session存在的价值就是给访问者分配一个sessionID代替用户名和密码，</li><li>为什么非常具有迷惑性，因为session确实做了这件事，而且也起到了很大的作用，所以它是对的，但是只对一半，而且没有涉及问题的本质，这种情况是最危险的（看似很有说服力，把你说服了，所以你很难有动力继续找下去，但是真实情况跟它有偏差，但是偏差不大，所以又很难把你说服回来，只有隐隐的不对劲，这个时候你离真实最近，也离真实最远）</li><li>那就顺便说说它为什么是对的，也就是用session做的另一件有用的事：<ol><li>给每个session一个ID，一方面用来方便自己查询，另一方面把这个ID给用户，用户下一次访问的时候就可以不用用户名和密码，而是直接使用这个ID来表明自己的身份</li><li>首先，这个ID安全吗？这个ID比直接传用户名和密码安全吗？<ol><li>你很容易会想到，本来用户名和密码的组合还特地设置地比较复杂，你这换一组数字就代替了，是不是太不安全了？</li><li>我们知道http协议本身是完全不加密的，如果使用用户名和密码，第一次访问是放在http头中，后边自动保存了密码就会放在cookie中，这些都完全没有加密，它的安全性基本为0，就是裸奔了，只要被窃取，那就丢失了</li><li>所以，就这个意义来讲，sessionID的安全性跟使用用户名和密码没什么区别</li><li>但是其实，虽然http本身不能加密，但是有些软件什么的，能在应用层面手动给你加密，比如QQ就会使用户名密码加临时验证码联合哈希，sessionID加一个时间戳简单加密也是非常常用的方法</li><li>而且因为sessionID本身有有效期，即使丢了，也可能很快失效，造成的损失可能没那么大，而用户名跟密码丢了，那就大了</li><li>所以总结就是：<ol><li>不严格加密的sessionID和用户名和密码一样，都不太安全</li><li>但是相比较来说，sessionID要安全一些</li><li>而使用https是完全安全的</li></ol></li></ol></li><li>然后，使用sessionID有哪些好处<ol><li>方便直接根据ID查询用户对应的session</li><li>加密的时候计算量小</li><li>安全性不会降低，甚至还更高一些</li></ol></li></ol></li></ol></li></ol><p>OK，通过独立地解决纯http机制会产生的问题，我们探讨了cookie和session机制的本质。而且想到：【使用http协议，服务器中不会保存客户端的状态】所产生的问题通过增加cookie和session机制解决了，是不是就意味着这个【状态】跟cookie和session的关系非常紧密？所以这个无状态指的是【没有对 本次会话 设置一个缓存区，记录这次会话的状态，缓存区包括服务器端和用户端】但好像还是没有点破关键（主要是觉得跟前面那些官方对状态的说法不太吻合，甚至没有对应关系）</p><p>忽然我想到一个问题：一个有状态的http是什么样的？</p><ol><li><p>很难直接想象有状态的http是什么样，因为http这种机制是天然无状态的</p></li><li><p>那就类比一下吧，另一个天然有状态的机制叫TCP</p><ol><li>如果有状态的意思是它的每次请求是有联系的，那么有状态的TCP的样子是：假如一份数据分了三份TCP包发送，那这个包上面会标明这是第几个包，会标明这个包跟那几个包是有联系的，有什么联系</li></ol></li><li><p>但好像这个有状态的TCP跟我们想要的有状态的HTTP没有关系，因为即使每次http请求之间互相有联系，它也不能解决上面提到的http无状态的问题</p></li><li><p>诶，等等，好像能类比：</p><ol><li><p>假如每个http连接都有一个签名，于是第一次登陆成功之后，服务器就知道了这个签名是允许登陆的，于是之后所有同样签名的http连接都能登陆，这里利用了同一个用户发出的http连接之间的同主人关系，这里解决了一个保持登录状态的问题</p></li><li><p>同样，来尝试利用这个【每次http请求之间互相有联系】来解决上面碰到的那个问题【每一次操作都要与系统底层的数据库进行交互】，但想了半天确实无法进行下去</p></li><li><p>不过我灵机一动，从另一个角度来想，好像解决了这个问题：</p><ol><li><p>只有【每次http请求之间互相有联系】这个条件，无法解决【每一次操作都要与系统底层的数据库进行交互】</p></li><li><p>因为很明显，要解决【每一次操作都要与系统底层的数据库进行交互】就必须在服务器端开辟一块缓存区</p></li><li><p>不过如果你思考一下如何实现【每次http请求之间互相有联系】，你就会发现，它也需要在服务器端开辟一块缓存区</p></li><li><p>所以【在服务器端开辟一块缓存区】才是真正的条件，也就是说，它确实等价于【有状态】</p></li><li><p>而且我也找到了这个【在服务器端开辟一块缓存区】的条件跟前面那些官方对状态的说法对应的点，那就是：</p><ol><li>通过在服务器端开辟一块缓存区，存储、记忆、共享一些临时数据，你就可以：<ol><li>协议对于事务处理有记忆能力【事物处理】【记忆能力】</li><li>对同一个url请求有上下文关系【上下文关系】</li><li>每次的请求都是不独立的，它的执行情况和结果与前面的请求和之后的请求是直接关系的【不独立】【直接关系】</li><li>服务器中保存客户端的状态【状态】</li></ol></li></ol></li><li><p>所以，这个状态，加上前面说的客户端也有cookie，就是指，</p><p>客户端和服务器在临时会话中产生的数据</p><p>！而前面也说道了，使用缓存区保存临时会话中的数据是多么重要</p><ol><li>所以状态不仅包括不同URL访问之间的关系，还有对其他URL访问的数据记录，还有一些其他的东西，所以更确切地说，状态应该是【实现了这些东西所凭借的后面的缓存空间】中的客户的临时数据</li><li>cookie和session应该是完全实现了有状态这个功能</li></ol></li></ol></li></ol></li></ol><p><strong>一种常见的对状态的误解：</strong></p><ol><li>有人在解释HTTP的无状态时，把它跟有连接对立，说是两种方式，也就是如果想不无状态，就必须有连接，但其实不然</li><li>有连接和无连接以及之后的Keep-Alive都是指TCP连接</li><li>有状态和无状态可以指TCP也可以指HTTP</li><li>TCP一直有状态，HTTP一直无状态，但是应用为了有状态，就给HTTP加了cookie和session机制，让使用http的应用也能有状态，但http还是无状态</li><li>开始TCP是有连接，后来TCP无连接，再后来也就是现在TCP是Keep-Alive，有点像有连接</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-HTTPS详解&quot;&gt;&lt;a href=&quot;#HTTP-HTTPS详解&quot; class=&quot;headerlink&quot; title=&quot;HTTP-HTTPS详解&quot;&gt;&lt;/a&gt;HTTP-HTTPS详解&lt;/h1&gt;&lt;h2 id=&quot;一：-基础概念&quot;&gt;&lt;a href=&quot;#一：-基础概念&quot; class=&quot;headerlink&quot; title=&quot;一： 基础概念&quot;&gt;&lt;/a&gt;一： 基础概念&lt;/h2&gt;&lt;h3 id=&quot;1-1-URI&quot;&gt;&lt;a href=&quot;#1-1-URI&quot; class=&quot;headerlink&quot; title=&quot;1.1 URI&quot;&gt;&lt;/a&gt;1.1 URI&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;URI 包含 URL 和 URN。&lt;/li&gt;
&lt;li&gt;我们通常所说的&lt;strong&gt;URL（统一资源定位符）是URI的子集&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;URI还有一个自己URN , URN只命名资源但是不指定如何定位资源.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120156077.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络编程" scheme="http://zhuuu.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://zhuuu.work/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://zhuuu.work/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-015-三数之和</title>
    <link href="http://zhuuu.work/2020/06/24/Leetcode/Leetcode-015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/06/24/Leetcode/Leetcode-015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-24T11:52:53.000Z</published>
    <updated>2020-06-27T04:35:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-015-三数之和"><a href="#Leecode-015-三数之和" class="headerlink" title="Leecode-015-三数之和"></a>Leecode-015-<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></h1><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路</strong></p><ul><li>首先对排序后的数组进行遍历，固定一个nums[i] 。</li><li>其次使用一个指针L指向 <code>i + 1</code> 的位置，一个指针R指向 <code>nums.length - 1</code>的位置，同时计算<code>nums[i] + nums[L] + nums[R]</code>,计算这三个数的和是否等于0</li><li>细节条件一定要注意<ul><li>如果<code>nums[i] &gt; 0</code> ，那么这三个数的和比不可能等于0</li><li>如果<code>nums[i] == nums[i -1]</code> ,则说明该数字重复，会导致结果的重复，所以应该跳过</li><li>当sum == 0的时候，如果<code>nums[L] == nums[L+1]</code>,则会导致结果的重复，应该跳过，(L++)</li><li>当sum == 0的时候，如果<code>nums[R] == nums[R - 1]</code>,则会导致结果的重复，应该跳过，(R–)</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li><strong>首先进行排序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100358932.png" alt="mark"></p><ol start="2"><li><strong>第一轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100418544.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100451353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100458185.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100504327.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100511291.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100527129.png" alt="mark"></p><ol start="3"><li><strong>第二轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100538257.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100548763.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100554929.png" alt="mark"></p><ol start="4"><li><strong>第三轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100609939.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100615721.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：ans记录结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历数组中的每一个数字，固定nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于0,，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：对 i 进行去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化双指针</span></span><br><span class="line">            <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 指针遍历</span></span><br><span class="line">            <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  如果三数之和等于0</span></span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 记录结果</span></span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>]) L++; <span class="comment">// 注意：去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>]) R--; <span class="comment">// 注意：去重</span></span><br><span class="line">                    <span class="comment">// 指针移动来产生新的结果</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O（n^2） 排序O(nlogn) + 循环O（n^2） = O(n^2)</li><li>空间复杂度：O(1)  没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-015-三数之和&quot;&gt;&lt;a href=&quot;#Leecode-015-三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-015-三数之和&quot;&gt;&lt;/a&gt;Leecode-015-&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;三数之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;p&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定数组 nums &amp;#x3D; [-1, 0, 1, 2, -1, -4]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;满足要求的三元组集合为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, -1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leecode-016-最接近的三数之和</title>
    <link href="http://zhuuu.work/2020/06/24/Leetcode/Leetcode-016-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/06/24/Leetcode/Leetcode-016-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-24T07:52:53.000Z</published>
    <updated>2020-06-25T01:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-016-最接近的三数之和"><a href="#Leecode-016-最接近的三数之和" class="headerlink" title="Leecode-016-最接近的三数之和"></a>Leecode-016-<a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091530419.png" alt="mark"></p><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><ul><li>本题目和Leetcode-015合在一起是三数之和的系列题目</li><li><a href="https://leetcode-cn.com/problems/3sum/（Leetcode-015）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/（Leetcode-015）</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。</li><li>找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。</li><li>假定每组输入只存在唯一答案。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">3 &lt;&#x3D; nums.length &lt;&#x3D; 10^3</span><br><span class="line">-10^3 &lt;&#x3D; nums[i] &lt;&#x3D; 10^3</span><br><span class="line">-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路：</strong></p><ul><li>本题目因为要计算三个数，如果暴力枚举的话时间复杂度会来到O（n^3） ，需要降低时间的复杂度才行</li><li>首先对数组进行排序，时间复杂度O(nlogn)</li><li>在数组 nums 中，进行遍历，每次遍历固定一个nums[i]</li><li>其次使用两个指针，一个L指针指向<code>i + 1</code> 处，一个R指针指向 <code>nums.length-1</code> 处，也就是结尾处。</li><li>计算sum的值 ，sum = nums[i] + nums[L] + nums[R]</li><li>最后判断sum 和 target的关系，因为数组有序，<ul><li>如果sum &gt; target, <code>R --</code></li><li>如果sum &lt; target , <code>L++</code></li><li>如果 sum == target ,距离为0直接返回结果</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li>排序</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091321683.png" alt="mark"></p><ol start="2"><li>初始化</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091334756.png" alt="mark"></p><ol start="3"><li>for循环</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091411150.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091423709.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091437310.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091444470.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091452814.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091505156.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091511678.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091521010.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化</span></span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 循环固定nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (L &lt; R)&#123;</span><br><span class="line">                <span class="comment">// 三数之和</span></span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次更新结果</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(target - sum) &lt; Math.abs(target - ans))&#123;</span><br><span class="line">                    ans = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断sum 和 target之间的关系</span></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target)&#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ：O（n^2）  排序O(nlogn) + 遍历O(n^2) = O(n^2)</li><li>空间复杂度： O(1) 没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-016-最接近的三数之和&quot;&gt;&lt;a href=&quot;#Leecode-016-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-016-最接近的三数之和&quot;&gt;&lt;/a&gt;Leecode-016-&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-closest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最接近的三数之和&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091530419.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本题目和Leetcode-015合在一起是三数之和的系列题目&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/（Leetcode-015）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/3sum/（Leetcode-015）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个包括 &lt;em&gt;n&lt;/em&gt; 个整数的数组 &lt;code&gt;nums&lt;/code&gt; 和 一个目标值 &lt;code&gt;target&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;找出 &lt;code&gt;nums&lt;/code&gt; 中的三个整数，使得它们的和与 &lt;code&gt;target&lt;/code&gt; 最接近。返回这三个数的和。&lt;/li&gt;
&lt;li&gt;假定每组输入只存在唯一答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1,2,1,-4], target &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：与 target 最接近的和是 2 (-1 + 2 + 1 &amp;#x3D; 2) 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 10^3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10^3 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 10^3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10^4 &amp;lt;&amp;#x3D; target &amp;lt;&amp;#x3D; 10^4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-350-两个数组的交集II</title>
    <link href="http://zhuuu.work/2020/06/23/Leetcode/Leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>http://zhuuu.work/2020/06/23/Leetcode/Leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</id>
    <published>2020-06-23T03:22:53.000Z</published>
    <updated>2020-06-25T07:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-350-两个数组的交集-II"><a href="#Leetcode-350-两个数组的交集-II" class="headerlink" title="Leetcode-350-两个数组的交集 II"></a>Leetcode-350-<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>进阶:</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><a id="more"></a><h2 id="方法一：排序-双指针"><a href="#方法一：排序-双指针" class="headerlink" title="方法一：排序+双指针"></a>方法一：排序+双指针</h2><p><strong>算法分析：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/143433760.jpg" alt="mark"></p><ul><li><p>首先对两个数组<code>nums1</code> 和 <code>nums2</code>进行排序</p></li><li><p>初始化指针<code>i,j</code> 用于指向两个数组</p><ul><li>指针<code>i</code> 指向 <code>nums1</code>,指针<code>j</code> 指向<code>nums2</code></li><li>如果<code>nums1[i] &lt; nums2[j]</code>  则 <code>i++</code></li><li>如果<code>nums1[i] &gt; nums2[j]</code>  则 <code>j++</code></li><li>如果<code>nums1[i] == nums2[j]</code>  则将元素拷贝到<code>nums1[k]</code>,且同时<code>i++ , j ++ , k++</code></li></ul></li><li><p><strong>初始化指针<code>k</code> 用于记录是否应该修改元素（作用是为了不使用额外的空间）</strong></p></li><li><p><strong>最后返回<code>nums1</code>的前k个元素就好</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对两个数组进行排序</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 指向nums1</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 指向nums2</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">// 用于记录nums1 和 nums2 中重复元素的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。</span></span><br><span class="line">        <span class="comment">// 注意这里包括下标from，不包括上标to。</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(nums1,<span class="number">0</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：</strong><code>O(nlogn+mlogm)</code>其中 n，m分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。</li><li><strong>空间复杂度</strong>：O（1） 没有使用额外的空间。</li></ul><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><ul><li>相对于上一题我们使用set去重，本题不要求去重，那么使用哈希表也很合适</li><li>如果 <code>nums1</code> 元素个数大于 <code>nums2</code>，则交换数组元素。</li><li>对于 <code>nums1</code> 的每个元素，添加到 <code>HashMap m</code> 中，如果元素已经存在则增加对应的计数。(这里用了一个getOrDefault方法，作用同map用if-else存放元素)</li><li>遍历数组<code>nums2</code><ul><li>检查元素在map中是否存在，如果存在且个数大于0<ul><li>将元素拷贝到<code>nums1[k]</code>, k++</li><li>减少map中对应元素的个数</li></ul></li></ul></li></ul><ul><li>最后返回<code>nums1</code>的前k个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 首先决定用长度小的数组进行操作（检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。）</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用map存放元素</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">            map.put(n, map.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 对应nums2去减少元素，（避免再开一个map浪费空间）</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果有这个Key存在的话</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums2[i]))&#123;</span><br><span class="line">                <span class="comment">// 获取这个key对应的value，</span></span><br><span class="line">                <span class="comment">// 如果对应的value &gt; 0,并将这个value值 - 1</span></span><br><span class="line">                <span class="keyword">int</span> count = map.get(nums2[i]);</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    map.put(nums2[i],count - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 同时把当前元素的值赋值给nums1[k] ，这样减少了内存的浪费</span></span><br><span class="line">                    nums1[k] = nums2[i];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(nums1,<span class="number">0</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>时间复杂度</strong>：<strong>O( n + m )</strong> 其中 n<em>，m</em> 分别代表了数组的大小。</p></li><li><p><strong>空间复杂度</strong>：<strong>O(min(m,n))</strong> 创建了两个数组中最小大小的map映射。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-350-两个数组的交集-II&quot;&gt;&lt;a href=&quot;#Leetcode-350-两个数组的交集-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-350-两个数组的交集 II&quot;&gt;&lt;/a&gt;Leetcode-350-&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个数组的交集 II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums1 &amp;#x3D; [1,2,2,1], nums2 &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums1 &amp;#x3D; [4,9,5], nums2 &amp;#x3D; [9,4,9,8,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [4,9]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。&lt;/li&gt;
&lt;li&gt;我们可以不考虑输出结果的顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果给定的数组已经排好序呢？你将如何优化你的算法？&lt;/li&gt;
&lt;li&gt;如果 nums1 的大小比 nums2 小很多，哪种方法更优？&lt;/li&gt;
&lt;li&gt;如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-242-有效的字母异位词</title>
    <link href="http://zhuuu.work/2020/06/15/Leetcode/Leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>http://zhuuu.work/2020/06/15/Leetcode/Leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</id>
    <published>2020-06-15T07:22:53.000Z</published>
    <updated>2020-06-17T09:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-242-有效的字母异位词"><a href="#Leecode-242-有效的字母异位词" class="headerlink" title="Leecode-242-有效的字母异位词"></a>Leecode-242-<a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p><p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><a id="more"></a><h2 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h2><p>思路： </p><ul><li>通过将s字符串转换成char数组</li><li>对每个字符进行排序。</li><li>因此，如果T是S的异位词，对两个字符串进行排序将产生两个相同的字符串。</li><li>此外，如果s和t的长度不同，t不可能是s的异位词，这样我们可以提前返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O（n）</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1,str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度分析<ul><li>时间复杂度：O(nlogn) ，排序的成本是O(nlogn) ，比较字符串的成本是O(n),所以总体的时间复杂度是O(nlogn)</li><li>空间复杂度：O(n) ,<code>toCharArray()</code> 制作了一个字符串的拷贝，所以它花费 O(n)额外的空间</li></ul></li></ul><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>思路：</p><ul><li>为了检查t是否是s的重新排列，我们只需要计算两个字符串中对应字母出现的次数是否相同即可</li><li>因为S和T都只包含26个小写字母，所以哈希表大小26个字母就够了</li><li>这里需要两个计数器来进行比较吗？<ul><li>答：不需要，只需要一个计数器表即可。用一个计数器表计算s字母的频率，用t减少计数器表中每个字母的计数器，然后检查计数器是否回到了0。</li></ul></li></ul><ul><li>这里直接用数组代替hash，减少哈希碰撞带来的复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="comment">// 为了检查t是否是s的重新排列，我们可以计算连个字符串中每个字母的出现次数并比较</span></span><br><span class="line"><span class="comment">// 因为s和t都只包含A-Z的字母，所以一个简单的26位计数器就够了</span></span><br><span class="line"><span class="comment">// 我们需要连个计数器表进行比较吗？</span></span><br><span class="line"><span class="comment">// 答：是不需要的，因为我们可以用一个计数器表计算s字母的频率，用t减少计数器表中每个字母的计数器，最后检查计数器是否回到0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            counter[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            counter[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count : counter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)     遍历两个字符串的开销</li><li>空间复杂度： O(1)     26个字母对计算机来说不是什么事情。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-242-有效的字母异位词&quot;&gt;&lt;a href=&quot;#Leecode-242-有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;Leecode-242-有效的字母异位词&quot;&gt;&lt;/a&gt;Leecode-242-&lt;a href=&quot;https://leetcode-cn.com/problems/valid-anagram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有效的字母异位词&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个字符串 &lt;em&gt;s&lt;/em&gt; 和 &lt;em&gt;t&lt;/em&gt; ，编写一个函数来判断 &lt;em&gt;t&lt;/em&gt; 是否是 &lt;em&gt;s&lt;/em&gt; 的字母异位词。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;anagram&amp;quot;, t &amp;#x3D; &amp;quot;nagaram&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;rat&amp;quot;, t &amp;#x3D; &amp;quot;car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;你可以假设字符串只包含小写字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;br&gt;如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-原码,补码,反码</title>
    <link href="http://zhuuu.work/2020/06/13/JavaInterview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%A0%81,%E8%A1%A5%E7%A0%81,%E5%8F%8D%E7%A0%81/"/>
    <id>http://zhuuu.work/2020/06/13/JavaInterview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%A0%81,%E8%A1%A5%E7%A0%81,%E5%8F%8D%E7%A0%81/</id>
    <published>2020-06-13T07:38:38.000Z</published>
    <updated>2020-06-13T07:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机基础-原码-补码-反码"><a href="#计算机基础-原码-补码-反码" class="headerlink" title="计算机基础-原码,补码,反码"></a>计算机基础-原码,补码,反码</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机基础-原码-补码-反码&quot;&gt;&lt;a href=&quot;#计算机基础-原码-补码-反码&quot; class=&quot;headerlink&quot; title=&quot;计算机基础-原码,补码,反码&quot;&gt;&lt;/a&gt;计算机基础-原码,补码,反码&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="计算机基础" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-349-两个数组的交集</title>
    <link href="http://zhuuu.work/2020/06/13/Leetcode/Leetcode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/06/13/Leetcode/Leetcode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-06-13T06:22:53.000Z</published>
    <updated>2020-07-13T11:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-349-两个数组的交集"><a href="#Leecode-349-两个数组的交集" class="headerlink" title="Leecode-349-两个数组的交集"></a>Leecode-349-<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">两个数组的交集</a></h1><h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h2 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：两个set"><a href="#方法：两个set" class="headerlink" title="方法：两个set"></a>方法：两个set</h2><ul><li>将两个数组都转换成集合</li><li>然后迭代较小的集合，检查其中每个元素是否在较大的集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将两个数组都转化为集合</span></span><br><span class="line"><span class="comment">// 然后迭代较小的集合</span></span><br><span class="line"><span class="comment">// 检查其中每个元素是否同样存在较大的集合中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把nums1数组存到对应的set1中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把nums2数组存到对应的set2中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            set2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从较小的set检查和较大数组的交集</span></span><br><span class="line">        <span class="keyword">if</span> (set1.size() &lt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(set1,set2);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(set2,set1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] helper(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;</span><br><span class="line">        <span class="comment">// 创建一个和较小set一样的数组记为result</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">        <span class="comment">// 交集含有的个数</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历较小Set</span></span><br><span class="line">        <span class="comment">// 查找较大set中是否存在较小set的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Integer num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.contains(num))&#123;</span><br><span class="line">                result[idx] = num;</span><br><span class="line">                idx++; <span class="comment">// 这里idx++完之后会比原数组长度多1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个idx长度的交集</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(result,idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度： O（m + n）</strong> 其中 <code>n</code> 和 <code>m</code> 是数组的长度。<ul><li>将<code>num1</code> 转换成集合要 O(n )的时间</li><li>类似地，将 <code>nums2</code> 转换为集合需要 <em>O</em>(<em>m</em>) 的时间</li><li>而在平均情况下，集合的 <code>in/contains</code> 操作只需要 O(1) 的时间。</li></ul></li></ul><ul><li><strong>空间复杂度：O<em>(</em>m<em>+</em>n)</strong>，最坏的情况是数组中的所有元素都不同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-349-两个数组的交集&quot;&gt;&lt;a href=&quot;#Leecode-349-两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;Leecode-349-两个数组的交集&quot;&gt;&lt;/a&gt;Leecode-349-&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个数组的交集&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：哈希表&quot;&gt;&lt;a href=&quot;#思路：哈希表&quot; class=&quot;headerlink&quot; title=&quot;思路：哈希表&quot;&gt;&lt;/a&gt;思路：哈希表&lt;/h2&gt;&lt;h2 id=&quot;题目表述&quot;&gt;&lt;a href=&quot;#题目表述&quot; class=&quot;headerlink&quot; title=&quot;题目表述&quot;&gt;&lt;/a&gt;题目表述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [1,2,2,1], nums2 &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [4,9,5], nums2 &amp;#x3D; [9,4,9,8,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[9,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>��Դ��Ŀ-02-SSM����</title>
    <link href="http://zhuuu.work/2020/06/13/Project/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-02-SSM%E6%95%B4%E5%90%88/"/>
    <id>http://zhuuu.work/2020/06/13/Project/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-02-SSM%E6%95%B4%E5%90%88/</id>
    <published>2020-06-13T03:02:24.000Z</published>
    <updated>2020-06-13T12:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="��Դ��L-02-SSM����"><a href="#��Դ��L-02-SSM����" class="headerlink" title="��Դ��Ŀ-02-SSM����"></a>��Դ��Ŀ-02-SSM����</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;��Դ��L-02-SSM����&quot;&gt;&lt;a href=&quot;#��Դ��L-02-SSM����&quot; class=&quot;headerlink&quot; title=&quot;��Դ��Ŀ-02-SSM����&quot;&gt;&lt;/a&gt;��Դ��Ŀ-02-SSM����&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="��Դ��Ŀ" scheme="http://zhuuu.work/tags/%EF%BF%BD%EF%BF%BD%D4%B4%EF%BF%BD%EF%BF%BDL/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-秒杀问题</title>
    <link href="http://zhuuu.work/2020/06/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/06/12/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-12T09:44:38.000Z</published>
    <updated>2020-09-17T03:02:19.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-秒杀问题"><a href="#Java-基础-秒杀问题" class="headerlink" title="Java-基础-秒杀问题"></a>Java-基础-秒杀问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>秒杀或抢购活动一般会经过【预约】【抢订单】【支付】这3个大环节，而其中【抢订单】这个环节是最考验业务提供方的抗压能力的。</p><p>抢订单环节一般会带来2个问题：</p><p>　　<strong>1、高并发</strong></p><p>　　比较火热的秒杀在线人数都是10w起的，如此之高的在线人数对于网站架构从前到后都是一种考验。</p><p>　　<strong>2、超卖</strong></p><p>　　任何商品都会有数量上限，如何避免成功下订单买到商品的人数不超过商品数量的上限，这是每个抢购活动都要面临的难题。</p><a id="more"></a><h2 id="1-前端解决方案"><a href="#1-前端解决方案" class="headerlink" title="1. 前端解决方案"></a>1. 前端解决方案</h2><p>面对高并发的抢购活动，前端常用的三板斧是<strong>【扩容】【静态化】【限流】</strong></p><p>　　<strong>A：扩容</strong></p><p>　　加机器，这是最简单的方法，通过增加前端池的整体承载量来抗峰值。</p><p>　　<strong>B：静态化</strong></p><p>　　将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过CDN来抗峰值。</p><p>　　<strong>C：限流</strong></p><p>　　一般都会采用IP级别的限流，即针对某一个IP，限制单位时间内发起请求数量。</p><p>　　或者活动入口的时候增加游戏或者问题环节进行消峰操作。</p><p>　　<strong>D：有损服务</strong></p><p>　　最后一招，在接近前端池承载能力的水位上限的时候，随机拒绝部分请求来保护活动整体的可用性。</p><h2 id="2-后端解决方案"><a href="#2-后端解决方案" class="headerlink" title="2. 后端解决方案"></a>2. 后端解决方案</h2><ul><li>那么后端的数据库在高并发和超卖下会遇到什么问题呢？主要会有如下3个问题：（<strong>主要讨论写的问题，读的问题通过增加cache可以很容易的解决）</strong><ul><li><strong>首先MySQL自身对于高并发的处理性能</strong>就会出现问题，一般来说，MySQL的处理性能会随着并发thread上升而上升，但是到了一定的并发度之后会出现明显的拐点，之后一路下降，最终甚至会比单thread的性能还要差。</li><li>其次，超卖的根结在于减库存操作是一个<strong>事务操作</strong>，需要先select，然后insert，最后update -1。最后这个-1操作是不能出现负数的，<strong>但是当多用户在有库存的情况下并发操作，出现负数这是无法避免的。</strong></li><li>最后，当减库存和高并发碰到一起的时候，由于操作的库存数目在同一行，就会出现<strong>争抢InnoDB行锁的问题，导致出现互相等待甚至死锁，</strong>从而大大降低MySQL的处理性能，最终导致前端页面出现超时异常。</li></ul></li></ul><p>针对上述问题，如何解决呢？ 我们先看眼<strong>淘宝的高大上解决方案</strong>：</p><p>　　<strong>I：  关闭死锁检测，提高并发处理性能。</strong></p><p>　　II： 修改源代码，将排队提到进入引擎层前，降低引擎层面的并发度。</p><p>　　<strong>III：组提交，降低server和引擎的交互次数，降低IO消耗。</strong></p><p>不过结合我们的实际，改源码这种高大上的解决方案显然有那么一点不切实际。于是小伙伴们需要讨论出一种适合我们实际情况的解决方案。以下就是我们讨论的解决方案：</p><ul><li>首先设定一个前提，为了防止超卖现象，所有减库存操作都需要进行一次减后检查，保证减完不能等于负数。（由于MySQL事务的特性，这种方法只能降低超卖的数量，但是不可能完全避免超卖）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="built_in">number</span> <span class="keyword">set</span> x=x<span class="number">-1</span> <span class="keyword">where</span> (x <span class="number">-1</span> ) &gt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>解决方案1：</strong></p><ul><li>将存库从MySQL前移到Redis中，所有的写操作放到内存中，由于Redis中不存在锁故不会出现互相等待，并且由于Redis的写性能和读性能都远高于MySQL，这就解决了高并发下的性能问题。<strong>然后通过队列等异步手段，将变化的数据异步写入到DB中。</strong><ul><li>优点：解决性能问题</li><li>缺点：没有解决超卖问题，同时由于异步写入DB，存在某一时刻DB和Redis中数据不一致的风险。</li></ul></li></ul><p><strong>解决方案2：</strong></p><ul><li><strong>引入队列，然后将所有写DB操作在单队列中排队，完全串行处理。当达到库存阀值的时候就不再消费队列，并关闭购买功能。这就解决了超卖问题。</strong><ul><li>（缓存里面设置阀值可以起到请求过滤的功能，有效的解决内存爆满问题。比如，设置阀值为100，每次请求先判断阀值是否大于0，大于0说明请求有效，存入Redis队列，阀值减1，小于等于0说明请求无效，直接返回结果（即产品售罄）。</li><li>一般来说，这个阀值的设置要比库存数稍微大点，这样就可以解决用户抢到产品而不付钱的情况。</li></ul></li><li><ul><li>优点：解决超卖问题，略微提升性能。</li><li>缺点：性能受限于队列处理机处理性能和DB的写入性能中最短的那个，另外多商品同时抢购的时候需要准备多条队列。</li></ul></li></ul><p><strong>解决方案3：</strong></p><ul><li><strong>将写操作前移到MC中</strong>，同时利用MC的轻量级的锁机制CAS来实现减库存操作。<ul><li>优点：读写在内存中，操作性能快，引入轻量级锁之后可以保证同一时刻只有一个写入成功，解决减库存问题。</li><li>缺点：没有实测，基于CAS的特性不知道高并发下是否会出现大量更新失败？不过加锁之后肯定对并发性能会有影响。</li></ul></li></ul><p><strong>解决方案4：</strong></p><ul><li><strong>将提交操作变成两段式，先申请后确认。</strong>然后利用Redis的原子自增操作（相比较MySQL的自增来说没有空洞），同时利用Redis的事务特性来发号，保证拿到小于等于库存阀值的号的人都可以成功提交订单。然后数据异步更新到DB中。<ul><li>优点：解决超卖问题，库存读写都在内存中，故同时解决性能问题。</li><li>缺点：由于异步写入DB，可能存在数据不一致。另可能存在少买，也就是如果拿到号的人不真正下订单，可能库存减为0，但是订单数并没有达到库存阀值。</li></ul></li></ul><p><strong>同时</strong></p><ul><li>为了防刷、防止同一个用户同一秒里面把购物车里的商品进行多次结算，防止前端代码出问题触发两次，我们可以使用<strong>分布式锁</strong>来解决。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>1、前端三板斧【扩容】【限流】【静态化】</p><p>2、后端两条路【内存】+【排队】</p><p><strong>参考博客：</strong> <a href="https://www.cnblogs.com/billyxp/p/3701124.html" target="_blank" rel="noopener">https://www.cnblogs.com/billyxp/p/3701124.html</a></p><p>​                    <a href="https://www.cnblogs.com/yaopengfei/p/12418229.html" target="_blank" rel="noopener">https://www.cnblogs.com/yaopengfei/p/12418229.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-秒杀问题&quot;&gt;&lt;a href=&quot;#Java-基础-秒杀问题&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-秒杀问题&quot;&gt;&lt;/a&gt;Java-基础-秒杀问题&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;秒杀或抢购活动一般会经过【预约】【抢订单】【支付】这3个大环节，而其中【抢订单】这个环节是最考验业务提供方的抗压能力的。&lt;/p&gt;
&lt;p&gt;抢订单环节一般会带来2个问题：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、高并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　比较火热的秒杀在线人数都是10w起的，如此之高的在线人数对于网站架构从前到后都是一种考验。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、超卖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　任何商品都会有数量上限，如何避免成功下订单买到商品的人数不超过商品数量的上限，这是每个抢购活动都要面临的难题。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="秒杀" scheme="http://zhuuu.work/tags/%E7%A7%92%E6%9D%80/"/>
    
      <category term="超卖" scheme="http://zhuuu.work/tags/%E8%B6%85%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-448-找到所有数组中消失的数字</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2020-06-12T08:44:53.000Z</published>
    <updated>2020-08-09T09:33:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-448-找到所有数组中消失的数字"><a href="#Leecode-448-找到所有数组中消失的数字" class="headerlink" title="Leecode-448-找到所有数组中消失的数字"></a>Leecode-448-<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h1><h2 id="思路：自哈希"><a href="#思路：自哈希" class="headerlink" title="思路：自哈希"></a>思路：自哈希</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p><strong>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</strong></p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：自哈希"><a href="#方法：自哈希" class="headerlink" title="方法：自哈希"></a>方法：自哈希</h2><ul><li><p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p><p>让数值 1 就放在索引位置 0 处；<br>让数值 2 就放在索引位置 1 处；<br>让数值 3 就放在索引位置 2 处；</p></li><li><p>再次遍历一遍数组，如果当前 <code>索引+1 != 当前值</code></p><ul><li>说明这个数不匹配，是消失的数，所以加入到结果集中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,i,nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历交换后的数组，查看消失的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基与异或的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边a b a</span></span><br><span class="line">        <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是数组的长度。<strong>(均摊复杂度)</strong></li><li>空间复杂度：O(1)，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;a href=&quot;#Leecode-448-找到所有数组中消失的数字&quot; class=&quot;headerlink&quot; title=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;/a&gt;Leecode-448-&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;找到所有数组中消失的数字&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希&quot;&gt;&lt;a href=&quot;#思路：自哈希&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希&quot;&gt;&lt;/a&gt;思路：自哈希&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-448-找到所有数组中消失的数字</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-06-12T08:44:53.000Z</published>
    <updated>2020-06-27T09:19:20.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-448-找到所有数组中消失的数字"><a href="#Leecode-448-找到所有数组中消失的数字" class="headerlink" title="Leecode-448-找到所有数组中消失的数字"></a>Leecode-448-<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h1><h2 id="思路：自哈希"><a href="#思路：自哈希" class="headerlink" title="思路：自哈希"></a>思路：自哈希</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p><strong>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</strong></p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：自哈希"><a href="#方法：自哈希" class="headerlink" title="方法：自哈希"></a>方法：自哈希</h2><ul><li><p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p><p>让数值 1 就放在索引位置 0 处；<br>让数值 2 就放在索引位置 1 处；<br>让数值 3 就放在索引位置 2 处；</p></li><li><p>再次遍历一遍数组，如果当前 <code>索引+1 != 当前值</code></p><ul><li>说明这个数不匹配，是消失的数，所以加入到结果集中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,i,nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历交换后的数组，查看消失的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基与异或的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边a b a</span></span><br><span class="line">        <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是数组的长度。<strong>(均摊复杂度)</strong></li><li>空间复杂度：O(1)，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;a href=&quot;#Leecode-448-找到所有数组中消失的数字&quot; class=&quot;headerlink&quot; title=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;/a&gt;Leecode-448-&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;找到所有数组中消失的数字&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希&quot;&gt;&lt;a href=&quot;#思路：自哈希&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希&quot;&gt;&lt;/a&gt;思路：自哈希&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-442-数组中重复的数据</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2020-06-12T07:46:53.000Z</published>
    <updated>2020-08-09T09:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-442-数组中重复的数据"><a href="#Leetcode-442-数组中重复的数据" class="headerlink" title="Leetcode-442-数组中重复的数据"></a>Leetcode-442-<a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">数组中重复的数据</a></h1><h2 id="思路：自哈希-抽屉原理"><a href="#思路：自哈希-抽屉原理" class="headerlink" title="思路：自哈希/抽屉原理"></a>思路：自哈希/抽屉原理</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</p><p>找到所有出现两次的元素。</p><p>你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：抽屉原理"><a href="#方法：抽屉原理" class="headerlink" title="方法：抽屉原理"></a>方法：抽屉原理</h2><ul><li><p><strong>思路分析：“桶排序”的思想是“抽屉原理”，</strong>即“一个萝卜一个坑”，8 个萝卜要放在 7 个坑里，则至少有 1 个坑里至少有 2 个萝卜。</p></li><li><p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p><p>让数值 1 就放在索引位置 0 处；<br>让数值 2 就放在索引位置 1 处；<br>让数值 3 就放在索引位置 2 处；</p></li><li><p><strong>一次遍历以后，那些“无处安放”的元素就是我们要查找的“出现两次的元素”</strong></p></li><li><p>为了不使用额外的空间，这里使用到的一个技巧是“基于异或运算交换两个变量的值”：交换两个整数，除了引入一个新的变量，写出一个“轮换”的赋值表达式以外，还有两种比较 tricky 的做法，下面给出结论。</p><ul><li>如果 <code>a ^ b = c</code> 那么 <code>a ^ c = b</code> 与 <code>b ^ c = a</code>同时成立</li></ul></li></ul><table><thead><tr><th>基于异或运算</th><th>基于加减法</th></tr></thead><tbody><tr><td><code>a = a ^ b</code> <code>b = a ^ b</code> <code>a = a ^ b</code></td><td><code>a = a + b</code> <code>b = a - b</code> <code>a = a - b</code></td></tr></tbody></table><ul><li>对于异或运算实现的交换方法，如果调用 <code>swap(nums, i, i)</code>，那么最终的结果会变为 <code>0</code>。</li><li>对于加减法实现的交换方法，有可能发生溢出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基与异或的交换方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左边a b a</span></span><br><span class="line">    <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">    nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">    nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数组自己做哈希：数值为i的数字映射到下标 i - 1的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 在指定范围内，如果数字并且没有放在正确的位置上，才交换</span></span><br><span class="line">            <span class="comment">// 例如：数值3应该放在索引2的位置上</span></span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,i,nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历交换后的数组，如果当前下标和数字不对应</span></span><br><span class="line">        <span class="comment">// 说明出现了重复的数字，加入到res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i)&#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基与异或的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边a b a</span></span><br><span class="line">        <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // 普通交换函数</span></span><br><span class="line"><span class="comment">//    private void swap(int[] nums, int i, int j) &#123;</span></span><br><span class="line"><span class="comment">//        int temp = nums[i];</span></span><br><span class="line"><span class="comment">//        nums[i] = nums[j];</span></span><br><span class="line"><span class="comment">//        nums[j] = temp;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是数组的长度。<strong>(均摊复杂度)</strong></li><li>空间复杂度：O(1)，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-442-数组中重复的数据&quot;&gt;&lt;a href=&quot;#Leetcode-442-数组中重复的数据&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-442-数组中重复的数据&quot;&gt;&lt;/a&gt;Leetcode-442-&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组中重复的数据&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希-抽屉原理&quot;&gt;&lt;a href=&quot;#思路：自哈希-抽屉原理&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希/抽屉原理&quot;&gt;&lt;/a&gt;思路：自哈希/抽屉原理&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。&lt;/p&gt;
&lt;p&gt;找到所有出现两次的元素。&lt;/p&gt;
&lt;p&gt;你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-0XX</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-264-%E4%B8%91%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-264-%E4%B8%91%E6%95%B0/</id>
    <published>2020-06-12T07:33:53.000Z</published>
    <updated>2020-06-17T10:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-264-丑数"><a href="#Leecode-264-丑数" class="headerlink" title="Leecode-264-丑数"></a>Leecode-264-<a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">丑数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 6</span><br><span class="line">输出: true</span><br><span class="line">解释: 6 &#x3D; 2 × 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 8</span><br><span class="line">输出: true</span><br><span class="line">解释: 8 &#x3D; 2 × 2 × 2</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 14</span><br><span class="line">输出: false </span><br><span class="line">解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li></ol><a id="more"></a><h3 id="方法一：除法"><a href="#方法一：除法" class="headerlink" title="方法一：除法"></a>方法一：除法</h3><ul><li>思路：不断除以2，3，5 ，最后结果是1，那么一定是丑数<ul><li>换句话来说：除尽所有的因子，那么最后一定等于1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度： O(1)</li><li>空间复杂度： O(1)</li></ul><h2 id="题目描述（丑数进阶）："><a href="#题目描述（丑数进阶）：" class="headerlink" title="题目描述（丑数进阶）："></a>题目描述（丑数进阶）：</h2><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><h3 id="方法一：三指针"><a href="#方法一：三指针" class="headerlink" title="方法一：三指针"></a>方法一：三指针</h3><p>思路：</p><ul><li><p>创建一个大小是 n+1 的数组，来存放n个丑数（第一个丑数是<code>numList[0] = 1</code>）</p></li><li><p>存入的每个丑数是2，3，5对应指针最小的那个丑数</p></li><li><p>三个指针分别指向2,3,5的因子</p><ul><li>如果含有2的因子，2的指针加1</li><li>如果含有3的因子，3的指针加1</li><li>如果含有5的因子，5的指针加1</li></ul></li><li><p>最后返回数组下标 <code>n - 1</code>对应的元素即可</p></li></ul><h3 id="方法二：最小堆"><a href="#方法二：最小堆" class="headerlink" title="方法二：最小堆"></a>方法二：最小堆</h3><p>思路：</p><ul><li><p>从堆中包含一个数字开始：1</p></li><li><p>去计算下一个丑数。将 1 从堆中弹出然后将三个数字添加到堆中：2，3，5</p></li><li><p>现在堆中最小的数字是 2。为了计算下一个丑数，要将 2 从堆中弹出然后添加三个数字：4，6，10</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181811361.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181826820.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181836970.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆：队列实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放丑数</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 用来对堆去重</span></span><br><span class="line">        HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 在每个步骤中，弹出堆中最小的丑数 k，并</span></span><br><span class="line">        <span class="comment">// 在堆中添加三个丑数：k×2, k×3，和 k×5</span></span><br><span class="line">        PriorityQueue&lt;Long&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时加入第一个丑数</span></span><br><span class="line">        pq.add(<span class="number">1L</span>);</span><br><span class="line">        set.add(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化丑数和因子</span></span><br><span class="line">        <span class="keyword">long</span> currUgly = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">long</span> newUgly  = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从堆中包含第一个数字开始</span></span><br><span class="line">        <span class="comment">// 重复该步骤计算所有丑数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 弹出堆中最小的丑数 k</span></span><br><span class="line">            currUgly = pq.poll();</span><br><span class="line">            <span class="comment">// 将这个丑数加入到数组存放</span></span><br><span class="line">            nums[i] = (<span class="keyword">int</span>)currUgly;</span><br><span class="line">            <span class="comment">// 添加三个新丑数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> prime : primes) &#123;</span><br><span class="line">                newUgly = currUgly * prime;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(newUgly))&#123;</span><br><span class="line">                    set.add(newUgly);</span><br><span class="line">                    pq.add(newUgly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n) 对每个丑数乘以因子的for循环操作。</li><li>空间复杂度：O(n) 数组的长度，Set的长度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-264-丑数&quot;&gt;&lt;a href=&quot;#Leecode-264-丑数&quot; class=&quot;headerlink&quot; title=&quot;Leecode-264-丑数&quot;&gt;&lt;/a&gt;Leecode-264-&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;丑数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个程序判断给定的数是否为丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 &lt;code&gt;2, 3, 5&lt;/code&gt; 的&lt;strong&gt;正整数&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 6 &amp;#x3D; 2 × 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 8 &amp;#x3D; 2 × 2 × 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 14 不是丑数，因为它包含了另外一个质因数 7。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 是丑数。&lt;/li&gt;
&lt;li&gt;输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="最小堆" scheme="http://zhuuu.work/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-283-移动0</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-283-%E7%A7%BB%E5%8A%A80/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-283-%E7%A7%BB%E5%8A%A80/</id>
    <published>2020-06-12T07:32:53.000Z</published>
    <updated>2020-06-14T09:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-283-移动零"><a href="#Leecode-283-移动零" class="headerlink" title="Leecode-283-移动零"></a>Leecode-283-<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><a id="more"></a><h2 id="方法一：两次遍历"><a href="#方法一：两次遍历" class="headerlink" title="方法一：两次遍历"></a>方法一：两次遍历</h2><ul><li>创建两个指针 i 和 j </li><li>第一次遍历指针 j 记录 当前有多少非0的元素，即遍历的时候每遇到一个非0的元素就将它向左边挪</li><li>第一次遍历完之后，j 指针就记录了最后一个非0元素的下标。</li><li>第二次遍历的时候，起始位置从 j 开始到结束，把所有剩下的元素都修改为0。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/172243741.gif" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次遍历，j指针记录非0的个数</span></span><br><span class="line">        <span class="comment">// 只要是非0的统统都赋给nums[j]</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次遍历把末尾的元素全部赋值为0</span></span><br><span class="line">        <span class="comment">// 非0元素统计完了，剩下的都是0了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j;i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度:O(1)</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul><h2 id="方法二：一次遍历"><a href="#方法二：一次遍历" class="headerlink" title="方法二：一次遍历"></a>方法二：一次遍历</h2><ul><li><strong>参考快速排序的思想</strong><ul><li>首先确定一个带分割的点 x ，</li><li>然后把所有小于等于x 的都放到 x的左边，把所有大于 x 的都放到 x的右边</li><li>这里的 x 根据题目 取 0 . (把所有小于等于0的都放在0的左边，所有大于0的都放在0的右边)</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/173058469.gif" alt="mark"></p><ul><li>这的中间点就是<code>0</code>本身，所以实现起来比快速排序简单很多，我们使用两个指针<code>i</code>和<code>j</code>，只要<code>nums[i]!=0</code>，我们就交换<code>nums[i]</code>和<code>nums[j]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针交换</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前元素不等于0.就把它交换到左边</span></span><br><span class="line">            <span class="comment">// 等于0就交换到右边</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-283-移动零&quot;&gt;&lt;a href=&quot;#Leecode-283-移动零&quot; class=&quot;headerlink&quot; title=&quot;Leecode-283-移动零&quot;&gt;&lt;/a&gt;Leecode-283-&lt;a href=&quot;https://leetcode-cn.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动零&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1,0,3,12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,3,12,0,0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在原数组上操作，不能拷贝额外的数组。&lt;/li&gt;
&lt;li&gt;尽量减少操作次数。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="快速排序" scheme="http://zhuuu.work/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
