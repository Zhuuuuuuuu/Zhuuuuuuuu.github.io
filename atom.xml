<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱酱酱的学习博客</title>
  <icon>https://www.gravatar.com/avatar/336d255f627c733c7a50883547bcec06</icon>
  <subtitle>From Zero to Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuuu.work/"/>
  <updated>2022-01-22T04:30:37.471Z</updated>
  <id>http://zhuuu.work/</id>
  
  <author>
    <name>Zhuuu</name>
    <email>353446503@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-203-移除链表元素</title>
    <link href="http://zhuuu.work/2022/01/22/Leetcode/Leetcode-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2022/01/22/Leetcode/Leetcode-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</id>
    <published>2022-01-22T01:12:53.000Z</published>
    <updated>2022-01-22T04:30:37.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-203-移除链表元素"><a href="#Leetcode-203-移除链表元素" class="headerlink" title="Leetcode-203-移除链表元素"></a>Leetcode-203-<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">移除链表元素</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-203-移除链表元素&quot;&gt;&lt;a href=&quot;#Leetcode-203-移除链表元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-203-移除链表元素&quot;&gt;&lt;/a&gt;Leetcode-203-&lt;a href=&quot;https:/
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-07-跨域问题</title>
    <link href="http://zhuuu.work/2021/12/13/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-07-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2021/12/13/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-07-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-13T08:38:38.000Z</published>
    <updated>2021-12-26T12:27:34.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发笔记-07-跨域问题"><a href="#开发笔记-07-跨域问题" class="headerlink" title="开发笔记-07-跨域问题"></a>开发笔记-07-跨域问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>原因：出于浏览器的同源策略限制。同源策略（<code>Sameoriginpolicy</code>）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。<ul><li>可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的<code>javascript</code>脚本和另外一个域的内容进行交互。</li><li>所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</li></ul></li></ul><a id="more"></a><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1. 什么是跨域"></a>1. 什么是跨域</h2><ul><li>当一个请求<code>url</code>的协议、域名、端口三者之间任意一个与当前页面<code>url</code>不同即为跨域</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/200857748.png" alt="mark"></p><p><strong>非同源限制了什么？</strong></p><p>【1】无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p><p>【2】无法接触非同源网页的 DOM</p><p>【3】无法向非同源地址发送 AJAX 请求</p><h2 id="2-跨域的解决方案"><a href="#2-跨域的解决方案" class="headerlink" title="2. 跨域的解决方案"></a>2. 跨域的解决方案</h2><p><strong>【1】设置document.domain解决无法读取非同源网页的 Cookie问题</strong></p><ul><li>因为浏览器是通过<code>document.domain</code>属性来检查两个页面是否同源，因此只要通过设置相同的<code>document.domain</code>，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个页面都设置</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'test.com'</span>;</span><br></pre></td></tr></table></figure><p><strong>【2】跨文档通信 API：window.postMessage()</strong></p><ul><li><p>调用<code>postMessage</code>方法实现父窗口<a href="http://test1.com向子窗口http://test2.com发消息（子窗口同样可以通过该方法发送消息给父窗口）" target="_blank" rel="noopener">http://test1.com向子窗口http://test2.com发消息（子窗口同样可以通过该方法发送消息给父窗口）</a></p></li><li><p>它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> openWindow = <span class="built_in">window</span>.open(<span class="string">'http://test2.com'</span>, <span class="string">'title'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)</span></span><br><span class="line">openWindow.postMessage(<span class="string">'Nice to meet you!'</span>, <span class="string">'http://test2.com'</span>);</span><br></pre></td></tr></table></figure><ul><li>调用message事件，监听对方发送的消息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听 message 消息</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.source); <span class="comment">// e.source 发送消息的窗口</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.origin); <span class="comment">// e.origin 消息发向的网址</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.data);   <span class="comment">// e.data   发送的消息</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>【3】JSONP</p><ul><li><p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。</p></li><li><p>核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</p></li></ul><p>①原生实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://test.com/data.php?callback=dosomething"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 处理服务器返回回调函数的数据</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    function dosomething(res)&#123;</span></span><br><span class="line"><span class="string">        // 处理获得的数据</span></span><br><span class="line"><span class="string">        console.log(res.data)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>② jQuery ajax：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://www.test.com:8080/login'</span>,</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    jsonpCallback: <span class="string">"handleCallback"</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>③ Vue.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.jsonp(<span class="string">'http://www.domain2.com:8080/login'</span>, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">'handleCallback'</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>【4】CORS</strong></p><p>CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。</p><p>1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin</p><p>2、带cookie跨域请求：前后端都需要进行设置</p><p>【前端设置】根据<code>xhr.withCredentials</code>字段判断是否带有cookie</p><p>①原生ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://www.domain2.com:8080/login'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'user=admin'</span>);</span><br><span class="line"> </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>② jQuery ajax </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   url: <span class="string">'http://www.test.com:8080/login'</span>,</span><br><span class="line">   type: <span class="string">'get'</span>,</span><br><span class="line">   data: &#123;&#125;,</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>③vue-resource</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>④ axios </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>【服务端设置】</strong></p><p>服务器端对于CORS的支持，主要是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p><p>① Java后台</p><ul><li><strong>Java还可以使用springMVC的@CrossOrigin注解实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 导入包：import javax.servlet.http.HttpServletResponse;</span></span><br><span class="line"><span class="comment"> * 接口参数中定义：HttpServletResponse response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type,X-Requested-With"</span>);</span><br></pre></td></tr></table></figure><p>② Nodejs后台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = require(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = require(<span class="string">'querystring'</span>);</span><br><span class="line"> </span><br><span class="line">server.on(<span class="string">'request'</span>, function(req, res) &#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">'data'</span>, function(chunk) &#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">'end'</span>, function() &#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.domain1.com'</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        res.write(JSON.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line">console.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><p>③ PHP后台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> header(&quot;Access-Control-Allow-Origin:*&quot;);</span><br></pre></td></tr></table></figure><p>④ Apache需要使用mod_headers模块来激活HTTP头的设置，它默认是激活的。你只需要在Apache配置文件的<Directory>, <Location>, <Files>或<VirtualHost>的配置里加入以下内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set Access-Control-Allow-Origin *</span><br></pre></td></tr></table></figure><p><strong>【5】webpack本地代理</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/202339538.png" alt="mark"></p><ul><li><p>在<code>webpack.config.js</code>中利用<code>WebpackDevServer</code> 配置本地代理，详情配置查看devServer</p><ul><li><a href="https://webpack.docschina.org/configuration/dev-server/#root" target="_blank" rel="noopener">https://webpack.docschina.org/configuration/dev-server/#root</a></li></ul></li><li><p>如下简单配置案例，这样 <code>http://localhost:8080/api/getUser.php</code> 的请求就是后端的接口 <code>http://192.168.25.20:8088/getUser.php</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    port: 8080,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        &quot;&#x2F;api&quot;: &#123;</span><br><span class="line">          target: &quot;http:&#x2F;&#x2F;192.168.25.20:8088&quot; &#x2F;&#x2F; 后端接口</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【6】websocket</strong></p><ul><li>Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</li><li>WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。</li><li>但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 服务器与 客户端都能主动向对方发送或接收数据。</li><li>同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</li></ul><p><strong>【7】Nginx反向代理</strong></p><ul><li><p>Nginx 实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。</p></li><li><p><strong>使用 nginx 反向代理实现跨域，是最简单的跨域方式</strong>。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。</p></li><li><p>我们只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。</p><ul><li>这样，这个服务器上所有url都是相同的域 名、协议和端口。</li><li>因此，对于浏览器来说，这些url都是同源的，没有跨域限制。</li><li>而实际上，这些url实际上由物理服务器提供服务。这些服务器内的 javascript可以跨域调用所有这些服务器上的url。</li></ul></li></ul><p><strong>实现方式：先下载nginx，然后将 nginx 目录下的 nginx.conf 修改如下：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#nginx监听所有localhost:8080端口收到的请求</span></span><br><span class="line"><span class="attribute">listen</span>       <span class="number">8080</span>;</span><br><span class="line"><span class="attribute">server_name</span>  localhost;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line"><span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="comment">#localhost:8080 会被转发到这里</span></span><br><span class="line"><span class="comment">#同时, 后端程序会接收到 "192.168.25.20:8088"这样的请求url</span></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://192.168.25.20:8088;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#localhost:8080/api/ 会被转发到这里</span></span><br><span class="line">    <span class="comment">#同时, 后端程序会接收到 "192.168.25.20:9000/api/"这样的请求url</span></span><br><span class="line"><span class="attribute">location</span> /api/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://192.168.25.20:9000;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line"><span class="attribute">location</span> = /40x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line"><span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发笔记-07-跨域问题&quot;&gt;&lt;a href=&quot;#开发笔记-07-跨域问题&quot; class=&quot;headerlink&quot; title=&quot;开发笔记-07-跨域问题&quot;&gt;&lt;/a&gt;开发笔记-07-跨域问题&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原因：出于浏览器的同源策略限制。同源策略（&lt;code&gt;Sameoriginpolicy&lt;/code&gt;）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。&lt;ul&gt;
&lt;li&gt;可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的&lt;code&gt;javascript&lt;/code&gt;脚本和另外一个域的内容进行交互。&lt;/li&gt;
&lt;li&gt;所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="开发笔记" scheme="http://zhuuu.work/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES-02-核心概念</title>
    <link href="http://zhuuu.work/2021/11/26/ES/ES-02-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://zhuuu.work/2021/11/26/ES/ES-02-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</id>
    <published>2021-11-26T12:32:24.000Z</published>
    <updated>2021-12-26T16:27:55.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES-02-核心概念"><a href="#ES-02-核心概念" class="headerlink" title="ES-02-核心概念"></a>ES-02-核心概念</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/193936245.png" alt="mark"></p><ul><li><code>ElasticSearch</code>是面向文档，关系行数据库和<code>ElasticSearch</code>客观对比！一切都是<code>JSON！</code></li></ul><table><thead><tr><th>Relational DB</th><th>ElasticSearch</th></tr></thead><tbody><tr><td>数据库（database）</td><td>索引（indices）</td></tr><tr><td>表（tables）</td><td>types &lt;慢慢会被弃用!&gt;</td></tr><tr><td>行（rows）</td><td>documents</td></tr><tr><td>字段（columns）</td><td>fields</td></tr></tbody></table><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>1、索引（<code>ElasticSearch</code>）</p><ul><li>包多个分片</li></ul><p>2、字段类型（映射）</p><ul><li>字段类型映射（字段是整型，还是字符型…）</li></ul><p>3、文档</p><p>4、分片（<code>Lucene</code>索引，倒排索引）</p><ul><li><strong>elasticsearch（集群）</strong>中可以包含多个<strong>索引（数据库）</strong> ,每个索引中可以包含多个<strong>类型（表）</strong> ,每个类型下又包含多个<strong>文档（行）</strong> ,每个文档中又包含多个<strong>字段（列）</strong>。</li></ul><p><strong>物理设计</strong></p><ul><li>一个人就是一个集群! ，即<strong>启动的ElasticSearch服务，默认就是一个集群，且默认集群名为elasticsearch</strong></li><li>elasticsearch在后台把<strong>每个索引划分成多个分片</strong>，每分分片可以在集群中的不同服务器间迁移</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211227/001341532.png" alt="mark"></p><h3 id="1-1-文档"><a href="#1-1-文档" class="headerlink" title="1.1 文档"></a>1.1 文档</h3><p>之前说elasticsearch是面向文档的，那么就意味着<strong>索引和搜索数据的最小单位是文档</strong>，elasticsearch中，文档有几个重要属性:</p><ul><li>自我包含，一篇文档同时包含字段和对应的值，也就是同时包含<code>key:value</code> !</li><li>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的! {就是一个json对象 ! fastjson进行自动转换 !}</li><li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候,我们可以忽略该字段，或者动态的添加一个新的字段。</li></ul><p>尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。</p><h3 id="1-2-类型"><a href="#1-2-类型" class="headerlink" title="1.2 类型"></a>1.2 类型</h3><p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定义称为映射，比如name映射为字符串类型。我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么<code>elasticsearch</code>是怎么做的呢?</p><ul><li><code>elasticsearch</code>会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，<code>elasticsearch</code>就开始猜，如果这个值是18，那么<code>elasticsearch</code>会认为它是整形。</li><li>但是<code>elasticsearch</code>也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。</li></ul><h3 id="1-3-索引"><a href="#1-3-索引" class="headerlink" title="1.3 索引"></a>1.3 索引</h3><ul><li>索引是映射类型的容器， <code>elasticsearch</code>中的索引是一个非常大的文档集合。 </li><li>索引存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</li></ul><p><strong>创建新索引</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211227/001857255.png" alt="mark" style="zoom:67%;" /><ul><li>一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片(<code>primary shard</code> ,又称主分片)构成的，每一个主分片会有一个副本(<code>replica shard</code>，又称复制分片)</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211227/002006109.png" alt="mark"></p><ul><li>上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉了，数据也不至于失。</li><li>实际上，<strong>一个分片是一个Lucene索引（<mark>一个ElasticSearch索引包含多个Lucene索引</mark>）</strong> ，<strong>一个包含倒排索引的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字</strong>。</li></ul><h3 id="1-4-倒排索引"><a href="#1-4-倒排索引" class="headerlink" title="1.4 倒排索引"></a>1.4 倒排索引</h3><p><strong>倒排索引（Lucene索引底层）</strong></p><ul><li>简单说就是 按（文章关键字，对应的文档&lt;0个或多个&gt;）形式建立索引，根据关键字就可直接查询对应的文档（含关键字的），无需查询每一个文档，如下图</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211227/002205451.png" alt="mark"></p><ul><li><strong>mysql 和 es 的区别</strong><ul><li><strong>mysql 拿着全文找单词</strong></li><li><strong>es 拿着单词找文档</strong> （倒排索引）<ul><li>关键词作为key</li><li>分片的ID作为value的值</li></ul></li></ul></li></ul><h2 id="2-IK分词器"><a href="#2-IK分词器" class="headerlink" title="2. IK分词器"></a>2. IK分词器</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES-02-核心概念&quot;&gt;&lt;a href=&quot;#ES-02-核心概念&quot; class=&quot;headerlink&quot; title=&quot;ES-02-核心概念&quot;&gt;&lt;/a&gt;ES-02-核心概念&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/193936245.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ElasticSearch&lt;/code&gt;是面向文档，关系行数据库和&lt;code&gt;ElasticSearch&lt;/code&gt;客观对比！一切都是&lt;code&gt;JSON！&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Relational DB&lt;/th&gt;
&lt;th&gt;ElasticSearch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;数据库（database）&lt;/td&gt;
&lt;td&gt;索引（indices）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表（tables）&lt;/td&gt;
&lt;td&gt;types &amp;lt;慢慢会被弃用!&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;行（rows）&lt;/td&gt;
&lt;td&gt;documents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字段（columns）&lt;/td&gt;
&lt;td&gt;fields&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="大数据" scheme="http://zhuuu.work/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ES" scheme="http://zhuuu.work/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>ES-01-简介</title>
    <link href="http://zhuuu.work/2021/11/25/ES/ES-01-%E7%AE%80%E4%BB%8B/"/>
    <id>http://zhuuu.work/2021/11/25/ES/ES-01-%E7%AE%80%E4%BB%8B/</id>
    <published>2021-11-25T12:32:24.000Z</published>
    <updated>2021-12-26T13:19:53.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES-01-简介"><a href="#ES-01-简介" class="headerlink" title="ES-01-简介"></a>ES-01-简介</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/193936245.png" alt="mark"></p><ul><li><p>官网：<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></p></li><li><p>笔记配套版本 软件下载传送门：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElasticSearch: https:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;elasticsearch&#x2F;?C&#x3D;N&amp;O&#x3D;D</span><br><span class="line">logstash: https:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;logstash&#x2F;?C&#x3D;N&amp;O&#x3D;D</span><br><span class="line">kibana: https:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;kibana&#x2F;?C&#x3D;N&amp;O&#x3D;D</span><br><span class="line">elasticsearch-analysis-ik: https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases</span><br><span class="line">cerebro: https:&#x2F;&#x2F;github.com&#x2F;lmenezes&#x2F;cerebro&#x2F;releases</span><br></pre></td></tr></table></figure><ul><li><p><strong>Elaticsearch</strong>，简称为es，es是一个开源的<strong>高扩展</strong>的<strong>分布式全文检索引擎</strong>，它可以近乎<strong>实时的存储</strong>、<strong>检索数据;</strong>本身扩展性很好，可以扩展到上百台服务器，处理PB级别(大数据时代）的数据。</p></li><li><p>es也使用java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的<strong>目的</strong>是通过简单的<strong>RESTful API</strong>来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p></li><li><p>据国际权威的数据库产品评测机构DB Engines的统计，在2016年1月，ElasticSearch已超过Solr等，成为<strong>排名第一的搜索引擎类应用</strong>。</p></li></ul><a id="more"></a><h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h2><p>1、维基百科,类似百度百科，全文检索,高亮,搜索推荐/2</p><p>2、<code>The Guardian</code> (国外新闻网站) ,类似搜狐新闻,用户行为日志(点击,浏览,收藏,评论) +社交网络数据(对某某新闻的相关看法) ,数据分析,给到每篇新闻文章的作者,让他知道他的文章的公众反馈(好,坏,热门，垃圾,鄙视，崇拜)</p><p>3、<code>Stack Overflow</code>(国外的程序异常讨论论坛) , IT问题,程序的报错,提交上去,有人会跟你讨论和回答,全文检索,搜索相关问题和答案,程序报错了,就会将报错信息粘贴到里面去,搜索有没有对应的答案</p><p>4、<code>GitHub</code> (开源代码管理),搜索 上千亿行代码</p><p>5、电商网站,检索商品</p><p>6、日志数据分析, <code>logstash</code>采集日志, ES进行复杂的数据分析, <strong>ELK技术,</strong></p><ul><li><code>elasticsearch+logstash+kibana</code></li></ul><p>7、商品价格监控网站,用户设定某商品的价格阈值,当低于该阈值的时候,发送通知消息给用户,比如说订阅牙膏的监控,如果高露洁牙膏的家庭套装低于50块钱,就通知我,我就去买</p><p>8、BI系统,商业智能,<code>Business Intelligence</code>。比如说有个大型商场集团，BI ,分析一下某某区域最近3年的用户消费 金额的趋势以及用户群体的组成构成,产出相关的数张报。ES执行数据分析和挖掘, Kibana进行数据可视化</p><p>9、国内:站内搜索(电商,招聘,门户,等等),IT系统搜索(OA,CRM,ERP,等等),数据分析(ES热门<br>的一一个使用场景)</p><hr><h2 id="2-ElasticSearch-与-Solr"><a href="#2-ElasticSearch-与-Solr" class="headerlink" title="2. ElasticSearch 与 Solr"></a>2. ElasticSearch 与 Solr</h2><ul><li>Solr是Apache下的一个顶级开源项目,采用Java开发,它是<strong>基于Lucene的全文搜索服务器</strong>。Solr提供了比Lucene更为<strong>丰富的查询语言</strong>,同时实现了<strong>可配置</strong>、<strong>可扩展</strong>，并<strong>对索引、搜索性能进行了优化</strong></li><li>Solr可以<strong>独立运行</strong>,运行在letty. Tomcat等这些Selrvlet容器中 , Solr 索引的实现方法很简单,<mark>用POST方法向Solr服务器发送一个描述Field及其内容的XML文档, Solr根据xml文档<strong>添加、删除、更新</strong>索引</mark>。</li><li>Solr 搜索只需要发送HTTP GET请求,然后对Solr返回xml、json等格式的查询结果进行解析,组织页面布局。</li><li>Solr不提供构建UI的功能, <strong>Solr提供了一个管理界面,通过管理界面可以查询Solr的配置和运行情况。</strong></li><li><strong>Solr是基于lucene开发企业级搜索服务器,实际上就是封装了lucene.</strong></li><li>Solr是一个独立的企业级搜索应用服务器,它<strong>对外提供类似于Web-service的API接口</strong>。用户可以通过http请求,向搜索引擎服务器提交-定格式的文件,生成索引;也可以通过提出查找请求,并得到返回结果。</li></ul><ol><li><code>当单纯的对已有数据进行搜索时，Solr更快</code></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/194444582.png" alt="mark"></p><ol start="2"><li>当实时建立索引时，Solr会产生io阻塞，查询性能较差，ElasticSearch具有明显的优势</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/194458858.png" alt="mark"></p><ol start="3"><li><code>随着数据量的增加，Solr的搜索效率会变得更低，而ElasticSearch却没有明显的变化</code></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/194514553.png" alt="mark"></p><h3 id="2-1-总结"><a href="#2-1-总结" class="headerlink" title="2.1 总结"></a>2.1 总结</h3><p>1、<strong>es</strong>基本是<strong>开箱即用</strong>(解压就可以用!) ,非常简单。Solr安装略微复杂一丢丢!</p><p>2、<strong>Solr 利用Zookeeper进行分布式管理</strong>,而<strong>Elasticsearch<mark>自身带有分布式协调管理功能</mark>。</strong></p><p>3、Solr 支持更多格式的数据,比如JSON、XML、 CSV ,而<strong>Elasticsearch仅支持json文件格式</strong>。</p><p>4、Solr 官方提供的功能更多,而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</p><p>5、<strong>Solr 查询快,但更新索引时慢(即插入删除慢)</strong> ，用于电商等查询多的应用;</p><ul><li><strong>ES建立索引快(即查询慢)</strong> ，即<strong>实时性查询快</strong>，用于facebook新浪等搜索。</li><li>Solr是传统搜索应用的有力解决方案，但Elasticsearch更适用于新兴的实时搜索应用。</li></ul><p>6、Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而Elasticsearch相对开发维护者较少,更新太快,学习使用成本较高。</p><h2 id="3-ES-安装"><a href="#3-ES-安装" class="headerlink" title="3. ES 安装"></a>3. ES 安装</h2><ul><li>使用Java开发，必须保证<code>ElasticSearch</code>的版本与Java的核心jar包版本对应！（Java环境保证没错）</li></ul><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><ul><li><p>下载地址：<a href="https://www.elastic.co/cn/downloads/" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/</a></p></li><li><p>历史版本下载：<a href="https://www.elastic.co/cn/downloads/past-releases/" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases/</a></p></li></ul><p>解压即可（尽量将ElasticSearch相关工具放在统一目录下）</p><h3 id="3-2-目录格式"><a href="#3-2-目录格式" class="headerlink" title="3.2 目录格式"></a>3.2 目录格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bin 启动文件目录</span><br><span class="line">config 配置文件目录</span><br><span class="line">    1og4j2 日志配置文件</span><br><span class="line">    jvm.options java 虚拟机相关的配置(默认启动占1g内存，内容不够需要自己调整)</span><br><span class="line">    elasticsearch.ym1 elasticsearch 的配置文件! 默认9200端口!跨域!</span><br><span class="line">1ib </span><br><span class="line">    相关jar包</span><br><span class="line">modules 功能模块目录</span><br><span class="line">plugins 插件目录</span><br><span class="line">    ik分词器</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/195058468.png" alt="mark"></p><h3 id="3-3-启动"><a href="#3-3-启动" class="headerlink" title="3.3 启动"></a>3.3 启动</h3><ul><li>启动ES：9200端口</li><li>启动ES-head : 9100端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch-head</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 启动</span><br><span class="line">npm run start</span><br><span class="line"># 访问</span><br><span class="line">http:&#x2F;&#x2F;localhost:9100&#x2F;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/202849339.png" alt="mark"></p><p><strong>访问</strong></p><blockquote><p>存在跨域问题（只有当两个页面同源，才能交互）</p><p>同源（端口，主机，协议三者都相同）</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/203321687.png" alt="mark"></p><p><strong>解决方法：</strong></p><ul><li>开启跨域（在elasticsearch解压目录config下elasticsearch.yml中添加）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启跨域</span><br><span class="line">http.cors.enabled: true</span><br><span class="line"># 所有人访问</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p><strong>如何理解上图：</strong></p><ul><li>如果你是初学者<ul><li>索引 可以看做 “数据库”</li><li>类型 可以看做 “表”</li><li>文档 可以看做 “库中的数据（表中的行）”</li></ul></li><li>这个head，我们只是把它当做可视化数据展示工具，之后所有的查询都在kibana中进行<ul><li>因为不支持json格式化，不方便</li></ul></li></ul><h2 id="4-ELK-理解"><a href="#4-ELK-理解" class="headerlink" title="4. ELK 理解"></a>4. ELK 理解</h2><ul><li>ELK是<code>Elasticsearch、Logstash、 Kibana</code>三大开源框架首字母大写简称。</li><li>市面上也被成为Elastic Stack。<ul><li>其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。<ul><li>像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es。</li></ul></li><li>Logstash是ELK的中央数据流引擎,用于从不同目标(文件/数据存储/MQ )收集的不同格式数据,经过过滤后支持输出到不同目的地(文件/MQ/redis/elasticsearch/kafka等)。</li><li>Kibana可以将elasticsearch的数据通过友好的页面展示出来 ,提供实时分析的功能。</li></ul></li><li><strong>市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称 ,但实际上ELK不仅仅适用于日志分析,它还可以支持其它任何数据分析和收集的场景,日志分析和收集只是更具有代表性。并非唯一性。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收集清洗数据(Logstash) &#x3D;&#x3D;&gt; 搜索、存储(ElasticSearch) &#x3D;&#x3D;&gt; 展示(Kibana)</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/210910752.png" alt="mark"></p><h2 id="5-安装kibana"><a href="#5-安装kibana" class="headerlink" title="5. 安装kibana"></a>5. 安装kibana</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/211125414.png" alt="mark"></p><ul><li>Kibana是一个针对ElasticSearch的开源分析及可视化平台,用来搜索、查看交互存储在Elasticsearch索引中的数据。</li><li>使用Kibana ,可以通过各种图表进行高级数据分析及展示。</li><li>Kibana让海量数据更容易理解。它操作简单,基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构,几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</li></ul><p><strong>注意：下载的版本需要与ElasticSearch版本对应</strong></p><h3 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h3><ul><li>解压即可（尽量将ElasticSearch相关工具放在统一目录下）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/211327262.png" alt="mark"></p><h2 id="5-2-启动"><a href="#5-2-启动" class="headerlink" title="5.2 启动"></a>5.2 启动</h2><ul><li>默认端口 5601</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/211416568.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/211438737.png" alt="mark"></p><h3 id="5-3-开发工具"><a href="#5-3-开发工具" class="headerlink" title="5.3 开发工具"></a>5.3 开发工具</h3><ul><li>（Postman、curl、head、谷歌浏览器插件）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/211950872.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES-01-简介&quot;&gt;&lt;a href=&quot;#ES-01-简介&quot; class=&quot;headerlink&quot; title=&quot;ES-01-简介&quot;&gt;&lt;/a&gt;ES-01-简介&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20211226/193936245.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;官网：&lt;a href=&quot;https://www.elastic.co/cn/downloads/elasticsearch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/cn/downloads/elasticsearch&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;笔记配套版本 软件下载传送门：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ElasticSearch: https:&amp;#x2F;&amp;#x2F;mirrors.huaweicloud.com&amp;#x2F;elasticsearch&amp;#x2F;?C&amp;#x3D;N&amp;amp;O&amp;#x3D;D&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logstash: https:&amp;#x2F;&amp;#x2F;mirrors.huaweicloud.com&amp;#x2F;logstash&amp;#x2F;?C&amp;#x3D;N&amp;amp;O&amp;#x3D;D&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kibana: https:&amp;#x2F;&amp;#x2F;mirrors.huaweicloud.com&amp;#x2F;kibana&amp;#x2F;?C&amp;#x3D;N&amp;amp;O&amp;#x3D;D&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;elasticsearch-analysis-ik: https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;medcl&amp;#x2F;elasticsearch-analysis-ik&amp;#x2F;releases&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cerebro: https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;lmenezes&amp;#x2F;cerebro&amp;#x2F;releases&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Elaticsearch&lt;/strong&gt;，简称为es，es是一个开源的&lt;strong&gt;高扩展&lt;/strong&gt;的&lt;strong&gt;分布式全文检索引擎&lt;/strong&gt;，它可以近乎&lt;strong&gt;实时的存储&lt;/strong&gt;、&lt;strong&gt;检索数据;&lt;/strong&gt;本身扩展性很好，可以扩展到上百台服务器，处理PB级别(大数据时代）的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;es也使用java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的&lt;strong&gt;目的&lt;/strong&gt;是通过简单的&lt;strong&gt;RESTful API&lt;/strong&gt;来隐藏Lucene的复杂性，从而让全文搜索变得简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;据国际权威的数据库产品评测机构DB Engines的统计，在2016年1月，ElasticSearch已超过Solr等，成为&lt;strong&gt;排名第一的搜索引擎类应用&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="大数据" scheme="http://zhuuu.work/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ES" scheme="http://zhuuu.work/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisPlus-05-代码自动生成器</title>
    <link href="http://zhuuu.work/2021/08/23/MyBatis-Plus/MyBatisPlus-05-%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://zhuuu.work/2021/08/23/MyBatis-Plus/MyBatisPlus-05-%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2021-08-23T12:38:38.000Z</published>
    <updated>2021-08-24T08:31:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-05-代码自动生成器"><a href="#MyBatisPlus-05-代码自动生成器" class="headerlink" title="MyBatisPlus-05-代码自动生成器"></a>MyBatisPlus-05-代码自动生成器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>dao、pojo、service、controller都是我们自己去编写完成！</li><li>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</li></ul><p><strong>效果对比</strong></p><ol><li>只配置代码的空项目</li></ol><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-24-083022.png" style="zoom:50%;" /><ol start="2"><li>MyBatis-Plus 自动生成代码之后</li></ol><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-24-083111.png" style="zoom:50%;" /><a id="more"></a><h2 id="1-可复用配置代码"><a href="#1-可复用配置代码" class="headerlink" title="1. 可复用配置代码"></a>1. 可复用配置代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">// 代码自动生成器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要构建一个 代码自动生成器 对象</span></span><br><span class="line">    AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">    <span class="comment">// 配置策略</span></span><br><span class="line">    <span class="comment">// 1、全局配置</span></span><br><span class="line">    GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">    String projectPath = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line">    gc.setOutputDir(projectPath+<span class="string">"/src/main/java"</span>);</span><br><span class="line">    gc.setAuthor(<span class="string">"Zhuuu"</span>);</span><br><span class="line">    gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">    gc.setFileOverride(<span class="keyword">false</span>);       <span class="comment">// 是否覆盖</span></span><br><span class="line">    gc.setServiceName(<span class="string">"%sService"</span>);  <span class="comment">// 去Service的I前缀</span></span><br><span class="line">    gc.setIdType(IdType.ID_WORKER);</span><br><span class="line">    gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">    gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line">    mpg.setGlobalConfig(gc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、设置数据源</span></span><br><span class="line">    DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">    dsc.setUrl(<span class="string">"jdbc:mysql://localhost:3306/表名字?</span></span><br><span class="line"><span class="string">               useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8"</span>);</span><br><span class="line">               dsc.setDriverName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">               dsc.setUsername(<span class="string">"root"</span>);</span><br><span class="line">               dsc.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">               dsc.setDbType(DbType.MYSQL);</span><br><span class="line">               mpg.setDataSource(dsc);</span><br><span class="line">               <span class="comment">//3、包的配置</span></span><br><span class="line">               PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">               pc.setModuleName(<span class="string">"blog"</span>);</span><br><span class="line">               pc.setParent(<span class="string">"com.zhuuu"</span>);</span><br><span class="line">               pc.setEntity(<span class="string">"entity"</span>);</span><br><span class="line">               pc.setMapper(<span class="string">"mapper"</span>);</span><br><span class="line">               pc.setService(<span class="string">"service"</span>);</span><br><span class="line">               pc.setController(<span class="string">"controller"</span>);</span><br><span class="line">               mpg.setPackageInfo(pc);</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//4、策略配置</span></span><br><span class="line">StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">strategy.setInclude(<span class="string">"blog_tags"</span>,<span class="string">"course"</span>,<span class="string">"links"</span>,<span class="string">"sys_settings"</span>,<span class="string">"user_record"</span>,<span class="string">"user_say"</span>); <span class="comment">// 设置要映射的表名</span></span><br><span class="line">strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">strategy.setEntityLombokModel(<span class="keyword">true</span>); <span class="comment">// 自动lombok；</span></span><br><span class="line">strategy.setLogicDeleteFieldName(<span class="string">"deleted"</span>);</span><br><span class="line">               </span><br><span class="line"><span class="comment">// 自动填充配置</span></span><br><span class="line">TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">"gmt_create"</span>, FieldFill.INSERT);</span><br><span class="line">TableFill gmtModified = <span class="keyword">new</span> TableFill(<span class="string">"gmt_modified"</span>,</span><br><span class="line">FieldFill.INSERT_UPDATE);</span><br><span class="line">ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">tableFills.add(gmtCreate);</span><br><span class="line">tableFills.add(gmtModified);</span><br><span class="line">strategy.setTableFillList(tableFills);</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 乐观锁</span></span><br><span class="line">               strategy.setVersionFieldName(<span class="string">"version"</span>);</span><br><span class="line">               strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">               strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>); <span class="comment">//</span></span><br><span class="line">               localhost:<span class="number">8080</span>/hello_id_2</span><br><span class="line">               mpg.setStrategy(strategy);</span><br><span class="line">               </span><br><span class="line">               mpg.execute(); <span class="comment">// 最后执行</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MyBatisPlus-05-代码自动生成器&quot;&gt;&lt;a href=&quot;#MyBatisPlus-05-代码自动生成器&quot; class=&quot;headerlink&quot; title=&quot;MyBatisPlus-05-代码自动生成器&quot;&gt;&lt;/a&gt;MyBatisPlus-05-代码自动生成器&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;dao、pojo、service、controller都是我们自己去编写完成！&lt;/li&gt;
&lt;li&gt;AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;效果对比&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只配置代码的空项目&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-24-083022.png&quot; style=&quot;zoom:50%;&quot; /&gt;



&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;MyBatis-Plus 自动生成代码之后&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-24-083111.png&quot; style=&quot;zoom:50%;&quot; /&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="http://zhuuu.work/tags/MyBatis/"/>
    
      <category term="MyBatis-Plus" scheme="http://zhuuu.work/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisPlus-04-条件构造器</title>
    <link href="http://zhuuu.work/2021/08/22/MyBatis-Plus/MyBatisPlus-04-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <id>http://zhuuu.work/2021/08/22/MyBatis-Plus/MyBatisPlus-04-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/</id>
    <published>2021-08-22T12:38:38.000Z</published>
    <updated>2021-08-24T08:27:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-04-条件构造器"><a href="#MyBatisPlus-04-条件构造器" class="headerlink" title="MyBatisPlus-04-条件构造器"></a>MyBatisPlus-04-条件构造器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>十分重要：Wrapper</p></li><li><p>写一些复杂的sql就可以使用它来替代！</p></li></ul><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-134209.png" style="zoom:50%;" /><a id="more"></a><h2 id="1-测试用例"><a href="#1-测试用例" class="headerlink" title="1. 测试用例"></a>1. 测试用例</h2><p>1、测试一，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</span></span><br><span class="line">  QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">  wrapper</span><br><span class="line">    .isNotNull(<span class="string">"name"</span>)</span><br><span class="line">    .isNotNull(<span class="string">"email"</span>)</span><br><span class="line">    .ge(<span class="string">"age"</span>,<span class="number">12</span>);</span><br><span class="line">  userMapper.selectList(wrapper).forEach(System.out::println); <span class="comment">// 和我们刚才学习</span></span><br><span class="line">  的map对比一下</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2、测试二，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 查询名字Zhuuu</span></span><br><span class="line">  QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">  wrapper.eq(<span class="string">"name"</span>,<span class="string">"Zhuuu"</span>);</span><br><span class="line">  User user = userMapper.selectOne(wrapper); <span class="comment">// 查询一个数据，出现多个结果使用List或者 Map</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试三，记住查看输出的SQL进行分析</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 查询年龄在 20 ~ 30 岁之间的用户</span></span><br><span class="line">  QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">  wrapper.between(<span class="string">"age"</span>,<span class="number">20</span>,<span class="number">30</span>); <span class="comment">// 区间</span></span><br><span class="line">  Integer count = userMapper.selectCount(wrapper);<span class="comment">// 查询结果数</span></span><br><span class="line">  System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-模糊查询"><a href="#1-1-模糊查询" class="headerlink" title="1.1 模糊查询"></a>1.1 模糊查询</h3><p>4、测试四，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模糊查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 查询年龄在 20 ~ 30 岁之间的用户</span></span><br><span class="line">  QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">  <span class="comment">// 左和右 t%</span></span><br><span class="line">  wrapper</span><br><span class="line">    .notLike(<span class="string">"name"</span>,<span class="string">"e"</span>)</span><br><span class="line">    .likeRight(<span class="string">"email"</span>,<span class="string">"t"</span>);</span><br><span class="line">  List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);</span><br><span class="line">  maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-134948.png" alt=""></p><h3 id="1-2-子查询"><a href="#1-2-子查询" class="headerlink" title="1.2 子查询"></a>1.2 子查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="comment">// id 在子查询中查出来</span></span><br><span class="line">    wrapper.inSql(<span class="string">"id"</span>,<span class="string">"select id from user where id&lt;3"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);</span><br><span class="line">    objects.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-135115.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MyBatisPlus-04-条件构造器&quot;&gt;&lt;a href=&quot;#MyBatisPlus-04-条件构造器&quot; class=&quot;headerlink&quot; title=&quot;MyBatisPlus-04-条件构造器&quot;&gt;&lt;/a&gt;MyBatisPlus-04-条件构造器&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;十分重要：Wrapper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一些复杂的sql就可以使用它来替代！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-134209.png&quot; style=&quot;zoom:50%;&quot; /&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="http://zhuuu.work/tags/MyBatis/"/>
    
      <category term="MyBatis-Plus" scheme="http://zhuuu.work/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisPlus-03-自动填充及乐观锁</title>
    <link href="http://zhuuu.work/2021/08/21/MyBatis-Plus/MyBatisPlus-03-%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <id>http://zhuuu.work/2021/08/21/MyBatis-Plus/MyBatisPlus-03-%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81/</id>
    <published>2021-08-21T12:38:38.000Z</published>
    <updated>2021-08-23T13:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-03-自动填充及乐观锁"><a href="#MyBatisPlus-03-自动填充及乐观锁" class="headerlink" title="MyBatisPlus-03-自动填充及乐观锁"></a>MyBatisPlus-03-自动填充及乐观锁</h1><h2 id="1-自动填充功能"><a href="#1-自动填充功能" class="headerlink" title="1. 自动填充功能"></a>1. 自动填充功能</h2><ul><li><p>创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！</p></li><li><p>阿里巴巴开发手册：所有的数据库表：<code>gmt_create、gmt_modified</code>几乎所有的表都要配置上！而且需要自动化！</p></li></ul><h3 id="1-1-方式一-：-数据库级别"><a href="#1-1-方式一-：-数据库级别" class="headerlink" title="1.1 方式一 ： 数据库级别"></a>1.1 方式一 ： 数据库级别</h3><p>1、在表中新增字段 <code>create_time, update_time</code></p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-125455.jpg" alt=""></p><p>2、再次测试插入方法，我们需要先把实体类同步！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure><ol start="3"><li>再次更新查看结果即可</li></ol><a id="more"></a><h3 id="1-2-方式二：代码级别"><a href="#1-2-方式二：代码级别" class="headerlink" title="1.2 方式二：代码级别"></a>1.2 方式二：代码级别</h3><p>1、删除数据库的默认值、更新操作！</p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-125915.jpg" alt=""></p><p>2、实体类字段属性上需要增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字段添加填充内容</span></span><br><span class="line"><span class="meta">@TableField</span>(fill = FieldFill.INSERT)</span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField</span>(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure><p>3、编写处理器来处理这个注解即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 一定不要忘记把处理器加到IOC容器中！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 插入时的填充策略</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"start insert fill....."</span>);</span><br><span class="line">    <span class="comment">// setFieldValByName(String fieldName, Object fieldVal, MetaObject</span></span><br><span class="line">    <span class="comment">// metaObject</span></span><br><span class="line">    <span class="keyword">this</span>.setFieldValByName(<span class="string">"createTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新时的填充策略</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"start update fill....."</span>);</span><br><span class="line">    <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试插入</p><p>5、测试更新、观察时间即可！</p><h2 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2. 乐观锁"></a>2. 乐观锁</h2><p>简单理解：</p><ul><li>乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试</li><li>悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！</li></ul><p>这里主要讲解 乐观锁机制！</p><ul><li>乐观锁实现方式：</li></ul><p>1.取出记录时，获取当前 version</p><p>2.更新时，带上这个version</p><p>3.执行更新时， set version = newVersion where version = oldVersion</p><p>4.如果version不对，就更新失败</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 大致原理分析</span></span><br><span class="line">乐观锁：1、先查询，获得版本号 version = 1</span><br><span class="line"><span class="comment">-- A</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">"zhuuu"</span>, <span class="keyword">version</span> = <span class="keyword">version</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">"zhuuu"</span>, <span class="keyword">version</span> = <span class="keyword">version</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-1-MyBatis-Plus实现"><a href="#2-1-MyBatis-Plus实现" class="headerlink" title="2.1 MyBatis-Plus实现"></a>2.1 <strong>MyBatis-Plus实现</strong></h3><p>1、给数据库中增加version字段！</p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-130956.png" alt=""></p><p>2、实体类加对应的字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span> <span class="comment">//乐观锁Version注解</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><p>3、注册组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描我们的 mapper 文件夹</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.zhuuu.mapper"</span>)</span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>            <span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注册乐观锁插件</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试一下！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试乐观锁成功！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOptimisticLocker</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1、查询用户信息</span></span><br><span class="line">  User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">  <span class="comment">// 2、修改用户信息</span></span><br><span class="line">  user.setName(<span class="string">"朱酱酱"</span>);</span><br><span class="line">  user.setEmail(<span class="string">"1235467@qq.com"</span>);</span><br><span class="line">  <span class="comment">// 3、执行更新操作</span></span><br><span class="line">  userMapper.updateById(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试乐观锁失败！多线程下</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOptimisticLocker2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 线程 1</span></span><br><span class="line">  User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">  user.setName(<span class="string">"zhuuu111"</span>);</span><br><span class="line">  user.setEmail(<span class="string">"2312312313@qq.com"</span>);</span><br><span class="line">  <span class="comment">// 模拟另外一个线程执行了插队操作</span></span><br><span class="line">  User user2 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">  user2.setName(<span class="string">"zhuuu222"</span>);</span><br><span class="line">  user2.setEmail(<span class="string">"12312312312@qq.com"</span>);</span><br><span class="line">  userMapper.updateById(user2);</span><br><span class="line">  <span class="comment">// 自旋锁来多次尝试提交！</span></span><br><span class="line">  userMapper.updateById(user);      <span class="comment">// 如果没有乐观锁就会覆盖插队线程的值！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-131821.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MyBatisPlus-03-自动填充及乐观锁&quot;&gt;&lt;a href=&quot;#MyBatisPlus-03-自动填充及乐观锁&quot; class=&quot;headerlink&quot; title=&quot;MyBatisPlus-03-自动填充及乐观锁&quot;&gt;&lt;/a&gt;MyBatisPlus-03-自动填充及乐观锁&lt;/h1&gt;&lt;h2 id=&quot;1-自动填充功能&quot;&gt;&lt;a href=&quot;#1-自动填充功能&quot; class=&quot;headerlink&quot; title=&quot;1. 自动填充功能&quot;&gt;&lt;/a&gt;1. 自动填充功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;阿里巴巴开发手册：所有的数据库表：&lt;code&gt;gmt_create、gmt_modified&lt;/code&gt;几乎所有的表都要配置上！而且需要自动化！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-方式一-：-数据库级别&quot;&gt;&lt;a href=&quot;#1-1-方式一-：-数据库级别&quot; class=&quot;headerlink&quot; title=&quot;1.1 方式一 ： 数据库级别&quot;&gt;&lt;/a&gt;1.1 方式一 ： 数据库级别&lt;/h3&gt;&lt;p&gt;1、在表中新增字段 &lt;code&gt;create_time, update_time&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-125455.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、再次测试插入方法，我们需要先把实体类同步！&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Date createTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Date updateTime;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;再次更新查看结果即可&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="http://zhuuu.work/tags/MyBatis/"/>
    
      <category term="MyBatis-Plus" scheme="http://zhuuu.work/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisPlus-02-主键生成策略及CRUD</title>
    <link href="http://zhuuu.work/2021/08/21/MyBatis-Plus/MyBatisPlus-02-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%8F%8ACRUD/"/>
    <id>http://zhuuu.work/2021/08/21/MyBatis-Plus/MyBatisPlus-02-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%8F%8ACRUD/</id>
    <published>2021-08-21T12:38:38.000Z</published>
    <updated>2021-08-23T13:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-02-主键生成策略及CRUD"><a href="#MyBatisPlus-02-主键生成策略及CRUD" class="headerlink" title="MyBatisPlus-02-主键生成策略及CRUD"></a>MyBatisPlus-02-主键生成策略及CRUD</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-123122.png" alt=""></p><ul><li><p>具体雪花算法可以参考：</p><ul><li>分布式系统唯一id生成：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html" target="_blank" rel="noopener">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></li></ul></li><li><p><strong>雪花算法：</strong></p></li><li><ul><li><code>snowflake</code>是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！</li></ul></li></ul><a id="more"></a><h2 id="1-主键自增"><a href="#1-主键自增" class="headerlink" title="1. 主键自增"></a>1. 主键自增</h2><p>1、实体类字段上 <code>@TableId(type = IdType.AUTO)</code></p><p>2、数据库字段一定要是自增！</p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-123427.jpg" alt=""></p><h2 id="2-其他策略源码"><a href="#2-其他策略源码" class="headerlink" title="2. 其他策略源码"></a>2. 其他策略源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IdType &#123;</span><br><span class="line">  AUTO(<span class="number">0</span>),            <span class="comment">// 数据库id自增</span></span><br><span class="line">  NONE(<span class="number">1</span>),            <span class="comment">// 未设置主键</span></span><br><span class="line">  INPUT(<span class="number">2</span>),           <span class="comment">// 手动输入</span></span><br><span class="line">  ID_WORKER(<span class="number">3</span>),       <span class="comment">// 默认的全局唯一id</span></span><br><span class="line">  UUID(<span class="number">4</span>),            <span class="comment">// 全局唯一id uuid</span></span><br><span class="line">  ID_WORKER_STR(<span class="number">5</span>);   <span class="comment">//ID_WORKER 字符串表示法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-基本CRUD"><a href="#3-基本CRUD" class="headerlink" title="3. 基本CRUD"></a>3. 基本CRUD</h2><h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试插入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  User user = <span class="keyword">new</span> User();</span><br><span class="line">  user.setName(<span class="string">"Zhuuu"</span>);</span><br><span class="line">  user.setAge(<span class="number">3</span>);</span><br><span class="line">  user.setEmail(<span class="string">"12345678@qq.com"</span>);</span><br><span class="line">  <span class="keyword">int</span> result = userMapper.insert(user); <span class="comment">// 帮我们自动生成id</span></span><br><span class="line">  System.out.println(result); <span class="comment">// 受影响的行数</span></span><br><span class="line">  System.out.println(user); <span class="comment">// 发现，id会自动回填</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-124839.png" alt=""></p><h3 id="3-2-更新"><a href="#3-2-更新" class="headerlink" title="3.2 更新"></a>3.2 更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试更新</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">  User user = <span class="keyword">new</span> User();</span><br><span class="line">  <span class="comment">// 通过条件自动拼接动态sql</span></span><br><span class="line">  user.setId(<span class="number">6L</span>);</span><br><span class="line">  user.setName(<span class="string">"zhuuu"</span>);</span><br><span class="line">  user.setAge(<span class="number">18</span>);</span><br><span class="line">  <span class="comment">// 注意：updateById 但是参数是一个对象！</span></span><br><span class="line">  <span class="keyword">int</span> i = userMapper.updateById(user);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-125235.png" alt=""></p><h3 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h3><p>1、根据 id 删除记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span></span>&#123;</span><br><span class="line">  userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过id批量删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteBatchId</span><span class="params">()</span></span>&#123;</span><br><span class="line">  userMapper.deleteBatchIds(Arrays.asList(<span class="number">2L</span>,<span class="number">3L</span></span><br><span class="line">                                          <span class="number">4L</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过map删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">"name"</span>,<span class="string">"Zhuuu"</span>);</span><br><span class="line">  userMapper.deleteByMap(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工作中中会遇到一些问题：逻辑删除！（下一篇博客会说）</p><h3 id="3-4-查询"><a href="#3-4-查询" class="headerlink" title="3.4 查询"></a>3.4 查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectById</span><span class="params">()</span></span>&#123;</span><br><span class="line">  User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">  System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试批量查询！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByBatchId</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">  users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按条件查询之一使用map操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByBatchIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 自定义查询</span></span><br><span class="line">  map.put(<span class="string">"name"</span>,<span class="string">"Zhuuu"</span>);</span><br><span class="line">  map.put(<span class="string">"age"</span>,<span class="number">3</span>);</span><br><span class="line">  List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">  users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-分页查询"><a href="#3-5-分页查询" class="headerlink" title="3.5 分页查询"></a>3.5 分页查询</h3><p>有以下三种方式进行分页查询</p><p>1、原始的 limit 进行分页</p><p>2、pageHelper 第三方插件</p><p>3、MP 其实也内置了分页插件！</p><hr><ul><li>对于MP来说，分页查询的使用</li></ul><p>1.配置拦截器组件即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、直接使用Page对象即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试分页查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 参数一：当前页</span></span><br><span class="line">  <span class="comment">// 参数二：页面大小</span></span><br><span class="line">  <span class="comment">// 使用了分页插件之后，所有的分页操作也变得简单的！</span></span><br><span class="line">  Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">  userMapper.selectPage(page,<span class="keyword">null</span>);</span><br><span class="line">  page.getRecords().forEach(System.out::println);</span><br><span class="line">  System.out.println(page.getTotal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-134420.png" alt=""></p><h3 id="3-6-逻辑删除"><a href="#3-6-逻辑删除" class="headerlink" title="3.6 逻辑删除"></a>3.6 逻辑删除</h3><p><strong>物理删除 ：从数据库中直接移除</strong></p><p><strong>逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 =&gt; deleted = 1</strong></p><p>作用 ： 管理员可以查看被删除的记录！防止数据的丢失，类似于回收站！</p><p>1、在数据表中增加一个 deleted 字段</p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-133105.jpg" alt=""></p><p>2、实体类中增加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure><p>3、配置！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑删除组件！</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">sqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LogicSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 配置逻辑删除</span><br><span class="line">mybatis-plus.global-config.db-config.logic-delete-value=<span class="number">1</span></span><br><span class="line">mybatis-plus.global-config.db-config.logic-not-delete-value=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>4、测试一下删除！</p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-133341.jpg" alt=""></p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-133351.jpg" alt=""></p><ul><li>记录依旧在数据库，但是值确已经变化了！</li><li>以上的所有CRUD操作及其扩展操作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MyBatisPlus-02-主键生成策略及CRUD&quot;&gt;&lt;a href=&quot;#MyBatisPlus-02-主键生成策略及CRUD&quot; class=&quot;headerlink&quot; title=&quot;MyBatisPlus-02-主键生成策略及CRUD&quot;&gt;&lt;/a&gt;MyBatisPlus-02-主键生成策略及CRUD&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-123122.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;具体雪花算法可以参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式系统唯一id生成：&lt;a href=&quot;https://www.cnblogs.com/haoxinyue/p/5208136.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/haoxinyue/p/5208136.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;雪花算法：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;snowflake&lt;/code&gt;是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="http://zhuuu.work/tags/MyBatis/"/>
    
      <category term="MyBatis-Plus" scheme="http://zhuuu.work/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisPlus-01-概述及入门案例</title>
    <link href="http://zhuuu.work/2021/08/21/MyBatis-Plus/MyBatisPlus-01-%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://zhuuu.work/2021/08/21/MyBatis-Plus/MyBatisPlus-01-%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2021-08-21T11:38:38.000Z</published>
    <updated>2021-08-23T13:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-01-概述及入门案例"><a href="#MyBatisPlus-01-概述及入门案例" class="headerlink" title="MyBatisPlus-01-概述及入门案例"></a>MyBatisPlus-01-概述及入门案例</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>为什么要学习<code>MyBatis-Plus</code>?</li></ol><ul><li><code>MyBatisPlus</code>可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！</li></ul><ol start="2"><li>类似的市场上的应用技术</li></ol><ul><li><code>JPA 、 tk-mapper、MyBatisPlus</code></li></ul><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>MyBatis 本来就是简化 JDBC 操作的！</li><li>官网：<a href="https://mp.baomidou.com/" target="_blank" rel="noopener">https://mp.baomidou.com/</a> <ul><li>MyBatis Plus，简化 MyBatis ！</li></ul></li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-103421.png" alt=""></p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-102908.png" alt=""></p><a id="more"></a><p><strong>特性</strong></p><ul><li><p>无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</p></li><li><p>损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作， BaseMapper</p></li><li><p><strong>强大的 CRUD 操作：内置通用 Mapper、通用 Service</strong></p><ul><li><strong>仅仅通过少量配置即可实现单表大部分CRUD 操作，更有强大的条件构造器，满足各类使用需求, 以后简单的CRUD操作，它不用自己编写了！</strong></li></ul></li><li><p>支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p></li><li><p><strong>支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），完美解决主键问题</strong></p></li><li><p>支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大</p><p>的 CRUD 操作</p></li><li><p>支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）</p></li><li><p>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、</p></li><li><p>Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（自动帮你生成代码）</p></li><li><p><strong>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</strong></p></li><li><p>分页插件支持多种数据库：支持 <code>MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite Postgre、SQLServer</code> 等多种数据库</p></li><li><p>内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢</p></li></ul><p>查询</p><ul><li>内置全局拦截插件：提供全表 <code>delete 、 update</code>操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><ul><li>架构如下图结构：</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-104607.png" alt=""></p><ol><li><p><strong>创建数据库表</strong>   <code>mybatis_plus</code></p></li><li><p><strong>创建用户表</strong></p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">email <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (<span class="keyword">id</span>, <span class="keyword">name</span>, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'Jone'</span>, <span class="number">18</span>, <span class="string">'test1@baomidou.com'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'Jack'</span>, <span class="number">20</span>, <span class="string">'test2@baomidou.com'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'Tom'</span>, <span class="number">28</span>, <span class="string">'test3@baomidou.com'</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">'Sandy'</span>, <span class="number">21</span>, <span class="string">'test4@baomidou.com'</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">'Billie'</span>, <span class="number">24</span>, <span class="string">'test5@baomidou.com'</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>编写项目，初始化项目！使用<code>SpringBoot</code>初始化！</p></li><li><p>导入依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>尽量不要同时导入 <code>mybatis</code>和 <code>mybatisplus！</code></li></ul><ol start="5"><li>连接数据库，这一步和MyBatis相同</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 5 驱动不同 com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置</span></span><br><span class="line"><span class="attr">serverTimezone</span>=<span class="string">GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?</span></span><br><span class="line"><span class="attr">useSSL</span>=<span class="string">false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><ol start="6"><li>传统方式pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller</li></ol><hr><ol start="6"><li>使用了<code>mybatis-plus</code> 之后</li></ol><ul><li><code>pojo</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mapper</code>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在对应的Mapper上面继承基本的类 BaseMapper</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 代表持久层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 所有的CRUD操作都已经编写完成了</span></span><br><span class="line"><span class="comment">// 你不需要像以前的配置一大堆文件了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><ul><li>注意点，我们需要在主启动类上去扫描我们的<code>mapper</code>包下的所有接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&quot;com.zhuuu.mapper&quot;)</span><br></pre></td></tr></table></figure><ul><li>测试类中测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusApplicationTests</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 继承了BaseMapper，所有的方法都来自己父类</span></span><br><span class="line">  <span class="comment">// 我们也可以编写自己的扩展方法！</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是一个 Wrapper ，条件构造器，这里我们先不用 null</span></span><br><span class="line">    <span class="comment">// 查询全部用户</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-121647.png" alt=""></p><h3 id="2-1-问题思考？"><a href="#2-1-问题思考？" class="headerlink" title="2.1 问题思考？"></a>2.1 问题思考？</h3><p>1、SQL谁帮我们写的 ? MyBatis-Plus 都写好了</p><p>2、方法哪里来的？ MyBatis-Plus 都写好了</p><h3 id="2-2-配置sql-日志"><a href="#2-2-配置sql-日志" class="headerlink" title="2.2 配置sql 日志"></a>2.2 配置sql 日志</h3><ul><li>所有的sql现在是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置日志</span></span><br><span class="line"><span class="meta">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><ul><li>配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL</li></ul><h3 id="2-3-性能分析插件及格式化器"><a href="#2-3-性能分析插件及格式化器" class="headerlink" title="2.3 性能分析插件及格式化器"></a>2.3 性能分析插件及格式化器</h3><p>在平时的开发中，会遇到一些慢sql。测试！ druid,,,,,</p><p>作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间</p><p>MP也提供性能分析插件，如果超过这个时间就停止运行！</p><p>1、导入插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* SQL执行效率插件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile</span>(&#123;<span class="string">"dev"</span>,<span class="string">"test"</span>&#125;)<span class="comment">// 设置 dev test 环境开启，保证我们的效率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PerformanceInterceptor <span class="title">performanceInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PerformanceInterceptor performanceInterceptor = <span class="keyword">new</span></span><br><span class="line">    PerformanceInterceptor();</span><br><span class="line">  performanceInterceptor.setMaxTime(<span class="number">100</span>); <span class="comment">// ms设置sql执行的最大时间，如果超过了则不</span></span><br><span class="line">  执行</span><br><span class="line">    performanceInterceptor.setFormat(<span class="keyword">true</span>); <span class="comment">// 是否格式化代码</span></span><br><span class="line">  <span class="keyword">return</span> performanceInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Ss测试使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 参数是一个 Wrapper ，条件构造器，这里我们先不用 null</span></span><br><span class="line">  <span class="comment">// 查询全部用户</span></span><br><span class="line">  List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">  users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>记住，要在SpringBoot中配置环境为dev或者 test 环境！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MyBatisPlus-01-概述及入门案例&quot;&gt;&lt;a href=&quot;#MyBatisPlus-01-概述及入门案例&quot; class=&quot;headerlink&quot; title=&quot;MyBatisPlus-01-概述及入门案例&quot;&gt;&lt;/a&gt;MyBatisPlus-01-概述及入门案例&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为什么要学习&lt;code&gt;MyBatis-Plus&lt;/code&gt;?&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyBatisPlus&lt;/code&gt;可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;类似的市场上的应用技术&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JPA 、 tk-mapper、MyBatisPlus&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;MyBatis 本来就是简化 JDBC 操作的！&lt;/li&gt;
&lt;li&gt;官网：&lt;a href=&quot;https://mp.baomidou.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.baomidou.com/&lt;/a&gt; &lt;ul&gt;
&lt;li&gt;MyBatis Plus，简化 MyBatis ！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-103421.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-23-102908.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="http://zhuuu.work/tags/MyBatis/"/>
    
      <category term="MyBatis-Plus" scheme="http://zhuuu.work/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>JUC-21-FutureTask 源码分析</title>
    <link href="http://zhuuu.work/2021/08/17/JUC/JUC-21-FutureTask/"/>
    <id>http://zhuuu.work/2021/08/17/JUC/JUC-21-FutureTask/</id>
    <published>2021-08-17T09:38:38.000Z</published>
    <updated>2021-09-05T07:12:06.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUC-21-FutureTask-源码分析"><a href="#JUC-21-FutureTask-源码分析" class="headerlink" title="JUC-21-FutureTask 源码分析"></a>JUC-21-FutureTask 源码分析</h2><ul><li>废话不多收，直接手撕源码</li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.sources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; The result type returned by this FutureTask's &#123;<span class="doctag">@code</span> get&#125; methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Possible state transitions:</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;                     <span class="comment">// 判断当前task的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;      <span class="comment">// 当前任务尚未执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;      <span class="comment">// 当前任务正在结束，稍微完全结束的临界状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;      <span class="comment">// 当前任务正常结束</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;      <span class="comment">// 当前任务执行过程中出现了异常，Callable.run()方法向上抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;      <span class="comment">// 当前任务被取消</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;      <span class="comment">// 当前任务中断中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;      <span class="comment">// 当前任务已中断</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;= CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state != NEW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// submit(runnable/callable) runnable 使用装饰着伪装成 callable了</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">// 1. 正常情况下：任务执行结束，outcome保存执行结果，callable 返回值</span></span><br><span class="line">    <span class="comment">// 2. 非正常情况下，callable向上抛出异常，outcome保存异常</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome;</span><br><span class="line">    <span class="comment">// 当前任务执行期间，保存当前执行对象线程的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    <span class="comment">// 所有等待的线程，包装成一个节点，并且把自己unsafe.park掉,除非被其他线程唤醒或者中断</span></span><br><span class="line">    <span class="comment">// 因为会有很多线程去get当前任务的结果，所有这里使用了一个头插头取的队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;                                           <span class="comment">// waiters保存了一个头节点的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="comment">// 内存地址的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = FutureTask<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            stateOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">            runnerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"runner"</span>));</span><br><span class="line">            waitersOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"waiters"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// get()方法向上汇报结果</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 正常情况下，outcome保存的是callable()运行结束的结果</span></span><br><span class="line">            <span class="comment">//非正常情况下，这里保存的是callale()抛出的异常</span></span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="comment">// 2. 当前任务正常结束，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="comment">// 3. 非正常结束，被中断或者被取消了，抛出了CancellationException</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 执行到这里，抛出ExecutionException，说明callable接口实现中是有bug的</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  构造方法，大多数情况不会来new它,而是直接提交到线程池里面</span></span><br><span class="line">    <span class="comment">//  submit 最终调用的是AbstractExecuotrService 的 execute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 1. callable 就是程序员自己实现的业务类</span></span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">// 2. 设置当前任务的状态为new</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the runnable is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 使用适配器模式将runnable 将转换成 callable，外部线程通过get获取（结果可能是null 也可能是自己 传的值）</span></span><br><span class="line">        <span class="comment">// 2. 传的结果是什么，返回的结果是什么，无法拿到线程执行的结果(自己骗自己)</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="comment">// 3. 设置任务的状态是new</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cancel()使用场景 ： 提交之后通过线程池执行任务，这个任务一直不结束，外层也不知道到里面是否执行完。（通过外部Future句柄中断掉）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 条件一 ： ！（state == NEW） 表示当前任务处理运行中 或者 处理线程池的任务队列中，才是可以取消的</span></span><br><span class="line">        <span class="comment">//    条件二 ： UNSAFE.compareAndSwapInt(this, stateOffset, NEW,</span></span><br><span class="line">        <span class="comment">//                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED))</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">              UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;                              <span class="comment">// 否则返回false,表示cancel()失败</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 只有上面执行成功，才会执行下面的逻辑</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1 运行中打断，给当前的线程发送一个中断信号</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;                 <span class="comment">// 拿到执行当前futureTask的线程</span></span><br><span class="line">                    <span class="comment">// 2.1.1 当前执行futureTask的线程为null的情况，说明当前任务在队列中呢，还没有线程有空来执行它</span></span><br><span class="line">                    <span class="comment">// 2.1.1 这里不是null 说明当前线程正在执行，给当前线程一个中断信号</span></span><br><span class="line">                            <span class="comment">// 这个时候如果程序响应中断就走中断逻辑</span></span><br><span class="line">                            <span class="comment">// 如果程序不响应中断，那么啥也不会发生</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.2 设置任务状态为中断完成</span></span><br><span class="line">                <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 最后唤醒所有get阻塞的线程</span></span><br><span class="line">                <span class="comment">// 虽然对于2来说，如果程序不响应中断，中断什么的也不会发生，但是这里还是会唤醒所有阻塞的线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重要的get()方法 ： 这里要注意的是，不要认为只有一个线程会来这里调用get（）方法，可能会有多个线程来这里调用get()方法</span></span><br><span class="line">    <span class="comment">// 场景： 多个线程等待当前任务执行完成后的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.1 获取当前任务状态</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 1.2 条件成立：要么是未执行，要么是正在执行，要么是正在完成</span></span><br><span class="line">        <span class="comment">//     调用get()的外部线程，会在这里阻塞等待结果</span></span><br><span class="line">        <span class="comment">//     这里尤其要注意的是，这里get()的线程和runner对应执行任务的线程，一定不是同一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">// 1.3 整个futureTask 最核心的方法</span></span><br><span class="line">            <span class="comment">// 这里返回当前task的状态，或者这里线程已经抛出中断异常了</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置c.call() 结果结果的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.1 使用CAS方式设置当前任务状态为完成中，临界值的状态</span></span><br><span class="line">        <span class="comment">// 1.2 这里有没有可能失败呢？ 外部线程等不及了，直接cancel()掉task。基本不可能发生</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">// 2.1 结果赋值给outcome</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            <span class="comment">// 2.2 将结果赋值给outcome之后，马上直接改写内存中的Int值，不是CAS。将当前任务转换成Normal，正常结束的状态</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            <span class="comment">// 2.3 回头再说，讲完get（）再说，猜一猜会做什么事</span></span><br><span class="line">                <span class="comment">// 起码会把get() 阻塞的线程给唤醒</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置c.call() 设置异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.1 使用CAS方式设置当前任务状态为完成中，临界值的状态</span></span><br><span class="line">        <span class="comment">// 1.2 这里有没有可能失败呢？ 外部线程等不及了，直接cancel()掉task。基本不可能发生</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">// 2.1 引用的是 callable向上层抛出的异常，拿不到结果了，只能get到异常</span></span><br><span class="line">            outcome = t;</span><br><span class="line">            <span class="comment">// 2.2 将结果赋值给outcome之后，马上直接改写内存中的Int值，不是CAS。将当前任务转换成EXCEPTIONAL</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            <span class="comment">// 2.3 回头再说，讲完get（）再说</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心方法 ： 线程执行方法的入口</span></span><br><span class="line">    <span class="comment">// 提交任务的流程  ： sumbit(runnable/callable) -&gt; newTaskFor(runnable) -&gt; execute(task) -&gt;pool</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 条件1 ： state != new : 说明当前task已经被执行过了或者被cancel掉了，总之非new状态的任务，线程就不处理了</span></span><br><span class="line">        <span class="comment">// 条件2 ： !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread())</span></span><br><span class="line">                    <span class="comment">// 2.1 通过CAS 将当前线程设置到FutureTask的runner中</span></span><br><span class="line">                    <span class="comment">// 2.2 若这里条件成立，说明cas失败，也就是当前任务被其他线程给抢占了</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置条件：执行到这里，当前的task一定是New 状态，而且当前线程也抢占到task成功</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.1 这里的callable就是程序员自己设置的任务，或者是适配后的runnable</span></span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="comment">// 条件1： c != null ，防止空指针异常</span></span><br><span class="line">            <span class="comment">// 条件2： state == NEW ，防止外部线程在这个空隙中cancel掉任务</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                <span class="comment">// 2.1 保留结果的引用</span></span><br><span class="line">                V result;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 true 表示 callable.run正常执行成功， false表示callable.run 执行失败</span></span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.3 正常执行,ran 是 true</span></span><br><span class="line">                    <span class="comment">// 拿到callable就是程序员自己设置的任务，或者是适配后的runnable 的运行结果</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// 2.4 执行失败，ran 默认是false</span></span><br><span class="line">                    <span class="comment">// 结果设置为空</span></span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 2.5 回头再说</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 说明当前c.call()正常执行结束了，设置结果</span></span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    <span class="comment">// set设置结果到outcome的一个过程，点开源码</span></span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. finally块 ： 这里只有抛出异常才会来到这里</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 4.1 将当前执行task的线程给设置为null</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.2 大于等于中断中，稍微让当前线程释放CPU</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                <span class="comment">// 4.3 回头再说，讲完 cancel() 方法就明白了</span></span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务完成之后，在改完任务状态为normal之后，需要调用此方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment">     * nulls out callable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. q指向waiters链表的头节点，头节点不为null的情况</span></span><br><span class="line">        <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 通过CAS方式，首先将CAS将waiters头节点设置为null</span></span><br><span class="line">            <span class="comment">// 这里是用CAS是因为怕外部线程，通过cancel()取消当前任务，也会触发finishCompletion（）</span></span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="comment">// 2.1 首先拿到当前节点的线程</span></span><br><span class="line">                    Thread t = q.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        q.thread = <span class="keyword">null</span>;             <span class="comment">// 将当前节点的线程置为空（help GC）</span></span><br><span class="line">                        LockSupport.unpark(t);       <span class="comment">// 并且唤醒所有在awaitDone阻塞的线程,unpark的方式，哪里阻塞在哪里唤醒</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 2.2 处理当前节点的下一个节点</span></span><br><span class="line">                    WaitNode next = q.next;</span><br><span class="line">                    <span class="comment">// 2.2.1 下一个节点为null的话，说明处理的是最后一个节点，就都唤醒完了</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 2.2.2 如果当前节点next不为空，继续处理下一个节点去</span></span><br><span class="line">                    q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                    q = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.3 都处理完了，跳出自旋</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 啥也没做</span></span><br><span class="line">        done();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 设置当前任务为空</span></span><br><span class="line">        callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个FutureTask 最核心的方法，这里讲的不带超时时间</span></span><br><span class="line">    <span class="comment">// 从FutureTask.get()方法入口进来的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.1 timed = 0 不带超时时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// 1.2 初始：引用当前线程，封装成WaitNode对象</span></span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1.3 表示当前线程waitNode对象有没有入队</span></span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 进入一个自旋，源码从下往上看</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 2.5 从LockSupport.park中断的线程</span></span><br><span class="line">            <span class="comment">// 条件成立：说明当前线程是被其他线程使用中断方式喊醒的。</span></span><br><span class="line">            <span class="comment">// Thread.interrupted()会返回true,并且把当前线程的中断标记位重新设置为false</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// 当前线程出队的操作</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="comment">// 向外层get()方法抛出中断异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.6 从LockSupport.park 被其他线程唤醒的线程 unpark，就会走下面的逻辑</span></span><br><span class="line">            <span class="comment">// 条件成立：unpark唤醒后会正常自旋，走下面的逻辑</span></span><br><span class="line">            <span class="comment">// 获取当前线程最新的状态</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 条件成立：说明当前任务已经有结果了，可能是好结果或者坏结果</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="comment">// 条件成立，说明当前线程已经创建过node了，此时需要将node中的Thread指向null, (help GC)</span></span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 直接返回当前状态</span></span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.7 说明当前任务接近完成状态，这里让当前线程再释放CPU,进行下一次抢占CPU</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 条件成立：第一次自旋，当前线程还未创建WaitNode对象，此时为当前线程创建WaitNode对象</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 条件成立：第二次自旋，当前线程创建WaitNode对象，但是当前node还未入队</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued) &#123;</span><br><span class="line">                <span class="comment">// 2.2.1 当前线程node节点 next指向原队列的头节点 ,waiters一直指向队列的头</span></span><br><span class="line">                q.next = waiters;</span><br><span class="line">                <span class="comment">// 2.2.2 CAS方式设置waiters引用指向当前线程node,成功的话queue == true,否则的话，可能其他线程先你一步入队了</span></span><br><span class="line">                <span class="comment">//          如果失败了的话，还会自旋去重新尝试入队的，一直成功位置</span></span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, waiters, q);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.3 条件成立：第三次自旋，会来到这里。这里的timed是0,会走到下一个else里面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.4 当前get操作的线程就会被park掉了，线程的状态会变成WAITING状态，相当于休眠了。。</span></span><br><span class="line">            <span class="comment">//     除非其他线程将你 唤醒，或者将当前线程  中断</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 首先将引用的线程置为空</span></span><br><span class="line">            node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 自旋,断开链表的操作</span></span><br><span class="line">            retry:</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 3. 内层for循环</span></span><br><span class="line">                <span class="comment">// pred当前节点上一个节点，q当前节点，s当前节点下一个节点。</span></span><br><span class="line">                <span class="comment">// 循环条件：q != null 一轮结束后q = s</span></span><br><span class="line">                <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                    s = q.next;                    <span class="comment">// 拿到当前节点的下一个节点</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.1 如果当前节点不为空</span></span><br><span class="line">                    <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                        pred = q;                  <span class="comment">// 指针前进，遍历到下一个节点去</span></span><br><span class="line">                        <span class="comment">// 3.2 当前节点q的线程是null，说明是一个要移除出队的节点</span></span><br><span class="line">                        <span class="comment">// 同时如果pred不是null的情况，说明当前节点不是头节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        pred.next = s;             <span class="comment">// 前置节点的节点直接指向下一个节点，跳过该节点，相当于直接删除这个节点</span></span><br><span class="line">                        <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>)   <span class="comment">// 怕的就是pred这个线程也执行出队了，重新再来一次</span></span><br><span class="line">                            <span class="keyword">continue</span> retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 3.3 如果当前节点的线程是null, 同时又是头节点</span></span><br><span class="line">                    <span class="comment">// CAS 当前节点直接指向下一个节点，跳过该节点，相当于直接删除这个节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                            q, s))</span><br><span class="line">                        <span class="keyword">continue</span> retry;             <span class="comment">// 成功就接着往下的逻辑，看有没有还要出队的</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the computation without setting its result, and then</span></span><br><span class="line"><span class="comment">     * resets this future to initial state, failing to do so if the</span></span><br><span class="line"><span class="comment">     * computation encounters an exception or is cancelled.  This is</span></span><br><span class="line"><span class="comment">     * designed for use with tasks that intrinsically execute more</span></span><br><span class="line"><span class="comment">     * than once.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successfully run and reset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAndReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.call(); <span class="comment">// don't set result</span></span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensures that any interrupt from a possible cancel(true) is only</span></span><br><span class="line"><span class="comment">     * delivered to a task while in run or runAndReset.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">        <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">        <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">            <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">                Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// assert state == INTERRUPTED;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to clear any interrupt we may have received from</span></span><br><span class="line">        <span class="comment">// cancel(true).  However, it is permissible to use interrupts</span></span><br><span class="line">        <span class="comment">// as an independent mechanism for a task to communicate with</span></span><br><span class="line">        <span class="comment">// its caller, and there is no way to clear only the</span></span><br><span class="line">        <span class="comment">// cancellation interrupt.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Thread.interrupted();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JUC-21-FutureTask-源码分析&quot;&gt;&lt;a href=&quot;#JUC-21-FutureTask-源码分析&quot; class=&quot;headerlink&quot; title=&quot;JUC-21-FutureTask 源码分析&quot;&gt;&lt;/a&gt;JUC-21-FutureTask 源码分析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;废话不多收，直接手撕源码&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="线程池" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="FutureTask" scheme="http://zhuuu.work/tags/FutureTask/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-06-DDD</title>
    <link href="http://zhuuu.work/2021/08/13/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-06-DDD/"/>
    <id>http://zhuuu.work/2021/08/13/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-06-DDD/</id>
    <published>2021-08-13T08:38:38.000Z</published>
    <updated>2021-12-26T09:13:28.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发笔记-06-DDD"><a href="#开发笔记-06-DDD" class="headerlink" title="开发笔记-06-DDD"></a>开发笔记-06-DDD</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>待后续补充</li></ul><a id="more"></a><!--more-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发笔记-06-DDD&quot;&gt;&lt;a href=&quot;#开发笔记-06-DDD&quot; class=&quot;headerlink&quot; title=&quot;开发笔记-06-DDD&quot;&gt;&lt;/a&gt;开发笔记-06-DDD&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;待后续补充&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="开发笔记" scheme="http://zhuuu.work/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-05-protal</title>
    <link href="http://zhuuu.work/2021/08/13/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-05-protal/"/>
    <id>http://zhuuu.work/2021/08/13/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-05-protal/</id>
    <published>2021-08-13T08:38:38.000Z</published>
    <updated>2021-08-13T10:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发笔记-05-protal"><a href="#开发笔记-05-protal" class="headerlink" title="开发笔记-05-protal"></a>开发笔记-05-protal</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>Portal</code>在英语中是入口的意思。<strong><code>Portal</code>认证通常也称为<code>Web</code>认证，一般将<code>Portal</code>认证网站称为门户网站。</strong></li><li>它提供了一种较为简单的用户认证方法，对用户而言，相对其它认证方式更易于使用。它有两大特色：<ul><li>免客户端 : 只需要网页浏览器（如IE）支持，即可为用户提供认证服务，不需要安装专门的客户端或者拨号程序。免客户端软件对于像宾馆、酒店等公共网络节点，免客户端软件是一个基本要求。</li><li>新业务载体 : 利用<code>Portal</code>认证的门户功能，运营商可以将小区广播、广告、信息查询、网上购物等业务放到<code>Portal</code>上。用户上网时会强制地看到上述信息。</li></ul></li><li>Portal认证的基本方式是通过在Portal页面的显著位置设置认证窗口，用户开机获取IP地址后，通过登录Portal认证页面进行认证，认证通过后即可访问Internet。</li><li>对于用户来说有两种方式访问认证页面：<ul><li>主动Portal：用户必须知道PORTAL服务器的IP地址，主动登陆PORTAL服务器进行认证，之后才能访问网络。</li><li>强制Portal：未认证用户访问网址，都会先强制定向到PORTAL服务器进行认证，用户不需要记忆Portal服务器的IP地址。</li></ul></li></ul><a id="more"></a><p><strong>参考博客：</strong><a href="https://blog.csdn.net/xianweijian/article/details/49450703" target="_blank" rel="noopener">https://blog.csdn.net/xianweijian/article/details/49450703</a></p><p><a href="https://blog.csdn.net/weixin_43741880/article/details/95637946" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43741880/article/details/95637946</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发笔记-05-protal&quot;&gt;&lt;a href=&quot;#开发笔记-05-protal&quot; class=&quot;headerlink&quot; title=&quot;开发笔记-05-protal&quot;&gt;&lt;/a&gt;开发笔记-05-protal&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Portal&lt;/code&gt;在英语中是入口的意思。&lt;strong&gt;&lt;code&gt;Portal&lt;/code&gt;认证通常也称为&lt;code&gt;Web&lt;/code&gt;认证，一般将&lt;code&gt;Portal&lt;/code&gt;认证网站称为门户网站。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;它提供了一种较为简单的用户认证方法，对用户而言，相对其它认证方式更易于使用。它有两大特色：&lt;ul&gt;
&lt;li&gt;免客户端 : 只需要网页浏览器（如IE）支持，即可为用户提供认证服务，不需要安装专门的客户端或者拨号程序。免客户端软件对于像宾馆、酒店等公共网络节点，免客户端软件是一个基本要求。&lt;/li&gt;
&lt;li&gt;新业务载体 : 利用&lt;code&gt;Portal&lt;/code&gt;认证的门户功能，运营商可以将小区广播、广告、信息查询、网上购物等业务放到&lt;code&gt;Portal&lt;/code&gt;上。用户上网时会强制地看到上述信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Portal认证的基本方式是通过在Portal页面的显著位置设置认证窗口，用户开机获取IP地址后，通过登录Portal认证页面进行认证，认证通过后即可访问Internet。&lt;/li&gt;
&lt;li&gt;对于用户来说有两种方式访问认证页面：&lt;ul&gt;
&lt;li&gt;主动Portal：用户必须知道PORTAL服务器的IP地址，主动登陆PORTAL服务器进行认证，之后才能访问网络。&lt;/li&gt;
&lt;li&gt;强制Portal：未认证用户访问网址，都会先强制定向到PORTAL服务器进行认证，用户不需要记忆Portal服务器的IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="开发笔记" scheme="http://zhuuu.work/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java8-新特性-接口中的方法</title>
    <link href="http://zhuuu.work/2021/08/12/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://zhuuu.work/2021/08/12/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2021-08-12T14:30:53.000Z</published>
    <updated>2021-08-28T03:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8-新特性-接口中的方法"><a href="#java8-新特性-接口中的方法" class="headerlink" title="java8-新特性-接口中的方法"></a>java8-新特性-接口中的方法</h1><h2 id="前言-JDK1-8-之前的回顾"><a href="#前言-JDK1-8-之前的回顾" class="headerlink" title="前言 : JDK1.8 之前的回顾"></a>前言 : JDK1.8 之前的回顾</h2><ul><li><p><strong>在jdk1.8之前，我们对接口的认知是这样的：</strong></p><p><strong>1、方法：只能包含public和abstract的方法，即使定义为：</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取几何图形的面积</span></span><br><span class="line">   <span class="function">Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 方法前面也默认加了<span class="keyword">public</span> <span class="keyword">abstract</span>修饰</span><br></pre></td></tr></table></figure><p> <strong>2、字段：只能包含常量，即public static final 修饰的变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">即使这样写，也是默认加上了<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>修饰。</span><br></pre></td></tr></table></figure><p><strong>问题展现</strong></p><ul><li>现在我们有很多类实现了该接口，有三角形<code>trangle</code>，有圆形<code>circle</code>······</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * width / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法时默认length传半径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * length * length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>有一天，我们发现接口功能不够用了，需要增加一个计算周长的方法。</p></li><li><p>这时候，<code>JDK1.7</code>及其之前版本该怎么办呢？</p><ul><li>管他三七二十一，往接口里直接加个方法，强迫所有实现该几何图形的接口的实现类（正方形、圆形、三角形······）都实现最新的接口方法</li><li>把接口代码移到抽象类，添加一个有默认实现的计算周长的方法，但是所有实现类都要改为继承，遇到实现类继承别的父类就行不通了（java只有单继承）</li><li>添加一个新接口，新接口里加上一个计算周长的方法，让所有实现了Shape接口的类再实现新的接口，看起来很美好，接口本身也是这么使用的，但是如果这个方法让所有的实现类再实现一遍，还是挺麻烦的。</li></ul></li></ul><ul><li>JDK1.8针对这种接口不易扩展的现象，在接口新增default方法，可以有效解决上述遇到的接口拓展新方法的问题。原先的实现类不用改任何代码就拥有了新的能力，有点像从接口继承了一个有实现的方法，可以直接调用。</li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Circle().getPerimeterOfCircle(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增默认方法，为四边形扩展计算周长</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 长</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width  款</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Double <span class="title">getPerimeterOfQuadrilateral</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (length + width) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增默认方法，为圆形计算周长</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redius 半径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Double <span class="title">getPerimeterOfCircle</span><span class="params">(<span class="keyword">double</span> redius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * <span class="number">2</span> * redius;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * width / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法时默认length传半径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * length * length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-default-方法"><a href="#1-default-方法" class="headerlink" title="1. default 方法"></a>1. default 方法</h2><ul><li>在<code>java8</code>以后，接口中可以添加使用<code>default</code>或者<code>static</code>修饰的方法，在这里我们只讨论default方法</li><li><strong><code>default</code>修饰方法只能在接口中使用</strong></li><li><strong>在接口中被default标记的方法为普通方法，可以直接写方法体。</strong></li></ul><h3 id="1-1-实现类会继承接口中的default方法"><a href="#1-1-实现类会继承接口中的default方法" class="headerlink" title="1.1 实现类会继承接口中的default方法"></a>1.1 实现类会继承接口中的default方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">如果接口A中有<span class="keyword">default</span>方法：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test类实现接口A：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么Test类将会继承接口A中的a方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">t.a();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-同时实现接口A和B，接口A和B中有相同的default方法"><a href="#1-2-同时实现接口A和B，接口A和B中有相同的default方法" class="headerlink" title="1.2 同时实现接口A和B，接口A和B中有相同的default方法"></a>1.2 <strong>同时实现接口A和B，接口A和B中有相同的default方法</strong></h3><ul><li><strong>如果一个类同时实现接口A和B，接口A和B中有相同的default方法，这时，该类必须重写接口中的default方法</strong></li></ul><blockquote><p>为什么要重写呢？是因为，类在继承接口中的default方法时，不知道应该继承哪一个接口中的default方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">接口A：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">接口B：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Test类：</strong></p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-27-135103.png" alt=""></p><h3 id="1-3-同时继承父类和实现接口方法"><a href="#1-3-同时继承父类和实现接口方法" class="headerlink" title="1.3 同时继承父类和实现接口方法"></a>1.3 同时继承父类和实现接口方法</h3><ul><li><strong>如果子类继承父类，父类中有b方法，该子类同时实现的接口中也有b方法（被default修饰），那么子类会继承父类的b方法而不是继承接口中的b方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">接口A：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AAA"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类C：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"CCC"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类：</strong></p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-27-135302.png" alt=""></p><ul><li>说明子类继承的b方法为父类C中的b方法，不是接口中的<code>default b(){}</code>方法。</li></ul><h2 id="2-static-方法"><a href="#2-static-方法" class="headerlink" title="2. static 方法"></a>2. static 方法</h2><ul><li><strong>静态方法比较直观，类比普通类的静态方法</strong></li><li><strong>就是可以不实例化，直接用类名调用的方法</strong></li><li><strong>接口的静态方法也是一样，直接用接口名调用方法。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Circle().getPerimeterOfCircle(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">        System.out.println(Shape.describe());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增默认方法，为四边形扩展计算周长</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 长</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width  款</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Double <span class="title">getPerimeterOfQuadrilateral</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (length + width) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增默认方法，为圆形计算周长</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redius 半径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Double <span class="title">getPerimeterOfCircle</span><span class="params">(<span class="keyword">double</span> redius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * <span class="number">2</span> * redius;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口描述方法，描述接口用途及其他信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是一个几何图形接口"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * width / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法时默认length传半径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * length * length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-28-030846.png" alt=""></p><ul><li>可以惊奇地看到，用接口直接调了一个方法，这个现象可以类比匿名类。</li><li>比如JDK1.7，我们要实现一个接口有一个方法，并且不用实例化的类来调用应该这么做：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Shape() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"我是一个几何图形接口"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.describe());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Double <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">String <span class="title">describe</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-28-031026.png" alt=""></p><ul><li>但是这样做完全没有太大的意义，没有接口中定义静态方法来的优雅、简单。</li></ul><h2 id="3-新的接口和抽象类对比"><a href="#3-新的接口和抽象类对比" class="headerlink" title="3. 新的接口和抽象类对比"></a>3. 新的接口和抽象类对比</h2><ul><li><p><strong>带默认或者静态方法的接口像是一个抽象类吗？的确有点像</strong></p><ul><li><strong>但是抽象类可能包含可变状态（实例变量），而接口只能定义行为和常量。</strong></li></ul></li><li><p><strong>另外，一个类只能直接从一个类继承，但可以实现所需的任意数量的接口。</strong></p></li><li><p><strong>所以，如果需要可变状态，并且确定某个类将构成一个合理的子类，则需要考虑一个抽象类。在其他情况下，使用具有默认/静态方法的接口就好了。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java8-新特性-接口中的方法&quot;&gt;&lt;a href=&quot;#java8-新特性-接口中的方法&quot; class=&quot;headerlink&quot; title=&quot;java8-新特性-接口中的方法&quot;&gt;&lt;/a&gt;java8-新特性-接口中的方法&lt;/h1&gt;&lt;h2 id=&quot;前言-JDK1-8-之前的回顾&quot;&gt;&lt;a href=&quot;#前言-JDK1-8-之前的回顾&quot; class=&quot;headerlink&quot; title=&quot;前言 : JDK1.8 之前的回顾&quot;&gt;&lt;/a&gt;前言 : JDK1.8 之前的回顾&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在jdk1.8之前，我们对接口的认知是这样的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、方法：只能包含public和abstract的方法，即使定义为：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//获取几何图形的面积&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;Double &lt;span class=&quot;title&quot;&gt;getArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; length, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; width)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 方法前面也默认加了&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt;修饰&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt; &lt;strong&gt;2、字段：只能包含常量，即public static final 修饰的变量&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;即使这样写，也是默认加上了&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt;修饰。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;问题展现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现在我们有很多类实现了该接口，有三角形&lt;code&gt;trangle&lt;/code&gt;，有圆形&lt;code&gt;circle&lt;/code&gt;······&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Trangle&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Double &lt;span class=&quot;title&quot;&gt;getArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; length, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; width)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; length * width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Double &lt;span class=&quot;title&quot;&gt;getArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; length, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; width)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//调用方法时默认length传半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3.14&lt;/span&gt; * length * length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一天，我们发现接口功能不够用了，需要增加一个计算周长的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这时候，&lt;code&gt;JDK1.7&lt;/code&gt;及其之前版本该怎么办呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管他三七二十一，往接口里直接加个方法，强迫所有实现该几何图形的接口的实现类（正方形、圆形、三角形······）都实现最新的接口方法&lt;/li&gt;
&lt;li&gt;把接口代码移到抽象类，添加一个有默认实现的计算周长的方法，但是所有实现类都要改为继承，遇到实现类继承别的父类就行不通了（java只有单继承）&lt;/li&gt;
&lt;li&gt;添加一个新接口，新接口里加上一个计算周长的方法，让所有实现了Shape接口的类再实现新的接口，看起来很美好，接口本身也是这么使用的，但是如果这个方法让所有的实现类再实现一遍，还是挺麻烦的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;JDK1.8针对这种接口不易扩展的现象，在接口新增default方法，可以有效解决上述遇到的接口拓展新方法的问题。原先的实现类不用改任何代码就拥有了新的能力，有点像从接口继承了一个有实现的方法，可以直接调用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java基础" scheme="http://zhuuu.work/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="lambda表达式" scheme="http://zhuuu.work/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="java8" scheme="http://zhuuu.work/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>java8-新特性-关键字</title>
    <link href="http://zhuuu.work/2021/08/08/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://zhuuu.work/2021/08/08/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-08-08T14:30:53.000Z</published>
    <updated>2021-08-27T13:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8-新特性-‘-’-关键字"><a href="#java8-新特性-‘-’-关键字" class="headerlink" title="java8-新特性-‘::’ 关键字"></a>java8-新特性-‘::’ 关键字</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>Java 8</code>中我们可以通过 <code>::</code> 关键字来访问类的构造方法，对象方法，静态方法。</li><li>方法的引用的语法，主要有三类:</li></ul><p>1.指向<strong>静态方法</strong>的方法引用，例如<code>Integer</code>的<code>parseInt</code>方法 ，可以写成<code>Integer::parseInt</code></p><pre><code>类：：静态方法名</code></pre><p>2.指向任意类型实例方法的方法引用，例如<code>String</code>的<code>length</code>方法，写成<code>String::length</code></p><pre><code>类：：实例方法名</code></pre><p>3.指向现有对象的实例方法的方法引用</p><pre><code>对象：：实例方法名</code></pre><p>4.构造器的引用：对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用<code>ClassName::new</code></p><ul><li><p>在<code>java8</code>中的函数式接口，提供了无参构造函数，以及有参构造函数创建实例的方式；构造器的参数列表，需要与函数式接口中参数列表保持一致！</p></li><li><p>方法的引用让你可以重复使用现有的方法定义，并像lambda一样传递他们，在一些情况下，比起使用lambda表达式，它们似乎更易读，感觉也更自然；</p></li></ul><a id="more"></a><ul><li>举个例子：</li></ul><ol><li>现有一个类<code>Something</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. constructor methods</span></span><br><span class="line">    Something() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 有参 </span></span><br><span class="line">    Something(String something) &#123;</span><br><span class="line">System.out.println(something);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3. static methods</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. object methods</span></span><br><span class="line">    <span class="function">String <span class="title">endWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(s.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 5. void methods</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endWith</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如何用 <code>&#39;::&#39;</code>来访问类<code>Something</code>中的方法呢？先定义一个接口，因为必须要用<code>functional interface</code>来接收，否则编译错误<code>（The target type of this expression must be a functional interface）</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IConvert</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F form)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（<code>@FunctionalInterface</code>注解要求接口有且只有一个抽象方法，<code>JDK</code>中有许多类用到该注解，比如 <code>Runnable</code>，它只有一个 <code>Run</code>方法。）</li></ul><ol start="3"><li>观察接口 <code>IConvert</code>，传参为类型 <code>F</code>，返回类型 <code>T</code>。</li><li>所以，可以这样访问类<code>Something</code>的方法：</li></ol><hr><h2 id="1-访问静态方法"><a href="#1-访问静态方法" class="headerlink" title="1. 访问静态方法"></a>1. 访问静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static methods</span></span><br><span class="line">IConvert&lt;String, String&gt; convert = Something::startsWith;</span><br><span class="line">String converted = convert.convert(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure><h2 id="2-访问静态方法"><a href="#2-访问静态方法" class="headerlink" title="2. 访问静态方法"></a>2. 访问静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object methods</span></span><br><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">IConvert&lt;String, String&gt; converter = something::endWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br></pre></td></tr></table></figure><h2 id="3-访问构造方法"><a href="#3-访问构造方法" class="headerlink" title="3. 访问构造方法"></a>3. 访问构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// constructor methods</span></span><br><span class="line">IConvert&lt;String, Something&gt; convert = Something::<span class="keyword">new</span>;</span><br><span class="line">Something something = convert.convert(<span class="string">"constructors"</span>);</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>可以把类<code>Something</code>中的方法<code>static String startsWith(String s){...}</code>、<code>String endWith(String s){...}</code>、<code>Something(String something){...}</code>看作是接口<code>IConvert</code>的实现</li><li>因为它们都符合接口定义的那个“模版”，有传参类型F以及返回值类型T。</li><li>比如构造方法<code>Something(String something)</code>，它传参为<code>String</code>类型，返回值类型为<code>Something</code>。</li><li>注解<code>@FunctionalInterface</code>保证了接口有且仅有一个抽象方法，所以<code>JDK</code>能准确地匹配到相应方法。</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*************** 方法的引用 ****************/</span></span><br><span class="line">    <span class="comment">// 类：：静态方法名</span></span><br><span class="line">    Comparator&lt;Integer&gt; bb = Integer::compare;</span><br><span class="line">    System.out.println(bb.compare(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">    Comparator&lt;Integer&gt; cc = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">    System.out.println(cc.compare(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line">    Comparator&lt;Integer&gt; dd = (x, y) -&gt; x.compareTo(y);</span><br><span class="line">    System.out.println(dd.compare(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">    Comparator&lt;Integer&gt; ee = Integer::compareTo;</span><br><span class="line">    System.out.println(ee.compare(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 类：：实例方法名</span></span><br><span class="line">    BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</span><br><span class="line">    System.out.println(bp.test(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp1 = String::equals;</span><br><span class="line">    System.out.println(bp1.test(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对象：：实例方法名</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = x -&gt; System.out.println(x);</span><br><span class="line">    con1.accept(<span class="string">"abc"</span>);</span><br><span class="line">    Consumer&lt;String&gt; con = System.out::println;</span><br><span class="line">    con.accept(<span class="string">"abc"</span>);</span><br><span class="line"> </span><br><span class="line">    Emp emp = <span class="keyword">new</span> Emp(<span class="string">"上海"</span>, <span class="string">"xiaoMIng"</span>, <span class="number">18</span>);</span><br><span class="line">    Supplier&lt;String&gt; supper1 = () -&gt; emp.getAddress();</span><br><span class="line">    System.out.println(supper1.get());</span><br><span class="line">    Supplier&lt;String&gt; supper = emp::getAddress;</span><br><span class="line">    System.out.println(supper.get());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*************** 构造器的引用 ****************/</span></span><br><span class="line">    <span class="comment">// 无参构造函数，创建实例</span></span><br><span class="line">    Supplier&lt;Emp&gt; supper2 = () -&gt; <span class="keyword">new</span> Emp();</span><br><span class="line">    Supplier&lt;Emp&gt; supper3 = Emp::<span class="keyword">new</span>;</span><br><span class="line">    Emp emp1 = supper3.get();</span><br><span class="line">    emp1.setAddress(<span class="string">"上海"</span>);</span><br><span class="line">    <span class="comment">// 一个参数</span></span><br><span class="line">    Function&lt;String, Emp&gt; fun = address -&gt; <span class="keyword">new</span> Emp(address);</span><br><span class="line">    Function&lt;String, Emp&gt; fun1 = Emp::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(fun1.apply(<span class="string">"beijing"</span>));</span><br><span class="line">    <span class="comment">// 两个参数</span></span><br><span class="line">    BiFunction&lt;String, Integer, Emp&gt; bFun = (name, age) -&gt; <span class="keyword">new</span> Emp(name, age);</span><br><span class="line">    BiFunction&lt;String, Integer, Emp&gt; bFun1 = Emp::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(bFun1.apply(<span class="string">"xiaohong"</span>, <span class="number">18</span>));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String address, String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Emp [address="</span> + address + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后，特别要注意：</li></ul><p>①方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！</p><p>②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： <code>ClassName::MethodName</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java8-新特性-‘-’-关键字&quot;&gt;&lt;a href=&quot;#java8-新特性-‘-’-关键字&quot; class=&quot;headerlink&quot; title=&quot;java8-新特性-‘::’ 关键字&quot;&gt;&lt;/a&gt;java8-新特性-‘::’ 关键字&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Java 8&lt;/code&gt;中我们可以通过 &lt;code&gt;::&lt;/code&gt; 关键字来访问类的构造方法，对象方法，静态方法。&lt;/li&gt;
&lt;li&gt;方法的引用的语法，主要有三类:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.指向&lt;strong&gt;静态方法&lt;/strong&gt;的方法引用，例如&lt;code&gt;Integer&lt;/code&gt;的&lt;code&gt;parseInt&lt;/code&gt;方法 ，可以写成&lt;code&gt;Integer::parseInt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类：：静态方法名&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.指向任意类型实例方法的方法引用，例如&lt;code&gt;String&lt;/code&gt;的&lt;code&gt;length&lt;/code&gt;方法，写成&lt;code&gt;String::length&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类：：实例方法名&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.指向现有对象的实例方法的方法引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;对象：：实例方法名&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.构造器的引用：对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用&lt;code&gt;ClassName::new&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;java8&lt;/code&gt;中的函数式接口，提供了无参构造函数，以及有参构造函数创建实例的方式；构造器的参数列表，需要与函数式接口中参数列表保持一致！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法的引用让你可以重复使用现有的方法定义，并像lambda一样传递他们，在一些情况下，比起使用lambda表达式，它们似乎更易读，感觉也更自然；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java基础" scheme="http://zhuuu.work/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="lambda表达式" scheme="http://zhuuu.work/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="java8" scheme="http://zhuuu.work/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-04-统一异常处理</title>
    <link href="http://zhuuu.work/2021/08/05/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-03-SpringBoot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://zhuuu.work/2021/08/05/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-03-SpringBoot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2021-08-05T08:38:38.000Z</published>
    <updated>2021-08-06T12:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发笔记-03-SpringBoot统一异常处理"><a href="#开发笔记-03-SpringBoot统一异常处理" class="headerlink" title="开发笔记-03-SpringBoot统一异常处理"></a>开发笔记-03-SpringBoot统一异常处理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>官方文档：</strong> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestControllerAdvice.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestControllerAdvice.html</a></li></ul><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-05-122107.png" style="zoom:67%;" /><ul><li><p>在做前后端分离的项目时，后端通常都会拆分成多个独立的微服务，这时候就会涉及每个服务返回给前端的数据格式问题了。</p></li><li><p><strong>下面就来实现一个比较常用的数据格式，统一所有服务的返回值格式。</strong></p></li><li><p>一般返回的数据格式会包括4个部分</p><ul><li>第一部分：请求处理是否成功</li><li>第二部分：服务处理结果编码</li><li>第三部分：编码对应的文本信息</li><li>第四部分：返回值</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;result&quot;: true,</span><br><span class="line">    &quot;code&quot;: 1000,</span><br><span class="line">    &quot;message&quot;: &quot;SUCCESS&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;lantian&quot;: 17,</span><br><span class="line">        &quot;qingfen&quot;: 16,</span><br><span class="line">        &quot;baiyun&quot;: 18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于异常处理情况，我们也需要统一成上面的格式<code>:</code><ul><li>如果在<code>controller</code>中通过<code>try catch</code>来处理异常的话，会出现一个问题就是每个函数里都加一个<code>Try catch,</code>代码会变的很乱。<ul><li>这个全局异常拦截器的目的是要把异常转化为通用的<code>json</code>结构，给到前端，前端根据不同的状态码。做出不同的业务逻辑</li><li>举例子，后端给前端未登录，前端跳登录页面</li><li>后端给前端服务器异常，接口超时，前端重新调用，或者弹出提示给用户</li><li>测试就是手动抛出这样一个异常，然后能看到对应的一个异常展示</li></ul></li><li>下面我们就通过<code>spring boot</code>的注解来省略掉<code>controller</code>中的<code>try-catch</code>帮助我们来封装异常信息并返回给前端，这样用户也不会得到一些奇奇怪怪的错误提示。</li></ul></li></ul><a id="more"></a><h2 id="1-实战练习"><a href="#1-实战练习" class="headerlink" title="1. 实战练习"></a>1. 实战练习</h2><h3 id="1-1-定义返回值结构信息-get-set省略"><a href="#1-1-定义返回值结构信息-get-set省略" class="headerlink" title="1.1 定义返回值结构信息(get,set省略)"></a>1.1 定义返回值结构信息(get,set省略)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallResultMsg</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-定义返回值和对应的code信息（get-set省略）"><a href="#1-2-定义返回值和对应的code信息（get-set省略）" class="headerlink" title="1.2 定义返回值和对应的code信息（get,set省略）"></a>1.2 定义返回值和对应的code信息（get,set省略）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CodeAndMsg &#123;</span><br><span class="line">    SUCCESS(<span class="number">1000</span>, <span class="string">"SUCCESS"</span>),</span><br><span class="line">    METHODFAIL(<span class="number">2000</span>, <span class="string">"ENCOUNTER AN ERROR WHEN EXECUTE METHOD"</span>),</span><br><span class="line">    UNKNOWEXCEPTION(<span class="number">3000</span>, <span class="string">"THIS IS AN UNKNOW EXCEPTION"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    CodeAndMsg(<span class="keyword">int</span> code, String msg)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-自定义异常"><a href="#1-3-自定义异常" class="headerlink" title="1.3 自定义异常"></a>1.3 自定义异常</h3><ul><li>对于一些特别的异常，可以自定义<code>Exception</code>和<code>Error Code,</code>这里自定义一个异常（需要继承<code>RuntimeException</code>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefinedException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CodeAndMsg exception;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDefinedException</span><span class="params">(CodeAndMsg exception)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exception = exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CodeAndMsg <span class="title">getException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(CodeAndMsg exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exception = exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-RestControllerAdvice-捕获全局异常"><a href="#1-4-RestControllerAdvice-捕获全局异常" class="headerlink" title="1.4 @RestControllerAdvice 捕获全局异常"></a>1.4 @RestControllerAdvice 捕获全局异常</h3><ul><li><code>@RestControllerAdvice</code>都是对<code>Controller</code>进行增强的，可以全局捕获<code>spring mvc</code>抛的异常。</li><li><code>@ExceptionHandler(value = Exception.class)</code><ul><li><code>ExceptionHandler</code>的作用是用来捕获指定的异常。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span>(annotations = RestController<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UniformReponseHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.OK)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CallResultMsg <span class="title">sendSuccessResponse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallResultMsg(<span class="keyword">true</span>, CodeAndMsg.SUCCESS, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.OK)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CallResultMsg <span class="title">sendSuccessResponse</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallResultMsg(<span class="keyword">true</span>, CodeAndMsg.SUCCESS, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(UserDefinedException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">INTERNAL_SERVER_ERROR</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CallResultMsg</span> <span class="title">sendErrorResponse_UserDefined</span>(<span class="title">Exception</span> <span class="title">exception</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallResultMsg(<span class="keyword">false</span>, ((UserDefinedException)exception).getException(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">INTERNAL_SERVER_ERROR</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CallResultMsg</span> <span class="title">sendErrorResponse_System</span>(<span class="title">Exception</span> <span class="title">exception</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> UserDefinedException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sendErrorResponse_UserDefined(exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallResultMsg(<span class="keyword">false</span>, CodeAndMsg.UNKNOWEXCEPTION, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的一波操作，我们的<code>controller</code>中就不需要再去写大量的<code>try-catch</code>了</li><li><code>RestControllerAdvice</code>会自动帮助<code>catch</code>,并匹配相应的<code>ExceptionHandler</code>,然后重新封装异常信息，返回值，统一格式返回给前端。</li><li>当然也可以写成一个jar包，供其他微服务使用</li></ul><h3 id="1-5-ControllerAdvice-和-RestControllerAdvice的区别"><a href="#1-5-ControllerAdvice-和-RestControllerAdvice的区别" class="headerlink" title="1.5 ControllerAdvice 和 RestControllerAdvice的区别"></a>1.5 ControllerAdvice 和 RestControllerAdvice的区别</h3><ul><li><code>@ControllerAdvice</code> 和 <code>@RestControllerAdvice</code>都是对<code>Controller</code>进行增强的，可以全局捕获<code>spring mvc</code>抛的异常。</li><li><code>RestControllerAdvice = ControllerAdvice + ResponseBody</code></li></ul><h3 id="1-6-测试统一异常捕获功能"><a href="#1-6-测试统一异常捕获功能" class="headerlink" title="1.6 测试统一异常捕获功能"></a>1.6 测试统一异常捕获功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/doTestObject"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CallResultMsg <span class="title">testObjectReturn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"qingfen"</span>, <span class="number">16</span>);</span><br><span class="line">    map.put(<span class="string">"lantian"</span>, <span class="number">17</span>);</span><br><span class="line">    map.put(<span class="string">"baiyun"</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UniformReponseHandler&lt;Map&gt;().sendSuccessResponse(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/doTestException/&#123;x&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">testExceptionResturn</span><span class="params">(@PathVariable <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; x &amp;&amp; x &lt; <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UserDefinedException(CodeAndMsg.METHODFAIL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"result"</span>: <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"SUCCESS"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"lantian"</span>: <span class="number">17</span>,</span><br><span class="line">        <span class="string">"qingfen"</span>: <span class="number">16</span>,</span><br><span class="line">        <span class="string">"baiyun"</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"result"</span>: <span class="keyword">false</span>,</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">2000</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"ENCOUNTER AN ERROR WHEN EXECUTE METHOD "</span>,</span><br><span class="line">    <span class="string">"data"</span>: <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发笔记-03-SpringBoot统一异常处理&quot;&gt;&lt;a href=&quot;#开发笔记-03-SpringBoot统一异常处理&quot; class=&quot;headerlink&quot; title=&quot;开发笔记-03-SpringBoot统一异常处理&quot;&gt;&lt;/a&gt;开发笔记-03-SpringBoot统一异常处理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;官方文档：&lt;/strong&gt; &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestControllerAdvice.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestControllerAdvice.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-05-122107.png&quot; style=&quot;zoom:67%;&quot; /&gt;



&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在做前后端分离的项目时，后端通常都会拆分成多个独立的微服务，这时候就会涉及每个服务返回给前端的数据格式问题了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;下面就来实现一个比较常用的数据格式，统一所有服务的返回值格式。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一般返回的数据格式会包括4个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：请求处理是否成功&lt;/li&gt;
&lt;li&gt;第二部分：服务处理结果编码&lt;/li&gt;
&lt;li&gt;第三部分：编码对应的文本信息&lt;/li&gt;
&lt;li&gt;第四部分：返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;result&amp;quot;: true,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;code&amp;quot;: 1000,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;message&amp;quot;: &amp;quot;SUCCESS&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;data&amp;quot;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;lantian&amp;quot;: 17,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;qingfen&amp;quot;: 16,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;baiyun&amp;quot;: 18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;对于异常处理情况，我们也需要统一成上面的格式&lt;code&gt;:&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果在&lt;code&gt;controller&lt;/code&gt;中通过&lt;code&gt;try catch&lt;/code&gt;来处理异常的话，会出现一个问题就是每个函数里都加一个&lt;code&gt;Try catch,&lt;/code&gt;代码会变的很乱。&lt;ul&gt;
&lt;li&gt;这个全局异常拦截器的目的是要把异常转化为通用的&lt;code&gt;json&lt;/code&gt;结构，给到前端，前端根据不同的状态码。做出不同的业务逻辑&lt;/li&gt;
&lt;li&gt;举例子，后端给前端未登录，前端跳登录页面&lt;/li&gt;
&lt;li&gt;后端给前端服务器异常，接口超时，前端重新调用，或者弹出提示给用户&lt;/li&gt;
&lt;li&gt;测试就是手动抛出这样一个异常，然后能看到对应的一个异常展示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;下面我们就通过&lt;code&gt;spring boot&lt;/code&gt;的注解来省略掉&lt;code&gt;controller&lt;/code&gt;中的&lt;code&gt;try-catch&lt;/code&gt;帮助我们来封装异常信息并返回给前端，这样用户也不会得到一些奇奇怪怪的错误提示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="开发笔记" scheme="http://zhuuu.work/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-04-高并发慢查询</title>
    <link href="http://zhuuu.work/2021/08/05/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-04-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <id>http://zhuuu.work/2021/08/05/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-04-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%85%A2%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-08-05T08:38:38.000Z</published>
    <updated>2021-08-11T12:52:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发笔记-04-高并发慢查询"><a href="#开发笔记-04-高并发慢查询" class="headerlink" title="开发笔记-04-高并发慢查询"></a>开发笔记-04-高并发慢查询</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p><strong>慢查询是高并发之大忌</strong></p></li><li><p>博客转载：<a href="https://www.cnblogs.com/donlianli/p/11068095.html" target="_blank" rel="noopener">https://www.cnblogs.com/donlianli/p/11068095.html</a></p></li></ul><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><ul><li>最近又遇到了一次慢查把db（mariadb10)几乎打挂的案例，作为一个核心支付系统的技术负责人，真是每日如履薄冰。因为之前支付系统经常出问题，现在各个BG对支付系统都盯得很紧。这次要不是我及时让DB给暴力清理数据，没准又提一个P2故障；</li><li>抱怨归抱怨，事后复盘，一丝都不能马虎。首先，描述一下故障的全过程。起因是我们支付系统有一个异步队列，这个队列使用的一张mysql表存储，异步回调业务线的任务（姑且表名称叫task)，都会首先放这里。同时这个task表还有其他的异步任务，不同的任务使用task_type字段来进行区分。然后应用系统有一个定时任务，扫描这张表是否有待消费的任务，如果有，则会取出来进行消费；典型的生产者消费者模型；</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-11-124616.jpg" alt=""></p><a id="more"></a><p>这里的task说的再具体一点：</p><ul><li>1、所有的异步任务都在这张表，有支付成功通知业务线消息，有给结算系统推送支付信息的任务；</li><li>2、消费者在任务处理成功后，则会把任务从task表删除。所以这张表经常是空的；<ul><li>消费者根据不同的任务，调用不同的上游订单系统和结算系统。</li><li>出故障时，是因为推送支付信息的结算系统接口超时，出了问题，导致任务被积压到了task表。</li></ul></li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-11-124812.jpg" alt=""></p><ul><li><p>任务积压之后，消费者线程池很快就被积压的任务占满，导致应该通知BG订单支付成功的任务也被block住，进而影响到订单支付成功率。</p></li><li><p>消费者线程池隔离没有做到位，立刻找DBA将推送给结算系统的任务进行了备份并清理。并且嘱咐DBA定时清理推送结算任务的数据。这样才化解支付成功率继续下滑的趋势。</p></li><li><p>危机解除后，我们和DBA配合进一步排查问题，找出了事情的根本原因。</p><ul><li>原来是推送结算信息的逻辑中，有一个对task表的查询，而这个查询的sql，没有建索引。</li><li>这样当这类任务数量积压的比较多时，查询会越来越慢，慢查导致mysql堵塞。</li><li>堵塞导致消费者无法拉取任务，进而影响到其他通知BG的任务的消费；分析了一下日志，其实我们的程序查询数量当时3分钟大概查询了1万多次，可以说qps不多。但是问题出现在sql无法命中索引，把mysql的worker thread都用完了。给我们研发的感觉，mysql是如此的脆弱，2w多条数据，查询没有索引，几千个select,就能把它打挂。</li></ul></li><li><p>几乎类似的案例，一年前，我们也碰到过一次。当时支付系统有一个bug，用户每支付一次，都会把支付客史中一个月之前的数据都清理一下（1月1日，清12月1日之前的数据，2月1清理1月1日之前的数据）。</p><ul><li>这个bug藏的很深，这块代码也很少有业务需求，一直没有被发现。但是，是雷就会有爆炸的一天。3月1日凌晨，支付系统突然所有接口都挂了。DBA最终定位是删除支付客史的sql。</li><li>这个问题，我们研发一开始是不承认的，毕竟这个sql,在线上跑了2年多，一直没有出过问题。DBA说这个delete语句删3000w数据，而且在不断的请求,数据库当然扛不住，我们反驳说，这个客史表一共才3000w数据。</li><li>事后我们发现，DBA的描述有误，不是说删除3000w，而是这个delete语句没有走索引，每次要扫描3000w数据。这样才能解释通，也就是说，这个delete进行了全表扫描。</li><li>而实际上，这个delete是按照时间删除的，并且时间字段是有单列索引的，但是为什么这个delete没有走索引呢？我们最后猜测，可能是因为2月份天数太少导致。以前，可能数据比较少，每次删一天，或者2天的数据，mysql可能会走索引。</li><li>但是3月1日比较特殊，因2月28日删的是1月28日一天的数据，3月1日却要删除1月29,30,31三天的数据，mysql可能认为删除这么多数据，没有必要走索引了。</li></ul></li></ul><h2 id="2-如何解决？"><a href="#2-如何解决？" class="headerlink" title="2. 如何解决？"></a>2. 如何解决？</h2><p>遇到类似问题如何解决？</p><p>1、读写分离。</p><p>2、提前消灭慢查询；</p><p>3、对异步任务做好线程隔离；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发笔记-04-高并发慢查询&quot;&gt;&lt;a href=&quot;#开发笔记-04-高并发慢查询&quot; class=&quot;headerlink&quot; title=&quot;开发笔记-04-高并发慢查询&quot;&gt;&lt;/a&gt;开发笔记-04-高并发慢查询&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;慢查询是高并发之大忌&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博客转载：&lt;a href=&quot;https://www.cnblogs.com/donlianli/p/11068095.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/donlianli/p/11068095.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述&quot;&gt;&lt;/a&gt;1. 问题描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最近又遇到了一次慢查把db（mariadb10)几乎打挂的案例，作为一个核心支付系统的技术负责人，真是每日如履薄冰。因为之前支付系统经常出问题，现在各个BG对支付系统都盯得很紧。这次要不是我及时让DB给暴力清理数据，没准又提一个P2故障；&lt;/li&gt;
&lt;li&gt;抱怨归抱怨，事后复盘，一丝都不能马虎。首先，描述一下故障的全过程。起因是我们支付系统有一个异步队列，这个队列使用的一张mysql表存储，异步回调业务线的任务（姑且表名称叫task)，都会首先放这里。同时这个task表还有其他的异步任务，不同的任务使用task_type字段来进行区分。然后应用系统有一个定时任务，扫描这张表是否有待消费的任务，如果有，则会取出来进行消费；典型的生产者消费者模型；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-11-124616.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="开发笔记" scheme="http://zhuuu.work/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-02-cola4.0</title>
    <link href="http://zhuuu.work/2021/08/02/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-02-cola4.0/"/>
    <id>http://zhuuu.work/2021/08/02/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-02-cola4.0/</id>
    <published>2021-08-02T11:38:38.000Z</published>
    <updated>2021-08-16T13:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发笔记-02-cola4-0"><a href="#开发笔记-02-cola4-0" class="headerlink" title="开发笔记-02-cola4.0"></a>开发笔记-02-cola4.0</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>COLA</code>的主要目的是为应用架构提供一套简单的可以复制、可以理解、可以落地、可以控制复杂性的”指导和约束”。</li><li>同样，好的应用架构，也遵循一些共同模式，都提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。</li><li>应用架构的本质，就是要从繁杂的业务系统中提炼出共性，找到解决业务问题的最佳共同模式，为开发人员提供统一的认知，治理混乱。帮助应用系统“从混乱到有序”</li><li><strong>COLA架构就是为此而生，其核心职责就是定义良好的应用结构，提供最佳实践</strong>。</li></ul><p><strong>开源项目地址 ：</strong> <a href="https://github.com/alibaba/COLA" target="_blank" rel="noopener">https://github.com/alibaba/COLA</a></p><h2 id="1-Cola-分层架构"><a href="#1-Cola-分层架构" class="headerlink" title="1. Cola 分层架构"></a>1. Cola 分层架构</h2><ul><li>所有的复杂系统都会呈现出层级结构，应用系统处理复杂业务逻辑也应该是分层的，下层对上层屏蔽处理细节，每一层各司其职，分离关注点。</li><li>对于一个典型的业务应用系统来说，COLA会做如下层次定义，每一层都有明确的职责定义</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-02-102957.jpg" alt=""></p><a id="more"></a><ul><li><p>适配层（<code>Adapter Layer</code>）：负责对前端展示（<code>web，wireless，wap</code>）的路由和适配，对于传统<code>B/S</code>系统而言，<code>adapter</code>就相当于<code>MVC中的controller</code>；</p></li><li><p>应用层（<code>Application Layer</code>）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层；</p></li><li><p>领域层（<code>Domain Layer</code>）：主要是封装了核心业务逻辑，并通过领域服务（<code>Domain Service</code>）和领域对象（<code>Domain Entity</code>）的方法对App层提供<strong>业务实体和业务逻辑计算</strong>。</p><ul><li><strong>领域是应用的核心，不依赖任何其他层次；</strong></li></ul></li><li><p>基础实施层（<code>Infrastructure Layer</code>）：主要负责技术细节问题的处理，<strong>比如数据库的<code>CRUD</code>、搜索引擎、文件系统、分布式服务的<code>RPC</code>等</strong>。此外，领域防腐的重任也落在这里，外部依赖需要通过<code>gateway</code>的转义处理，才能被上面的<code>App</code>层和<code>Domain</code>层使用。</p></li></ul><h2 id="2-Cola-包结构"><a href="#2-Cola-包结构" class="headerlink" title="2. Cola 包结构"></a>2. Cola 包结构</h2><ul><li>分层是属于大粒度的职责划分，太粗，有必要往下再<code>down</code>一层，细化到包结构的粒度，才能更好的指导我们的工作。</li><li>还是拿一堆玩具举例子，分层类似于拿来了一个架子，分包类似于在每一层架子上又放置了多个收纳盒。所谓的内聚，就是把功能类似的玩具放在一个盒子里，这样可以让应用结构清晰，极大的降低系统的认知成本和维护成本。</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-02-104658.jpg" alt=""></p><ul><li>那么，对于一个后端应用来说，应该需要哪些收纳盒呢？<ul><li>基本上每一次COLA的迭代都会涉及到包结构的调整，迭代到现在，才算基本稳定下来。 </li></ul></li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-02-104801.jpg" alt=""></p><ul><li><strong>各个包结构的简要功能描述，如下表所示：</strong></li></ul><table><thead><tr><th>层次</th><th>包名</th><th>功能</th><th>必选</th></tr></thead><tbody><tr><td>Adapter层</td><td>web</td><td>处理页面请求的Controller</td><td>否</td></tr><tr><td>Adapter层</td><td>wireless</td><td>处理无线端的适配</td><td>否</td></tr><tr><td>Adapter层</td><td>wap</td><td>处理wap端的适配</td><td>否</td></tr><tr><td>App层</td><td>executor</td><td>处理request，包括command和query</td><td>是</td></tr><tr><td>App层</td><td>consumer</td><td>处理外部message</td><td>否</td></tr><tr><td>App层</td><td>scheduler</td><td>处理定时任务</td><td>否</td></tr><tr><td>Domain层</td><td>model</td><td>领域模型</td><td>否</td></tr><tr><td>Domain层</td><td>ability</td><td>领域能力，包括DomainService</td><td>否</td></tr><tr><td>Domain层</td><td>gateway</td><td>领域网关，解耦利器</td><td>是</td></tr><tr><td>Infra层</td><td>gatewayimpl</td><td>网关实现</td><td>是</td></tr><tr><td>Infra层</td><td>mapper</td><td>ibatis数据库映射</td><td>否</td></tr><tr><td>Infra层</td><td>config</td><td>配置信息</td><td>否</td></tr><tr><td>Client SDK</td><td>api</td><td>服务对外透出的API</td><td>是</td></tr><tr><td>Client SDK</td><td>dto</td><td>服务对外的DTO</td><td>是</td></tr></tbody></table><ul><li>为什么<code>Domain</code>的<code>model</code>是可选的？因为<code>COLA</code>是应用架构，不是<code>DDD</code>架构。</li><li>在工作中，领域模型要怎么设计，<strong>原则是 ：无有必要勿增实体</strong>。</li><li>领域模型对设计能力要求很高，没把握用好，一个错误的抽象还不如不抽象，宁可不要用，也不要滥用，不要为了<code>DDD</code>而<code>DDD</code>。<ul><li>模型虽然可选，但<code>DDD</code>的思想是一定要去学习和贯彻的，特别是统一语言、边界上下文、防腐层的思想，值得深入学习，仔细体会。实际上，<code>COLA</code>里面的很多设计思想都来自于DDD。其中就包括<strong>领域包的设计</strong>。</li></ul></li></ul><hr><ul><li>为了兼顾领域维度的内聚性，有必要对包结构进行一下微调，即顶层包结构应该是按照领域划分，让领域内聚。<ul><li>综合考虑功能和领域两个维度包结构定义。按照领域和功能两个维度分包策略，最后呈现出来的，是如下图所示的顶层包节点是领域名称，领域之下，再按功能划分包结构。</li></ul></li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-02-124844.jpg" alt=""></p><ul><li>例如，在刚刚上线的一个云店铺（<code>cloudstore</code>）项目中，按照COLA的分包策略,在每一个<code>module</code>下面首先按照领域做一个顶层划分，然后在领域内，再按照功能进行分包。</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-02-125207.jpg" alt=""></p><h2 id="3-Cola-解耦思想"><a href="#3-Cola-解耦思想" class="headerlink" title="3. Cola 解耦思想"></a>3. Cola 解耦思想</h2><ul><li><strong>“高内聚，低耦合”</strong> 这句话，工作的越久，就越会觉得其有道理。</li><li><strong>所谓耦合就是联系的紧密程度，只要有依赖就会有耦合，不管是进程内的依赖，还是跨进程的RPC依赖，都会产生耦合</strong>。<ul><li>依赖不可消除，同样，耦合也不可避免。我们所能做的不是消除耦合，而是把耦合降低到可以接受的程度。在软件设计中，有大量的设计模式，设计原则都是为了解耦这一目的。</li></ul></li><li>在<code>DDD</code>中有一个很棒的解耦设计思想——防腐层<code>（Anti-Corruption）</code><ul><li>简单说，就是应用不要直接依赖外域的信息，要把外域的信息转换成自己领域上下文（<code>Context</code>）的实体再去使用，从而实现本域和外部依赖的解耦。</li><li>在<code>COLA</code>中，把防腐层这个概念进行了泛化，将数据库、搜索引擎等数据存储都列为外部依赖的范畴。<strong>利用依赖倒置，统一使用gateway来实现业务领域和外部依赖的解耦</strong>。</li><li>DDD 带来最大的改变是让我们得以从“数据驱动”转向”领域驱动“，让我们知道领域是应用的核心，其他都是技术的细节，随时可以被替换。</li></ul></li><li>其实现方式如下图所示，主要是在<code>Domain</code>层定义<code>Gateway</code>接口，然后在<code>Infrastructure</code>提供<code>Gateway</code>接口的实现。</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-02-132355.jpg" alt=""></p><p><strong>举个例子：</strong></p><ul><li><p>假如有一个电商系统，对于下单这个操作，它需要联动订单服务、商品服务、库存服务、营销服务等多个系统才能完成。</p><ul><li>那么在订单域，该如何获取商品和库存信息呢？最直接的方式，无外乎就是<code>RPC</code>调用商品和库存服务，拿到<code>DTO</code>直接使用就完了。</li><li>然而，商品域吐出的是一个大而全的<code>DTO</code>（可能包含几十个字段），而在下单这个阶段，订单所需要的可能只是其中几个字段而已。</li><li>更合适的做法，应该是在订单域中，使用<code>gateway</code>对商品域和库存域的依赖进行解耦。</li></ul></li><li><p>这样做有两个好处，一个是降低了对外域信息依赖的耦合；另一个是通过上下文映射<code>（Context mapping）</code>，确保本领域边界上下文（<code>Bounded context）</code>下领域知识的完整性，实现了统一语言<code>（Ubiquitous language）</code>。</p></li></ul><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-03-065013.jpg" style="zoom:67%;" /><h2 id="4-Cola-组件"><a href="#4-Cola-组件" class="headerlink" title="4. Cola 组件"></a>4. Cola 组件</h2><ul><li><p>以上就是COLA架构的核心内容了。然而这么多<code>module</code>，这么多package，如果要手动去创建的话，是非常繁琐和费时的。为了能够快速创建满足COLA架构的应用，阿里有两个现成的<code>cola Maven</code>工程</p><ul><li>一个是用来创建纯后端服务的<code>archetype</code>：<code>cola-archetype-service</code></li><li>一个是用来创建adapter和后端服务一体的web应用<code>archetype：cola-archetype-web</code></li></ul></li><li><p>另外，也可以使用阿里云的<a href="https://start.aliyun.com/bootstrap.html" target="_blank" rel="noopener">应用生成器</a>去生成一个COLA应用，只是那边的版本没有同步更新，可能会老旧一点。</p></li></ul><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-03-065456.png" style="zoom:67%;" /><hr><ul><li>COLA除了架构之外，还提供了一些框架级别的功能，比如拦截器功能，扩展点功能等。<ul><li><strong>可以单纯的使用COLA架构，而不使用任何COLA组件提供的功能也是完全没问题的</strong>。</li></ul></li><li>为了方便管理，以及更清晰的把架构和框架区分开来。<ul><li>在此次COLA 4.0的升级中，功能组件全部收拢到了<code>cola-components</code>下面。</li></ul></li></ul><table><thead><tr><th>组件名称</th><th>功能</th><th>版本</th><th>依赖</th></tr></thead><tbody><tr><td>cola-component-dto</td><td>定义了DTO格式，包括分页</td><td>1.0.0</td><td>无</td></tr><tr><td>cola-component-exception</td><td>定义了异常格式， 主要有BizException和SysException</td><td>1.0.0</td><td>无</td></tr><tr><td>cola-component-statemachine</td><td>状态机组件</td><td>1.0.0</td><td>无</td></tr><tr><td>cola-component-domain-starter</td><td>Spring托管的领域实体组件</td><td>1.0.0</td><td>无</td></tr><tr><td>cola-component-catchlog-starter</td><td>异常处理和日志组件</td><td>1.0.0</td><td>exception ,dto组件</td></tr><tr><td>cola-component-extension-starter</td><td>扩展点组件</td><td>1.0.0</td><td>无</td></tr><tr><td>cola-component-test-container</td><td>测试容器组件</td><td>1.0.0</td><td>无</td></tr></tbody></table><h2 id="5-如何使用-cola"><a href="#5-如何使用-cola" class="headerlink" title="5. 如何使用 cola"></a>5. 如何使用 cola</h2><ol><li><strong>安装 cola archetype</strong></li></ol><ul><li>下载<code>cola-archetypes</code>下的源码到本地，然后本地运行<code>mvn install</code>安装。</li></ul><ol start="2"><li><strong>安装 cola components</strong></li></ol><ul><li>下载<code>cola-components</code>下的源码到本地，然后本地运行<code>mvn install</code>安装。</li></ul><p><strong>3. 创建应用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId&#x3D;com.alibaba.demo -DartifactId&#x3D;demoWeb -Dversion&#x3D;1.0.0-SNAPSHOT -Dpackage&#x3D;com.alibaba.demo -DarchetypeArtifactId&#x3D;cola-framework-archetype-web -DarchetypeGroupId&#x3D;com.alibaba.cola -DarchetypeVersion&#x3D;4.0.0</span><br></pre></td></tr></table></figure><p><strong>4.运行应用</strong></p><ul><li>首先在<code>demoWeb</code>目录下运行<code>mvn install</code>（如果不想运行测试，可以加上<code>-DskipTests</code>参数）。然后进入start目录，执行<code>mvn spring-boot:run</code></li><li>运行成功的话，可以看到<code>SpringBoot</code>启动成功的界面。</li></ul><p><strong>项目结构：</strong></p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-03-064537.jpg" alt=""></p><p><strong>5.生成的应用中，已经实现了一个简单的Rest请求，可以在浏览器中输入</strong> </p><ul><li><a href="http://localhost:8080/helloworld" target="_blank" rel="noopener">http://localhost:8080/helloworld</a> 进行测试。</li></ul><p><strong>附录：</strong></p><ul><li>COLA 开源地址： <a href="https://github.com/alibaba/COLA" target="_blank" rel="noopener">https://github.com/alibaba/COLA</a></li></ul><h2 id="6-Cola-4-0"><a href="#6-Cola-4-0" class="headerlink" title="6. Cola 4.0"></a>6. Cola 4.0</h2><ul><li><code>COLA</code>会被分成<code>COLA</code>架构和<code>COLA</code>组件两个部分：<ul><li>COLA架构：关注应用架构的定义和构建，提升应用质量。</li><li>COLA组件：提供应用开发所需要的可复用组件，提升研发效率。</li></ul></li></ul><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-03-024332.jpg" style="zoom:67%;" /><p>参考博客： <a href="https://blog.csdn.net/significantfrank/article/details/110934799" target="_blank" rel="noopener">https://blog.csdn.net/significantfrank/article/details/110934799</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发笔记-02-cola4-0&quot;&gt;&lt;a href=&quot;#开发笔记-02-cola4-0&quot; class=&quot;headerlink&quot; title=&quot;开发笔记-02-cola4.0&quot;&gt;&lt;/a&gt;开发笔记-02-cola4.0&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;COLA&lt;/code&gt;的主要目的是为应用架构提供一套简单的可以复制、可以理解、可以落地、可以控制复杂性的”指导和约束”。&lt;/li&gt;
&lt;li&gt;同样，好的应用架构，也遵循一些共同模式，都提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。&lt;/li&gt;
&lt;li&gt;应用架构的本质，就是要从繁杂的业务系统中提炼出共性，找到解决业务问题的最佳共同模式，为开发人员提供统一的认知，治理混乱。帮助应用系统“从混乱到有序”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;COLA架构就是为此而生，其核心职责就是定义良好的应用结构，提供最佳实践&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源项目地址 ：&lt;/strong&gt; &lt;a href=&quot;https://github.com/alibaba/COLA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alibaba/COLA&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Cola-分层架构&quot;&gt;&lt;a href=&quot;#1-Cola-分层架构&quot; class=&quot;headerlink&quot; title=&quot;1. Cola 分层架构&quot;&gt;&lt;/a&gt;1. Cola 分层架构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;所有的复杂系统都会呈现出层级结构，应用系统处理复杂业务逻辑也应该是分层的，下层对上层屏蔽处理细节，每一层各司其职，分离关注点。&lt;/li&gt;
&lt;li&gt;对于一个典型的业务应用系统来说，COLA会做如下层次定义，每一层都有明确的职责定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-08-02-102957.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="开发笔记" scheme="http://zhuuu.work/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="cola" scheme="http://zhuuu.work/tags/cola/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-01-sdk/api</title>
    <link href="http://zhuuu.work/2021/08/02/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-01-sdk_api/"/>
    <id>http://zhuuu.work/2021/08/02/deploy_learn/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-01-sdk_api/</id>
    <published>2021-08-02T09:38:38.000Z</published>
    <updated>2021-08-05T07:43:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发笔记-01-sdk-api"><a href="#开发笔记-01-sdk-api" class="headerlink" title="开发笔记-01-sdk/api"></a>开发笔记-01-sdk/api</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本系列笔记用于记录刚入职，开发过程中遇到的问题</li><li>本系列持续更新</li></ul><h2 id="1-api"><a href="#1-api" class="headerlink" title="1. api"></a>1. api</h2><ol><li><strong>api</strong></li></ol><ul><li>研发人员A开发了软件A，研发人员B正在研发软件B。</li><li>有一天，研发人员B想要调用软件A的部分功能来用，但是他又不想从头看一遍软件A的源码和功能实现过程，怎么办呢？</li><li>研发人员A想了一个好主意：<strong>我把软件A里你需要的功能打包好，写成一个函数。你按照我说的流程，把这个函数放在软件B里，就能直接用我的功能了！</strong></li></ul><p><img src="https://pic1.zhimg.com/80/v2-4160a3b3d7361a1d75fa0174f8e3e83e_1440w.jpg?source=1940ef5c" alt="img"></p><ul><li>其中，API就是研发人员A说的那个函数。</li></ul><h2 id="2-sdk"><a href="#2-sdk" class="headerlink" title="2. sdk"></a>2. sdk</h2><ul><li><code>SDK</code> 就是 <code>Software Development Kit</code> 的缩写，翻译过来——软件开发工具包。这是一个覆盖面相当广泛的名词，可以这么说：辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK。SDK被开发出来是为了减少程序员工作量的。</li><li>有公司开发出某种软件的某一功能，把它封装成SDK（比如数据分析SDK就是能够实现数据分析功能的SDK），出售给其他公司做开发用，其他公司如果想要给软件开发出某种功能，但又不想从头开始搞开发，直接付钱省事。</li></ul><a id="more"></a><h2 id="3-api-sdk-关系"><a href="#3-api-sdk-关系" class="headerlink" title="3. api/sdk 关系"></a>3. api/sdk 关系</h2><p><strong>最后，贴近生活讲讲两者的关系：</strong></p><ul><li><p>有一杯密封饮料，它的名字叫做“SDK”。</p></li><li><p>饮料上插着吸管，吸管的名字叫“API”。</p></li><li><p>把你叫做“XX系统”。</p></li><li><p>如果你想喝到SDK里的饮料（让系统拥有SDK中的功能），你必须通过API这根吸管来实现（通过API连接你的系统和SDK工具包），否则你就喝不到饮料。</p></li></ul><p><strong>现在可以谈谈API和SDK的区别了。</strong></p><ul><li><strong>总的来说，两者没有值得比较的区别，因为是具有关联性的两种东西。</strong></li><li><strong>可以把SDK想象成一个虚拟的程序包，在这个程序包中有一份做好的软件功能，这份程序包几乎是全封闭的，只有一个小小接口可以联通外界，这个接口就是API。</strong></li></ul><p><strong>举例：</strong></p><ul><li><strong>现在要在企业ERP系统中增加某个功能（比如自动备份、数据分析、云存储等），但又不想耗费大量时间、也没那么多研发亲自去做这个功能。这时我们可以选择使用这个“SDK”软件包，把ERP系统连接上API接口，就可以使用SDK软件包里的功能。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发笔记-01-sdk-api&quot;&gt;&lt;a href=&quot;#开发笔记-01-sdk-api&quot; class=&quot;headerlink&quot; title=&quot;开发笔记-01-sdk/api&quot;&gt;&lt;/a&gt;开发笔记-01-sdk/api&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本系列笔记用于记录刚入职，开发过程中遇到的问题&lt;/li&gt;
&lt;li&gt;本系列持续更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-api&quot;&gt;&lt;a href=&quot;#1-api&quot; class=&quot;headerlink&quot; title=&quot;1. api&quot;&gt;&lt;/a&gt;1. api&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;api&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;研发人员A开发了软件A，研发人员B正在研发软件B。&lt;/li&gt;
&lt;li&gt;有一天，研发人员B想要调用软件A的部分功能来用，但是他又不想从头看一遍软件A的源码和功能实现过程，怎么办呢？&lt;/li&gt;
&lt;li&gt;研发人员A想了一个好主意：&lt;strong&gt;我把软件A里你需要的功能打包好，写成一个函数。你按照我说的流程，把这个函数放在软件B里，就能直接用我的功能了！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-4160a3b3d7361a1d75fa0174f8e3e83e_1440w.jpg?source=1940ef5c&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中，API就是研发人员A说的那个函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-sdk&quot;&gt;&lt;a href=&quot;#2-sdk&quot; class=&quot;headerlink&quot; title=&quot;2. sdk&quot;&gt;&lt;/a&gt;2. sdk&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SDK&lt;/code&gt; 就是 &lt;code&gt;Software Development Kit&lt;/code&gt; 的缩写，翻译过来——软件开发工具包。这是一个覆盖面相当广泛的名词，可以这么说：辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK。SDK被开发出来是为了减少程序员工作量的。&lt;/li&gt;
&lt;li&gt;有公司开发出某种软件的某一功能，把它封装成SDK（比如数据分析SDK就是能够实现数据分析功能的SDK），出售给其他公司做开发用，其他公司如果想要给软件开发出某种功能，但又不想从头开始搞开发，直接付钱省事。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="开发笔记" scheme="http://zhuuu.work/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="api" scheme="http://zhuuu.work/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>rpc-02-grpc</title>
    <link href="http://zhuuu.work/2021/07/28/rpc/rpc-02-grpc/"/>
    <id>http://zhuuu.work/2021/07/28/rpc/rpc-02-grpc/</id>
    <published>2021-07-28T09:38:38.000Z</published>
    <updated>2021-08-04T08:05:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rpc-02-grpc"><a href="#rpc-02-grpc" class="headerlink" title="rpc-02-grpc"></a>rpc-02-grpc</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsvsj6enmzj30f108e74w.jpg" alt=""></p><p>业界主流的 RPC 框架整体上分为三类：</p><ul><li>支持多语言的 RPC 框架，比较成熟的有 <strong>Google 的 gRPC</strong>、<strong>Apache（Facebook）的 Thrift；</strong></li><li>只支持特定语言的 RPC 框架，例如新浪微博的 Motan；</li><li>支持服务治理等服务化特性的分布式服务框架，其底层内核仍然是 RPC 框架, 例如阿里的 Dubbo。</li></ul><a id="more"></a><h2 id="1-grpc-简介"><a href="#1-grpc-简介" class="headerlink" title="1. grpc 简介"></a>1. grpc 简介</h2><ul><li>gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端，<strong>基于 HTTP/2 设计。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">特点</span><br><span class="line"></span><br><span class="line">1. 语言中立，支持多种语言；</span><br><span class="line">2. 基于 IDL 文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub；</span><br><span class="line">3. 通信协议基于标准的 HTTP&#x2F;2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量；</span><br><span class="line">4. 序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能序列化框架，基于 HTTP&#x2F;2 + PB, 保障了 RPC 调用的高性能。</span><br></pre></td></tr></table></figure><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-07-29-072001.jpg" style="zoom:67%;" /><ul><li>但是，通常我们<strong>不会去单独使用gRPC</strong>，而是将gRPC作为一个部件进行使用<ul><li>这是因为在生产环境，我们面对大并发的情况下，需要使用分布式系统来去处理，而gRPC并没有提供分布式系统相关的一些必要组件。</li><li>而且，<strong>真正的线上服务还需要提供包括负载均衡，限流熔断，监控报警，服务注册和发现等等必要的组件。</strong>不过，这就不属于本篇文章讨论的主题了，我们还是先继续看下如何使用gRPC。</li></ul></li></ul><h2 id="2-gRpc-原理分析"><a href="#2-gRpc-原理分析" class="headerlink" title="2. gRpc 原理分析"></a>2. gRpc 原理分析</h2><ul><li>参考博客 ： <a href="https://www.jianshu.com/p/9e57da13b737" target="_blank" rel="noopener">https://www.jianshu.com/p/9e57da13b737</a></li></ul><h3 id="2-1-服务端创建流程"><a href="#2-1-服务端创建流程" class="headerlink" title="2.1 服务端创建流程"></a>2.1 服务端创建流程</h3><ul><li><p>gRPC 服务端创建采用 Build 模式，对底层服务绑定、<code>transportServer</code> 和<code>NettyServer</code> s的创建和实例化做了封装和屏蔽，让服务调用者不用关心 RPC 调用细节，整体上分为三个过程：</p><ul><li><p>创建 <code>Netty HTTP/2</code> s服务端；</p></li><li><p>将需要调用的服务端接口实现类注册到内部的 <code>Registry</code>  中，RPC 调用时，可以根据 RPC 请求消息中的服务定义信息查询到服务接口实现类；</p></li><li><p>创建 <code>gRPC Server</code> ，它是 gRPC 服务端的抽象，聚合了各种 Listener，用于 RPC 消息的统一调度和处理。</p></li></ul></li></ul><ul><li><p><strong>gRPC 服务端关键创建流程分析：</strong></p><ul><li><p>NettyServer 实例创建：gRPC 服务端创建，<strong>首先需要初始化 NettyServer，它是 gRPC 基于 Netty 4.1 HTTP/2 协议栈之上封装的 HTTP/2 服务端。</strong>NettyServer 实例由 NettyServerBuilder 的 buildTransportServer 方法构建，NettyServer 构建完成之后，监听指定的 Socket 地址，即可实现基于 HTTP/2 协议的请求消息接入。</p></li><li><p>绑定 IDL 定义的服务接口实现类：<strong>gRPC 与其它一些 RPC 框架的差异点是服务接口实现类的调用并不是通过动态代理和反射机制，而是通过 proto 工具生成代码，</strong>在服务端启动时，将服务接口实现类实例注册到 gRPC 内部的服务注册中心上。请求消息接入之后，可以根据服务名和方法名，直接调用启动时注册的服务实例，而不需要通过反射的方式进行调用，性能更优。</p></li><li><p>gRPC 服务实例（<code>ServerImpl</code> ）构建：<code>ServerImpl</code> 负责整个 gRPC 服务端消息的调度和处理，创建<code>ServerImpl</code>实例过程中，会对服务端依赖的对象进行初始化，例如 Netty 的线程池资源、gRPC 的线程池、内部的服务注册类<code>（InternalHandlerRegistry）</code>等，</p><ul><li>ServerImpl 初始化完成之后，就可以调用 <code>NettyServer</code>的 start 方法启动 <code>HTTP/2</code> s服务端，接收 gRPC 客户端的服务调用请求</li></ul></li></ul></li></ul><ul><li><strong>服务端的调用流程</strong><ul><li>gRPC 的客户端请求消息由 <code>Netty Http2ConnectionHandler</code>接入，<strong>由 gRPC 负责将 PB 消息（或者 JSON）反序列化为 POJO 对象</strong>，然后通过服务定义查询到该消息对应的接口实例，发起本地 Java 接口调用，调用完成之后，将响应消息反序列化为 PB（或者 JSON），通过 HTTP2 Frame 发送给客户端。</li><li>整个 service 调用可以划分为如下四个过程：<ul><li>gRPC 请求消息接入；</li><li>gRPC 消息头和消息体处理；</li><li>内部的服务路由和调用；</li><li>响应消息发送。</li></ul></li></ul></li></ul><ol><li><strong>gRPC 请求消息接入；</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gRPC 的请求消息由 Netty HTTP&#x2F;2 协议栈接入，通过 gRPC 注册的 Http2FrameListener，将解码成功之后的 HTTP Header 和 HTTP Body 发送到 gRPC 的 NettyServerHandler 中，实现基于 HTTP&#x2F;2 的 RPC 请求消息接入。</span><br><span class="line"></span><br><span class="line">gRPC 请求消息接入流程如下：</span><br><span class="line">关键流程解读如下：</span><br><span class="line">Netty 4.1 提供了 HTTP&#x2F;2 底层协议栈，通过 Http2ConnectionHandler 及其依赖的其它类库，实现了 HTTP&#x2F;2 消息的统一接入和处理。通过注册 Http2FrameListener 监听器，可以回调接收 HTTP2 协议的消息头、消息体、优先级、Ping、SETTINGS 等。gRPC 通过 FrameListener 重载 Http2FrameListener 的 onDataRead、onHeadersRead 等方法，将 Netty 的 HTTP&#x2F;2 消息转发到 gRPC 的 NettyServerHandler 中。</span><br><span class="line">Netty 的 HTTP&#x2F;2 协议接入仍然是通过 ChannelHandler 的 CodeC 机制实现，它并不影响 NIO 线程模型。</span><br><span class="line">因此，理论上各种协议、以及同一个协议的多个服务端实例可以共用同一个 NIO 线程池（NioEventLoopGroup）.也可以独占。</span><br><span class="line">在实践中独占模式普遍会存在线程资源占用过载问题，很容易出现句柄等资源泄漏。在 gRPC 中，为了避免该问题，默认采用共享池模式创建 NioEventLoopGroup，所有的 gRPC 服务端实例，都统一从 SharedResourceHolder 分配 NioEventLoopGroup 资源，实现 NioEventLoopGroup 的共享。</span><br></pre></td></tr></table></figure><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-07-29-094429.jpg" style="zoom:67%;" /><ol start="2"><li><strong>gRPC 消息头和消息体处理；</strong></li></ol><p><strong>gRPC 消息头</strong>的处理入口是 NettyServerHandler 的 onHeadersRead()，处理流程如下所示：</p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-07-29-094637.jpg" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对 HTTP Header 的 Content-Type 校验，此处必须是 “application&#x2F;grpc”；</span><br><span class="line">从 HTTP Header 的 URL 中提取接口和方法名，以 HelloWorldServer 为例，它的 method 为：”helloworld.Greeter&#x2F;SayHello”；</span><br><span class="line">将 Netty 的 HTTP Header 转换成 gRPC 内部的 Metadata，Metadata 内部维护了一个键值对的二维数组 namesAndValues，以及一系列的类型转换方法：</span><br><span class="line">创建 NettyServerStream 对象，它持有了 Sink 和 TransportState 类，负责将消息封装成 GrpcFrameCommand，与底层 Netty 进行交互，实现协议消息的处理；</span><br><span class="line">创建 NettyServerStream 之后，会触发 ServerTransportListener 的 streamCreated 方法，在该方法中，主要完成了消息上下文和 gRPC 业务监听器的创建；</span><br><span class="line">gRPC 上下文创建：CancellableContext 创建之后，支持超时取消，如果 gRPC 客户端请求消息在 Http Header 中携带了“grpc-timeout”，系统在创建 CancellableContext 的同时会启动一个延时定时任务，延时周期为超时时间，一旦该定时器成功执行，就会调用 CancellableContext.CancellationListener 的 cancel 方法，发送 CancelServerStreamCommand 指令；</span><br><span class="line">JumpToApplicationThreadServerStreamListener 的创建：它是 ServerImpl 的内部类，从命名上基本可以看出它的用途，即从 ServerStream 跳转到应用线程中进行服务调用，gRPC 服务端的接口调用主要通过 JumpToApplicationThreadServerStreamListener 的 messageRead 和 halfClosed 方法完成；</span><br><span class="line">将 NettyServerStream 的 TransportState 缓存到 Netty 的 Http2Stream 中，当处理请求消息体时，可以根据 streamId 获取到 Http2Stream，进而根据“streamKey”还原 NettyServerStream 的 TransportState，进行后续处理。</span><br></pre></td></tr></table></figure><p><strong>gRPC 消息体</strong>的处理入口是 NettyServerHandler 的 onDataRead()，处理流程如下所示：</p><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-07-29-094802.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息体处理比较简单，下面就关键技术点进行讲解：</span><br><span class="line"></span><br><span class="line">因为 Netty HTTP&#x2F;2 协议 Http2FrameListener 分别提供了 onDataRead 和 onHeadersRead 回调方法，所以 gRPC NettyServerHandler 在处理完消息头之后需要缓存上下文，以便后续处理消息体时使用；</span><br><span class="line">onDataRead 和 onHeadersRead 方法都是由 Netty 的 NIO 线程负责调度，但是在执行 onDataRead 的过程中发生了线程切换，如下所示（ServerTransportListenerImpl 类）：</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>内部的服务路由和调用</strong></li></ol><p>主要包括如下几个步骤：</p><ul><li>将请求消息体反序列为 Java 的 POJO 对象，即 IDL 中定义的请求参数对象；</li><li>根据请求消息头中的方法名到注册中心查询到对应的服务定义信息；</li><li>通过 Java 本地接口调用方式，调用服务端启动时注册的 IDL 接口实现类。</li></ul><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-07-29-094929.jpg" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">中间的交互流程比较复杂，涉及的类较多，但是关键步骤主要有三个：</span><br><span class="line"></span><br><span class="line">解码：对 HTTP&#x2F;2 Body 进行应用层解码，转换成服务端接口的请求参数，解码的关键就是调用 requestMarshaller.parse(input)，将 PB 码流转换成 Java 对象；</span><br><span class="line"></span><br><span class="line">路由：根据 URL 中的方法名从内部服务注册中心查询到对应的服务实例，路由的关键是调用 registry.lookupMethod(methodName) 获取到 ServerMethodDefinition 对象；</span><br><span class="line"></span><br><span class="line">调用：调用服务端接口实现类的指定方法，实现 RPC 调用，与一些 RPC 框架不同的是，此处调用是 Java 本地接口调用，非反射调用，性能更优，它的实现关键是 UnaryRequestMethod.invoke(request, responseObserver) 方法。</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>响应消息的发送</strong></li></ol><p>响应消息的发送由 StreamObserver 的 onNext 触发，流程如下所示：</p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-07-29-095108.jpg" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">响应消息的发送原理如下：</span><br><span class="line">1. 分别发送 gRPC HTTP&#x2F;2 响应消息头和消息体，由 NettyServerStream 的 Sink 将响应消息封装成 SendResponseHeadersCommand 和 SendGrpcFrameCommand，加入到 WriteQueue 中；</span><br><span class="line">WriteQueue 通过 Netty 的 NioEventLoop 线程进行消息处理，NioEventLoop 将 SendResponseHeadersCommand 和 SendGrpcFrameCommand 写入到 Netty 的 Channel 中，进而触发 DefaultChannelPipeline 的</span><br><span class="line">2. write(Object msg, ChannelPromise promise) 操作；</span><br><span class="line">响应消息通过 ChannelPipeline 职责链进行调度，触发 NettyServerHandler 的 sendResponseHeaders 和 sendGrpcFrame 方法，调用 Http2ConnectionEncoder 的 writeHeaders 和 writeData 方法，将响应消息通过 Netty 的 HTTP&#x2F;2 协议栈发送给客户端.</span><br></pre></td></tr></table></figure><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><ul><li>后续研究 ： <a href="https://www.jianshu.com/p/9e57da13b737" target="_blank" rel="noopener">https://www.jianshu.com/p/9e57da13b737</a></li></ul><h2 id="3-grpc-实现远程调用例子"><a href="#3-grpc-实现远程调用例子" class="headerlink" title="3. grpc 实现远程调用例子"></a>3. grpc 实现远程调用例子</h2><p><code>gRPC</code>的使用通常包括如下几个步骤：</p><ol><li>通过<code>protobuf</code>来定义接口和数据类型</li><li>编写<code>gRPC server</code>端代码</li><li>编写<code>gRPC client</code>端代码</li></ol><p><strong>代码示例：</strong></p><ol><li><code>pom.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>a.b.c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">grpc.version</span>&gt;</span>1.34.1<span class="tag">&lt;/<span class="name">grpc.version</span>&gt;</span><span class="comment">&lt;!-- CURRENT_GRPC_VERSION --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protobuf.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">protobuf.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">protoc.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">protoc.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java-util<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;protobuf.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protoc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:$&#123;grpc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">protoSourceRoot</span>&gt;</span>src/main/resources/proto<span class="tag">&lt;/<span class="name">protoSourceRoot</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建<code>proto</code>文件夹并创建<code>.proto</code>文件</li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">文件夹地址 ： src/main/resources/proto</span><br><span class="line">文件名：add.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;            <span class="comment">// 使用的语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> mygrpc;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">"a.b.c"</span>;     <span class="comment">// 真正的包名</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"AddServiceProto"</span>;</span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddService 服务名</span></span><br><span class="line"><span class="comment">// AddService 参数名</span></span><br><span class="line"><span class="comment">// AddReply   返回值</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">AddService</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> add(AddRequest) <span class="keyword">returns</span> (AddReply)&#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 定义参数和返回值的 数据结构类型</span></span><br><span class="line"><span class="function">message AddRequest&#123;</span></span><br><span class="line"><span class="function">    int32 a = 1</span>;</span><br><span class="line">    <span class="built_in">int32</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AddReply</span></span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> res = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>maven install</code> 后 项目会产生<code>.proto</code>文件<ul><li>使用<code>gRPC protobuf</code>生成工具生成对应语言的库函数</li></ul></li></ol><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-07-29-071439.png" style="zoom:50%;" /><ul><li><p>其中<code>AddServiceGrpc</code> 是一个生成的类，里面有一个非常重要的抽象类</p></li><li><p>我们需要做的就是继承<code>AddServiceGrpc</code>这个抽象类，并且重写里面的add方法即可</p></li></ul><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-07-29-071838.png" style="zoom:50%;" /><ol start="4"><li><code>addServer.java</code> : 服务端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a.b.c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Zhuuu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/9 16:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AddServiceImplBase 抽象类并重写add方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddServer</span> <span class="keyword">extends</span> <span class="title">AddServiceGrpc</span>.<span class="title">AddServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 主方法监听服务</span></span><br><span class="line">        ServerBuilder.forPort(<span class="number">9999</span>)</span><br><span class="line">                .addService(<span class="keyword">new</span> AddServer())<span class="comment">// 加入的服务是自己</span></span><br><span class="line">                .build()<span class="comment">// 编译</span></span><br><span class="line">                .start();  <span class="comment">// 启动</span></span><br><span class="line">        System.out.println(<span class="string">"server start at 9999"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;                               <span class="comment">// 这里便于一直监听</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 重写add方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AddRequest request, StreamObserver&lt;AddReply&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = myAdd(request.getA(),request.getB()); <span class="comment">// 拿到结果</span></span><br><span class="line">        responseObserver.onNext(AddReply.newBuilder().setRes(res).build()); <span class="comment">// 返回结果</span></span><br><span class="line">        responseObserver.onCompleted();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 业务代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">myAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>addClient.java</code> : 客户端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a.b.c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Zhuuu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/9 16:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddClient</span> </span>&#123;</span><br><span class="line">    AddServiceGrpc.AddServiceBlockingStub stub; <span class="comment">// 客户端代理</span></span><br><span class="line">    ManagedChannel channel;<span class="comment">// 与服务端的连接通道</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">101</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">102</span>;</span><br><span class="line">      <span class="comment">// 2. 客户端建立通道，并设置参数</span></span><br><span class="line">        AddClient client = <span class="keyword">new</span> AddClient();</span><br><span class="line">      </span><br><span class="line">        AddReply reply =</span><br><span class="line">             client.stub.add(AddRequest.newBuilder().setA(a).setB(b).build());</span><br><span class="line">        System.out.println(reply.getRes());<span class="comment">// 最后拿到调用结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 与服务端建立连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        channel = ManagedChannelBuilder</span><br><span class="line">                .forAddress(<span class="string">"127.0.0.1"</span>,<span class="number">9999</span>)</span><br><span class="line">                .usePlaintext()<span class="comment">// 纯本文的方式</span></span><br><span class="line">                .build();</span><br><span class="line">        stub =</span><br><span class="line">                AddServiceGrpc.newBlockingStub(channel);<span class="comment">// 阻塞的代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><ul><li>以上模拟了一个基本的<code>grpc + protobuf</code>的调用案例</li></ul><h2 id="4-ProtoBuf"><a href="#4-ProtoBuf" class="headerlink" title="4. ProtoBuf"></a>4. ProtoBuf</h2><ul><li>学习文档 ： <a href="https://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="noopener">https://colobu.com/2015/01/07/Protobuf-language-guide/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;rpc-02-grpc&quot;&gt;&lt;a href=&quot;#rpc-02-grpc&quot; class=&quot;headerlink&quot; title=&quot;rpc-02-grpc&quot;&gt;&lt;/a&gt;rpc-02-grpc&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNly1gsvsj6enmzj30f108e74w.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;业界主流的 RPC 框架整体上分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多语言的 RPC 框架，比较成熟的有 &lt;strong&gt;Google 的 gRPC&lt;/strong&gt;、&lt;strong&gt;Apache（Facebook）的 Thrift；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;只支持特定语言的 RPC 框架，例如新浪微博的 Motan；&lt;/li&gt;
&lt;li&gt;支持服务治理等服务化特性的分布式服务框架，其底层内核仍然是 RPC 框架, 例如阿里的 Dubbo。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="rpc" scheme="http://zhuuu.work/tags/rpc/"/>
    
      <category term="grace" scheme="http://zhuuu.work/tags/grace/"/>
    
  </entry>
  
  <entry>
    <title>rpc-01-简介</title>
    <link href="http://zhuuu.work/2021/07/27/rpc/rpc-01-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://zhuuu.work/2021/07/27/rpc/rpc-01-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-07-27T09:38:38.000Z</published>
    <updated>2021-07-29T06:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rpc-01-简介"><a href="#rpc-01-简介" class="headerlink" title="rpc-01-简介"></a>rpc-01-简介</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>rpc</code>并不是一种协议，而是一种开发的理念</li><li>底层本质都是传输二进制流（TCP可以进行传输）</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsvlcrfydhj30dw08qaam.jpg" alt=""></p><p><strong>概念阐述</strong></p><ul><li><code>RPC（Remote Procedure Call）</code>—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</li><li>比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 <em>HTTP请求</em> 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</li></ul><p>最终解决的问题：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p><a id="more"></a><h2 id="0-RPC-原理"><a href="#0-RPC-原理" class="headerlink" title="0. RPC 原理"></a>0. RPC 原理</h2><h3 id="0-1-例子"><a href="#0-1-例子" class="headerlink" title="0.1 例子"></a>0.1 例子</h3><ul><li>RPC就是要像调用本地的函数一样去调远程函数。<ul><li>在研究RPC前，我们先看看本地调用是怎么调的。假设我们要调用函数Multiply来计算<code>lvalue * rvalue</code>的结果:</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">int</span> y = l * r;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">return</span> y;</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">6</span> <span class="keyword">int</span> lvalue = <span class="number">10</span>;</span><br><span class="line"><span class="number">7</span> <span class="keyword">int</span> rvalue = <span class="number">20</span>;</span><br><span class="line"><span class="number">8</span> <span class="keyword">int</span> l_times_r = Multiply(lvalue, rvalue);</span><br><span class="line"></span><br><span class="line">那么在第<span class="number">8</span>行时，我们实际上执行了以下操作：</span><br><span class="line">  将 lvalue 和 rvalue 的值压栈进入Multiply函数，取出栈中的值<span class="number">10</span> 和 <span class="number">20</span>，将其赋予 l 和 r执行第<span class="number">2</span>行代码，</span><br><span class="line">  计算 l * r ，并将结果存在 y将 y 的值压栈，</span><br><span class="line">  然后从Multiply返回第<span class="number">8</span>行，从栈中取出返回值 <span class="number">200</span> ，并赋值给 l_times_r以上<span class="number">5</span>步就是执行本地调用的过程。</span><br><span class="line">  （注：以上步骤只是为了说明原理。事实上编译器经常会做优化，对于参数和返回值少的情况会直接将其存放在寄存器，而不需要压栈弹栈的过程，甚至都不需要调用call，而直接做inline操作。仅就原理来说，这<span class="number">5</span>步是没有问题的。）</span><br></pre></td></tr></table></figure><ul><li><strong>远程调用带来的问题：</strong><ul><li><strong>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。</strong>这就带来了几个新问题：</li></ul></li></ul><ol><li><p><strong>Call ID映射</strong>。</p><ul><li>我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？</li><li>在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。</li><li>但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。</li><li>所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。</li><li><strong>客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表</strong>。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。</li><li>当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li></ul></li><li><p><strong>序列化和反序列化</strong>。客户端怎么把参数值传给远程的函数呢？</p><ul><li>在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。</li><li>但是在远程过程调用时，<strong>客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言</strong>（比如服务端用C++，客户端用Java或者Python）。</li><li>这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li><li>常见的有：<code>protobuf,hessian,JSON</code></li></ul></li><li><p><strong>网络传输</strong> ：远程调用往往用在网络上，客户端和服务端是通过网络连接的。</p><ul><li>所有的数据都需要通过网络传输，因此就需要有一个网络传输层。</li><li>网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。</li><li>只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。</li><li><strong>尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</strong></li></ul></li></ol><p><strong>有了这三个机制，就能实现RPC了，具体过程如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client端 </span></span><br><span class="line"><span class="comment">//    int l_times_r = Call(ServerAddr, Multiply, lvalue, rvalue)</span></span><br><span class="line"><span class="number">1.</span> 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法</span><br><span class="line"><span class="number">2.</span> 将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包</span><br><span class="line"><span class="number">3.</span> 把<span class="number">2</span>中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class="line"><span class="number">4.</span> 等待服务器返回结果</span><br><span class="line"><span class="number">5.</span> 如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server端</span></span><br><span class="line"><span class="number">1.</span> 在本地维护一个Call ID到函数指针的映射call_id_map，可以用<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::function&lt;&gt;&gt;</span><br><span class="line"><span class="number">2.</span> 等待请求</span><br><span class="line"><span class="number">3.</span> 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class="line"><span class="number">4.</span> 通过在call_id_map中查找，得到相应的函数指针</span><br><span class="line"><span class="number">5.</span> 将lvalue和rvalue反序列化后，在本地调用Multiply函数，得到结果</span><br><span class="line"><span class="number">6.</span> 将结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure><p>所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。</p><p><strong>其中：</strong></p><ul><li><p><code>Call ID</code>映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。</p></li><li><p>序列化反序列化可以自己写，也可以使用<code>Protobuf</code>或者<code>JSON</code>之类的。</p></li><li><p>网络传输库可以自己写<code>socket</code>，或者用<code>asio，ZeroMQ，Netty</code>之类。</p></li><li><p>当然，这里面还有一些细节可以填充，比如如何处理网络错误，如何防止攻击，如何做流量控制，等等。但有了以上的架构，这些都可以持续加进去。</p></li></ul><p><strong>接下来将以栗子来说明RPC的演进迭代过程</strong></p><h3 id="0-2-流程小结"><a href="#0-2-流程小结" class="headerlink" title="0.2 流程小结"></a>0.2 流程小结</h3><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><h3 id="0-3-业界RPC"><a href="#0-3-业界RPC" class="headerlink" title="0.3 业界RPC"></a>0.3 业界RPC</h3><ul><li><strong>业界常用的RPC框架</strong></li></ul><p><strong>Dubbo:</strong> Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</p><p><strong>gRPC</strong> ：gRPC 是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</p><h3 id="0-4-RPC-HTTP"><a href="#0-4-RPC-HTTP" class="headerlink" title="0.4 RPC / HTTP"></a>0.4 RPC / HTTP</h3><ul><li><p>首先需要指正，这两个并不是并行概念。RPC 是一种<strong>设计</strong>，就是为了解决<strong>不同服务之间的调用问题</strong>，完整的 RPC 实现一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p></li><li><p>而 HTTP 是一种传输协议，RPC 框架完全可以使用 HTTP 作为传输协议，也可以直接使用 TCP，使用不同的协议一般也是为了适应不同的场景。</p></li></ul><h3 id="0-5-序列化"><a href="#0-5-序列化" class="headerlink" title="0.5 序列化"></a>0.5 序列化</h3><ul><li>通过将对象序列化成字节数组，即可将对象发送到网络中。</li><li><strong>序列化</strong>（<code>serialization</code>）在计算机科学的资料处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</li><li>依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。</li><li>这种过程也称为对象编组（<code>marshalling</code>）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、<code>deserialization、unmarshalling</code>）。</li></ul><p><strong>在Java中的操作：</strong></p><ul><li>在 Java 中，想要序列化一个对象，这个对象所属的类必须实现了 <code>Serializable</code> 接口，并且其内部属性必须都是可序列化的。如果有一个属性不是可序列化的，则该属性必须被声明为 <code>transient</code>。</li><li>JDK 中提供了 <code>ObjectOutStream</code> 类来对对象进行序列化。</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsvpuze4qsj30em0pm0tr.jpg" style="zoom:33%;" /><p><strong>常见的序列化方式： JSON、Kryo、Hessian 和 Protobuf 的序列化。</strong></p><ul><li><code>JSON</code> 是一种轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象，类似 <code>xml，Json</code> 比<code>xml</code>更小、更快更容易解析。JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。</li><li><strong>剩下的都是基于字节的序列化</strong><ul><li><code>Kryo</code>是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、数据库或网络数据 Kryo 都可以随时完成序列化。 Kryo 还可以执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂。</li><li><code>protobuf（Protocol Buffers）</code>是由 Google 发布的数据交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 protocol compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预编译上。序列化反序列化性能较高，平台无关。</li><li><code>Hessian</code> 是一个基于二进制的协议，Hessian 支持很多种语言，例如 Java、python、c++,、net/c#、D、Erlang、PHP、Ruby、object-c等，它的序列化和反序列化也是非常高效。速度较慢，序列化后的体积较大。</li></ul></li></ul><h2 id="1-代码举例"><a href="#1-代码举例" class="headerlink" title="1. 代码举例"></a>1. 代码举例</h2><h3 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h3><ol><li><code>User.java</code> ： 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>IUserService</code> : 寻找用户id</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id,<span class="string">"Alice"</span>);</span><br><span class="line">    &#125;<span class="comment">//直接new模拟数据库查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-rpc-01-原始方式"><a href="#1-1-rpc-01-原始方式" class="headerlink" title="1.1 rpc-01-原始方式"></a>1.1 rpc-01-原始方式</h3><ul><li>使用二进制流</li></ul><ol><li><code>Server 端</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 在端口进行监听</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8088</span>);</span><br><span class="line">        <span class="keyword">while</span>(running)&#123;</span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            process(client);                                    <span class="comment">// 处理传过来的请求</span></span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 处理请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 2.1 二进制流对象</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 读到请求的用户，调出他的id，在写回去</span></span><br><span class="line">        <span class="keyword">int</span> id = dis.readInt();</span><br><span class="line">        IUserService service = <span class="keyword">new</span> IUserServiceImpl();</span><br><span class="line">        User user = service.findUserById(id);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 以下两行代码：客户端将user的id和name通过二进制写回去</span></span><br><span class="line">        dos.writeInt(user.getId());</span><br><span class="line">        dos.writeUTF(user.getName());</span><br><span class="line">      </span><br><span class="line">        dos.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>client 客户端</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.客户端以及包装二进制工具</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8088</span>);</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line">        dos.writeInt(<span class="number">123</span>); <span class="comment">// 注意这里是写死的，缺少灵活性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 发送出要查询的id</span></span><br><span class="line">        socket.getOutputStream().write(baos.toByteArray());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 接收服务端返回的结果</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">        <span class="keyword">int</span> id = dis.readInt();             <span class="comment">// 处理接收到的int</span></span><br><span class="line">        String name = dis.readUTF();        <span class="comment">// 处理接收到的str</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(id,name);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        dos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>问题缺点所在<ul><li>代码是写死的，对象有多少个属性，那么这个代码修改起来就有多麻烦</li><li>如果新增属性，业务代码和传输数据的代码是耦合的</li></ul></li></ol><h3 id="1-2-rpc-02-网络封装"><a href="#1-2-rpc-02-网络封装" class="headerlink" title="1.2 rpc-02-网络封装"></a>1.2 rpc-02-网络封装</h3><ul><li>省略了网络传输的部分（对网络部分进行封装）<ul><li>使用网络部分的代理 <code>stub 对象</code></li><li><strong>静态代理</strong></li></ul></li></ul><ol><li><code>stub</code> ： 其实就是网络部分放进一个类中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 联网写出去</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8088</span>);</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line">        dos.writeInt(<span class="number">123</span>); <span class="comment">// 注意这里是写死的，缺少灵活性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 发送出要查询的id</span></span><br><span class="line">        socket.getOutputStream().write(baos.toByteArray());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.接收服务端返回的结果</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">        <span class="keyword">int</span> idtmp = dis.readInt();</span><br><span class="line">        <span class="keyword">if</span>(idtmp != id) System.out.println(<span class="string">"error"</span>);</span><br><span class="line">        String name = dis.readUTF();</span><br><span class="line">        User user = <span class="keyword">new</span> User(id,name);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>client</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Stub stub = <span class="keyword">new</span> Stub();</span><br><span class="line">        System.out.println(stub.findUserById(<span class="number">123</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-rpc-03-动态代理"><a href="#1-3-rpc-03-动态代理" class="headerlink" title="1.3 rpc-03-动态代理"></a>1.3 rpc-03-动态代理</h3><ul><li><p><strong>对于变化的代码: 使用动态代理</strong></p><ul><li><code>Proxy ：</code>动态代理的类</li><li><code>InvocationHandler ：</code>处理对网络的请求</li><li>基于动态代理生成代理对象，当调用代理对象的方法时，由代理进行相关信息（方法、参数等）的组装并发送到服务器进行远程调用，并由代理接收调用结果并返回。</li><li><code>JDK</code> 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用业务方法前调用<code>InvocationHandler</code> 处理。代理类必须实现 <code>InvocationHandler</code> 接口，并且，JDK 动态代理只能代理实现了接口的类</li></ul></li><li><p>使用动态代理的步骤</p><p>1、编写需要被代理的类和接口</p><p>2、编写代理类，需要实现 <code>InvocationHandler</code> 接口，重写 <code>invoke()</code> 方法；</p><p>3、使用<code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>动态创建代理类对象，通过代理类对象调用业务方法。</p></li><li><p>动态代理代码demo:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DemoInterface</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoImpl</span> <span class="keyword">implements</span> <span class="title">DemoInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"msg = "</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DemoInterface service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoProxy</span><span class="params">(DemoInterface service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用方法前..."</span>);</span><br><span class="line">        Object returnValue = method.invoke(service, args);</span><br><span class="line">        System.out.println(<span class="string">"调用方法后..."</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoProxy proxy = <span class="keyword">new</span> DemoProxy(<span class="keyword">new</span> DemoImpl());</span><br><span class="line">        DemoInterface service = Proxy.newInstance(</span><br><span class="line">            DemoInterface<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">            new Class&lt;?&gt;[]&#123;DemoInterface.class&#125;,</span><br><span class="line">            proxy</span><br><span class="line">        );</span><br><span class="line">        System.out.println(service.hello(<span class="string">"呀哈喽！"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>stub</code> : 代理类（屏蔽了对网络的细节）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUserService <span class="title">getStub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. invocationHandler: 生成代理类</span></span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// proxy : 代理的类</span></span><br><span class="line">            <span class="comment">// method : finduserbyid</span></span><br><span class="line">            <span class="comment">// args : id = 123</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8088</span>);</span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line">                dos.writeInt(<span class="number">123</span>); <span class="comment">// 注意这里是写死的，缺少灵活性</span></span><br><span class="line">                <span class="comment">//发送出要查询的id</span></span><br><span class="line">                socket.getOutputStream().write(baos.toByteArray());</span><br><span class="line">                socket.getOutputStream().flush();</span><br><span class="line">                <span class="comment">//接收服务端返回的结果</span></span><br><span class="line">                DataInputStream dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">                <span class="keyword">int</span> id = dis.readInt();</span><br><span class="line">                String name = dis.readUTF();</span><br><span class="line">                Object user = <span class="keyword">new</span> User(id,name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. new 代理，注意三个参数</span></span><br><span class="line">        Object o = Proxy.newProxyInstance(IUserService.class.getClassLoader(), new Class[]&#123;IUserService.class&#125;, h);</span><br><span class="line">        System.out.println(o.getClass().getName());                     <span class="comment">// 打印结果：Proxy</span></span><br><span class="line">        System.out.println(o.getClass().getInterfaces()[<span class="number">0</span>]);            <span class="comment">// 打印结果：IUserService接口</span></span><br><span class="line">        <span class="keyword">return</span> (IUserService) o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>client</code> : 客户端使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 使用动态代理新产生的类</span></span><br><span class="line">        IUserService stub = Stub.getStub();</span><br><span class="line">        System.out.println(stub.findUserById(<span class="number">123</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-rpc-04-动态代理通用代码"><a href="#1-4-rpc-04-动态代理通用代码" class="headerlink" title="1.4 rpc-04-动态代理通用代码"></a>1.4 rpc-04-动态代理通用代码</h3><ol><li><code>stub</code> : 代理 (方法类型和参数的更改)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> IUserService <span class="title">getStub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8088</span>);</span><br><span class="line">                ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通用化的改动 ：</span></span><br><span class="line">                oos.writeUTF(method.getName());                      <span class="comment">// 调用方法的名称</span></span><br><span class="line">                oos.writeObject(method.getParameterTypes());         <span class="comment">// 避免重载的存在，参数类型不同</span></span><br><span class="line">                oos.writeObject(args);                               <span class="comment">// 调用方法的参数</span></span><br><span class="line">                oos.flush();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//接收服务端返回的结果,object读入</span></span><br><span class="line">                ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                User user = (User)ois.readObject();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object o = Proxy.newProxyInstance(IUserService.class.getClassLoader(), new Class[]&#123;IUserService.class&#125;, h);</span><br><span class="line">        System.out.println(o.getClass().getName());</span><br><span class="line">        System.out.println(o.getClass().getInterfaces()[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> (IUserService) o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>server 端</code> ： 这里不像之前，也需要做出改动（对应客户端）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 建立链接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8088</span>);</span><br><span class="line">        <span class="keyword">while</span>(running)&#123;</span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            process(client);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理客户端逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了适应客户端通用化而做的改动</span></span><br><span class="line">        String methodName = ois.readUTF();                              <span class="comment">// 读取客户端传来调用的方法名字</span></span><br><span class="line">        Class[] parameterTypes = (Class[]) ois.readObject();            <span class="comment">// 读取客户端调用的参数类型</span></span><br><span class="line">        Object[] parameters = (Object[]) ois.readObject();              <span class="comment">// 读取客户端调用的方法参数</span></span><br><span class="line"></span><br><span class="line">        IUserService service = <span class="keyword">new</span> IUserServiceImpl();<span class="comment">//服务类型暂时还是写死的，不够灵活</span></span><br><span class="line">        Method method = service.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">        User user = (User)method.invoke(service, parameters);</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-rpc-05-处理不同客户请求"><a href="#1-5-rpc-05-处理不同客户请求" class="headerlink" title="1.5 rpc-05-处理不同客户请求"></a>1.5 rpc-05-处理不同客户请求</h3><ol><li>假设还有一个<code>Product</code> 对象以及<code>Product</code> 的业务类</li><li><strong>这个实现类过程完全可以使用Spring注入！！</strong></li><li>以下的rpc调用屏蔽了底层的网络的实现，也实现了服务端代码的复用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name="</span> + name +</span><br><span class="line">                <span class="string">", count="</span> + count +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProductService</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">findProductByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">IProductService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">findProductByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product(<span class="number">1</span>,name,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>客户端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IUserService service = (IUserService) Stub.getStub(IUserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        IProductService service2 = (IProductService)Stub.getStub(IProductService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(service.findUserById(<span class="number">123</span>));</span><br><span class="line">        System.out.println(service2.findProductByName(<span class="string">"Bob"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>代理类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Object <span class="title">getStub</span><span class="params">(Class c)</span></span>&#123;<span class="comment">// 注意这里传入的是Class</span></span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8088</span>);</span><br><span class="line">                ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//添加了服务类型的传输</span></span><br><span class="line">                oos.writeUTF(c.getName());<span class="comment">//服务类型</span></span><br><span class="line">                oos.writeUTF(method.getName());<span class="comment">//方法名</span></span><br><span class="line">                oos.writeObject(method.getParameterTypes());<span class="comment">//方法参数类型</span></span><br><span class="line">                oos.writeObject(args);<span class="comment">//方法参数</span></span><br><span class="line">                oos.flush();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//接收服务端返回的结果,object读入</span></span><br><span class="line">                ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                Object obj = ois.readObject();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> obj;<span class="comment">//改为返回通用对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object o = Proxy.newProxyInstance(c.getClassLoader(), <span class="keyword">new</span> Class[]&#123;c&#125;, h);<span class="comment">//这里要写成通用的c，而不是固定的接口</span></span><br><span class="line">        System.out.println(o.getClass().getName());</span><br><span class="line">        System.out.println(o.getClass().getInterfaces()[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>服务端代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Class&gt; registerTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        registerTable.put(IUserService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(),<span class="title">IUserServiceImpl</span>.<span class="title">class</span>)</span>;<span class="comment">//key类型是接口，value是具体实现类才能完成调用</span></span><br><span class="line">        registerTable.put(IProductService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">IProductServiceImpl</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8088</span>);</span><br><span class="line">        <span class="keyword">while</span>(running)&#123;</span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            process(client);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了适应客户端通用化而做的改动</span></span><br><span class="line">        String clazzName = ois.readUTF();</span><br><span class="line">        String methodName = ois.readUTF();</span><br><span class="line">        Class[] parameterTypes = (Class[]) ois.readObject();</span><br><span class="line">        Object[] parameters = (Object[]) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//IUserService service = new IUserServiceImpl();</span></span><br><span class="line">        <span class="comment">//本来是硬编码new出来的，现在变成从注册表中查到服务类，如果使用spring甚至还可以直接根据配置注入bean然后根据bean查找。(@autowired)</span></span><br><span class="line">        Object service = registerTable.get(clazzName).newInstance();</span><br><span class="line">        Method method = service.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">        Object o = method.invoke(service, parameters);</span><br><span class="line">        oos.writeObject(o);</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-序列化-Hessian使用"><a href="#2-序列化-Hessian使用" class="headerlink" title="2 序列化 Hessian使用"></a>2 序列化 Hessian使用</h2><ol><li>序列化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是讲object序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialization(Object obj)&#123;</span><br><span class="line"><span class="keyword">if</span>(obj==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line">ByteArrayOutputStream os=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">HessianOutput output=<span class="keyword">new</span> HessianOutput(os);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">output.writeObject(obj);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> os.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>反序列化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> by</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] by)</span></span>&#123;</span><br><span class="line">Object readObject=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(by==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line">ByteArrayInputStream ins=<span class="keyword">new</span> ByteArrayInputStream(by);</span><br><span class="line">HessianInput input=<span class="keyword">new</span> HessianInput(ins);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">readObject = input.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> readObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与JDK的序列化对比：<code>hessian</code>去掉了许多多余的信息，长度更短</li><li>常用的序列化协议：<code>protobuf , thift, hessian</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;rpc-01-简介&quot;&gt;&lt;a href=&quot;#rpc-01-简介&quot; class=&quot;headerlink&quot; title=&quot;rpc-01-简介&quot;&gt;&lt;/a&gt;rpc-01-简介&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rpc&lt;/code&gt;并不是一种协议，而是一种开发的理念&lt;/li&gt;
&lt;li&gt;底层本质都是传输二进制流（TCP可以进行传输）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNly1gsvlcrfydhj30dw08qaam.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概念阐述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RPC（Remote Procedure Call）&lt;/code&gt;—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。&lt;/li&gt;
&lt;li&gt;比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 &lt;em&gt;HTTP请求&lt;/em&gt; 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终解决的问题：&lt;strong&gt;让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="rpc" scheme="http://zhuuu.work/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-671-二叉树第二小的节点</title>
    <link href="http://zhuuu.work/2021/07/27/Leetcode/Leetcode-671-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2021/07/27/Leetcode/Leetcode-671-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2021-07-27T07:52:53.000Z</published>
    <updated>2021-07-31T05:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-671-二叉树中第二小的节点"><a href="#Leetcode-671-二叉树中第二小的节点" class="headerlink" title="Leetcode-671-二叉树中第二小的节点"></a>Leetcode-671-<a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener">二叉树中第二小的节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 <code>2</code> 或<code>0</code>。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</li></ul><ul><li><p>更正式地说，<code>root.val = min(root.left.val, root.right.val)</code> 总成立。</p></li><li><p>给出这样的一个二叉树，你需要输出所有节点中的<strong>第二小的值。</strong>如果第二小的值不存在的话，输出 <code>-1</code>。</p></li></ul><p><strong>示例 1：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsx28jdcdtj30bz08e74a.jpg" alt=""></p><p><strong>示例2:</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsx29sgb6tj308x052t8l.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [2,2,5,null,null,5,7]</span><br><span class="line">输出：5</span><br><span class="line">解释：最小的值是 2 ，第二小的值是 5 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root &#x3D; [2,2,2]</span><br><span class="line">输出：-1</span><br><span class="line">解释：最小的值是 2, 但是不存在第二小的值。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-深度优先搜索"><a href="#方法一-：-深度优先搜索" class="headerlink" title="方法一 ： 深度优先搜索"></a>方法一 ： 深度优先搜索</h2><ul><li><p>根据题目中的描述「如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个」，我们可以知道，对于二叉树中的任意节点 x，x 的值不大于其所有子节点的值，因此：</p><ul><li>对于二叉树中的任意节点 x，x 的值不大于以 x为根的子树中所有节点的值。</li><li>令 x为二叉树的根节点，此时我们可以得出结论：<ul><li>二叉树根节点的值即为所有节点中的最小值。</li></ul></li></ul></li><li><p>因此，我们可以对整棵二叉树进行一次遍历。设根节点的值为 <code>rootvalue</code>，只需要通过遍历，找出严格大于 <code>rootvalue</code> 的最小值，即为「所有节点中的第二小的值」。</p></li></ul><p><strong>具体实现：</strong></p><ul><li>可以使用深度优先搜索的方法对二叉树进行遍历。</li><li>假设当前遍历到的节点为 node，如果 node 的值严格大于<code>rootvalue</code>，那么我们就可以用 node 的值来更新答案 ans。</li><li>当我们遍历完整棵二叉树后，即可返回 <em>ans</em>。</li></ul><p><strong>细节：</strong></p><ul><li>根据题目要求，如果第二小的值不存在的话，输出 -1，那么我们可以将 <em>ans</em> 的初始值置为 −1</li><li>在遍历的过程中，如果当前节点的值严格大于 <em>rootvalue</em> 的节点时<ul><li>那么只要 ans 的值为 −1 或者当前节点的值严格小于 ans，我们就需要对 ans 进行更新。</li></ul></li><li>此外，如果当前节点的值大于等于 <em>ans</em><ul><li>那么根据「思路」部分，以当前节点为根的子树中所有节点的值都大于等于 ans，我们就直接回溯，无需对该子树进行遍历。这样做可以省去不必要的遍历过程。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> rootValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 赋值及dfs逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = -<span class="number">1</span>;                <span class="comment">// 如果第二小的值不存在的话，输出 -1，那么我们可以将 ans 的初始值置为 −1   </span></span><br><span class="line">        rootValue = root.val;    <span class="comment">// 从根节点对二叉树进行遍历</span></span><br><span class="line">        dfs(root);               <span class="comment">// dfs逻辑</span></span><br><span class="line">        <span class="keyword">return</span> ans;              <span class="comment">// 返回最后结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. dfs处理逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2.1 遍历终止的条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2 剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(ans != -<span class="number">1</span> &amp;&amp; node.val &gt;= ans)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.3 更新逻辑 : ans == -1的情形下</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &gt; rootValue)&#123;</span><br><span class="line">            ans = node.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.4 dfs左右节点</span></span><br><span class="line">        dfs(node.left);</span><br><span class="line">        dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 O(<em>n</em>)：</strong> 其中 n是二叉树中的节点个数。我们最多需要对整棵二叉树进行一次遍历。</li><li><strong>空间复杂度O(<em>n</em>)</strong> ： 我们使用深度优先搜索的方法进行遍历，需要使用的栈空间为 O(<em>n</em>)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-671-二叉树中第二小的节点&quot;&gt;&lt;a href=&quot;#Leetcode-671-二叉树中第二小的节点&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-671-二叉树中第二小的节点&quot;&gt;&lt;/a&gt;Leetcode-671-&lt;a href=&quot;https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树中第二小的节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 &lt;code&gt;2&lt;/code&gt; 或&lt;code&gt;0&lt;/code&gt;。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;更正式地说，&lt;code&gt;root.val = min(root.left.val, root.right.val)&lt;/code&gt; 总成立。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给出这样的一个二叉树，你需要输出所有节点中的&lt;strong&gt;第二小的值。&lt;/strong&gt;如果第二小的值不存在的话，输出 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNly1gsx28jdcdtj30bz08e74a.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNly1gsx29sgb6tj308x052t8l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [2,2,5,null,null,5,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最小的值是 2 ，第二小的值是 5 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [2,2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：-1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最小的值是 2, 但是不存在第二小的值。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-LCP007-传递信息</title>
    <link href="http://zhuuu.work/2021/07/26/Leetcode/Leetcode-LCP007-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/"/>
    <id>http://zhuuu.work/2021/07/26/Leetcode/Leetcode-LCP007-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</id>
    <published>2021-07-26T11:02:24.000Z</published>
    <updated>2021-07-26T14:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-LCP007-传递信息"><a href="#Leetcode-LCP007-传递信息" class="headerlink" title="Leetcode-LCP007-传递信息"></a>Leetcode-LCP007-<a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/" target="_blank" rel="noopener">传递信息</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</li><li>有 n 名玩家，所有玩家编号分别为 <code>0 ～ n-1</code>，其中小朋友 A 的编号为 0<br>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。</li><li>传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li><li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 5, relation &#x3D; [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 3, relation &#x3D; [[0,2],[2,1]], k &#x3D; 2</span><br><span class="line">输出：0</span><br><span class="line">解释：信息不能从小 A 处经过 2 轮传递到编号 2</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-DFS"><a href="#方法一-DFS" class="headerlink" title="方法一 : DFS"></a>方法一 : DFS</h2><ul><li><p>可以把传信息的关系看成有向图，每个玩家对应一个节点，每个传信息的关系对应一条有向边。</p><ul><li>如果 x 可以向 y 传信息，则对应从节点 x到节点 y 的一条<strong>有向</strong>边。</li><li>寻找从编号 0 的玩家经过 k 轮传递到编号 <code>n−1</code> 的玩家处的方案数，<strong>等价于在有向图中寻找从节点 0 到节点 n-1 的长度为 k 的路径数，同一条路径可以重复经过同一个节点。</strong></li></ul></li><li><p>可以使用深度优先搜索计算方案数</p><ul><li>从节点<code>0</code>出发做深度优先搜索，每一步记录当前所在的节点以及经过的轮数，当经过 k 轮时，如果位于节点 <code>n-1</code>，则将方案数加 1。</li><li>搜索结束就是总的方案数量。</li></ul></li><li><p>具体实现方面，可以对传信息的关系进行预处理，使用列表存储有向边的关系，即可在<code>O(1)</code>的时间内得到特定节点的相邻节点（即可以沿着有向边一步到达的节点）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 节点变量和存放变量的列表</span></span><br><span class="line">    <span class="keyword">int</span> n,k,ways;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 主逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        ways = <span class="number">0</span>;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 将边的关系存入列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge:relation)&#123;</span><br><span class="line">            <span class="keyword">int</span> src = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> dst = edge[<span class="number">1</span>];</span><br><span class="line">            edges.get(src).add(dst);              <span class="comment">// 建立边之间的关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2 dfs</span></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ways;                              <span class="comment">// index0: 起点    index1:轮数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. dfs逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 3.1 dfs终止的条件</span></span><br><span class="line">        <span class="keyword">if</span>(step == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == n - <span class="number">1</span>)&#123;</span><br><span class="line">                ways++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.2 搜索逻辑</span></span><br><span class="line">        List&lt;Integer&gt; list = edges.get(index);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> nextIndex : list)&#123;</span><br><span class="line">            dfs(nextIndex,step + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：<code>O(n ^ k)</code>。 最多需要遍历 <em>k</em> 层，每层遍历最多有 <em>O</em>(<em>n</em>) 个分支。</li><li>空间复杂度：<em>O</em>(<em>n</em>+<em>m</em>+<em>k</em>)。其中 m 为 <code>relation</code> 数组的长度。空间复杂度主要取决于图的大小和递归调用栈的深度，保存有向图信息所需空间为 <code>O(n+m)</code>，递归调用栈的深度不会超过<code>k</code>。</li></ul><h2 id="方法二：BFS"><a href="#方法二：BFS" class="headerlink" title="方法二：BFS"></a>方法二：BFS</h2><ul><li>后续待补充</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-LCP007-传递信息&quot;&gt;&lt;a href=&quot;#Leetcode-LCP007-传递信息&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-LCP007-传递信息&quot;&gt;&lt;/a&gt;Leetcode-LCP007-&lt;a href=&quot;https://leetcode-cn.com/problems/chuan-di-xin-xi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传递信息&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：&lt;/li&gt;
&lt;li&gt;有 n 名玩家，所有玩家编号分别为 &lt;code&gt;0 ～ n-1&lt;/code&gt;，其中小朋友 A 的编号为 0&lt;br&gt;每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。&lt;/li&gt;
&lt;li&gt;传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。&lt;/li&gt;
&lt;li&gt;每轮信息必须需要传递给另一个人，且信息可重复经过同一个人&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 5, relation &amp;#x3D; [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&amp;gt;2-&amp;gt;0-&amp;gt;4， 0-&amp;gt;2-&amp;gt;1-&amp;gt;4， 0-&amp;gt;2-&amp;gt;3-&amp;gt;4。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 3, relation &amp;#x3D; [[0,2],[2,1]], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：信息不能从小 A 处经过 2 轮传递到编号 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度优先搜索" scheme="http://zhuuu.work/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-645-错误的集合</title>
    <link href="http://zhuuu.work/2021/07/04/Leetcode/Leetcode-645-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <id>http://zhuuu.work/2021/07/04/Leetcode/Leetcode-645-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/</id>
    <published>2021-07-04T07:52:53.000Z</published>
    <updated>2021-07-04T12:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-645-错误的集合"><a href="#Leetcode-645-错误的集合" class="headerlink" title="Leetcode-645-错误的集合"></a>Leetcode-645-<a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">错误的集合</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。</li><li>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。</li><li>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,2,4]</span><br><span class="line">输出：[2,3]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-哈希表"><a href="#方法一-：-哈希表" class="headerlink" title="方法一 ： 哈希表"></a>方法一 ： 哈希表</h2><ul><li><strong>重复的数字在数组中出现 2次，丢失的数字在数组中出现 0次，其余的每个数字在数组中出现 1 次。</strong><ul><li>因此可以使用哈希表记录每个元素在数组中出现的次数</li><li><strong>然后遍历从 1 到 n 的每个数字，分别找到出现 2 次和出现 0 次的数字，即为重复的数字和丢失的数字。</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建哈希表并且把数组塞入</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历哈希表，统计重复和缺失的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(i,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">2</span>)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                result[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度  :  O(n), 遍历数组和哈希表的时间</li><li>空间复杂度 ：O(n)，哈希表使用的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-645-错误的集合&quot;&gt;&lt;a href=&quot;#Leetcode-645-错误的集合&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-645-错误的集合&quot;&gt;&lt;/a&gt;Leetcode-645-&lt;a href=&quot;https://leetcode-cn.com/problems/set-mismatch/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;错误的集合&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。&lt;/li&gt;
&lt;li&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt; 代表了集合 &lt;code&gt;S&lt;/code&gt; 发生错误后的结果。&lt;/li&gt;
&lt;li&gt;请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,2,2,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>计组-11-IO系统</title>
    <link href="http://zhuuu.work/2021/06/20/Compute_Organization/%E8%AE%A1%E7%BB%84-11-IO%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhuuu.work/2021/06/20/Compute_Organization/%E8%AE%A1%E7%BB%84-11-IO%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-06-20T03:02:24.000Z</published>
    <updated>2021-07-15T04:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-11-IO系统"><a href="#计算机组成原理-11-IO系统" class="headerlink" title="计算机组成原理-11-IO系统"></a>计算机组成原理-11-IO系统</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>本章总览</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/110745945.png" alt="mark" style="zoom:80%;" /><ul><li><p>I/O方式需要注意的是：中断方式的各种原理和特点，处理过程，中断屏蔽，DMA方式和传输过程</p></li><li><p>I/O系统的演变过程如下图所示：</p></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/111139742.png" alt="mark" style="zoom: 67%;" /><a id="more"></a><h2 id="1-I-O系统的基本组成"><a href="#1-I-O系统的基本组成" class="headerlink" title="1. I/O系统的基本组成"></a>1. I/O系统的基本组成</h2><ul><li>一般来说<code>I/O</code>指令由<code>I/O</code>硬件和<code>I/O</code>软件组成</li></ul><ol><li><strong>I/O 软件</strong><ul><li>I/O命令</li><li>I/O的命令编码</li></ul></li></ol><ol start="2"><li><strong>I/O 硬件</strong></li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/111550097.png" alt="mark" style="zoom:50%;" /><h2 id="2-I-O-方式"><a href="#2-I-O-方式" class="headerlink" title="2. I/O 方式"></a>2. I/O 方式</h2><ul><li><strong>I/O方式总览如下</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/111825416.png" alt="mark" style="zoom:67%;" /><h3 id="2-1-程序查询方式"><a href="#2-1-程序查询方式" class="headerlink" title="2.1 程序查询方式"></a>2.1 程序查询方式</h3><ul><li><strong>工作流程</strong><ul><li>CPU执行初始化程序并设置参数</li><li>向I/O发送命令字，启动I/O参数</li><li>向外设接口读取状态信息</li><li>CPU不断查询I/O设备状态，直到外设就绪</li><li>传送一次数据</li><li>修改地址和计数器参数</li><li>判断是否结束，未结束继续回到第三步，直到计数器为0</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/112044725.png" alt="mark" style="zoom:67%;" /><p><strong>小结：</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/112447921.png" alt="mark" style="zoom:67%;" /><h3 id="2-2-程序中断方式"><a href="#2-2-程序中断方式" class="headerlink" title="2.2 程序中断方式"></a>2.2 程序中断方式</h3><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/112640529.png" alt="mark" style="zoom:67%;" /><h4 id="2-2-1-中断机制"><a href="#2-2-1-中断机制" class="headerlink" title="2.2.1 中断机制"></a>2.2.1 中断机制</h4><ul><li><strong>程序中断</strong>：计算机在执行程序的过程中，出现某些急需处理的异常和特殊请求，CPU暂时暂停现行的程序，而转去处理异常或者特殊请求。在处理完毕后，CPU回到断点，再继续执行原来的程序。</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/113010471.png" alt="mark" style="zoom: 67%;" /><ol><li><strong>外中断和内中断</strong></li></ol><ul><li>外中断：来自内存和处理器之外的中断，如外设,I/O设备<ul><li>非屏蔽中断：关中断也会被响应</li><li>可屏蔽中断：关中断不会被响应</li><li>CPU会在一个统一的时刻进行查询是否有中断查询信号</li></ul></li><li>内中断：来自内存和处理器的中断，如缺页，整数除0</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/114021369.png" alt="mark" style="zoom:67%;" /><ol start="2"><li><strong>中断请求标记</strong></li></ol><ul><li>给每个中断请求设置一个中断标记，来对中断进行分类</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/114254177.png" alt="mark" style="zoom:67%;" /><ol start="3"><li><strong>中断判优</strong></li></ol><ul><li>中断判优既可以从硬件实现，也可以使用软件实现</li><li>优先级的问题（硬件大于软件，非屏蔽优于可屏蔽，高速优于低速等等）</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/114515248.png" alt="mark" style="zoom:67%;" /><ol start="4"><li><strong>中断处理过程</strong></li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/115336441.png" alt="mark" style="zoom:67%;" /><ol start="5"><li><strong>单重中断和多重中断</strong><ul><li>单重中断：不会被新的中断打断</li><li>多重中断：可以嵌套新的中断</li></ul></li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/115521089.png" alt="mark" style="zoom:67%;" /><ol start="6"><li><strong>屏蔽字</strong></li></ol><ul><li>每个中断源都有一个屏蔽触发器，所有屏蔽触发字组合组成一个屏蔽触发寄存器，屏蔽寄存器的内容叫做屏蔽字</li><li>屏蔽触发器是中断的优先级</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/115825131.png" alt="mark" style="zoom:67%;" /><p><strong>例题分析：</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/115857718.png" alt="mark" style="zoom:67%;" /><h4 id="2-2-2-I-O-中断机制"><a href="#2-2-2-I-O-中断机制" class="headerlink" title="2.2.2 I/O 中断机制"></a>2.2.2 I/O 中断机制</h4><ul><li><p><strong>目的：实现CPU和I/O设备的并行工作</strong></p></li><li><p><strong>中断隐指令</strong></p><ul><li>关中断</li><li>保存断点</li><li>引出中断服务程序</li></ul></li><li><p><strong>具体工作流程如下图所示：</strong></p></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/120305605.png" alt="mark" style="zoom:80%;" /><h3 id="2-3-DMA-方式"><a href="#2-3-DMA-方式" class="headerlink" title="2.3 DMA 方式"></a>2.3 DMA 方式</h3><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/120512852.png" alt="mark" style="zoom:50%;" /><ul><li><p><strong>DMA 控制器</strong>：<code>I/O</code>设备向<code>DMA</code>控制器发送请求，CPU响应之后让出系统总线，由<code>DMA</code>控制器接管总线进行数据传输</p></li><li><p><strong>DMA 控制器的功能</strong></p><ul><li>传送前<ul><li>接收<code>DMA</code>请求，向CPU发出总线请求</li><li><code>CPU</code>响应之后让出系统总线，<code>DMA</code>接管总线</li></ul></li><li>传送时：<ul><li>确定传送数据的主存单元地址及长度，并能自动修改主存地址和传送长度</li><li>规定数据在主存和外设之间的传送方向，并且发出读写控制信号</li></ul></li><li>传送后：<ul><li>向<code>CPU</code>报告<code>DMA</code>操作的结束</li></ul></li></ul></li></ul><h4 id="2-3-1-DMA-传送过程"><a href="#2-3-1-DMA-传送过程" class="headerlink" title="2.3.1 DMA 传送过程"></a>2.3.1 DMA 传送过程</h4><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/121156932.png" alt="mark" style="zoom:67%;" /><ul><li><strong>预处理</strong>：由CPU完成一些数据必要的准备工作</li><li><strong>数据传送：</strong>DMA控制器将数据写入数据缓冲中</li><li><strong>后处理：</strong>DMA控制器向CPU发送中断请求，CPU校验传送数据的正确性</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/121457423.png" alt="mark" style="zoom:67%;" /><p><strong>注意：</strong></p><ul><li>当DMA控制器和CPU同时访问内存的时候，会产生争夺内存的使用权问题，此时就是DMA的传送方式问题</li></ul><h4 id="2-3-2-DMA-传送方式"><a href="#2-3-2-DMA-传送方式" class="headerlink" title="2.3.2 DMA 传送方式"></a>2.3.2 DMA 传送方式</h4><ul><li><strong>处理冲突分为三种方式</strong><ul><li>停止CPU访问内存</li><li>DMA和CPU交替访问内存 ： 将一个周期分为两个周期</li><li>周期窃取 : 前两种方式的折中</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/121908744.png" alt="mark" style="zoom:67%;" /><h4 id="2-3-3-DMA方式-和-中断方式比对"><a href="#2-3-3-DMA方式-和-中断方式比对" class="headerlink" title="2.3.3 DMA方式 和 中断方式比对"></a>2.3.3 DMA方式 和 中断方式比对</h4><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210715/122111865.png" alt="mark" style="zoom:67%;" /><h2 id="3-外部设备"><a href="#3-外部设备" class="headerlink" title="3. 外部设备"></a>3. 外部设备</h2><ul><li>外部设备主要包括<ul><li>输入设备：如键盘鼠标</li><li>输出设备：显示器和打印机</li><li>外存设备：CPU缓存，光盘和磁盘</li></ul></li></ul><h3 id="3-1-输入设备"><a href="#3-1-输入设备" class="headerlink" title="3.1 输入设备"></a>3.1 输入设备</h3><p><strong>键盘和鼠标的基本原理</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/112127884.png" alt="mark" style="zoom: 67%;" /><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/112157000.png" alt="mark" style="zoom:67%;" /><h3 id="3-2-输出设备"><a href="#3-2-输出设备" class="headerlink" title="3.2 输出设备"></a>3.2 输出设备</h3><ul><li><strong>以显示器基本原理为例</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/112326470.png" alt="mark" style="zoom:67%;" /><ul><li><strong>显示器的 VRAM 的计算</strong><ul><li><code>VRAM</code>容量 = 分辨率 * 灰度级位数</li><li><code>VRAM</code> 带宽 = 分辨率* 灰度级位数* 帧数</li></ul></li></ul><h3 id="3-3-外存储器"><a href="#3-3-外存储器" class="headerlink" title="3.3 外存储器"></a>3.3 外存储器</h3><h4 id="3-3-1-磁盘原理"><a href="#3-3-1-磁盘原理" class="headerlink" title="3.3.1 磁盘原理"></a>3.3.1 磁盘原理</h4><ul><li>计算机使用的外存储器叫做辅助存储器，目前主要使用是磁表面存储器</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/112632401.png" alt="mark" style="zoom:67%;" /><p><strong>1. 磁盘设备的组成</strong></p><ul><li><strong>存储区域</strong><ul><li>磁头数</li><li>柱面数</li><li>扇区数</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/112956785.png" alt="mark" style="zoom:67%;" /><ul><li><strong>磁盘存储器的组成</strong><ul><li>磁盘驱动器：磁头组件和盘片组件</li><li>磁盘控制器：磁盘存储器的接口</li></ul></li></ul><p><strong>2. 磁盘存储器的性能指标</strong></p><ul><li>磁盘容量分为：格式化和非格式化容量</li><li>磁盘记录密度：道密度，位密度，面密度</li><li>磁盘寻道时间：寻道时间+旋转延迟时间+传输时间</li><li>数据传输率：单位时间内向主机传输的数据字节数<ul><li><code>D = r N</code></li><li>D是数据传输率，r是磁盘转速，N是每条磁盘容量</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/113154540.png" alt="mark" style="zoom:67%;" /><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/113351585.png" alt="mark" style="zoom: 67%;" /><ol start="3"><li><strong>磁盘地址</strong></li></ol><ul><li>驱动器号：哪一个磁头</li><li>柱面号：柱面的地址</li><li>盘面：盘面的地址</li><li>扇区：扇区号</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/113602322.png" alt="mark" style="zoom:67%;" /><p><strong>注意</strong>：</p><ul><li>磁盘的读写是串行的，不能同时读写</li><li>每个操作对应于一个控制字，第一步是取控制字，第二部是执行控制字</li></ul><h4 id="3-3-2-磁盘阵列-RAID"><a href="#3-3-2-磁盘阵列-RAID" class="headerlink" title="3.3.2 磁盘阵列 RAID"></a>3.3.2 磁盘阵列 RAID</h4><ul><li><strong>RAID（廉价冗余磁盘阵列）：将多个独立的物理磁盘组成一个独立的逻辑磁盘</strong></li><li><strong>数据可以在多个物理盘上交叉存储，并行访问</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/113944019.png" alt="mark" style="zoom:67%;" /><ul><li>对应于<code>RAID</code>有以下几种方案<ul><li><code>RAID0 :</code>  无冗余和无校验的这列</li><li><code>RAID1：</code> 镜像的磁盘阵列</li><li><code>RAID2：</code>海明码校验的磁盘阵列</li><li><code>RAID3：</code>位交叉奇偶校验码磁盘阵列</li><li><code>RAID4：</code>块交叉奇偶校验码磁盘阵列</li><li><code>RAID5：</code>无独立校验的奇偶校验码磁盘阵列</li></ul></li></ul><h4 id="3-3-3-光盘"><a href="#3-3-3-光盘" class="headerlink" title="3.3.3 光盘"></a>3.3.3 光盘</h4><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/114209515.png" alt="mark" style="zoom:67%;" /><h4 id="3-3-4-固态硬盘"><a href="#3-3-4-固态硬盘" class="headerlink" title="3.3.4 固态硬盘"></a>3.3.4 固态硬盘</h4><ul><li>采用的是<code>Flash</code>闪存的硬盘</li><li>本质上是只读存储器</li></ul><h2 id="4-I-O-接口"><a href="#4-I-O-接口" class="headerlink" title="4. I/O 接口"></a>4. I/O 接口</h2><ul><li>I/O 接口是主机和外设之间的交接界面，并且有如下功能<ul><li>设备选址功能 ： 设备选择电路</li><li>传送命令的功能 ：命令寄存器和命令译码器</li><li>传送数据的功能 ： 数据缓冲寄存器DBR</li><li>反馈I/O 设备的工作状态 : 设备状态标记</li></ul></li></ul><h3 id="4-1-基本结构"><a href="#4-1-基本结构" class="headerlink" title="4.1 基本结构"></a>4.1 基本结构</h3><ul><li><strong>基本结构图如下：</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/114922042.png" alt="mark" style="zoom:67%;" /><ul><li><strong>接口和端口</strong><ul><li>端口是I/O接口中直接可以被访问的寄存器<ul><li>端口：数据端口，控制端口，状态端口</li></ul></li><li>接口是由端口和控制逻辑组成的</li><li>端口是由地址来进行访问的</li></ul></li></ul><ul><li><strong>端口的编址方式</strong><ul><li>统一编址：主存和设备统一编址（共用一套地址线）<ul><li>命令通用一套指令</li></ul></li><li>独立编址：I/O和存储器地址是分开的<ul><li>命令是不同的指令集</li></ul></li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/135752993.png" alt="mark" style="zoom:67%;" /><h3 id="4-2-接口类型"><a href="#4-2-接口类型" class="headerlink" title="4.2 接口类型"></a>4.2 接口类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**按传送方式分类**</span><br><span class="line"></span><br><span class="line">- 并行和串行</span><br><span class="line"></span><br><span class="line">**按控制方式分类**</span><br><span class="line"></span><br><span class="line">- 程序查询</span><br><span class="line">- 中断接口</span><br><span class="line">- DMA接口</span><br><span class="line"></span><br><span class="line">**按功能的灵活性**</span><br><span class="line"></span><br><span class="line">- 可编程接口   ：通道处理器</span><br><span class="line">- 不可编程接口</span><br></pre></td></tr></table></figure><h3 id="4-3-本章小结"><a href="#4-3-本章小结" class="headerlink" title="4.3 本章小结"></a>4.3 本章小结</h3><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/135957637.png" alt="mark" style="zoom:67%;" />]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-11-IO系统&quot;&gt;&lt;a href=&quot;#计算机组成原理-11-IO系统&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-11-IO系统&quot;&gt;&lt;/a&gt;计算机组成原理-11-IO系统&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本章总览&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/110745945.png&quot; alt=&quot;mark&quot; style=&quot;zoom:80%;&quot; /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I/O方式需要注意的是：中断方式的各种原理和特点，处理过程，中断屏蔽，DMA方式和传输过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I/O系统的演变过程如下图所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210714/111139742.png&quot; alt=&quot;mark&quot; style=&quot;zoom: 67%;&quot; /&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-10-总线</title>
    <link href="http://zhuuu.work/2021/06/15/Compute_Organization/%E8%AE%A1%E7%BB%84-10-%E6%80%BB%E7%BA%BF/"/>
    <id>http://zhuuu.work/2021/06/15/Compute_Organization/%E8%AE%A1%E7%BB%84-10-%E6%80%BB%E7%BA%BF/</id>
    <published>2021-06-15T03:02:24.000Z</published>
    <updated>2021-07-15T04:44:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-10-总线"><a href="#计算机组成原理-10-总线" class="headerlink" title="计算机组成原理-10-总线"></a>计算机组成原理-10-总线</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>本章内容概览</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/172913587.png" alt="mark"></p><ul><li><strong>总线</strong>是一组能为多个部件分时共享的公共信息的传送线路<ul><li>分时和共享是总线的特点</li><li>分时：同一时刻只允许有一个部件向总线发送信息</li><li>共享：总线上可以挂接多个部件</li></ul></li></ul><a id="more"></a><h2 id="1-总线的分类"><a href="#1-总线的分类" class="headerlink" title="1. 总线的分类"></a>1. 总线的分类</h2><ol><li><strong>按传送的结构分类：串行和并行总线</strong></li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/173214276.png" alt="mark" style="zoom: 33%;" /><ol start="2"><li><strong>按照系统总线来分类</strong><ul><li>数据总线：用来传输各部件中间的数据信息</li><li>地址总线：用来指出数据总线上的端口地址</li><li>控制总线：CPU发出命令和反馈信号流经的线路</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/173433411.png" alt="mark"></p><ol start="3"><li><strong>按照时序来分类</strong><ul><li>同步总线</li><li>异步总线</li></ul></li></ol><h2 id="2-总线的结构"><a href="#2-总线的结构" class="headerlink" title="2. 总线的结构"></a>2. 总线的结构</h2><ol><li><strong>单总线结构</strong>：所有的CPU,主存，I/O设备都在一根总线上</li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/173818679.png" alt="mark" style="zoom: 33%;" /><ol start="2"><li><strong>双总线结构</strong> <ul><li>一条主存总线：用于CPU,主存之间的数据传送</li><li>一条I/O总线：用于多个外部设备和通道之间的数据交换</li></ul></li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/174548937.png" alt="mark" style="zoom:50%;" /><ol start="3"><li><strong>三总线结构</strong><ul><li>一条主存总线：用于CPU,主存之间的数据传送</li><li>一条I/O总线：用于多个外部设备和通道之间的数据交换</li><li>DMA总线：用于内存和高速外设之间直接传送数据</li></ul></li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/174740219.png" alt="mark" style="zoom:50%;" /><ol start="4"><li><strong>四总线结构：目前的全局总线结构</strong></li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/174840821.png" alt="mark" style="zoom: 33%;" /><h2 id="3-总线的性能指标"><a href="#3-总线的性能指标" class="headerlink" title="3. 总线的性能指标"></a>3. 总线的性能指标</h2><ol><li><strong>周期，频率</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210620-154026785.png" alt="mark"></p><ol start="2"><li><strong>速度与带宽</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210620-154323354.png" alt="mark"></p><ol start="3"><li><strong>总线复用，串行和并行</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210620-154629564.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210620-154837611.png" alt="mark"></p><ul><li><strong>本节小结</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/175014715.png" alt="mark"></p><h2 id="4-总结仲裁"><a href="#4-总结仲裁" class="headerlink" title="4. 总结仲裁"></a>4. 总结仲裁</h2><ul><li>目的：解决多个主设备同时竞争总线控制权的问题</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/175836577.png" alt="mark" style="zoom:50%;" /><h3 id="4-1-集中仲裁方式"><a href="#4-1-集中仲裁方式" class="headerlink" title="4.1 集中仲裁方式"></a>4.1 集中仲裁方式</h3><p><strong>整体工作流程</strong></p><ol><li>主设备发出占用总线的请求</li><li>若多个主设备同时使用总线，则由控制器判优，按照一定的算法来使用总线</li><li>获得总线控制权的主设备开始传送数据</li></ol><ul><li><strong>链式查询方式</strong></li></ul><ol><li>部件离总线越近，其优先级越高</li><li>缺点对线路故障十分敏感</li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/180154252.png" alt="mark" style="zoom:50%;" /><ul><li><strong>计数器定时查询方式</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/180327489.png" alt="mark" style="zoom:50%;" /><ul><li><strong>独立请求方式</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/180436320.png" alt="mark" style="zoom:50%;" /><p><strong>小结：</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/180515110.png" alt="mark" style="zoom:67%;" /><h3 id="4-2-分布仲裁方式"><a href="#4-2-分布仲裁方式" class="headerlink" title="4.2 分布仲裁方式"></a>4.2 分布仲裁方式</h3><p><strong>特点：不需要中央仲裁器，每个主模块都有自己的仲裁号和仲裁器</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/180610484.png" alt="mark" style="zoom:50%;" /><h2 id="5-总线的操作和定时"><a href="#5-总线的操作和定时" class="headerlink" title="5. 总线的操作和定时"></a>5. 总线的操作和定时</h2><p><strong>总线定时：本质上就是双方交换数据传输过程的时间上的配合关系，主要有同步和异步两种基本的定时方式</strong></p><h3 id="5-1-总线传送数据4个阶段"><a href="#5-1-总线传送数据4个阶段" class="headerlink" title="5.1 总线传送数据4个阶段"></a>5.1 总线传送数据4个阶段</h3><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/181237125.png" alt="mark" style="zoom: 67%;" /><h3 id="5-2-同步定时方式"><a href="#5-2-同步定时方式" class="headerlink" title="5.2 同步定时方式"></a>5.2 同步定时方式</h3><ul><li><strong>系统采用统一的时钟周期来协调发送和接收方的数据定时关系</strong></li><li><strong>在一个总线周期中，发送方和接收方可以进行一次的数据传送</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/181427059.png" alt="mark"></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/181457435.png" alt="mark" style="zoom:67%;" /><h3 id="5-3-异步定时方式"><a href="#5-3-异步定时方式" class="headerlink" title="5.3 异步定时方式"></a>5.3 异步定时方式</h3><ul><li><strong>在异步定时方式中，没有统一的时钟信号</strong></li><li><strong>完全依靠传送双方的握手信号</strong></li><li><strong>主设备提出交换信息的 请求信号</strong></li><li><strong>从设备提出 回答信号</strong></li></ul><p>根据请求和回答吸纳后的撤销是否互锁，分为以下三种</p><ol><li>不互锁</li><li>半互锁</li><li>全互锁</li></ol><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/181805747.png" alt="mark" style="zoom: 67%;" /><h3 id="5-4-本章小结"><a href="#5-4-本章小结" class="headerlink" title="5.4 本章小结"></a>5.4 本章小结</h3><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/182049547.png" alt="mark" style="zoom:67%;" /><h2 id="6-总线标准"><a href="#6-总线标准" class="headerlink" title="6. 总线标准"></a>6. 总线标准</h2><h3 id="6-1-总线标准的基本概念"><a href="#6-1-总线标准的基本概念" class="headerlink" title="6.1 总线标准的基本概念"></a>6.1 总线标准的基本概念</h3><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/182156482.png" alt="mark" style="zoom:80%;" /><h3 id="6-2-总线标准的分类"><a href="#6-2-总线标准的分类" class="headerlink" title="6.2 总线标准的分类"></a>6.2 总线标准的分类</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/182234007.png" alt="mark"></p><ul><li><strong>有以下分类</strong><ol><li>系统总线</li><li>局部总线</li><li>显示总线</li><li>设备总线</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-10-总线&quot;&gt;&lt;a href=&quot;#计算机组成原理-10-总线&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-10-总线&quot;&gt;&lt;/a&gt;计算机组成原理-10-总线&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本章内容概览&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210713/172913587.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;总线&lt;/strong&gt;是一组能为多个部件分时共享的公共信息的传送线路&lt;ul&gt;
&lt;li&gt;分时和共享是总线的特点&lt;/li&gt;
&lt;li&gt;分时：同一时刻只允许有一个部件向总线发送信息&lt;/li&gt;
&lt;li&gt;共享：总线上可以挂接多个部件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-231-2的幂</title>
    <link href="http://zhuuu.work/2021/05/30/Leetcode/Leetcode-231-2%E7%9A%84%E5%B9%82/"/>
    <id>http://zhuuu.work/2021/05/30/Leetcode/Leetcode-231-2%E7%9A%84%E5%B9%82/</id>
    <published>2021-05-30T00:33:53.000Z</published>
    <updated>2021-05-29T20:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-231-2的幂"><a href="#Leetcode-231-2的幂" class="headerlink" title="Leetcode-231-2的幂"></a>Leetcode-231-<a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">2的幂</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</li><li>如果存在一个整数 <code>x</code> 使得 <code>n == 2^x</code> ，则认为 <code>n</code> 是 2 的幂次方。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：20 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 16</span><br><span class="line">输出：true</span><br><span class="line">解释：24 &#x3D; 16</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-位运算"><a href="#思路-：-位运算" class="headerlink" title="思路 ： 位运算"></a>思路 ： 位运算</h2><ul><li>一个数n 是 2的幂，当且仅当 n是正整数，并且 n的二进制表示中仅包含 1 个 1。</li><li><strong>因此我们可以考虑使用位运算，将<em>n</em> 的二进制表示中最低位的那个 1 提取出来，再判断剩余的数值是否为 0 即可。</strong><ul><li>下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。</li></ul></li></ul><ol><li><strong>第一个技巧是 ： n &amp; (n - 1) == 0</strong></li></ol><p>其中 &amp; 表示按位与运算。该位运算技巧可以直接将 <em>n</em> 二进制表示的最低位 1 移除，它的原理如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210530/040801441.png" alt="mark"></p><p><strong>因此，如果 n 是正整数并且n &amp; (n - 1) = 0，那么 <em>n</em> 就是 2 的幂。</strong></p><ol start="2"><li><strong>第二个技巧是：n &amp; (-n)</strong></li></ol><p><strong>其中 −<em>n</em> 是 n 的相反数，是一个负数。该位运算技巧可以直接获取 n二进制表示的最低位的 1。</strong></p><ul><li><strong>由于负数是按照补码规则在计算机中存储的，−<em>n</em> 的二进制表示为 n 的二进制表示的每一位取反再加上 1，</strong></li><li>因此它的原理如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210530/041055729.png" alt="mark"></p><ul><li>因此，如果 n 是正整数并且n &amp; (-n) = n，那么 n 就是 2 的幂。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; -n) == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(1)  </li><li>空间复杂度 ： O(1)  没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-231-2的幂&quot;&gt;&lt;a href=&quot;#Leetcode-231-2的幂&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-231-2的幂&quot;&gt;&lt;/a&gt;Leetcode-231-&lt;a href=&quot;https://leetcode-cn.com/problems/power-of-two/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2的幂&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。&lt;/li&gt;
&lt;li&gt;如果存在一个整数 &lt;code&gt;x&lt;/code&gt; 使得 &lt;code&gt;n == 2^x&lt;/code&gt; ，则认为 &lt;code&gt;n&lt;/code&gt; 是 2 的幂次方。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：20 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：24 &amp;#x3D; 16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 5：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-872-叶子相似的树</title>
    <link href="http://zhuuu.work/2021/05/21/Leetcode/Leetcode-872-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/"/>
    <id>http://zhuuu.work/2021/05/21/Leetcode/Leetcode-872-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/</id>
    <published>2021-05-21T08:02:24.000Z</published>
    <updated>2021-05-21T01:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-872-叶子相似的树"><a href="#Leetcode-872-叶子相似的树" class="headerlink" title="Leetcode-872-叶子相似的树"></a>Leetcode-872-<a href="https://leetcode-cn.com/problems/leaf-similar-trees/" target="_blank" rel="noopener">叶子相似的树</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <strong>叶值序列</strong> 。</p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-092542328.png" alt="mark" style="zoom:80%;" /></li><li><p>举个例子，如上图所示，给定一棵叶值序列为 <code>(6, 7, 4, 9, 8)</code> 的树。</p></li><li><p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 <em>叶相似</em> 的。</p></li><li><p>如果给定的两个根结点分别为 <code>root1</code> 和 <code>root2</code> 的树是叶相似的，则返回 <code>true</code>；否则返回 <code>false</code> 。</p></li></ul><a id="more"></a><p><strong>示例 1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-092619185.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 &#x3D; [3,5,1,6,2,9,8,null,null,7,4], root2 &#x3D; [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-092644802.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 &#x3D; [1,2,3], root2 &#x3D; [1,3,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">给定的两棵树可能会有 1 到 200 个结点。</span><br><span class="line">给定的两棵树上的值介于 0 到 200 之间。</span><br></pre></td></tr></table></figure><!--more--><h2 id="方法-：-DFS"><a href="#方法-：-DFS" class="headerlink" title="方法 ： DFS"></a>方法 ： DFS</h2><ul><li>可以使用深度优先搜索的方法得到一棵树的「叶值序列」。</li><li><strong>具体地，在深度优先搜索的过程中，我们总是先搜索当前节点的左子节点，再搜索当前节点的右子节点。</strong></li><li><strong>如果我们搜索到一个叶节点，就将它的值放入序列中。</strong></li><li><strong>在得到了两棵树分别的「叶值序列」后，我们比较它们是否相等即可。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建两个叶子节点顺序集：判断是否相同</span></span><br><span class="line">        List&lt;Integer&gt; seq1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root1,seq1);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; seq2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root2,seq2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seq1.equals(seq2); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. dfs逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,List&lt;Integer&gt; seq)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2.1 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            seq.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2 递归 : 满足先左后右的顺序</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left,seq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.right,seq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n1 + n2) 。 n1, n2分别是两棵树的节点个数。</p></li><li><p>空间复杂度：O(n1 + n2) 。空间复杂度主要取决于存储「叶值序列」的空间以及深度优先搜索的过程中需要使用的栈空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-872-叶子相似的树&quot;&gt;&lt;a href=&quot;#Leetcode-872-叶子相似的树&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-872-叶子相似的树&quot;&gt;&lt;/a&gt;Leetcode-872-&lt;a href=&quot;https://leetcode-cn.com/problems/leaf-similar-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;叶子相似的树&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 &lt;strong&gt;叶值序列&lt;/strong&gt; 。&lt;/p&gt;
&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-092542328.png&quot; alt=&quot;mark&quot; style=&quot;zoom:80%;&quot; /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举个例子，如上图所示，给定一棵叶值序列为 &lt;code&gt;(6, 7, 4, 9, 8)&lt;/code&gt; 的树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 &lt;em&gt;叶相似&lt;/em&gt; 的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果给定的两个根结点分别为 &lt;code&gt;root1&lt;/code&gt; 和 &lt;code&gt;root2&lt;/code&gt; 的树是叶相似的，则返回 &lt;code&gt;true&lt;/code&gt;；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1035-不相交的线</title>
    <link href="http://zhuuu.work/2021/05/21/Leetcode/Leetcode-1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/"/>
    <id>http://zhuuu.work/2021/05/21/Leetcode/Leetcode-1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/</id>
    <published>2021-05-21T07:02:24.000Z</published>
    <updated>2021-05-21T00:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1035-不相交的线"><a href="#Leetcode-1035-不相交的线" class="headerlink" title="Leetcode-1035-不相交的线"></a>Leetcode-1035-<a href="https://leetcode-cn.com/problems/uncrossed-lines/" target="_blank" rel="noopener">不相交的线</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</li><li>现在，可以绘制一些连接两个数字 <code>nums1[i]</code>和 <code>nums2[j]</code>的直线，这些直线需要同时满足满足：<ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul></li><li>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。</li></ul><p><strong>示例 1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-085111696.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,4,2], nums2 &#x3D; [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[1]&#x3D;4 到 nums2[2]&#x3D;4 的直线将与从 nums1[2]&#x3D;2 到 nums2[1]&#x3D;2 的直线相交。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [2,5,1,2,5], nums2 &#x3D; [10,5,2,1,5,2]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums1 &#x3D; [1,3,7,1,7,5], nums2 &#x3D; [1,9,2,5,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; nums1.length &lt;&#x3D; 500</span><br><span class="line">1 &lt;&#x3D; nums2.length &lt;&#x3D; 500</span><br><span class="line">1 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 2000</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>给定两个数组<code>nums1</code> 和  <code>nums2</code> ，当nums1[i] == nums2[j] 的时候，可以使用一条直接进行相连</p></li><li><p>假设一共绘制了k条不相交的直线 ，上述 k 条互不相交的直线分别连接了数组 nums1 和 nums2 中k对相等的元素，而且这 k对相等的元素在两个数组中的相对顺序是一致的</p></li><li><p><strong>因此，这k对相等元素组成的序列就是 两个数组的最长公共子序列</strong></p><ul><li>要计算最大的连线数量，即计算两个数组的最长公共子序列的长度</li><li>最长公共子序列问题是典型的二维动态规划问题。</li></ul></li></ul><h2 id="方法-：-动态规划"><a href="#方法-：-动态规划" class="headerlink" title="方法 ： 动态规划"></a>方法 ： 动态规划</h2><ul><li>最长公共子序列 ： <a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/</a></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-085740422.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本质就是最长公共子序列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化定义 </span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 边界条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;++j)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转移逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = nums1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> num2 = nums2[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(num1 == num2)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 != num2)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>],dp[i -<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 :    O(mn)</li><li>空间复杂度 ： O(mn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1035-不相交的线&quot;&gt;&lt;a href=&quot;#Leetcode-1035-不相交的线&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1035-不相交的线&quot;&gt;&lt;/a&gt;Leetcode-1035-&lt;a href=&quot;https://leetcode-cn.com/problems/uncrossed-lines/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不相交的线&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在两条独立的水平线上按给定的顺序写下 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; 中的整数。&lt;/li&gt;
&lt;li&gt;现在，可以绘制一些连接两个数字 &lt;code&gt;nums1[i]&lt;/code&gt;和 &lt;code&gt;nums2[j]&lt;/code&gt;的直线，这些直线需要同时满足满足：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums1[i] == nums2[j]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;且绘制的直线不与任何其他连线（非水平线）相交。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-085111696.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [1,4,2], nums2 &amp;#x3D; [1,2,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：可以画出两条不交叉的线，如上图所示。 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;但无法画出第三条不相交的直线，因为从 nums1[1]&amp;#x3D;4 到 nums2[2]&amp;#x3D;4 的直线将与从 nums1[2]&amp;#x3D;2 到 nums2[1]&amp;#x3D;2 的直线相交。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [2,5,1,2,5], nums2 &amp;#x3D; [10,5,2,1,5,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [1,3,7,1,7,5], nums2 &amp;#x3D; [1,9,2,5,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; nums1.length &amp;lt;&amp;#x3D; 500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; nums2.length &amp;lt;&amp;#x3D; 500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; nums1[i], nums2[i] &amp;lt;&amp;#x3D; 2000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>计组-09-CPU</title>
    <link href="http://zhuuu.work/2021/05/20/Compute_Organization/%E8%AE%A1%E7%BB%84-09-CPU/"/>
    <id>http://zhuuu.work/2021/05/20/Compute_Organization/%E8%AE%A1%E7%BB%84-09-CPU/</id>
    <published>2021-05-20T03:02:24.000Z</published>
    <updated>2021-06-19T13:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理–09-CPU"><a href="#计算机组成原理–09-CPU" class="headerlink" title="计算机组成原理–09-CPU"></a>计算机组成原理–09-CPU</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>CPU 具体是由 ： 控制器和运算器组成</strong></li><li><strong>本章总览：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-201406483.png" alt="mark"></p><a id="more"></a><h2 id="1-功能和结构"><a href="#1-功能和结构" class="headerlink" title="1. 功能和结构"></a>1. 功能和结构</h2><ul><li>具体功能如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-201751812.png" alt="mark"></p><ol><li><strong>指令控制</strong></li></ol><ul><li>完成取指令，分析指令和执行指令的操作</li></ul><ol start="2"><li><strong>操作控制</strong></li></ol><ul><li>一条指令往往由若干条操作信号组合实现，CPU把各种操作信号送到相应的部件</li></ul><ol start="3"><li><strong>时间控制</strong></li></ol><ul><li>对各种操作加以时间上的控制，时间控制要为每条指令按时间顺序提供控制信号</li></ul><ol start="4"><li><strong>数据加工</strong></li></ol><ul><li>对数据进行逻辑和算数运算</li></ul><ol start="5"><li><strong>中断处理</strong></li></ol><ul><li>对计算机过程中出现的异常和特殊请求进行处理</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-201954728.png" alt="mark"></p><h2 id="2-CPU的基本结构"><a href="#2-CPU的基本结构" class="headerlink" title="2. CPU的基本结构"></a>2. CPU的基本结构</h2><h3 id="2-1-运算器"><a href="#2-1-运算器" class="headerlink" title="2.1 运算器"></a>2.1 运算器</h3><ul><li>运算器收到控制器发送来的命令执行相应的操作<ul><li>算数逻辑单元（ALU）</li><li>暂存寄存器</li><li>累加寄存器（ACC）</li><li>通用寄存器组</li><li>程序状态寄存器（PSW）</li><li>移位器</li><li>计数器</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-202926374.png" alt="mark"></p><h3 id="2-2-控制器"><a href="#2-2-控制器" class="headerlink" title="2.2 控制器"></a>2.2 控制器</h3><ul><li><p><strong>控制器有硬布线和微程序控制器两种类型</strong></p></li><li><p>在控制器的控制下，运算器，存储器和输入输出设备才能称为一个整体</p></li><li><p><strong>控制器组成结构</strong></p><ul><li>程序计数器 (PC)</li><li>指令寄存器 (IR)</li><li>指令译码器</li><li>存储器地址寄存器（MAR）</li><li>存储器数据寄存器  (MDR)</li><li>时序系统</li><li>微操作信号发生器</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-203433520.png" alt="mark"></p></li></ul><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><ul><li><strong>将运算器和控制器合到一张图上</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-203637257.png" alt="mark"></p><ul><li><strong>CPU 从逻辑上看由四大模块组成</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-203833080.png" alt="mark" style="zoom:67%;" /><h2 id="3-指令的执行过程"><a href="#3-指令的执行过程" class="headerlink" title="3. 指令的执行过程"></a>3. 指令的执行过程</h2><ul><li>CPU 从主存中取出并且执行一条指令的时间叫做<strong>指令周期</strong></li><li>一个指令周期可能含有若干个时钟周期，<strong>时钟周期</strong>是CPU操作的最基本的时间单位</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-211458404.png" alt="mark" style="zoom:67%;" /><ul><li><strong>有以下几种指令周期</strong><ul><li>取指周期</li><li>间址周期</li><li>执行周期</li><li>中断周期</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-113241562.png" alt="mark" style="zoom:67%;" /><ul><li><strong>指令周期执行的流程</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-113450617.png" alt="mark" style="zoom:67%;" /><h3 id="3-1-取址周期"><a href="#3-1-取址周期" class="headerlink" title="3.1 取址周期"></a>3.1 取址周期</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-113719807.png" alt="mark"></p><h3 id="3-2-间址周期"><a href="#3-2-间址周期" class="headerlink" title="3.2 间址周期"></a>3.2 间址周期</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-113840235.png" alt="mark"></p><h3 id="3-3-执行周期"><a href="#3-3-执行周期" class="headerlink" title="3.3 执行周期"></a>3.3 执行周期</h3><ul><li>下文内容将详细介绍</li></ul><h3 id="3-4-中断周期"><a href="#3-4-中断周期" class="headerlink" title="3.4 中断周期"></a>3.4 中断周期</h3><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210521-115524212.png" alt="mark" style="zoom:67%;" /><p>注意：指令执行的方案有如下几种方式</p><ul><li>单指令周期</li><li>多指令周期</li><li>流水线方案 ： 指令之间可以并行的执行</li></ul><h2 id="4-数据通路"><a href="#4-数据通路" class="headerlink" title="4. 数据通路"></a>4. 数据通路</h2><h3 id="4-1-数据通路的功能"><a href="#4-1-数据通路的功能" class="headerlink" title="4.1 数据通路的功能"></a>4.1 数据通路的功能</h3><ul><li>数据在功能部件之间传送的路径被叫做是数据通路，路径上的部件称为数据通路部件</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210527-201100469.png" alt="mark"></p><h3 id="4-2-数据通路的结构"><a href="#4-2-数据通路的结构" class="headerlink" title="4.2 数据通路的结构"></a>4.2 数据通路的结构</h3><ul><li>单总线方式 ： 所有的寄存器的输入输出端都连接到一条公共通路上，存在冲突的现象</li><li>内部三总线方式 ： 连到不同的数据通路上</li><li>专用数据通路方式 ： 根据流动方向安排专用线路</li></ul><p><strong>下面以单总线为例子：注意数据的流向</strong></p><ul><li>寄存器之间的数据传送</li><li>主存和CPU之间的数据传送</li><li>执行算数逻辑运算</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210527-201310165.png" alt="mark" style="zoom:80%;" /><h2 id="5-控制器的功能和工作原理"><a href="#5-控制器的功能和工作原理" class="headerlink" title="5. 控制器的功能和工作原理"></a>5. 控制器的功能和工作原理</h2><ul><li>控制器是计算机系统的指挥中心，控制器的主要功能有：<ul><li>从主存中取出一条指令，并指出下一条指令在主存中的位置</li><li>对指令进行译码或者测试，产生相应的操作控制信号，以便启动规定的操作</li><li>指挥并控制CPU，主存，输入和输出设备之间的数据流动方向</li></ul></li></ul><h3 id="5-1-硬布线控制器"><a href="#5-1-硬布线控制器" class="headerlink" title="5.1 硬布线控制器"></a>5.1 硬布线控制器</h3><ul><li>首先对操作的指令进行译码的操作，指令的操作码决定了的那个了不同指令所需要完成的控制信号</li><li>时序系统产生的机器周期信号和节拍信号。</li><li>来自执行单元的反馈信息即标志。</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-194725825.png" alt="mark" style="zoom:80%;" /><h3 id="5-2-微程序控制器"><a href="#5-2-微程序控制器" class="headerlink" title="5.2 微程序控制器"></a>5.2 微程序控制器</h3><ul><li>微程序控制器采用存储逻辑进行实现，将微操作进行代码话<ul><li>设计思想：每条机器指令编写成一个微程序，每个微程序包含若干条指令</li><li>目前，大多数的计算机都采用微程序的设计控制</li></ul></li><li>微操作是计算机中最基本的，不可再分解的操作。</li><li>微命令是构成控制序列的最小单元，微命令是微操作的控制信号，微操作是微命令的执行过程。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-195441419.png" alt="mark"></p><ul><li><strong>微指令的操作格式</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-195750601.png" alt="mark"></p><ul><li><strong>微指令的编码方式</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-200105187.png" alt="mark"></p><p><strong>概念小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-200257470.png" alt="mark"></p><h2 id="6-指令流水线"><a href="#6-指令流水线" class="headerlink" title="6. 指令流水线"></a>6. 指令流水线</h2><ul><li>流水线技术只需要增加少量的硬件就能把计算机的运算速度提升几倍</li><li>目前是计算机中普通使用的并行处理技术</li></ul><ol><li><strong>指令流水的定义</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-201045142.png" alt="mark"></p><ol start="2"><li><strong>不同指令执行方式的处理时间</strong></li></ol><ul><li><strong>顺序执行</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-201132870.png" alt="mark"></p><ul><li><strong>一次重叠方式</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-201211174.png" alt="mark"></p><ul><li><strong>二次重叠方式</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-201319405.png" alt="mark"></p><ol start="2"><li><strong>时空图</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-201555413.png" alt="mark"></p><ol start="3"><li><strong>流水线的性能指标</strong></li></ol><ul><li><strong>吞吐率</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210619-212928120.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理–09-CPU&quot;&gt;&lt;a href=&quot;#计算机组成原理–09-CPU&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理–09-CPU&quot;&gt;&lt;/a&gt;计算机组成原理–09-CPU&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU 具体是由 ： 控制器和运算器组成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本章总览：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-201406483.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1738-找出第 K 大的异或坐标值</title>
    <link href="http://zhuuu.work/2021/05/19/Leetcode/Leetcode-1738-%E6%89%BE%E5%87%BA%E7%AC%AC%20K%20%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC/"/>
    <id>http://zhuuu.work/2021/05/19/Leetcode/Leetcode-1738-%E6%89%BE%E5%87%BA%E7%AC%AC%20K%20%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC/</id>
    <published>2021-05-19T07:02:24.000Z</published>
    <updated>2021-07-13T10:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1738-找出第-K-大的异或坐标值"><a href="#Leetcode-1738-找出第-K-大的异或坐标值" class="headerlink" title="Leetcode-1738-找出第 K 大的异或坐标值"></a>Leetcode-1738-<a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/" target="_blank" rel="noopener">找出第 K 大的异或坐标值</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p></li><li><p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足</p><p><code>0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 matrix[i][j]</code></p><p><code>（下标从 0 开始计数）执行异或运算得到。</code></p></li><li><p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（<strong><code>k</code> 的值从 1 开始计数</strong>）。</p></li><li><p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作</p></li></ul><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-092808313.png" alt="mark" style="zoom: 80%;" /><ul><li>因此我们可以使用「前缀和」这一技巧对按位异或运算的结果进行维护。<strong>由于本题中给定的矩阵matrix 是二维的，因此我们需要使用二维前缀和。</strong></li><li>二位前缀和 <code>pre(i,j) = pre(i - 1,j) ^ pre(i , j - 1) ^ pre(i - 1,j - 1) ^ matrix(i,j)</code></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-092927117.png" alt="mark" style="zoom:200%;" /><ul><li>下图给出了该二维前缀和递推式的可视化展示。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-093052019.png" alt="mark"></p><ul><li>因为当我们 <code>pre(i - 1,j)， pre(i , j - 1)</code> 进行按位异或运算后，由于对一个数异或等于本身<em>x</em>⊕<em>y</em>⊕<em>y</em>=x</li><li>因此<code>pre(i - 1, j - 1)</code> 对应区域的异或结果被抵消，我们需要将其补上，对位置 (i, j）的元素进行按位异或运算，这样就得到了 <em>pre</em>(<em>i</em>,<em>j</em>)。</li></ul><h2 id="方法一-：-排序-二维前缀和"><a href="#方法一-：-排序-二维前缀和" class="headerlink" title="方法一 ： 排序 + 二维前缀和"></a>方法一 ： 排序 + 二维前缀和</h2><ul><li>在得到了所有的二维前缀和之后，我们只需要找出其中第 <em>k</em> 大的元素即为答案。</li><li>这一步我们可以直接将<code>mn</code>个二维前缀和进行排序后返第 <em>k</em> 大的元素，也可以参考「<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/" target="_blank" rel="noopener">215. 数组中的第 K 个最大元素的官方题解</a>」中时间复杂度更低的做法。</li></ul><p><strong>细节：</strong></p><ul><li>在二维前缀和的计算过程中，如果我们正在计算首行或者首列，即 i=0或 j=0</li><li>此时<code>pre(i - 1, j - 1)</code>  的下标越界，因此我们可以使用一个<code>(m + 1) * （n + 1）</code>大小的二维矩阵，首行和首列空出来赋予默认值 0</li><li>并使用接下来的 m行和 n 列存储二维前缀和，这样就不必进行下标范围的判断了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 构造二维前缀和</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] pre = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];                <span class="comment">// 省去了下标越界</span></span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();   <span class="comment">// 方便排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                pre[i][j] = pre[i - <span class="number">1</span>][j] ^ pre[i][j - <span class="number">1</span>] ^ pre[i - <span class="number">1</span>][j - <span class="number">1</span>] ^ matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                results.add(pre[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 对前缀和进行排序 : 降序排序</span></span><br><span class="line">        Collections.sort(results,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b - a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回第k大</span></span><br><span class="line">        <span class="keyword">return</span> results.get(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(mnlog(mn))</code>。计算二维前缀和的时间复杂度为<code>O(mn)</code>，排序的时间复杂度为<code>O(mnlog(mn))</code>，因此总时间复杂度为 <code>O(mnlog(mn))。</code></p></li><li><p>空间复杂度：<code>O(mn)</code>，即为存储二维前缀和需要的空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1738-找出第-K-大的异或坐标值&quot;&gt;&lt;a href=&quot;#Leetcode-1738-找出第-K-大的异或坐标值&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1738-找出第 K 大的异或坐标值&quot;&gt;&lt;/a&gt;Leetcode-1738-&lt;a href=&quot;https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;找出第 K 大的异或坐标值&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给你一个二维矩阵 &lt;code&gt;matrix&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，矩阵大小为 &lt;code&gt;m x n&lt;/code&gt; 由非负整数组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;矩阵中坐标 &lt;code&gt;(a, b)&lt;/code&gt; 的 &lt;strong&gt;值&lt;/strong&gt; 可由对所有满足&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt;= a &amp;lt; m 且 0 &amp;lt;= j &amp;lt;= b &amp;lt; n 的元素 matrix[i][j]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;（下标从 0 开始计数）执行异或运算得到。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请你找出 &lt;code&gt;matrix&lt;/code&gt; 的所有坐标中第 &lt;code&gt;k&lt;/code&gt; 大的值（&lt;strong&gt;&lt;code&gt;k&lt;/code&gt; 的值从 1 开始计数&lt;/strong&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意：&lt;strong&gt;^&lt;/strong&gt; 表示 &lt;strong&gt;按位异或&lt;/strong&gt; 操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="异或" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1442-形成两个异或相等数组的三元组数目</title>
    <link href="http://zhuuu.work/2021/05/18/Leetcode/Leetcode-1442-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
    <id>http://zhuuu.work/2021/05/18/Leetcode/Leetcode-1442-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/</id>
    <published>2021-05-18T07:02:24.000Z</published>
    <updated>2021-05-19T01:14:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1442-形成两个异或相等数组的三元组数目"><a href="#Leetcode-1442-形成两个异或相等数组的三元组数目" class="headerlink" title="Leetcode-1442-形成两个异或相等数组的三元组数目"></a>Leetcode-1442-<a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给你一个整数数组 <code>arr</code> 。</p></li><li><p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p></li><li><p>a 和 b 定义如下：</p><p><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code><br><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></p><p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作</p></li><li><p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p></li></ul><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>用 ⊕ 表示按位异或运算。<ul><li>定义长度为 <em>n</em> 的数组 arr 的异或前缀和为</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-090205795.png" alt="mark"></p><ul><li>这是一个关于 S<em>*i</em> 的递推式，根据该递推式我们可以用 O(n)的时间得到数组 arr 的异或前缀和数组。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-090336923.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-090400746.png" alt="mark"></p><h2 id="方法一-：-二重循环"><a href="#方法一-：-二重循环" class="headerlink" title="方法一 ： 二重循环"></a>方法一 ： 二重循环</h2><ul><li>当等于<code>S_i = S_k+1</code> 时候，<code>[i + 1,k]</code> 中的任何一个j都是满足要求的，故枚举下标<code>i</code> 或者 下标<code>k</code> 即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 统计前缀和s[i]</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] ^ arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 若a = b ，那么 s[i] = s[k + 1], 即[i + 1,k] 中任意的j都是满足条件的</span></span><br><span class="line">        <span class="comment">// 所以二重循环枚举下标i或k</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>;k &lt; n;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[k + <span class="number">1</span>])&#123;</span><br><span class="line">                    ans += k - i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n^2)，其中 n 是数组 arr 的长度。</li><li>空间复杂度：O(n)。</li></ul><h2 id="方法二-：-一重循环"><a href="#方法二-：-一重循环" class="headerlink" title="方法二 ： 一重循环"></a>方法二 ： 一重循环</h2><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-090837233.png" alt="mark" style="zoom:150%;" /><ul><li><p>当遍历下标k的时候，我们需要知道所有满足<code>S_i = S_k+1</code> </p><ul><li>下标 i  出现的次数 = m</li><li>下标 i 的和</li></ul></li><li><p>这可以借助两个哈希表来做到, 在遍历下标 k 的同时</p><ul><li>一个哈希表统计<code>S_k</code> 的出现次数</li><li>另外一个统计<code>S_k</code>  的下标之和</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] ^ arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; total = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.containsKey(s[k + <span class="number">1</span>])) &#123;</span><br><span class="line">                ans += cnt.get(s[k + <span class="number">1</span>]) * k - total.get(s[k + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.put(s[k], cnt.getOrDefault(s[k], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            total.put(s[k], total.getOrDefault(s[k], <span class="number">0</span>) + k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>复杂度分析</strong><ul><li>时间复杂度：O(n)，其中 n 是数组 arr 的长度。</li><li>空间复杂度：O(n)。我们需要使用 O(n) 的空间存储两个哈希表。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1442-形成两个异或相等数组的三元组数目&quot;&gt;&lt;a href=&quot;#Leetcode-1442-形成两个异或相等数组的三元组数目&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1442-形成两个异或相等数组的三元组数目&quot;&gt;&lt;/a&gt;Leetcode-1442-&lt;a href=&quot;https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;形成两个异或相等数组的三元组数目&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现需要从数组中取三个下标 &lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; ，其中 &lt;code&gt;(0 &amp;lt;= i &amp;lt; j &amp;lt;= k &amp;lt; arr.length)&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a 和 b 定义如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]&lt;/code&gt;&lt;br&gt;&lt;code&gt;b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;^&lt;/strong&gt; 表示 &lt;strong&gt;按位异或&lt;/strong&gt; 操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请返回能够令 &lt;code&gt;a == b&lt;/code&gt; 成立的三元组 (&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; , &lt;code&gt;k&lt;/code&gt;) 的数目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="异或" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-993-二叉树的堂兄弟节点</title>
    <link href="http://zhuuu.work/2021/05/17/Leetcode/Leetcode-993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2021/05/17/Leetcode/Leetcode-993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/</id>
    <published>2021-05-17T07:52:53.000Z</published>
    <updated>2021-05-17T02:18:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-993-二叉树的堂兄弟节点"><a href="#Leetcode-993-二叉树的堂兄弟节点" class="headerlink" title="Leetcode-993-二叉树的堂兄弟节点"></a>Leetcode-993-<a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/" target="_blank" rel="noopener">二叉树的堂兄弟节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</li><li>如果二叉树的两个节点深度相同，但 <strong>父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</li><li>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</li><li>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</li></ul><p><strong>示例 1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210517/094222942.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4], x &#x3D; 4, y &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210517/094241324.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,4,null,5], x &#x3D; 5, y &#x3D; 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li><li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li></ul><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>要想判断两个节点 x 和 <em>y</em> 是否为堂兄弟节点，我们就需要求出这<strong>两个节点分别的「深度」以及「父节点」。</strong></li><li>因此，我们可以从根节点开始，对树进行一次遍历，在遍历的过程中维护「深度」以及「父节点」这两个信息。</li><li>当我们遍历到 x 或 y节点时，就将信息记录下来；当这两个节点都遍历完成了以后，我们就可以退出遍历的过程，判断它们是否为堂兄弟节点了。</li></ul><p>常见的遍历方法有两种：深度优先搜索和广度优先搜索。</p><h2 id="方法一-：-深度优先遍历"><a href="#方法一-：-深度优先遍历" class="headerlink" title="方法一 ： 深度优先遍历"></a>方法一 ： 深度优先遍历</h2><ul><li>我们只需要在深度优先搜索的递归函数中增加表示「深度」以及「父节点」的两个参数即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 记录x节点的信息</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    TreeNode xParent;</span><br><span class="line">    <span class="keyword">int</span> xDepth;</span><br><span class="line">    <span class="keyword">boolean</span> xFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 记录y节点的信息</span></span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    TreeNode yParent;</span><br><span class="line">    <span class="keyword">int</span> yDepth;</span><br><span class="line">    <span class="keyword">boolean</span> yFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断是否是堂兄弟节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCousins</span><span class="params">(TreeNode root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;                                             <span class="comment">// 对x赋值</span></span><br><span class="line">        <span class="keyword">this</span>.y = y;                                             <span class="comment">// 对y赋值</span></span><br><span class="line">        dfs(root,<span class="number">0</span>,<span class="keyword">null</span>);                                       <span class="comment">// 从root节点开始遍历</span></span><br><span class="line">        <span class="keyword">return</span> xDepth == yDepth &amp;&amp; xParent != yParent;          <span class="comment">// 父节点不同 深度相同（堂兄弟）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 深度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth,TreeNode parent)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 4.1 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 如果两个节点都找到了，就可以提前退出遍历</span></span><br><span class="line">        <span class="keyword">if</span>(node.val == x)&#123;</span><br><span class="line">            xParent = parent;</span><br><span class="line">            xDepth  = depth;</span><br><span class="line">            xFound  = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.val == y)&#123;</span><br><span class="line">            yParent = parent;</span><br><span class="line">            yDepth  = depth;</span><br><span class="line">            yFound  = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xFound &amp;&amp; yFound)&#123;                                 <span class="comment">// 即使不提前退出，对最坏情况下的时间复杂度也不会有影响</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3 中序遍历</span></span><br><span class="line">        dfs(node.left,depth + <span class="number">1</span>,node);</span><br><span class="line">        <span class="keyword">if</span>(xFound &amp;&amp; yFound)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.right,depth + <span class="number">1</span>,node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度：</strong>O(n)，其中 n 是树中的节点个数。在最坏情况下，我们需要遍历整棵树，时间复杂度为 O(n)。</li><li><strong>空间复杂度</strong>：O(n)，即为深度优先搜索的过程中需要使用的栈空间。<strong>在最坏情况下，树呈现链状结构</strong>，递归的深度为 O(n）。</li></ul><h2 id="方法二-：-广度优先搜索"><a href="#方法二-：-广度优先搜索" class="headerlink" title="方法二 ： 广度优先搜索"></a>方法二 ： 广度优先搜索</h2><ul><li>在广度优先搜索的过程中，每当我们从队首取出一个节点，它就会作为「父节点」</li><li>它就会作为「父节点」，将最多两个子节点放入队尾。<strong>因此，除了节点以外，我们只需要在队列中额外存储「深度」的信息即可。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 记录x节点的信息</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    TreeNode xParent;</span><br><span class="line">    <span class="keyword">int</span> xDepth;</span><br><span class="line">    <span class="keyword">boolean</span> xFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 记录y节点的信息</span></span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    TreeNode yParent;</span><br><span class="line">    <span class="keyword">int</span> yDepth;</span><br><span class="line">    <span class="keyword">boolean</span> yFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. BFS逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCousins</span><span class="params">(TreeNode root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; depthQueue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        depthQueue.offer(<span class="number">0</span>);</span><br><span class="line">        update(root, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 取出父节点，层序遍历判断是否满足条件</span></span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeQueue.poll();</span><br><span class="line">            <span class="keyword">int</span> depth = depthQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeQueue.offer(node.left);</span><br><span class="line">                depthQueue.offer(depth + <span class="number">1</span>);</span><br><span class="line">                update(node.left, node, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeQueue.offer(node.right);</span><br><span class="line">                depthQueue.offer(depth + <span class="number">1</span>);</span><br><span class="line">                update(node.right, node, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xFound &amp;&amp; yFound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xDepth == yDepth &amp;&amp; xParent != yParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 用来判断是否遍历到 x 或 y 的辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TreeNode node, TreeNode parent, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.val == x) &#123;</span><br><span class="line">            xParent = parent;</span><br><span class="line">            xDepth = depth;</span><br><span class="line">            xFound = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val == y) &#123;</span><br><span class="line">            yParent = parent;</span><br><span class="line">            yDepth = depth;</span><br><span class="line">            yFound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度</strong>：O(n)，其中 n是树中的节点个数。在最坏情况下，我们需要遍历整棵树，时间复杂度为 O(n)。</p></li><li><p><strong>空间复杂度</strong>：O(n)，即为广度优先搜索的过程中需要使用的队列空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-993-二叉树的堂兄弟节点&quot;&gt;&lt;a href=&quot;#Leetcode-993-二叉树的堂兄弟节点&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-993-二叉树的堂兄弟节点&quot;&gt;&lt;/a&gt;Leetcode-993-&lt;a href=&quot;https://leetcode-cn.com/problems/cousins-in-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树的堂兄弟节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在二叉树中，根节点位于深度 &lt;code&gt;0&lt;/code&gt; 处，每个深度为 &lt;code&gt;k&lt;/code&gt; 的节点的子节点位于深度 &lt;code&gt;k+1&lt;/code&gt; 处。&lt;/li&gt;
&lt;li&gt;如果二叉树的两个节点深度相同，但 &lt;strong&gt;父节点不同&lt;/strong&gt; ，则它们是一对&lt;em&gt;堂兄弟节点&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;我们给出了具有唯一值的二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，以及树中两个不同节点的值 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;只有与值 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 对应的节点是堂兄弟节点时，才返回 &lt;code&gt;true&lt;/code&gt; 。否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210517/094222942.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [1,2,3,4], x &amp;#x3D; 4, y &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210517/094241324.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [1,2,3,null,4,null,5], x &amp;#x3D; 5, y &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树的节点数介于 &lt;code&gt;2&lt;/code&gt; 到 &lt;code&gt;100&lt;/code&gt; 之间。&lt;/li&gt;
&lt;li&gt;每个节点的值都是唯一的、范围为 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;100&lt;/code&gt; 的整数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度优先搜索" scheme="http://zhuuu.work/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-LCP006-拿硬币</title>
    <link href="http://zhuuu.work/2021/05/17/Leetcode/Leetcode-LCP006-%E6%8B%BF%E7%A1%AC%E5%B8%81/"/>
    <id>http://zhuuu.work/2021/05/17/Leetcode/Leetcode-LCP006-%E6%8B%BF%E7%A1%AC%E5%B8%81/</id>
    <published>2021-05-17T03:02:24.000Z</published>
    <updated>2021-05-17T09:46:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-LCP006-拿硬币"><a href="#Leetcode-LCP006-拿硬币" class="headerlink" title="Leetcode-LCP006-拿硬币"></a>Leetcode-LCP006-<a href="https://leetcode-cn.com/problems/na-ying-bi/" target="_blank" rel="noopener">拿硬币</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。</span><br><span class="line"></span><br><span class="line">输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n &#x2F; m，且n, m最大公约数为1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[4,2,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,3,10]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= n &lt;= 4</code></li><li><code>1 &lt;= coins[i] &lt;= 10</code></li></ul></li></ul><a id="more"></a><h2 id="算法思路：模拟"><a href="#算法思路：模拟" class="headerlink" title="算法思路：模拟"></a>算法思路：模拟</h2><ul><li><p>有 n 堆硬币，每次从任意一堆拿走一枚或者两枚。问最少几次能够全部拿完。</p></li><li><p>题目中虽然给了 n 堆硬币，但是最终每一堆都是要拿完的。而每一堆拿的情况又不影响其他硬币堆，<strong>因此每一堆硬币的拿法实际上是互相独立的</strong>。</p></li><li><p>于是我们可以<strong>只考虑一堆的情况。</strong></p><ul><li><strong>假设一堆有 x 枚硬币，既然我们的目的是尽早拿完所有硬币堆，那么两枚两枚的拿显然是更快的。</strong></li><li>求单堆硬币最小次数：<code>(x+1)//2</code></li></ul></li><li><p>那么，拿完所有硬币堆只需要循环对所有硬币堆都计算一次，然后求和就可以了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 统计需要的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 每堆硬币拿走的次数为(coin + 1) //2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin: coins)&#123;</span><br><span class="line">            count += (coin + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O<em>(</em>n)。</li><li>空间复杂度：O<em>(</em>n*)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-LCP006-拿硬币&quot;&gt;&lt;a href=&quot;#Leetcode-LCP006-拿硬币&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-LCP006-拿硬币&quot;&gt;&lt;/a&gt;Leetcode-LCP006-&lt;a href=&quot;https://leetcode-cn.com/problems/na-ying-bi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;拿硬币&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;桌上有 &lt;code&gt;n&lt;/code&gt; 堆力扣币，每堆的数量保存在数组 &lt;code&gt;coins&lt;/code&gt; 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n &amp;#x2F; m，且n, m最大公约数为1。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[4,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[2,3,10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= coins[i] &amp;lt;= 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>图像学-色彩空间</title>
    <link href="http://zhuuu.work/2021/05/16/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2021/05/16/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/</id>
    <published>2021-05-16T09:38:38.000Z</published>
    <updated>2021-05-16T03:10:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-色彩空间"><a href="#图像学-色彩空间" class="headerlink" title="图像学-色彩空间"></a>图像学-色彩空间</h1><ul><li>作为摄影师，你是不是遇到过这样的问题：相机设置里的色彩空间是什么意思？ sRGB 和 Adobe RGB 有什么不同？为什么我的图片在 Photoshop 里看着好好的，一保存发布到网上色彩就变了？</li><li>本篇文章将分为几个部分。首先从几个实验规律出发，借助线性代数相关的概念，定义色彩空间，然后介绍并推导几个重要的色彩空间之间的关系。</li></ul><h2 id="1-实验基础"><a href="#1-实验基础" class="headerlink" title="1. 实验基础"></a>1. 实验基础</h2><ul><li><p>相信大家都熟悉「三原色」理论，也知道现代显示器是按照 RGB 模式来显示色彩，不知道有没有想过，为什么是「三原色」？为什么是「三」这个数字？为什么一定要选择 RGB 红绿蓝三种颜色作为原色呢？选其他行不行？用四种颜色行不行？</p></li><li><p>知乎上有个问题 <a href="https://www.zhihu.com/question/24886171" target="_blank" rel="noopener">红绿蓝三色是（唯一的）正交基吗？</a> 就提出了这个疑问</p></li><li><p>追根溯源的话，得从我们人类的<strong>视网膜说起。大部分人类的视网膜上有三种感知颜色的感光细胞，叫做视锥细胞，分别对不同波长的光线敏感，称为 L/M/S 型细胞</strong>。三种视锥细胞最敏感的波长分别是橙红色（长波，Long），绿色（中波，Medium），蓝色（短波，Short）。这三种视锥细胞的归一化感光曲线如下图所示（图片数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk/">CVLR</a> ）</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/154904307.png" alt="mark"></p><hr><p>可以看到 L 型视锥细胞与 M 型视锥细胞的感光曲线差别很小，实际上这两种视锥细胞起源于一次基因变异，在这之前人类可都是红绿色盲呢，多亏这个基因变异，让人类可以看到更加多彩的世界——这又是一个庞大的话题了，就此打住。</p><p>总之，大自然的这千千万万种颜色，在人类的眼里看到，最后传送到大脑里的信号，就只有这三种视锥细胞的电信号而已。根据这三种电信号的强弱，大脑解读成了不同的颜色。这就是三原色理论的生物学依据。</p><hr><ul><li><p>不仅如此，人类眼睛对不同颜色光线混合的反应还是 <strong>线性</strong> 的。</p></li><li><p>根据 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Grassmann%27s_law_(optics)">格拉斯曼定律（Grassmann’s Law）</a>，两束不同颜色的光 <img src="https://www.zhihu.com/equation?tex=C_1" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=C_2" alt="[公式]">，假设某个视锥细胞对他们的反应分别是 <img src="https://www.zhihu.com/equation?tex=r_1" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=r_2" alt="[公式]">，现在将他们按照一个比例混合，得到第三种颜色 <img src="https://www.zhihu.com/equation?tex=C_3+%3D+%5Calpha+C_1+%2B+%5Cbeta+C_2" alt="[公式]">，那么视锥细胞对这个混合颜色的反应也将是前两个反应的线性叠加 <img src="https://www.zhihu.com/equation?tex=r_3+%3D+%5Calpha+r_1+%2B+%0A%5Cbeta+r_2" alt="[公式]">。</p></li><li><p>格拉斯曼定律是一个实验规律，并没有物理或者生物学上的依据。然而这个规律大大简化了我们对人类彩色视觉系统的建模，并且给我们使用线性代数理论分析人类彩色视觉系统提供了一个前提和基础。</p></li></ul><a id="more"></a><h2 id="2-色匹配函数"><a href="#2-色匹配函数" class="headerlink" title="2. 色匹配函数"></a>2. 色匹配函数</h2><ul><li>前面已经提到，人类视网膜上有三种感知色彩的视锥细胞，所以理论上我们用三种颜色的光就可以混合出自然界中任何一种颜色来。</li><li>在 20 世纪 20 年代，David Wright 和 John Guild 各自独立地领导了一些实验，通过三种颜色的光源进行匹配，得到了人眼对于不同颜色光的匹配函数。此后，多名科学家多次进行了类似的实验，加深了我们对人类彩色视觉的认识。</li></ul><p>实验过程大致是这样的，把一个屏幕用不透光的挡板分割成两个区域，左边照射某个被测试的颜色的光线，这里记为<img src="https://www.zhihu.com/equation?tex=C" alt="[公式]"> （以下用大写字母表明颜色，用小写字母表明分量大小），右边同时用三种颜色的光同时照射，这里记为<img src="https://www.zhihu.com/equation?tex=R" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=G" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=B" alt="[公式]">)。然后，调节右边三种颜色光源的强度，直到左右两边的颜色看上去一样为止。假设这个时候三种颜色的光源强度分别为<img src="https://www.zhihu.com/equation?tex=r" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=g" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=b" alt="[公式]">，那么根据光色叠加的线性性质，我们可以写出</p><p><img src="https://www.zhihu.com/equation?tex=C+%3D+rR+%2B+gG+%2B+bB" alt="[公式]"></p><p>也就是说，只要按照 (r,g,b) 的分量来混合 (R,G,B) 三种颜色的光，就可以得到 C 这个颜色的光。</p><hr><ul><li><p>于是在这一系列实验里，科学家们把左边的颜色按着光谱顺序，挨个测试了一遍，得到了纯光谱色的混合叠加的数据，这就是 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/CIE_1931_color_space%23/Color_matching_functions">色匹配函数（Color Matching Function）</a> ，并且在这个基准下定义的色彩空间，就是 CIE RGB 色彩空间。</p></li><li><p>图是 CIE RGB 的色匹配函数曲线，数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk">CVLR</a>。浅色的细线代表实验中不同参与者个人的色匹配函数曲线，中间深色的粗线代表数据的平均值。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/161352290.png" alt="mark"></p><ul><li><p>可以看到，曲线上出现了负数，这是怎么回事？</p><ul><li>回想一下前面描述的实验过程，左边是被测试的光色，右边是可调节的三色光的混合。如果碰到一种情况，右边三色光无论如何调节比例，都不能混合出左边的颜色</li><li>比如某种颜色的光强度已经减小为 0 了，然而看趋势还需要继续减小才能与左边的光色相匹配，怎么办？</li><li>这时候需要往左边的光色中混入三色光中的一种或者几种，继续调节，直到两边的颜色匹配。</li><li>在左边（被测试）的色光中添加，那就是相当于在右边的混合光中减去，这就导致了色匹配函数曲线上出现了负数。实际上，这相当于就是光线的「减法」了。</li></ul></li><li><p>比如，对于 555nm 的黄色光，色匹配函数的值是 (1.30, 0.97, -0.01)，意味着将 1.30 份的红光与 0.97 份的绿光混合放在右边，左边放上 1 份的 555nm 的黄光，以及 0.01 份的蓝光，这样左右两边的光色看上去就一样了。</p></li></ul><hr><ul><li>因为有部分出现了负数，在使用和计算上都有不方便，因此就对这个匹配函数进行了一下线性变换，变换到一个所有分量都是正的空间中。</li><li>变换后的色彩空间就是 CIE XYZ 色彩空间。 图片数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk">CVLR</a>，</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/161910992.png" alt="mark"></p><ul><li>CIE RGB 色彩空间和 CIE XYZ 色彩空间是完全等价的，两者只是差了一个线性变换。由于允许「减法」的存在，因此 CIE RGB 空间是能够表示所有颜色的；同样的，CIE XYZ 空间也能。</li></ul><h2 id="3-从线性空间的角度理解色彩空间"><a href="#3-从线性空间的角度理解色彩空间" class="headerlink" title="3. 从线性空间的角度理解色彩空间"></a>3. 从线性空间的角度理解色彩空间</h2><ul><li>以上的实验基础提示我们，色彩空间和线性代数中的线性空间之间具有某种相似性。我们可以看到，由于人类有三种感知色彩的视锥细胞，自然界千千万万的色彩被眼睛接收后，可以用三个数值来表征。</li><li>而格拉斯曼定律也揭示了色彩叠加的线性性质。<strong>这似乎意味着，色彩空间就是一个 3 维的线性空间。事实上也的确如此</strong>（详细的论证参见末尾小节）。</li></ul><hr><ul><li><p>自然界本身是没有「颜色」这个属性的，只有对不同波长光线的反射率/透过率，到达人眼中的，显然是一个连续的光谱分布函数。数学上，这是一个无穷维的函数空间（巴拿赫空间）。</p><ul><li>而人眼内的三种视锥细胞，它们的感光特性曲线相当于是在这个无穷维的函数空间中建立了三个基底。任何一个光谱分布进来，三种视锥细胞被激发。由于色视觉响应的线性性，这一过程相当于光谱分布函数与三个基底做内积，或者说，「投影」到这三个基底上。</li></ul></li><li><p><strong>从这个观点看，人类的色视觉，是相当于在自然界所有颜色的无穷维函数空间中取了一个三维的投影。这个三维空间的基底，既可以是视锥细胞的感光特性曲线（我们的大脑就用的是这套），当然也可以是选取三种颜色的光进行组合（CIE RGB 空间），甚至还可以是用实际中不存在的「光线」进行组合 （CIE XYZ 空间）。</strong></p><ul><li><strong>既然这几个空间实际上是同一个线性空间，只不过由于选择了不同的基底而有不同的表达形式，那么根据线性代数的结论，这几个空间的表述形式之间，只需要通过矩阵乘法就可以完成转换，这是完全的线性变换。</strong></li><li>当然，色彩空间并不是真正数学意义上的三维线性空间。由于不存在真正数学意义的「减法」，在实际应用中是有所限制的。数学中的「线性组合」在这里就要被替换为「锥组合」，也就是每个分量都必须是大于等于 0 的。</li></ul></li></ul><hr><ul><li>至此我们终于可以回答开头的部分问题了，<strong>为什么是三原色？因为人类对色彩的感知结果位于一个三维的线性空间中。最少需要三种颜色的光才能有足够的表达能力来表现各种颜色。</strong></li><li>为什么选 RGB 作为三原色？因为色彩空间不是真正数学意义上的线性空间，从工程角度考虑，以 RGB 作为三原色，能让显示器能够显示更多的颜色（此外，最初测试人眼对 RGB 三色光的色匹配曲线，也是希望能尽量单独地刺激三种视锥细胞）。</li></ul><h2 id="4-设备相关的RGB色彩空间"><a href="#4-设备相关的RGB色彩空间" class="headerlink" title="4. 设备相关的RGB色彩空间"></a>4. 设备相关的RGB色彩空间</h2><ul><li><p>如前文所述，色彩空间的基底的选择有一定的任意性。事实上，如果允许真正的减法存在，那么选择哪三种颜色作为基底是无关紧要的。不过由于实际中我们不能对色光采用减法，只能使用「锥组合」而非「线性组合」，这时候到底如何选取基底就显得重要了。好的基底不仅能表达的颜色更丰富，而且工程上也易于稳定地实现。</p></li><li><p>由于 CIE XYZ 空间是一个很方便的线性空间，与具体设备无关，因此常用来做各种颜色空间转换的中间媒介。设想某个颜色的光，经过色匹配函数的计算，得到了三个 XYZ 的值，如果直接将这三个值作为 RGB 颜色显示到屏幕上，显然是不对的。我们必须把 XYZ 的值转换到屏幕的 RGB 空间中的值。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A++++++++R_%7B%5Ctext%7Blin%7D%7D+%5C%5C+G_%7B%5Ctext%7Blin%7D%7D+%5C%5C+B_%7B%5Ctext%7Blin%7D%7D%0A++++%5Cend%7Barray%7D%5Cright%5D+%3D+%0A++++%5Cboldsymbol%7BM%7D%0A++++%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A++++++++X+%5C%5C+Y+%5C%5C+Z%0A++++%5Cend%7Barray%7D%5Cright%5D" alt="[公式]"></p></li></ul><p>这里下标 lin 代表线性空间，<img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7BM%7D" alt="[公式]"> 是转换矩阵。得到线性 RGB 空间的表达之后，还需要经过 gamma 校正，才是最终在屏幕上显示的 RGB 的值。一般的 gamma 校正过程为 <img src="https://www.zhihu.com/equation?tex=C+%3D+%5Ctextstyle+C%5E%7B1%2F%5Cgamma%7D_%7B%5Ctext%7Blin%7D%7D" alt="[公式]">，其中 <img src="https://www.zhihu.com/equation?tex=C" alt="[公式]"> 代表 RGB 的某个分量，<img src="https://www.zhihu.com/equation?tex=%5Cgamma" alt="[公式]"> 值通常为 2.2。对于如何计算的细节，我希望在 <a href="https://zhuanlan.zhihu.com/p/24281841" target="_blank" rel="noopener">下一篇文章</a> 中进行详细说明。</p><ul><li>对于 RGB 色彩空间来说，关键点在于两个：<ul><li><strong>如何选择三个作为基底的颜色；</strong></li><li><strong>如何定义白色</strong>。一旦选好这两个关键参数，那么从 CIE XYZ 空间到设备的 RGB 空间的转换就完全确定了。我们平时常说的 sRGB 空间和 Adobe RGB 空间，他们的区别就在于这两个关键参数的定义不同。常用的的 RGB 空间的转换矩阵如下表：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/164118772.png" alt="mark"></p><p>不同的 RGB 空间能表示的范围如下图所示（这个图在 <a href="https://zhuanlan.zhihu.com/p/24281841" target="_blank" rel="noopener">以后的文章</a> 中再详细解释），</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/164151141.png" alt="mark"></p><ul><li><p>可以看到，不同的 RGB 空间所能表示的颜色范围是不一样的，并且我们可以推断出，即使是同样的 RGB 分量，在不同的 RGB 空间中所代表的颜色也是不一样的。所以我们在描述一个 RGB 颜色的时候，<strong>不仅需要描述它的 RGB 三个分量，还要说明是在哪个空间，这就是 ICC 文件的作用。</strong></p></li><li><p><strong>很多数码相机都可以设置色彩空间，常见的有 sRGB 和 Adobe RGB</strong></p><ul><li>从上面的图中我们可以看到， Adobe RGB 所能表达的色彩比 sRGB 要丰富很多。然而常见的网络环境下图片的色彩空间是 sRGB，有很多浏览器不能正确地解析图片自带的色彩空间说明，默认按照 sRGB 来进行解析。</li><li>如果使用相机直出的 JPG 文件直接上传，或者说在后期处理过程中没有进行色彩空间转换，保留了相机设置的 Adobe RGB 空间，那么在浏览器中看到的图片很可能与 Photoshop 中看到的不一样。</li><li>浏览器很可能会将一张 Adobe RGB 空间中的图片解释为 sRGB 空间下的图片，引起颜色偏差。<strong>由于 sRGB 是目前屏幕显示的「事实标准」</strong>，大多数屏幕空间都在 sRGB 内（这是颜色复现设备本身决定的），所以我的建议是，对用于网络交流目的的图片，统一转换到 sRGB 中进行保存。</li></ul></li></ul><h2 id="5-数学论证"><a href="#5-数学论证" class="headerlink" title="5. 数学论证"></a>5. 数学论证</h2><p>回顾一下线性代数中构成线性空间的几个要素：</p><blockquote><p>交换律：<img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%2B%5Cboldsymbol%7By%7D+%3D+%5Cboldsymbol%7By%7D%2B%5Cboldsymbol%7Bx%7D" alt="[公式]"></p><p>结合律：<img src="https://www.zhihu.com/equation?tex=%28%5Cboldsymbol%7Bx%7D%2B%5Cboldsymbol%7By%7D%29%2B%5Cboldsymbol%7Bz%7D+%3D+%0A%5Cboldsymbol%7Bx%7D%2B%28%5Cboldsymbol%7By%7D%2B%5Cboldsymbol%7Bz%7D%29" alt="[公式]"></p></blockquote><p>这两条容易理解，显然，交换不同色光叠加的顺序并不会改变叠加的结果。</p><blockquote><p>加法零元：<img src="https://www.zhihu.com/equation?tex=%5Cexists+%5C%3A+%5Cboldsymbol%7B0%7D%2C%5C%3B+%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B+%5Cboldsymbol%7Bx%7D+%2B+%5Cboldsymbol%7B0%7D+%3D+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>这一点也很好理解，加法零元就是全黑，什么光都没有。任何一种色光叠加一个全黑那还是它自身。</p><blockquote><p>加法逆元：<img src="https://www.zhihu.com/equation?tex=%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%5Cexists+%5C%3A+%28-%5Cboldsymbol%7Bx%7D%29%2C%5C%3B+%0A%5Cboldsymbol%7Bx%7D+%2B+%28-%5Cboldsymbol%7Bx%7D%29+%3D+%5Cboldsymbol%7B0%7D" alt="[公式]"></p></blockquote><p>回想前文对实验中需要「负数」数量的光的处理手法，我们可以在左边叠加光线，这就相当于在右边减去光线。如果承认这种形式的「减法」，那么加法逆元也是顺理成章了：在另一边加入自身。</p><blockquote><p>乘法幺元：<img src="https://www.zhihu.com/equation?tex=%5Cexists+%5C%3A+1%2C%5C%3B+%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%0A1%5Ccdot%5Cboldsymbol%7Bx%7D+%3D+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>这也很明显，数字 1 就可以作为乘法幺元。</p><blockquote><p>乘法分配率：<br><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Cboldsymbol%7Bx%7D%2C+%5C%3A+%5Cboldsymbol%7By%7D%2C+%5C%3A+%5Calpha%2C%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B%5Calpha%5C%2C%28%5Cboldsymbol%7Bx%7D+%2B+%5Cboldsymbol%7By%7D%29+%3D+%5Calpha+%5Cboldsymbol%7Bx%7D+%2B+%0A%5Calpha+%5Cboldsymbol%7By%7D" alt="[公式]"><br><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5C%3A%5Cbeta%2C%5C%3A%5Cboldsymbol%7Bx%7D%2C%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B+%28%5Calpha%2B%5Cbeta%29%5C%2C%5Cboldsymbol%7Bx%7D+%3D+%0A%5Calpha+%5Cboldsymbol%7Bx%7D+%2B+%5Cbeta+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>根据格拉斯曼定律，这一点也是实际上成立的。</p><p>综上所述，人类对色彩的感知在实验层面满足线性性质，人眼感知的色彩空间是一个 3 维线性空间。当然，容易想见，通常我们选取的基底（比如 CIE XYZ 空间的色匹配函数），是不正交的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-色彩空间&quot;&gt;&lt;a href=&quot;#图像学-色彩空间&quot; class=&quot;headerlink&quot; title=&quot;图像学-色彩空间&quot;&gt;&lt;/a&gt;图像学-色彩空间&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;作为摄影师，你是不是遇到过这样的问题：相机设置里的色彩空间是什么意思？ sRGB 和 Adobe RGB 有什么不同？为什么我的图片在 Photoshop 里看着好好的，一保存发布到网上色彩就变了？&lt;/li&gt;
&lt;li&gt;本篇文章将分为几个部分。首先从几个实验规律出发，借助线性代数相关的概念，定义色彩空间，然后介绍并推导几个重要的色彩空间之间的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-实验基础&quot;&gt;&lt;a href=&quot;#1-实验基础&quot; class=&quot;headerlink&quot; title=&quot;1. 实验基础&quot;&gt;&lt;/a&gt;1. 实验基础&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相信大家都熟悉「三原色」理论，也知道现代显示器是按照 RGB 模式来显示色彩，不知道有没有想过，为什么是「三原色」？为什么是「三」这个数字？为什么一定要选择 RGB 红绿蓝三种颜色作为原色呢？选其他行不行？用四种颜色行不行？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎上有个问题 &lt;a href=&quot;https://www.zhihu.com/question/24886171&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;红绿蓝三色是（唯一的）正交基吗？&lt;/a&gt; 就提出了这个疑问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;追根溯源的话，得从我们人类的&lt;strong&gt;视网膜说起。大部分人类的视网膜上有三种感知颜色的感光细胞，叫做视锥细胞，分别对不同波长的光线敏感，称为 L/M/S 型细胞&lt;/strong&gt;。三种视锥细胞最敏感的波长分别是橙红色（长波，Long），绿色（中波，Medium），蓝色（短波，Short）。这三种视锥细胞的归一化感光曲线如下图所示（图片数据来自 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk/&quot;&gt;CVLR&lt;/a&gt; ）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/154904307.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;可以看到 L 型视锥细胞与 M 型视锥细胞的感光曲线差别很小，实际上这两种视锥细胞起源于一次基因变异，在这之前人类可都是红绿色盲呢，多亏这个基因变异，让人类可以看到更加多彩的世界——这又是一个庞大的话题了，就此打住。&lt;/p&gt;
&lt;p&gt;总之，大自然的这千千万万种颜色，在人类的眼里看到，最后传送到大脑里的信号，就只有这三种视锥细胞的电信号而已。根据这三种电信号的强弱，大脑解读成了不同的颜色。这就是三原色理论的生物学依据。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不仅如此，人类眼睛对不同颜色光线混合的反应还是 &lt;strong&gt;线性&lt;/strong&gt; 的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Grassmann%27s_law_(optics)&quot;&gt;格拉斯曼定律（Grassmann’s Law）&lt;/a&gt;，两束不同颜色的光 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C_1&quot; alt=&quot;[公式]&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C_2&quot; alt=&quot;[公式]&quot;&gt;，假设某个视锥细胞对他们的反应分别是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_1&quot; alt=&quot;[公式]&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_2&quot; alt=&quot;[公式]&quot;&gt;，现在将他们按照一个比例混合，得到第三种颜色 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C_3+%3D+%5Calpha+C_1+%2B+%5Cbeta+C_2&quot; alt=&quot;[公式]&quot;&gt;，那么视锥细胞对这个混合颜色的反应也将是前两个反应的线性叠加 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_3+%3D+%5Calpha+r_1+%2B+%0A%5Cbeta+r_2&quot; alt=&quot;[公式]&quot;&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;格拉斯曼定律是一个实验规律，并没有物理或者生物学上的依据。然而这个规律大大简化了我们对人类彩色视觉系统的建模，并且给我们使用线性代数理论分析人类彩色视觉系统提供了一个前提和基础。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-690-员工的重要性</title>
    <link href="http://zhuuu.work/2021/05/16/Leetcode/Leetcode-690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <id>http://zhuuu.work/2021/05/16/Leetcode/Leetcode-690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</id>
    <published>2021-05-16T08:22:53.000Z</published>
    <updated>2021-05-16T03:47:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-690-员工的重要性"><a href="#Leetcode-690-员工的重要性" class="headerlink" title="Leetcode-690-员工的重要性"></a>Leetcode-690-<a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">员工的重要性</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id</strong> ，<strong>重要度</strong> 和 <strong>直系下属的 id</strong> 。</p><p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。</p><p>那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。</p><p>注意虽然员工 3 也是员工 1 的一个下属，但是由于 <strong>并不是直系</strong> 下属，因此没有体现在员工 1 的数据结构中。</p><ul><li>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出：11</span><br><span class="line">解释：</span><br><span class="line">员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 &#x3D; 11 。</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-690-员工的重要性&quot;&gt;&lt;a href=&quot;#Leetcode-690-员工的重要性&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-690-员工的重要性&quot;&gt;&lt;/a&gt;Leetcode-690-&lt;a href=&quot;https://leetcode-cn.com/problems/employee-importance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;员工的重要性&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个保存员工信息的数据结构，它包含了员工 &lt;strong&gt;唯一的 id&lt;/strong&gt; ，&lt;strong&gt;重要度&lt;/strong&gt; 和 &lt;strong&gt;直系下属的 id&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。&lt;/p&gt;
&lt;p&gt;那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。&lt;/p&gt;
&lt;p&gt;注意虽然员工 3 也是员工 1 的一个下属，但是由于 &lt;strong&gt;并不是直系&lt;/strong&gt; 下属，因此没有体现在员工 1 的数据结构中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 &amp;#x3D; 11 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="BFS" scheme="http://zhuuu.work/tags/BFS/"/>
    
      <category term="DFS" scheme="http://zhuuu.work/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-012-整数转罗马数字</title>
    <link href="http://zhuuu.work/2021/05/14/Leetcode/Leetcode-012-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://zhuuu.work/2021/05/14/Leetcode/Leetcode-012-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2021-05-14T03:02:24.000Z</published>
    <updated>2021-05-14T01:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-012-整数转罗马数字"><a href="#Leetcode-012-整数转罗马数字" class="headerlink" title="Leetcode-012-整数转罗马数字"></a>Leetcode-012-<a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">整数转罗马数字</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br></pre></td></tr></table></figure><ul><li>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 3999</code></li></ul><a id="more"></a><h2 id="方法一-：-贪心算法"><a href="#方法一-：-贪心算法" class="headerlink" title="方法一 ： 贪心算法"></a>方法一 ： 贪心算法</h2><ul><li>罗马数字由 7 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 6 个复合符号。</li><li>这给了我们总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成），如下图所示。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-091632912.png" alt="mark"></p><p><strong>罗马数字的唯一表示法</strong></p><ul><li>从一个例子入手。考虑 140 的罗马数字表示，下面哪一个是正确的？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-091654117.png" alt="mark"></p><ul><li>确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。<ul><li>对于 140，最大可以选择的符号值为 C=100。</li><li>接下来，对于剩余的数字 40，最大可以选择的符号值为 XL=40</li><li>因此，140 的对应的罗马数字为 <code>C+XL=CXL</code></li></ul></li></ul><p><strong>算法实现</strong></p><ul><li>根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，<ul><li>将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值，</li><li>将该符号拼接在上一个找到的符号之后，</li><li>循环直至 num 为 0。</li><li>最后得到的字符串即为 num 的罗马数字表示。</li></ul></li><li>编程时，可以建立一个数值-符号对的列表 <em>valueSymbols</em>，按数值从大到小排列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 编程时，可以建立一个数值-符号对的列表 valueSymbols，按数值从大到小排列。</span><br><span class="line">int[] values &#x3D; &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">String[] symbols &#x3D; &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>遍历<em>valueSymbols</em> 中的每个数值-符号对，</p></li><li><p>若当前数值value 不超过 num，则从 num 中不断减去 value，直至num 小于 value</p></li><li><p>然后遍历下一个数值-符号对。若遍历中 num为 0 则跳出循环。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 编程时，可以建立一个数值-符号对的列表 valueSymbols，按数值从大到小排列。</span></span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String[] symbols = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 寻找罗马数字的唯一表示法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuffer roman = <span class="keyword">new</span> StringBuffer();            <span class="comment">// 用于返回结果</span></span><br><span class="line">        <span class="comment">// 2.1 寻找不超过num 的最大符号值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            <span class="comment">// 2.2 将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值</span></span><br><span class="line">            <span class="keyword">while</span>(num &gt;= value)&#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);                       <span class="comment">// 将该符号拼接在上一个找到的符号之后</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.3 判断循环直至 num 为 0。最后得到的字符串即为num 的罗马数字表示。</span></span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(1)。由于 valueSymbols 长度是固定的，且这 13 字符中的每个字符的出现次数均不会超过 3，因此循环次数有一个确定的上限。对于本题给出的数据范围，循环次数不会超过 15 次。</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-012-整数转罗马数字&quot;&gt;&lt;a href=&quot;#Leetcode-012-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-012-整数转罗马数字&quot;&gt;&lt;/a&gt;Leetcode-012-&lt;a href=&quot;https://leetcode-cn.com/problems/integer-to-roman/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;整数转罗马数字&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;罗马数字包含以下七种字符： &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符          数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;III&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;IV&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;IX&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;LVIII&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: L &amp;#x3D; 50, V &amp;#x3D; 5, III &amp;#x3D; 3.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 5:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 1994&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;MCMXCIV&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: M &amp;#x3D; 1000, CM &amp;#x3D; 900, XC &amp;#x3D; 90, IV &amp;#x3D; 4.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= num &amp;lt;= 3999&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1310-子数组异或查询</title>
    <link href="http://zhuuu.work/2021/05/12/Leetcode/Leetcode-1310-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/"/>
    <id>http://zhuuu.work/2021/05/12/Leetcode/Leetcode-1310-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-05-12T03:02:24.000Z</published>
    <updated>2021-05-12T01:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1310-子数组异或查询"><a href="#Leetcode-1310-子数组异或查询" class="headerlink" title="Leetcode-1310-子数组异或查询"></a>Leetcode-1310-<a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/" target="_blank" rel="noopener">子数组异或查询</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>有一个正整数数组 <code>arr</code>，现给你一个对应的查询数组 <code>queries</code>，其中 <code>queries[i] = [Li, Ri]</code>。</p></li><li><p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 <code>arr[Li] xor arr[Li+1] xor ... xor arr[Ri]</code>）作为本次查询的结果。</p></li><li><p>并返回一个包含给定查询 <code>queries</code> 所有结果的数组。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,4,8], queries &#x3D; [[0,1],[1,2],[0,3],[3,3]]</span><br><span class="line">输出：[2,7,14,8] </span><br><span class="line">解释：</span><br><span class="line">数组中元素的二进制表示形式是：</span><br><span class="line">1 &#x3D; 0001 </span><br><span class="line">3 &#x3D; 0011 </span><br><span class="line">4 &#x3D; 0100 </span><br><span class="line">8 &#x3D; 1000 </span><br><span class="line">查询的 XOR 值为：</span><br><span class="line">[0,1] &#x3D; 1 xor 3 &#x3D; 2 </span><br><span class="line">[1,2] &#x3D; 3 xor 4 &#x3D; 7 </span><br><span class="line">[0,3] &#x3D; 1 xor 3 xor 4 xor 8 &#x3D; 14 </span><br><span class="line">[3,3] &#x3D; 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [4,8,2,10], queries &#x3D; [[2,3],[1,3],[0,0],[0,3]]</span><br><span class="line">输出：[8,0,4,4]</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= arr[i] &lt;= 10^9</code></li><li><code>1 &lt;= arr.length &lt;= 3 * 10^4</code></li><li><code>encoded.length == n - 1</code></li><li><code>1 &lt;= queries.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</code></li></ul></li></ul><a id="more"></a><h2 id="算法思路：异或性质-前缀和"><a href="#算法思路：异或性质-前缀和" class="headerlink" title="算法思路：异或性质/前缀和"></a>算法思路：异或性质/前缀和</h2><p><strong>异或运算具有如下性质：</strong></p><ul><li><p>异或运算满足交换律和结合律；</p></li><li><p>任意整数和自身做异或运算的结果都等于 0，即<code>x⊕x=0；</code></p></li><li><p>任意整数和 0 做异或运算的结果都等于其自身，即<code>x⊕0=0⊕x=x。</code></p></li></ul><p>依然可以考虑能否使用<code>前缀和</code>的思想解决本题：</p><ul><li>假设有数组<code>arr = [A, B, C, D, E],</code>将异或运算<code>A XOR B</code>简记为<code>AB</code>，那么前缀和<code>preXOR = [0, A, AB, ABC, ABCD, ABCDE](preXOR的第一个数值0可以认为是初始化)；</code></li><li>假设我们求 <code>[1, 2]</code> 区间上的区间异或，那么结果为<code>arr[1] XOR arr[2] = BC = preXOR[2 + 1] XOR preXOR[1] = ABC XOR A = BC</code>，至此，我们使用前缀和<code>preXOR</code>得到了区间异或结果。</li></ul><p><strong>具体来说：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210512-092119417.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210512-092142117.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] xorQueries(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="comment">// 1. 计算异或前缀和</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] xors = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];                <span class="comment">// 前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;                   <span class="comment">// 计算前缀和</span></span><br><span class="line">            xors[i + <span class="number">1</span>] = xors[i] ^ arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算前缀和区间查询数组</span></span><br><span class="line">        <span class="keyword">int</span> m = queries.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;                   <span class="comment">// 区间[left,right]的前缀和</span></span><br><span class="line">            ans[i] = xors[queries[i][<span class="number">0</span>]] ^ xors[queries[i][<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回结果数组</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(n + m)</code> , 其中n是arr的长度, m是queries的长度</li><li>空间复杂度 ：<code>O(1)</code>  注意空间复杂度不考虑返回值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1310-子数组异或查询&quot;&gt;&lt;a href=&quot;#Leetcode-1310-子数组异或查询&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1310-子数组异或查询&quot;&gt;&lt;/a&gt;Leetcode-1310-&lt;a href=&quot;https://leetcode-cn.com/problems/xor-queries-of-a-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;子数组异或查询&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一个正整数数组 &lt;code&gt;arr&lt;/code&gt;，现给你一个对应的查询数组 &lt;code&gt;queries&lt;/code&gt;，其中 &lt;code&gt;queries[i] = [Li, Ri]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 &lt;code&gt;arr[Li] xor arr[Li+1] xor ... xor arr[Ri]&lt;/code&gt;）作为本次查询的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并返回一个包含给定查询 &lt;code&gt;queries&lt;/code&gt; 所有结果的数组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [1,3,4,8], queries &amp;#x3D; [[0,1],[1,2],[0,3],[3,3]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,7,14,8] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组中元素的二进制表示形式是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;#x3D; 0001 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 &amp;#x3D; 0011 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 &amp;#x3D; 0100 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8 &amp;#x3D; 1000 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查询的 XOR 值为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,1] &amp;#x3D; 1 xor 3 &amp;#x3D; 2 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1,2] &amp;#x3D; 3 xor 4 &amp;#x3D; 7 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,3] &amp;#x3D; 1 xor 3 xor 4 xor 8 &amp;#x3D; 14 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[3,3] &amp;#x3D; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [4,8,2,10], queries &amp;#x3D; [[2,3],[1,3],[0,0],[0,3]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[8,0,4,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= arr[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= arr.length &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoded.length == n - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= queries.length &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= queries[i][0] &amp;lt;= queries[i][1] &amp;lt; arr.length&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="异或" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-303- 区域和检索 - 数组不可变</title>
    <link href="http://zhuuu.work/2021/05/12/Leetcode/Leetcode-303-%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>http://zhuuu.work/2021/05/12/Leetcode/Leetcode-303-%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</id>
    <published>2021-05-12T03:02:24.000Z</published>
    <updated>2021-05-12T01:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-303-区域和检索-数组不可变"><a href="#Leetcode-303-区域和检索-数组不可变" class="headerlink" title="Leetcode-303- 区域和检索 - 数组不可变"></a>Leetcode-303- <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code>（<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点。</p></li><li><p>实现 <code>NumArray</code> 类：</p><ul><li><p><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</p></li><li><p><code>int sumRange(int i, int j)</code>返回数组<code>nums</code>从索引<code>i</code>到 j（i ≤ j）范围内元素的总和，包含<code>i、j</code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])）</code></p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure><ul><li><p><strong>提示：</strong></p><ul><li><p><code>0 &lt;= nums.length &lt;= 10^4</code></p></li><li><p><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></p></li><li><p><code>0 &lt;= i &lt;= j &lt; nums.length</code></p></li><li><p>最多调用<code>10^4 次 sumRange</code> 方法</p></li></ul></li></ul><a id="more"></a><h2 id="算法思路：前缀和"><a href="#算法思路：前缀和" class="headerlink" title="算法思路：前缀和"></a>算法思路：前缀和</h2><ul><li><p>关于<code>区间求和</code>，常用手段是<code>前缀和</code>。（如果学过GRE数学，那么可以将<code>前缀和</code>和<code>百分位数（percentile）</code>的定义放在一起）</p></li><li><p>我们举一个简单的例子：</p><ul><li>假如需要对<code>nums = [1, 2, 3, 4, 5]</code>进行处理，我们先得到前缀和。所谓前缀和就是从数组的0位置开始到当前位置的和值，比如nums的前缀和是<code>preSum = [0, 1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, 1 + 2 + 3 + 4 + 5]</code>，即<code>preSum = [0, 1, 3, 6, 10, 15](preSum[0] = 0 可以认为是初始化)；</code></li><li>得到前缀和之后，可以求区间的和值。比如说求 [2 , 4] 区间的和值，那么就是<code>3 + 4 + 5 = preSum[4 + 1] - preSum[2] = 15 - 3 = 12。</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.提前计算出前缀和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 计算出这段数组的和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(n)</code> , 其中n是原数组的长度，原因是要遍历encoded数组一次</li><li>空间复杂度 ：<code>O(1)</code> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-303-区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#Leetcode-303-区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-303- 区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;Leetcode-303- &lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区域和检索 - 数组不可变&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个整数数组  &lt;code&gt;nums&lt;/code&gt;，求出数组从索引 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;j&lt;/code&gt;（&lt;code&gt;i ≤ j&lt;/code&gt;）范围内元素的总和，包含 &lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;两点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现 &lt;code&gt;NumArray&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;NumArray(int[] nums)&lt;/code&gt; 使用数组 &lt;code&gt;nums&lt;/code&gt; 初始化对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;int sumRange(int i, int j)&lt;/code&gt;返回数组&lt;code&gt;nums&lt;/code&gt;从索引&lt;code&gt;i&lt;/code&gt;到 j（i ≤ j）范围内元素的总和，包含&lt;code&gt;i、j&lt;/code&gt;两点（也就是 &lt;code&gt;sum(nums[i], nums[i + 1], ... , nums[j])）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;NumArray&amp;quot;, &amp;quot;sumRange&amp;quot;, &amp;quot;sumRange&amp;quot;, &amp;quot;sumRange&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[null, 1, -1, -3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NumArray numArray &amp;#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numArray.sumRange(0, 2); &amp;#x2F;&amp;#x2F; return 1 ((-2) + 0 + 3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numArray.sumRange(2, 5); &amp;#x2F;&amp;#x2F; return -1 (3 + (-5) + 2 + (-1)) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numArray.sumRange(0, 5); &amp;#x2F;&amp;#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-10^5 &amp;lt;= nums[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt;= j &amp;lt; nums.length&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最多调用&lt;code&gt;10^4 次 sumRange&lt;/code&gt; 方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1734-解码异或后的排列</title>
    <link href="http://zhuuu.work/2021/05/11/Leetcode/Leetcode-1734-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://zhuuu.work/2021/05/11/Leetcode/Leetcode-1734-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2021-05-11T03:02:24.000Z</published>
    <updated>2021-05-11T02:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1734-解码异或后的排列"><a href="#Leetcode-1734-解码异或后的排列" class="headerlink" title="Leetcode-1734-解码异或后的排列"></a>Leetcode-1734-<a href="https://leetcode-cn.com/problems/decode-xored-permutation/" target="_blank" rel="noopener">解码异或后的排列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给你一个整数数组 <code>perm</code>，它是前 n 个正整数的排列，且 n 是个 奇数 。</p></li><li><p>它被加密成另一个长度为<code>n - 1</code>的整数数组 <code>encoded</code>，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code>。比方说，如果 <code>perm = [1,3,2] ，那么 encoded = [2,1] 。</code></p></li><li><p>给你 <code>encoded</code>数组，请你返回原始数组 <code>perm</code>。题目保证答案存在且唯一。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：encoded &#x3D; [3,1]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line">解释：如果 perm &#x3D; [1,2,3] ，那么 encoded &#x3D; [1 XOR 2,2 XOR 3] &#x3D; [3,1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：encoded &#x3D; [6,5,4,6]</span><br><span class="line">输出：[2,4,1,5,3]</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>3 &lt;= n &lt; 10^5</code></li><li><code>n</code> 是奇数。</li><li><code>encoded.length == n - 1</code></li></ul></li></ul><a id="more"></a><h2 id="算法思路：异或性质"><a href="#算法思路：异或性质" class="headerlink" title="算法思路：异或性质"></a>算法思路：异或性质</h2><p><strong>异或运算具有如下性质：</strong></p><ul><li><p>异或运算满足交换律和结合律；</p></li><li><p>任意整数和自身做异或运算的结果都等于 0，即<code>x⊕x=0；</code></p></li><li><p>任意整数和 0 做异或运算的结果都等于其自身，即<code>x⊕0=0⊕x=x。</code></p></li></ul><p><strong>实现算法分析：</strong></p><ul><li><p>这道题规定了数组<em>perm</em> 是前 <em>n</em> 个正整数的排列，其中 <em>n</em> 是<strong>奇数</strong>，只有充分利用给定的条件，才能得到答案。</p></li><li><p><strong>为了得到原始数组perm，应首先得到数组 perm 的第一个元素（即下标为 0 的元素），这也是最容易得到的</strong>。</p><ul><li><p>如果能得到数组 <strong>perm 的全部元素的异或运算结果</strong>，<strong>以及数组 perm 除了 perm[0] 以外的全部元素的异或运算结果</strong>，即可得到perm[0] 的值。</p><ul><li>由于数组 perm 是前 n 个正整数的排列，因此数组 perm 的全部元素的异或运算结果即为从 1 到 n 的全部正整数的异或运算结果。用total 表示数组 perm 的全部元素的异或运算结果，则有</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-093040171.png" alt="mark"></p></li></ul></li><li><p>如何得到数组 perm 除了 <code>perm[0]</code> 以外的全部元素的异或运算结果？</p><ul><li><p>由于 n 是奇数，除了 perm[0] 以外，数组 perm 还有 n−1 个其他元素，<code>n−1</code> 是偶数，又由于数组<code>encoded</code>的每个元素都是数组<code>perm</code> 的两个元素异或运算的结果，因此数组 encoded 中存在 <code>n-1/2</code>个元素，这些元素的异或运算结果为数组perm除了<code>perm[0]</code>以外所有元素的异或和</p></li><li><p>具体而言，数组 encoded 的所有下标为奇数的元素的异或运算结果即为数组 perm 除了 perm[0] 以外的全部元素的异或运算结果。用 odd 表示数组encoded 的所有下标为奇数的元素的异或运算结果，则有</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-102254529.png" alt="mark"></p></li></ul></li><li><p>根据 total 和 odd<em>的值，即可计算得到 perm</em>[0] 的值：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-102354157.png" alt="mark"></p><ul><li><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-102640805.png" alt="mark"></p></li><li><p>由于perm[0] 已知，因此对 i 从 1 到 n−1 依次计算 perm[i] 的值，即可得到原始数组perm。</p></li></ul><p>计算过程见「<a href="https://leetcode-cn.com/problems/decode-xored-array/solution/jie-ma-yi-huo-hou-de-shu-zu-by-leetcode-yp0mg/" target="_blank" rel="noopener">1720. 解码异或后的数组的官方题解</a>」。</p><p><strong>性质分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-093611704.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] decode(<span class="keyword">int</span>[] encoded) &#123;</span><br><span class="line">        <span class="comment">// 1. 计算出perm[0]</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;                                  <span class="comment">// 1-n内所有数字的异或和</span></span><br><span class="line">        <span class="keyword">int</span> odd   = <span class="number">0</span>;                                  <span class="comment">// encoded中所有奇数下标的异或和</span></span><br><span class="line">        <span class="keyword">int</span> n = encoded.length + <span class="number">1</span>;                     <span class="comment">// perm 的数组长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;                      <span class="comment">// 计算1-n内所有数字的异或和</span></span><br><span class="line">            total ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n - <span class="number">1</span>;i += <span class="number">2</span>)&#123;                <span class="comment">// 计算除了perm[0]以外的异或和</span></span><br><span class="line">            odd ^= encoded[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] perm = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        perm[<span class="number">0</span>] = total ^ odd;                          <span class="comment">// perm [0]的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 力扣题号1720的逻辑：利用异或性质</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i)&#123;</span><br><span class="line">            perm[i] = perm[i - <span class="number">1</span>] ^ encoded[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> perm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(n)</code> , 其中n是原数组的长度，原因是要遍历encoded数组一次</li><li>空间复杂度 ：<code>O(1)</code>  注意空间复杂度不考虑返回值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1734-解码异或后的排列&quot;&gt;&lt;a href=&quot;#Leetcode-1734-解码异或后的排列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1734-解码异或后的排列&quot;&gt;&lt;/a&gt;Leetcode-1734-&lt;a href=&quot;https://leetcode-cn.com/problems/decode-xored-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解码异或后的排列&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;perm&lt;/code&gt;，它是前 n 个正整数的排列，且 n 是个 奇数 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它被加密成另一个长度为&lt;code&gt;n - 1&lt;/code&gt;的整数数组 &lt;code&gt;encoded&lt;/code&gt;，满足 &lt;code&gt;encoded[i] = perm[i] XOR perm[i + 1]&lt;/code&gt;。比方说，如果 &lt;code&gt;perm = [1,3,2] ，那么 encoded = [2,1] 。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给你 &lt;code&gt;encoded&lt;/code&gt;数组，请你返回原始数组 &lt;code&gt;perm&lt;/code&gt;。题目保证答案存在且唯一。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：encoded &amp;#x3D; [3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如果 perm &amp;#x3D; [1,2,3] ，那么 encoded &amp;#x3D; [1 XOR 2,2 XOR 3] &amp;#x3D; [3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：encoded &amp;#x3D; [6,5,4,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,4,1,5,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;3 &amp;lt;= n &amp;lt; 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 是奇数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoded.length == n - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="异或" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>计组-08-指令系统</title>
    <link href="http://zhuuu.work/2021/05/10/Compute_Organization/%E8%AE%A1%E7%BB%84-08-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhuuu.work/2021/05/10/Compute_Organization/%E8%AE%A1%E7%BB%84-08-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-05-10T03:02:24.000Z</published>
    <updated>2021-05-20T12:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-08-指令系统"><a href="#计算机组成原理-08-指令系统" class="headerlink" title="计算机组成原理-08-指令系统"></a>计算机组成原理-08-指令系统</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><strong>什么是指令？</strong><ul><li>指令（机器指令）是计算机执行某种操作的命令，是计算机最小的功能单位</li><li>一台计算机上的所有指令的集合叫做指令集</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-145126466.png" alt="mark"></p><a id="more"></a><h2 id="1-指令的格式"><a href="#1-指令的格式" class="headerlink" title="1. 指令的格式"></a>1. 指令的格式</h2><p><strong>一条指令分为两个字段</strong></p><ul><li>操作码（OP）: 指出指令应该执行什么性质的操作</li><li>地址码（A）： 被操作信息或者数据的地址</li></ul><h3 id="1-1-定长指令字"><a href="#1-1-定长指令字" class="headerlink" title="1.1 定长指令字"></a>1.1 定长指令字</h3><h4 id="1-1-1-四地址指令"><a href="#1-1-1-四地址指令" class="headerlink" title="1.1.1 四地址指令"></a>1.1.1 四地址指令</h4><ul><li>若指令字长位32位，操作码占8位，4个地址码各占6位</li><li>操作数指令寻址范围是<code>2^6 = 64</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-150214420.png" alt="mark"></p><h4 id="1-1-2-三地址指令"><a href="#1-1-2-三地址指令" class="headerlink" title="1.1.2 三地址指令"></a>1.1.2 三地址指令</h4><ul><li>利用程序计数器自动+1 (进行地址改变)</li><li>若指令字长32位，操作码占8位，3个地址码字段各占8位</li><li>寻址范围：<code>2^8 = 256</code></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-150854141.png" alt="mark" style="zoom:80%;" /><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-151015682.png" alt="mark"></p><h4 id="1-1-3-二地址指令"><a href="#1-1-3-二地址指令" class="headerlink" title="1.1.3 二地址指令"></a>1.1.3 二地址指令</h4><ul><li>寻址范围 ： <code>2 ^12 = 4K</code></li><li>对于常用的算数和逻辑计算指令：常常会用到两个操作数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-151154802.png" alt="mark"></p><h4 id="1-1-4-一地址指令"><a href="#1-1-4-一地址指令" class="headerlink" title="1.1.4 一地址指令"></a>1.1.4 一地址指令</h4><ul><li>寻址范围 ： <code>2^24</code> = 16M</li><li>常用于<code>+1，-1</code>，求补等操作</li></ul><p><strong>上述小结：</strong></p><ul><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-151348134.png" alt="mark"></li></ul><h4 id="1-1-5-零地址指令"><a href="#1-1-5-零地址指令" class="headerlink" title="1.1.5 零地址指令"></a>1.1.5 零地址指令</h4><ul><li>不需要操作数，如空操作，停机，关中断</li><li>使用堆栈操作的，两个操作数隐含在栈顶和次栈顶，计算结果压回栈顶</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-151635001.png" alt="mark"></p><p>与定长指令字相对的有：变长指令字，这里不再详细描述</p><h3 id="1-2-操作码的设计"><a href="#1-2-操作码的设计" class="headerlink" title="1.2 操作码的设计"></a>1.2 操作码的设计</h3><p><strong>操作码同样也分为</strong></p><ul><li>定长操作码 ： <code>n 位 -&gt; 2^n</code> 条指令</li><li>变长操作码 ： 操作码长度可变</li></ul><p><strong>定长操作码：</strong></p><ul><li>简化了硬件的设计，提高指令译码和识别的速度，当计算机字长为32位甚至更长的时候，这是最常用的方法</li></ul><p><strong>扩展操作码：</strong></p><ul><li>在指令字长有限的情况下仍然保持比较丰富的指令种类</li><li>即：全部指令的操作码的字段位数不固定，且分散的放在指令字的不同位置上</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-162606762.png" alt="mark"></p><ul><li>在设计扩展操作码指令格式时<ul><li>不允许短码是长码的前缀</li><li>各指令的操作码一定不能重复</li></ul></li></ul><h2 id="2-指令的寻址方式"><a href="#2-指令的寻址方式" class="headerlink" title="2. 指令的寻址方式"></a>2. 指令的寻址方式</h2><h3 id="2-1-数据存储的方式"><a href="#2-1-数据存储的方式" class="headerlink" title="2.1 数据存储的方式"></a>2.1 数据存储的方式</h3><ul><li>首先回顾一下数据的存储方式<ul><li>大端存储 : 高地址数据放在存储低位</li><li>小端存储 ：低地址数据放在存储高位</li></ul></li><li>编址又分为：<ul><li>按字编址</li><li>按字节编址</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-164512929.png" alt="mark"></p><h3 id="2-2-寻址方式"><a href="#2-2-寻址方式" class="headerlink" title="2.2 寻址方式"></a>2.2 寻址方式</h3><ul><li>寻址方式分为：<ul><li>指令寻址：寻找下一条将要执行的指令地址</li><li>数据寻址：寻找操作数的地址</li></ul></li></ul><h4 id="2-2-1-指令寻址"><a href="#2-2-1-指令寻址" class="headerlink" title="2.2.1 指令寻址"></a>2.2.1 指令寻址</h4><p>指令寻址：使用PC程序计数器来实现</p><ol><li><strong>顺序寻址</strong>：通过程序计数器<code>（PC = PC + 1）</code> 实现</li><li><strong>跳跃寻址</strong>：通过转移类指令实现（本质还是由当前的指令修改PC的值，使得下一条指令仍然通过PC给出）</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-164708059.png" alt="mark"></p><h4 id="2-2-2-数据寻址"><a href="#2-2-2-数据寻址" class="headerlink" title="2.2.2 数据寻址"></a>2.2.2 数据寻址</h4><ul><li>数据寻址是指令中表示一个操作数的地址</li><li>操作数的类型 ： 用寻址特征来表示<ul><li>地址 ： 无符号数</li><li>数字 ： 定点浮点数，BCD码</li><li>字符 ： ASCII</li><li>逻辑运算</li></ul></li><li>具体的数据寻址分类如下所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-164908750.png" alt="mark"></p><p>注意：在接下来的讨论中</p><ul><li>EA ： 表示真实地址</li><li>A ： 表示形式地址</li></ul><ol><li><strong>立即寻址</strong></li></ol><ul><li>地址字段不是操作数的地址，而是操作数本身</li><li>缺点是：位数限制了立即数的范围</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-165340503.png" alt="mark"></p><ol start="2"><li><strong>直接寻址</strong></li></ol><ul><li>形式地址A就是操作数的真实地址EA </li><li>EA = A</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-165428298.png" alt="mark"></p><ol start="3"><li><strong>间接寻址</strong></li></ol><ul><li>操作数的有效地址所在的存储单元的地址，也就是操作数地址的地址</li><li>EA = （A）</li><li>优点：扩大了寻址范围，方便程序调用的返回</li><li>缺点：多次访问主存</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-165545022.png" alt="mark"></p><ol start="4"><li><strong>寄存器寻址</strong></li></ol><ul><li>操作数放在寄存器中，类似直接寻址</li><li>EA = R</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-165719760.png" alt="mark"></p><ol start="5"><li><strong>寄存器间接寻址</strong></li></ol><ul><li>类似于间接寻址，只不过把主存换成了寄存器</li><li>寄存器给出的不是一个操作数，而是主存中的地址</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-165833543.png" alt="mark"></p><ol start="6"><li><strong>隐含寻址</strong></li></ol><ul><li>只给出一个操作数的地址，不明显的在地址中指出第二条操作数的地址</li><li>比如使用（ACC）作为第二操作数的地址</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-165950249.png" alt="mark"></p><p><strong>上述小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-170016730.png" alt="mark"></p><p><strong>接下来介绍三种偏移寻址方式：特点是需要进行运算</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-170227064.png" alt="mark" style="zoom:80%;" /><ol><li><strong>基址寻址</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-171718198.png" alt="mark"></p><ul><li>基址寄存器是面向操作系统的，基址寄存器的内容不变，形式地址可变</li><li><strong>优点：</strong><ul><li><strong>可以扩大寻址的范围</strong></li><li><strong>利用全局程序的浮动</strong></li></ul></li><li><strong>与直接寻址的对比：不用查主存的状态，操作系统就能判断内存的状态</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-172013188.png" alt="mark"></p><ol start="2"><li><strong>变址寻址</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-172133165.png" alt="mark"></p><ul><li><strong>变址寻址</strong> ： 是面向用户的，寄存器的内容用户可以改变，但是形式地址A不可改变</li><li>特别适合编址循环的程序，适合处理数组</li><li><strong>变址寻址</strong> ：实现程序内的浮动，可与其他寻址配合使用</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-172423784.png" alt="mark"></p><ol start="3"><li><strong>相对寻址</strong></li></ol><ul><li>把程序计数器PC 的内容加上指令格式中的形式地址A</li><li>EA = (PC) + A</li><li>其中 A 是偏移量，A 用补码表示 ，可正可负</li><li>适合程序内部的浮动</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210519-172939715.png" alt="mark"></p><h2 id="3-CISC-和-RISC"><a href="#3-CISC-和-RISC" class="headerlink" title="3. CISC 和 RISC"></a>3. CISC 和 RISC</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-200906832.png" alt="mark"></p><ol><li><strong>CISC</strong></li></ol><ul><li>复杂指令系统的计算机</li><li>典型的架构是X86</li></ul><ol start="2"><li><strong>RISC</strong></li></ol><ul><li>精简指令集</li><li>典型的架构是ARM</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-201003917.png" alt="mark"></p><h2 id="4-本章小结"><a href="#4-本章小结" class="headerlink" title="4. 本章小结"></a>4. 本章小结</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210520-201050148.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-08-指令系统&quot;&gt;&lt;a href=&quot;#计算机组成原理-08-指令系统&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-08-指令系统&quot;&gt;&lt;/a&gt;计算机组成原理-08-指令系统&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;什么是指令？&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;指令（机器指令）是计算机执行某种操作的命令，是计算机最小的功能单位&lt;/li&gt;
&lt;li&gt;一台计算机上的所有指令的集合叫做指令集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-145126466.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1720-解码异或后的数组</title>
    <link href="http://zhuuu.work/2021/05/06/Leetcode/Leetcode-1720-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2021/05/06/Leetcode/Leetcode-1720-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2021-05-06T03:02:24.000Z</published>
    <updated>2021-05-06T01:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1720-解码异或后的数组"><a href="#Leetcode-1720-解码异或后的数组" class="headerlink" title="Leetcode-1720-解码异或后的数组"></a>Leetcode-1720-<a href="https://leetcode-cn.com/problems/decode-xored-array/" target="_blank" rel="noopener">解码异或后的数组</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>未知 整数数组 arr 由 n 个非负整数组成。</li><li>经编码后变为长度为 <code>n - 1</code>的另一个整数数组 <code>encoded</code>，其中 <code>encoded[i] = arr[i] XOR arr[i + 1]</code> 。例如，<code>arr = [1,0,2,1]</code> 经编码后得到<code>encoded = [1,2,3]</code>。</li><li>给你编码后的数组 <code>encoded</code>和原数组<code>arr</code>的第一个元素 <code>first（arr[0]）</code>。</li><li>请解码返回原数组<code>arr</code>。可以证明答案存在并且是唯一的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：encoded &#x3D; [1,2,3], first &#x3D; 1</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：若 arr &#x3D; [1,0,2,1] ，那么 first &#x3D; 1 且 encoded &#x3D; [1 XOR 0, 0 XOR 2, 2 XOR 1] &#x3D; [1,2,3]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：encoded &#x3D; [6,2,7,3], first &#x3D; 4</span><br><span class="line">输出：[4,2,0,7,4]</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>2 &lt;= n &lt;= 10^4</code></li><li><code>encoded.length == n - 1</code></li><li><code>0 &lt;= encoded[i] &lt;= 10^5</code></li><li><code>0 &lt;= first &lt;= 10^5</code></li></ul></li></ul><a id="more"></a><h2 id="算法思路：异或性质"><a href="#算法思路：异或性质" class="headerlink" title="算法思路：异或性质"></a>算法思路：异或性质</h2><p><strong>异或运算具有如下性质：</strong></p><ul><li><p>异或运算满足交换律和结合律；</p></li><li><p>任意整数和自身做异或运算的结果都等于 0，即<code>x⊕x=0；</code></p></li><li><p>任意整数和 0 做异或运算的结果都等于其自身，即<code>x⊕0=0⊕x=x。</code></p></li></ul><p><strong>题目要求：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-093511909.png" alt="mark"></p><p><strong>性质分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-093611704.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] decode(<span class="keyword">int</span>[] encoded, <span class="keyword">int</span> first) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建arr数组</span></span><br><span class="line">        <span class="keyword">int</span> n = encoded.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 异或还原</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] ^ encoded[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回结果数组</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(n)</code> , 其中n是原数组的长度，原因是要遍历encoded数组一次</li><li>空间复杂度 ：<code>O(1)</code>  注意空间复杂度不考虑返回值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1720-解码异或后的数组&quot;&gt;&lt;a href=&quot;#Leetcode-1720-解码异或后的数组&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1720-解码异或后的数组&quot;&gt;&lt;/a&gt;Leetcode-1720-&lt;a href=&quot;https://leetcode-cn.com/problems/decode-xored-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解码异或后的数组&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;未知 整数数组 arr 由 n 个非负整数组成。&lt;/li&gt;
&lt;li&gt;经编码后变为长度为 &lt;code&gt;n - 1&lt;/code&gt;的另一个整数数组 &lt;code&gt;encoded&lt;/code&gt;，其中 &lt;code&gt;encoded[i] = arr[i] XOR arr[i + 1]&lt;/code&gt; 。例如，&lt;code&gt;arr = [1,0,2,1]&lt;/code&gt; 经编码后得到&lt;code&gt;encoded = [1,2,3]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;给你编码后的数组 &lt;code&gt;encoded&lt;/code&gt;和原数组&lt;code&gt;arr&lt;/code&gt;的第一个元素 &lt;code&gt;first（arr[0]）&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;请解码返回原数组&lt;code&gt;arr&lt;/code&gt;。可以证明答案存在并且是唯一的。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：encoded &amp;#x3D; [1,2,3], first &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,0,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：若 arr &amp;#x3D; [1,0,2,1] ，那么 first &amp;#x3D; 1 且 encoded &amp;#x3D; [1 XOR 0, 0 XOR 2, 2 XOR 1] &amp;#x3D; [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：encoded &amp;#x3D; [6,2,7,3], first &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,2,0,7,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= n &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoded.length == n - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= encoded[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= first &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="异或" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-554-砖墙</title>
    <link href="http://zhuuu.work/2021/05/02/Leetcode/Leetcode-554-%E7%A0%96%E5%A2%99/"/>
    <id>http://zhuuu.work/2021/05/02/Leetcode/Leetcode-554-%E7%A0%96%E5%A2%99/</id>
    <published>2021-05-02T03:02:24.000Z</published>
    <updated>2021-05-14T00:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-554-砖墙"><a href="#Leetcode-554-砖墙" class="headerlink" title="Leetcode-554-砖墙"></a>Leetcode-554-<a href="https://leetcode-cn.com/problems/brick-wall/" target="_blank" rel="noopener">砖墙</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</li><li><strong>你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。</strong>如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</li><li>给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code>是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-084009075.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：wall &#x3D; [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：wall &#x3D; [[1],[1],[1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p><strong>提示：</strong></p><ul><li><p><code>n == wall.length</code></p></li><li><p>``1 &lt;= n &lt;= 10^4`</p></li><li><p><code>1 &lt;= wall[i].length &lt;= 10^4</code></p></li><li><p><code>1 &lt;= sum(wall[i].length) &lt;= 2 * 10^4</code></p></li><li><p><code>对于每一行 i ，sum(wall[i]) 是相同的1 &lt;= wall[i][j] &lt;= 2^31 - 1</code></p></li></ul></li></ul><h2 id="算法思路：哈希表"><a href="#算法思路：哈希表" class="headerlink" title="算法思路：哈希表"></a>算法思路：哈希表</h2><p><strong>思路</strong></p><ul><li><p><strong>题目要求穿过的砖块数量最少，等效于通过的间隙最多</strong></p></li><li><p><strong>可以使用「哈希表」记录每个间隙的出现次数，最终统计所有行中哪些间隙出现得最多，使用「总行数」减去「间隙出现的最多次数」即是答案。</strong></p></li></ul><p><strong>实现：</strong></p><ul><li>如何记录间隙呢？直接使用行前缀记录即可。</li><li>就用示例数据来举 🌰 ：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-084009075.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第 1 行的间隙有 [1,3,5]</span><br><span class="line">第 2 行的间隙有 [3,4]</span><br><span class="line">第 3 行的间隙有 [1,4]</span><br><span class="line">第 4 行的间隙有 [2]</span><br><span class="line">第 5 行的间隙有 [3,4]</span><br><span class="line">第 6 行的间隙有 [1,4,5]</span><br></pre></td></tr></table></figure><ul><li>对间隙计数完成后，遍历「哈希表」找出出现次数最多间隙 <code>4</code>，根据同一个间隙编号只会在单行内被统计一次，用总行数减去出现次数，即得到「最少穿过的砖块数」。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastBricks</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 哈希表统计所有的砖块间隙</span></span><br><span class="line">        <span class="keyword">int</span> n = wall.size();</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;                                    <span class="comment">// 每次统计用来清0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> brick_width:wall.get(i))&#123;</span><br><span class="line">                sum += brick_width;                         <span class="comment">// 统计每行的砖块间隔位置</span></span><br><span class="line">                map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 间隔出现的次数放入哈希表中</span></span><br><span class="line">            &#125;</span><br><span class="line">            map.remove(sum);                                <span class="comment">// 不能从两边穿过，需要 remove 掉最后一个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 比较最小通过的砖块数量</span></span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = map.get(u);                           <span class="comment">// 拿到砖块的间隔数</span></span><br><span class="line">            ans = Math.min(ans, n - cnt);                   <span class="comment">// 最少的穿越：最多的间隔出现</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：记所有砖块数量为 <code>n</code>，所有砖块都会被扫描。复杂度为 O<em>(</em>n)</li><li>空间复杂度：O<em>(</em>n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-554-砖墙&quot;&gt;&lt;a href=&quot;#Leetcode-554-砖墙&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-554-砖墙&quot;&gt;&lt;/a&gt;Leetcode-554-&lt;a href=&quot;https://leetcode-cn.com/problems/brick-wall/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;砖墙&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。&lt;/strong&gt;如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。&lt;/li&gt;
&lt;li&gt;给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，&lt;code&gt;wall[i]&lt;/code&gt;是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-084009075.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：wall &amp;#x3D; [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：wall &amp;#x3D; [[1],[1],[1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-137-只出现一次的数字II</title>
    <link href="http://zhuuu.work/2021/04/30/Leetcode/Leetcode-137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/"/>
    <id>http://zhuuu.work/2021/04/30/Leetcode/Leetcode-137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/</id>
    <published>2021-04-30T03:02:24.000Z</published>
    <updated>2021-04-30T01:39:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-137-只出现一次的数字-II"><a href="#Leetcode-137-只出现一次的数字-II" class="headerlink" title="Leetcode-137-只出现一次的数字 II"></a>Leetcode-137-<a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">只出现一次的数字 II</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,1,0,1,99]</span><br><span class="line">输出：99</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= nums.length &lt;= 3 * 10^4</code><br><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code><br><code>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</code></p><a id="more"></a><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><ul><li>可以使用哈希映射统计数组中每个元素的出现次数。对于哈希映射中的每个键值对，键表示一个元素，值表示其出现的次数。</li><li>在统计完成后，遍历哈希映射即可找出只出现一次的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建哈希表并把元素都放在内</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 检查出现一次的数字并统计结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> occ = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(occ == <span class="number">1</span>)&#123;</span><br><span class="line">                ans = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ： O(n)</li><li>空间复杂度 ： O(n)</li></ul><h2 id="方法二：二进制位"><a href="#方法二：二进制位" class="headerlink" title="方法二：二进制位"></a>方法二：二进制位</h2><ul><li>为了方便叙述，我们称「只出现了一次的元素」为「答案」。</li><li>由于数组中的元素都在 int（即 32位整数）范围内，因此我们可以依次计算答案的每一个二进制位是 0 还是 1。</li></ul><hr><ul><li><p><strong>具体地，考虑答案的第 i个二进制位（i 从 0 开始编号），它可能为 0 或 1。对于数组中非答案的元素，每一个元素都出现了 3 次，对应着第 i 个二进制位的 3 个 0 或 3 个 1，无论是哪一种情况，它们的和都是 3 的倍数（即和为 0 或 3）。</strong></p></li><li><p><strong>因此：答案的第 i个二进制位就是数组中所有元素的第 i个二进制位之和除以 3 的余数。</strong></p></li><li><p>这样一来，对于数组中的每一个元素<code>x</code>，使用位运算<code>(x &gt;&gt; i) &amp; 1</code> 得到 <code>x</code>的第<code>i</code>个二进制位，并将他们相加再对3取余，得到的结果一定为0或者1，即答案的第i个二进制位</p></li></ul><p><strong>注意：</strong></p><ul><li><strong>需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，那么可能会得到错误的答案。</strong><ul><li>这是因为「有符号整数类型」(int 类型)的第31个二进制位补码对应的是符号位对应着 <code>-2^{31}</code></li><li>而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2^{31}</li><li>因此在某些语言（Python）中需要对最高位进行特殊判断。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化变量</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 对32位依次进行二进制累和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                total += (num &gt;&gt; i) &amp; <span class="number">1</span>;                    <span class="comment">// (num &gt;&gt; i) &amp; 1 拿到二进制位</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 对累和进行求余数判断</span></span><br><span class="line">            <span class="keyword">if</span>(total % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i);                            <span class="comment">// 说明ans这位应该取1                </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围，在本题中 logC=log2 32=32，也就是我们需要遍历第 0∼31 个二进制位。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h2 id="方法三：-数字电路"><a href="#方法三：-数字电路" class="headerlink" title="方法三： 数字电路"></a>方法三： 数字电路</h2><ul><li>待后续</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-137-只出现一次的数字-II&quot;&gt;&lt;a href=&quot;#Leetcode-137-只出现一次的数字-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-137-只出现一次的数字 II&quot;&gt;&lt;/a&gt;Leetcode-137-&lt;a href=&quot;https://leetcode-cn.com/problems/single-number-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;只出现一次的数字 II&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，除某个元素仅出现 &lt;strong&gt;一次&lt;/strong&gt; 外，其余每个元素都恰出现 &lt;strong&gt;三次 。&lt;/strong&gt;请你找出并返回那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [2,2,3,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0,1,0,1,0,1,99]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：99&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;br&gt;&lt;code&gt;-2^31 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;br&gt;&lt;code&gt;nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-14-消息的可靠性保证</title>
    <link href="http://zhuuu.work/2021/04/30/RabbitMQ/RabbitMQ-14-%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/"/>
    <id>http://zhuuu.work/2021/04/30/RabbitMQ/RabbitMQ-14-%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/</id>
    <published>2021-04-30T02:02:24.000Z</published>
    <updated>2021-04-30T03:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-14-消息的可靠性保证"><a href="#RabbitMQ-14-消息的可靠性保证" class="headerlink" title="RabbitMQ-14-消息的可靠性保证"></a>RabbitMQ-14-消息的可靠性保证</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><ul><li><p>RabbitMQ如何确保消息可靠？很多时候，笔者的回答都是：说来话长的事情何来长话短说。的确，要确保消息可靠不只是单单几句就能够叙述明白的，包括Kafka也是如此。</p></li><li><p>可靠并不是一个绝对的概念，曾经有人也留言说过类似全部磁盘损毁也会导致消息丢失，笔者戏答：还有机房被炸了也会导致消息丢失。</p></li><li><p>可靠性是一个相对的概念，在条件合理的范围内系统所能确保的多少个9的可靠性。一切尽可能的趋于完美而无法企及于完美。</p></li><li><p>我们可以尽可能的确保RabbitMQ的消息可靠。在详细论述RabbitMQ的消息可靠性之前，我们先来回顾下消息在RabbitMQ中的经由之路。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-094238362.png" alt="mark"></p><p>如图所示，从AMQP协议层面上来说：</p><ul><li><p>消息先从生产者<code>Producer</code> 出发到达交换器 <code>Exchange</code></p></li><li><p>交换器<code>Exchange</code> 根据路由规则将消息转发到对应的<code>Queue</code> 上</p></li><li><p>消息在队列<code>Queue</code> 上进行存储</p></li><li><p>消费者Consumer订阅队列Queue并进行消费。</p></li></ul><p>接下来 ： 我们对于消息可靠性的分析也从这四个阶段来一一探讨。</p><a id="more"></a><h3 id="2-生产者到交换机"><a href="#2-生产者到交换机" class="headerlink" title="2. 生产者到交换机"></a>2. 生产者到交换机</h3><ul><li><p>消息从生产者发出到达交换器<code>Exchange</code>，在这个过程中可以发生各种情况，生产者客户端发送出去之后可以发生网络丢包、网络故障等造成消息丢失。一般情况下如果不采取措施，生产者无法感知消息是否已经正确无误的发送到交换器中。</p></li><li><p>如果消息在传输到<code>Exchange</code>的过程中发生失败而可以让生产者感知的话，生产者可以进行进一步的处理动作，比如重新投递相关消息以确保消息的可靠性。</p></li><li><p>为此AMQP协议在建立之初就考虑到这种情况而提供了事务机制。</p><ul><li>RabbitMQ客户端中与事务机制相关的方法有三个：<code>channel.txSelect、channel.txCommit以及channel.txRollback。</code></li><li><code>channel.txSelect</code>用于将当前的信道设置成事务模式，<code>channel.txCommit</code>用于提交事务，而<code>channel.txRollback</code>用于事务回滚。</li><li>在通过<code>channel.txSelect</code>方法开启事务之后，我们便可以发布消息给<code>RabbitMQ</code>了，如果事务提交成功，则消息一定到达了<code>RabbitMQ</code>中，如果在事务提交执行之前由于<code>RabbitMQ</code>异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行<code>channel.txRollback</code>方法来实现事务回滚。</li><li><strong>注意这里的RabbitMQ中的事务机制与大多数数据库中的事务概念并不相同，需要注意区分。</strong></li></ul></li><li><p>事务确实能够解决消息发送方和<code>RabbitMQ</code>之间消息确认的问题，只有消息成功被<code>RabbitMQ</code>接收，事务才能提交成功，否则我们便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。</p></li></ul><hr><ul><li><strong>但是使用事务机制的话会“吸干”RabbitMQ的性能，那么有没有更好的方法既能保证消息发送方确认消息已经正确送达，又能基本上不带来性能上的损失呢？</strong><ul><li>从AMQP协议层面来看并没有更好的办法，但是RabbitMQ提供了一个改进方案，即<strong>发送方确认机制（publisher confirm）。</strong></li><li>生产者将信道设置成<code>confirm</code>（确认）模式，一旦信道进入<code>confirm</code>模式，所有在该信道上面发布的消息都会被指派一个唯一的<code>ID</code>（从1开始），一旦消息被投递到所有匹配的队列之后，<code>RabbitMQ</code>就会发送一个确认<code>（Basic.Ack）</code>给生产者（包含消息的唯一<code>ID</code>）,这就使得生产者知晓消息已经正确到达了目的地了。</li><li><code>RabbitMQ</code>回传给生产者的确认消息中的<code>deliveryTag</code>包含了确认消息的序号，此外RabbitMQ也可以设置channel.basicAck方法中的<strong>multiple参数</strong>，表示到这个序号之前的所有消息都已经得到了处理。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-103912395.png" alt="mark"></p><p><strong>对比小结：</strong></p><ul><li><strong>事务机制在一条消息发送之后会使发送端阻塞</strong>，以等待RabbitMQ的回应，之后才能继续发送下一条消息。<ul><li>相比之下，<strong>发送方确认机制最大的好处在于它是异步的</strong>，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息</li><li>如果<code>RabbitMQ</code>因为自身内部错误导致消息丢失，就会发送一条<code>nack（Basic.Nack</code>）命令，生产者应用程序同样可以在回调方法中处理该<code>nack</code>命令。</li><li>生产者通过调用<code>channel.confirmSelect</code>方法（即<code>Confirm.Select</code>命令）将信道设置为<code>confirm</code>模式，之后<code>RabbitMQ</code>会返回<code>Confirm.Select-Ok</code>命令表示同意生产者将当前信道设置为<code>confirm</code>模式。所有被发送的后续消息都被ack或者nack一次，不会出现一条消息即被ack又被nack的情况。并且RabbitMQ也并没有对消息被confirm的快慢做任何保证。</li></ul></li><li>事务机制和<code>publisher confirm</code>机制两者是互斥的，不能共存。<ul><li>如果企图将已开启事务模式的信道再设置为<code>publisher confirm</code>模式，RabbitMQ会报错：<code>{amqp_error, precondition_failed, “cannot switch from tx to confirm mode”, ‘confirm.select’}</code></li><li>或者如果企图将已开启<code>publisher confirm</code>模式的信道在设置为事务模式的话，RabbitMQ也会报错：<code>{amqp_error, precondition_failed, “cannot switch from confirm to tx mode”, ‘tx.select’ }。</code></li></ul></li><li>事务机制和<code>publisher confirm</code>机制确保的是消息能够正确的发送至<code>RabbitMQ</code>，这里的“发送至RabbitMQ”的含义是指消息被正确的发往至<code>RabbitMQ</code>的交换器，<strong>如果此交换器没有匹配的队列的话，那么消息也将会丢失。</strong><ul><li>所以在使用这两种机制的时候要确保所涉及的交换器能够有匹配的队列。<strong>更进一步的讲，发送方要配合<code>mandatory</code>参数或者备份交换器一起使用来提高消息传输的可靠性。</strong></li></ul></li></ul><h3 id="3-交换机"><a href="#3-交换机" class="headerlink" title="3. 交换机"></a>3. 交换机</h3><ul><li><code>mandatory</code>和<code>immediate</code>是<code>channel.basicPublish</code>方法中的两个参数，它们都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。</li><li>而RabbitMQ提供的备份交换器<code>（Alternate Exchange）</code>可以将未能被交换器路由的消息（没有绑定队列或者没有匹配的绑定）存储起来，而不用返回给客户端。<ul><li>RabbitMQ 3.0版本开始去掉了对于immediate参数的支持，对此RabbitMQ官方解释是：immediate参数会影响镜像队列的性能，增加代码复杂性，建议采用TTL和DLX的方法替代。所以<strong>本文只简单介绍mandatory和备份交换器。</strong></li></ul></li></ul><ol><li><code>mandatory</code> 参数</li></ol><ul><li><p>当<code>mandatory</code>参数设为<code>true</code>时，交换器无法根据自身的类型和路由键找到一个符合条件的队列的话，那么<code>RabbitMQ</code>会调用<code>Basic.Return</code>命令将消息返回给生产者。</p></li><li><p>当<code>mandatory</code>参数设置为<code>false</code>时，出现上述情形的话，消息直接被丢弃。 </p></li><li><p><strong>那么生产者如何获取到没有被正确路由到合适队列的消息呢？</strong>这时候可以通过调用<code>channel.addReturnListener</code>来添加<code>ReturnListener</code>监听器实现。使用<code>mandatory</code>参数的关键代码如下所示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">true</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"mandatory test"</span>.getBytes());</span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP</span></span></span><br><span class="line"><span class="function"><span class="params">            .BasicProperties basicProperties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body);</span><br><span class="line">        System.out.println(<span class="string">"Basic.Return返回的结果是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面代码中生产者没有成功的将消息路由到队列，此时RabbitMQ会通过Basic.Return返回“mandatory test”这条消息，之后生产者客户端通过ReturnListener监听到了这个事件，上面代码的最后输出应该是“Basic.Return返回的结果是：mandatory test”。</span><br></pre></td></tr></table></figure><ul><li>生产者可以通过ReturnListener中返回的消息来重新投递或者其它方案来提高消息的可靠性。</li></ul><ol start="2"><li><strong>备份交换机</strong></li></ol><ul><li>备份交换器，英文名称<code>Alternate Exchange</code>，简称AE，或者更直白的可以称之为“备胎交换器”。</li><li>生产者在发送消息的时候如果不设置mandatory参数，那么消息在未被路由的情况下将会丢失，如果设置了mandatory参数，那么需要添加ReturnListener的编程逻辑，生产者的代码将变得复杂化。</li><li><strong>如果你不想复杂化生产者的编程逻辑，又不想消息丢失</strong>，那么可以使用备份交换器，这样可以将未被路由的消息存储在RabbitMQ中，再在需要的时候去处理这些消息。<ul><li>可以通过在声明交换器（调用<code>channel.exchangeDeclare</code>方法）的时候添加<code>alternate-exchange</code>参数来实现，也可以通过策略的方式实现。如果两者同时使用的话，前者的优先级更高，会覆盖掉<code>Policy</code>的设置。</li></ul></li></ul><p><strong>举个例子</strong></p><ul><li>参考下图，如果此时我们发送一条消息到<code>normalExchange</code>上<ul><li>当路由键等于<code>“normalKey”</code>的时候，消息能正确路由到<code>normalQueue</code>这个队列中。</li><li>如果路由键设为其他值，比如<code>“errorKey”</code>，即消息不能被正确的路由到与<code>normalExchange</code>绑定的任何队列上，此时就会发送给myAe, 进而发送到<code>unroutedQueue</code>这个队列。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-105341541.png" alt="mark"></p><ul><li><strong>备份交换器其实和普通的交换器没有太大的区别，为了方便使用，建议设置为fanout类型</strong><ul><li>如若读者想设置为direct或者topic的类型也没有什么不妥。<strong>需要注意的是消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。</strong></li><li>备份交换器的实质就是原有交换器的一个“备胎”，所有无法正确路由的消息都发往这个备份交换器中，可以为所有的交换器设置同一个AE，不过这里需要提前确保的是AE已经正确的绑定了队列</li><li>最好类型也是<code>fanout</code>的。如果备份交换器和<code>mandatory</code>参数一起使用，那么<code>mandatory</code>参数无效。</li></ul></li></ul><h3 id="4-消息存入队列后"><a href="#4-消息存入队列后" class="headerlink" title="4. 消息存入队列后"></a>4. 消息存入队列后</h3><ul><li>mandatory或者AE可以让消息在路由到队列之前得到极大的可靠性保障，但是消息存入队列之后的可靠性又如何保证？</li></ul><ol><li><strong>首先是持久化。持久化可以提高队列的可靠性，以防在异常情况（重启、关闭、宕机等）下的数据丢失。</strong><ul><li><strong>队列的持久化</strong>是通过在声明队列时将durable参数置为true实现的，如果队列不设置持久化，那么在RabbitMQ服务重启之后，相关队列的元数据将会丢失，此时数据也会丢失。</li><li>正所谓“皮之不存，毛将焉附”，队列都没有了，消息又能存在哪里呢？</li><li>队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。</li><li>要确保<strong>消息不会丢失，需要将其设置为持久化</strong>。通过将消息的投递模式（BasicProperties中的deliveryMode属性）设置为2即可实现消息的持久化。</li></ul></li></ol><p><strong>设置了队列和消息的持久化，当RabbitMQ服务重启之后，消息依旧存在</strong>。单单只设置队列持久化，重启之后消息会丢失；单单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</p><hr><ul><li>在持久化的消息正确存入RabbitMQ之后，还需要有一段时间（虽然很短，但是不可忽视）才能存入磁盘之中。</li><li><strong>RabbitMQ并不会为每条消息都做同步存盘（调用内核的fsync6方法）的处理</strong>，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。</li><li>如果在这段时间内RabbitMQ服务节点发生了宕机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。</li></ul><ol start="2"><li><strong>如果在前面步骤中采用了事务机制或者publisher confirm机制的话</strong>，服务端的返回是在消息落盘之后执行的，这样可以进一步的提高了消息的可靠性。<ul><li>但是即便如此也无法避免单机故障且无法修复（比如磁盘损毁）而引起的消息丢失，<strong>这里就需要引入镜像队列。</strong></li><li><strong>镜像队列相当于配置了副本</strong>，绝大多数分布式的东西都有多副本的概念来确保HA。</li><li>在镜像队列中，如果主节点（master）在此特殊时间内挂掉，可以自动切换到从节点（slave），这样有效的保证了高可用性，除非整个集群都挂掉。</li></ul></li></ol><p>虽然这样也不能完全的保证RabbitMQ消息不丢失（比如机房被炸。。。），但是配置了镜像队列要比没有配置镜像队列的可靠性要高很多，<strong>在实际生产环境中的关键业务队列一般都会设置镜像队列。</strong></p><h3 id="5-消费者"><a href="#5-消费者" class="headerlink" title="5. 消费者"></a>5. 消费者</h3><ul><li>进一步的从消费者的角度来说，如果在消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。</li><li>为了保证消息从队列可靠地达到消费者，RabbitMQ提供了<strong>消息确认机制</strong>（<code>message acknowledgement</code>）。<ul><li>消费者在订阅队列时，可以指定<code>autoAck</code>参数，<strong>当autoAck等于false时</strong>，RabbitMQ会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。</li><li><strong>当autoAck等于true时</strong>，RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正的消费到了这些消息。</li></ul></li></ul><p><strong>采用消息确认机制后，只要设置autoAck参数为false，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直等待持有消息直到消费者显式调用Basic.Ack命令为止。</strong></p><hr><ul><li><p><strong>当autoAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分:</strong></p><ul><li>一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者确认信号的消息。</li><li>如果RabbitMQ一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</li><li><strong>RabbitMQ不会为未确认的消息设置过期时间</strong>，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的<strong>消费者连接是否已经断开</strong>，这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</li></ul></li><li><p><strong>如果消息消费失败，也可以调用Basic.Reject或者Basic.Nack来拒绝当前消息而不是确认</strong></p><ul><li>如果只是简单的拒绝那么消息会丢失，需要将相应的requeue参数设置为true，那么RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者。</li><li>如果requeue参数设置为false的话，RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。</li></ul></li><li><p><strong>还有一种情况需要考虑：<code>requeue</code> 的消息是存入队列头部的，即可以快速的又被发送给消费</strong>，如果此时消费者又不能正确的消费而又requeue的话就会进入一个无尽的循环之中</p><ul><li>对于这种情况，笔者的建议是在出现无法正确消费的消息时<strong>不要采用requeue的方式来确保消息可靠性，而是重新投递到新的队列中</strong></li><li>比如设定的死信队列中，以此可以避免前面所说的死循环而又可以确保相应的消息不丢失。对于死信队列中的消息可以用另外的方式来消费分析，以便找出问题的根本。</li></ul></li></ul><p><strong>参考博客 ：</strong> </p><p><a href="https://blog.csdn.net/u013256816/article/details/79147591" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/79147591</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-14-消息的可靠性保证&quot;&gt;&lt;a href=&quot;#RabbitMQ-14-消息的可靠性保证&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-14-消息的可靠性保证&quot;&gt;&lt;/a&gt;RabbitMQ-14-消息的可靠性保证&lt;/h2&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ如何确保消息可靠？很多时候，笔者的回答都是：说来话长的事情何来长话短说。的确，要确保消息可靠不只是单单几句就能够叙述明白的，包括Kafka也是如此。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可靠并不是一个绝对的概念，曾经有人也留言说过类似全部磁盘损毁也会导致消息丢失，笔者戏答：还有机房被炸了也会导致消息丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可靠性是一个相对的概念，在条件合理的范围内系统所能确保的多少个9的可靠性。一切尽可能的趋于完美而无法企及于完美。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们可以尽可能的确保RabbitMQ的消息可靠。在详细论述RabbitMQ的消息可靠性之前，我们先来回顾下消息在RabbitMQ中的经由之路。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-094238362.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，从AMQP协议层面上来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消息先从生产者&lt;code&gt;Producer&lt;/code&gt; 出发到达交换器 &lt;code&gt;Exchange&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;交换器&lt;code&gt;Exchange&lt;/code&gt; 根据路由规则将消息转发到对应的&lt;code&gt;Queue&lt;/code&gt; 上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息在队列&lt;code&gt;Queue&lt;/code&gt; 上进行存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消费者Consumer订阅队列Queue并进行消费。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来 ： 我们对于消息可靠性的分析也从这四个阶段来一一探讨。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计组-07-存储器</title>
    <link href="http://zhuuu.work/2021/04/29/Compute_Organization/%E8%AE%A1%E7%BB%84-07-%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://zhuuu.work/2021/04/29/Compute_Organization/%E8%AE%A1%E7%BB%84-07-%E5%AD%98%E5%82%A8%E5%99%A8/</id>
    <published>2021-04-29T03:02:24.000Z</published>
    <updated>2021-05-14T06:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-07-存储器"><a href="#计算机组成原理-07-存储器" class="headerlink" title="计算机组成原理-07-存储器"></a>计算机组成原理-07-存储器</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-224820865.png" alt="mark"></p><a id="more"></a><h2 id="1-主存储器"><a href="#1-主存储器" class="headerlink" title="1. 主存储器"></a>1. 主存储器</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul><li><strong>回忆主存储器</strong><ul><li>逻辑结果如下所示</li><li>物理结果如下所示</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-225215817.png" alt="mark"></p><p><strong>读写操作流程：</strong></p><ul><li>指令执行的过程中需要访问主存的时候，<ul><li><strong>CPU首先把被访问单元的地址放入到MAR 中，然后通过地址线（注意是单向的）将主存地址送到主存的地址寄存器中</strong>，</li><li>以便地址译码器进行译码相应的单元，</li><li>同时CPU将读写信号通过控制先送到主存的读写控制电路</li></ul></li><li><strong>如果是写操作</strong>，那么CPU同时将要写的信息送到MDR中，在读写电路的控制下，经数据线（注意是双向的）将信号写入选中的单元</li><li><strong>如果是读操作</strong>，那么主存读出选中选中单元的内容送到数据线，然后送到MDR中</li><li><strong>需要注意的是：数据线的宽度和MDR的宽度是相同的，地址线的宽度和MAR的宽度是相同的</strong><ul><li>若采用64位的数据线，那么在按照字节编址的方式下，每次最多可以存取8个单元的内容<strong>（存储体的列数）</strong></li><li>地址线决定了主存地址空间的最大寻址范围，如36位的地址最大寻址范围是<code>0-(2^36)-1</code>（<strong>存储体的行数</strong>）</li><li>数据线和地址线数量共同反映了存储体的大小，若采用以上的存储方式，那么芯片的容量是<code>(2^36)*64位</code><strong>（行*列）</strong></li></ul></li></ul><p><strong>存储体容量计算：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-114712759.png" alt="mark"></p><p><strong>具体存储如下所示：</strong></p><ul><li>存储元：存储0或1的记忆单元（电容和开关组成）</li><li>存储单元：由一行存储元组成</li><li>存储字：一行存储元的位数</li><li>存储矩阵：也叫存储体，是存储器的核心</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-225425551.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-113850632.png" alt="mark"></p><ul><li>存储器和存储字长的关系</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-114145627.png" alt="mark"></p><p><strong>上图存储体的缺点</strong>：</p><ul><li><strong>一次只能进行一次读写（只有一行的控制线起作用）</strong></li><li><strong>优化是加入译码器 （n位地址 -&gt; 2^n 的存储单元）</strong><ul><li>本质是通过映射去实现</li><li>（n位地址 -&gt; 2^n 的存储单元）</li><li>（n位地址 -&gt; 2^n 的行数）</li></ul></li></ul><h3 id="1-2-主存的简单模型"><a href="#1-2-主存的简单模型" class="headerlink" title="1.2 主存的简单模型"></a>1.2 主存的简单模型</h3><ul><li>存储器芯片电路如下所示</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-150206423.png" alt="mark"></p><ul><li><strong>逻辑结构如下所示</strong><ul><li>片选线：控制开关</li><li>读写控制线：控制读写操作</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-150346258.png" alt="mark"></p><h3 id="1-3-寻址"><a href="#1-3-寻址" class="headerlink" title="1.3 寻址"></a>1.3 寻址</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-151155672.png" alt="mark"></p><p>对于上图结构而言：<strong>寻址</strong></p><ul><li><p><strong>如果存储的总容量为1KB,按字节寻址</strong></p><ul><li>那么就有1K个存储单元</li><li>每个存储单元的大小为1B = 8bit</li></ul></li><li><p><strong>如果存储的总容量为1KB,按字寻址</strong></p><ul><li>那么就有256个存储单元</li><li>每个存储单元的大小为4B</li></ul></li><li><p><strong>如果存储的总容量为1KB,按半字寻址</strong></p><ul><li>那么就有512个存储单元</li><li>每个存储单元的大小为2B</li></ul></li><li><p><strong>如果存储的总容量为1KB,按双字寻址</strong></p><ul><li>那么就有1024个存储单元</li><li>每个存储单元的大小为8B=64bit</li></ul></li></ul><p><strong>编址的概念如下所示：</strong></p><ul><li><strong>如果存储的总容量为1KB,按字节寻址</strong><ul><li>那么就有1K个存储单元</li><li>每个存储单元的大小为1B = 8bit</li><li><strong>需要地址线为10根数，地址为（0-1023）</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-151653135.png" alt="mark"></p><p><strong>若按字进行编址</strong></p><ul><li>也就是4个字节为一组</li><li>通过高位来分辨组与组之间的不同</li><li>具体编址如下所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-151915587.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-151926752.png" alt="mark"></p><p><strong>但是按字编址带来的问题：如何存储数据</strong></p><ul><li>大端存储：按照人的阅读模式存放（先放高位地址）</li><li>小端存储：与上面相反（先放低位字节）</li></ul><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-152245524.png" alt="mark"></p><h2 id="2-半导体存储器"><a href="#2-半导体存储器" class="headerlink" title="2. 半导体存储器"></a>2. 半导体存储器</h2><h3 id="2-1-半导体存储器的基本结构"><a href="#2-1-半导体存储器的基本结构" class="headerlink" title="2.1 半导体存储器的基本结构"></a>2.1 半导体存储器的基本结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-152648433.png" alt="mark"></p><h3 id="2-2-RAM"><a href="#2-2-RAM" class="headerlink" title="2.2 RAM"></a>2.2 RAM</h3><h4 id="2-2-1-RAM"><a href="#2-2-1-RAM" class="headerlink" title="2.2.1 RAM"></a>2.2.1 RAM</h4><ol><li><strong>半导体随机存储器</strong>（RAM）<ul><li>访问的内存位置与存放的地址无关</li><li>只和电流的速度有关</li></ul></li><li><strong>RAM分为以下两种类别</strong><ul><li>SRAM : 静态存储器</li><li>DRAM : 动态存储器</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-152912848.png" alt="mark"></p><ul><li>对比如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-085756413.png" alt="mark"></p><h4 id="2-2-2-DRAM的刷新问题"><a href="#2-2-2-DRAM的刷新问题" class="headerlink" title="2.2.2 DRAM的刷新问题"></a>2.2.2 DRAM的刷新问题</h4><ul><li>DRAM的刷新是以行为单位的（减少了选通线的数量）</li><li>刷新的周期为2ms</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-090312139.png" alt="mark"></p><ul><li>如何进行刷新的问题？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-090917502.png" alt="mark"></p><h4 id="2-2-3-SRAM读写周期"><a href="#2-2-3-SRAM读写周期" class="headerlink" title="2.2.3 SRAM读写周期"></a>2.2.3 SRAM读写周期</h4><ol><li><strong>读周期</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091259166.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091322746.png" alt="mark"></p><ol start="2"><li><strong>写周期</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091414747.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091427862.png" alt="mark"></p><h4 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4 小结"></a>2.2.4 小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091452293.png" alt="mark"></p><h3 id="2-3-ROM"><a href="#2-3-ROM" class="headerlink" title="2.3 ROM"></a>2.3 ROM</h3><ul><li><strong>ROM只读存储器</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-092216039.png" alt="mark"></p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-092328735.png" alt="mark"></p><h2 id="3-存储器的概念"><a href="#3-存储器的概念" class="headerlink" title="3. 存储器的概念"></a>3. 存储器的概念</h2><h3 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h3><ul><li>层次的角度来分<ul><li>高速缓冲存储器（cache）</li><li>主存储器（主存，内存）</li><li>辅助存储器（辅存，外存）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-092639214.png" alt="mark"></p><ul><li>存储介质来分类<ul><li>磁盘 磁带</li><li>磁芯存储器</li><li>半导体存储器</li></ul></li><li>存储方式来分类<ul><li>随机存储器（RAM） : 存储时间与存储的物理位置无关</li><li>只读存储器（ROM）: 只能随机读出而不能写入</li><li>串行访问存储器<ul><li>顺序存取存储器（磁带）</li><li>直接存取存储器（磁盘）</li></ul></li></ul></li></ul><h3 id="3-2-性能指标"><a href="#3-2-性能指标" class="headerlink" title="3.2 性能指标"></a>3.2 性能指标</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-095819701.png" alt="mark"></p><h3 id="3-3-层次化结构"><a href="#3-3-层次化结构" class="headerlink" title="3.3 层次化结构"></a>3.3 层次化结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-100220243.png" alt="mark"></p><h2 id="4-主存和CPU的连接"><a href="#4-主存和CPU的连接" class="headerlink" title="4. 主存和CPU的连接"></a>4. 主存和CPU的连接</h2><h3 id="4-1-主存容量的扩展"><a href="#4-1-主存容量的扩展" class="headerlink" title="4.1 主存容量的扩展"></a>4.1 主存容量的扩展</h3><h4 id="4-1-1-位扩展"><a href="#4-1-1-位扩展" class="headerlink" title="4.1.1 位扩展"></a>4.1.1 位扩展</h4><ul><li>当CPU的数据线与存储芯片的数据位数不相等时，需要对存储芯片进行位扩展，假设使用<code>8K*1位</code>的RAM芯片和<code>8K*8位</code>的CPU,使得数据位数和CPU的数据线位数相等。</li><li><strong>如下图所示：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-114456994.png" alt="mark"></p><ul><li>扩展后如下所示：<ul><li>地址并行的送至地址线</li><li>数据进行位扩展送到CPU</li><li>相当于合并为一个8K*8位的存储器</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-114644768.png" alt="mark"></p><h4 id="4-1-2-字扩展"><a href="#4-1-2-字扩展" class="headerlink" title="4.1.2 字扩展"></a>4.1.2 字扩展</h4><ul><li><p>字扩展是指增加存储器中字的数量，而位数不变</p></li><li><p>共用地址线 出现的问题：使得两个芯片同时开始工作 </p></li></ul><p><strong>如下图所示</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-115156837.png" alt="mark"></p><ul><li>解决方法：如下节所示<ul><li>线选法 ： n条线 产生n个片选信号</li><li>译码片选法 ：  n条线 产生<code>2^n</code>个片选信号</li></ul></li></ul><p><strong>线选法结果：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-115559709.png" alt="mark"></p><p><strong>译码片选法 ：</strong></p><ol><li><strong>单位二进制片选</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-120116732.png" alt="mark"></p><ol start="2"><li><strong>多位二进制位的片选</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-120541363.png" alt="mark"></p><p><strong>译码片选法结果 ：</strong></p><p>地址空间分布</p><ul><li><code>00XX</code></li><li><code>01XX</code></li><li><code>10XX</code></li><li><code>11XX</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-120847165.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-121236593.png" alt="mark"></p><h4 id="4-1-3-字和位同时扩展"><a href="#4-1-3-字和位同时扩展" class="headerlink" title="4.1.3 字和位同时扩展"></a>4.1.3 字和位同时扩展</h4><ul><li>先进行位扩展</li><li>再进行字扩展</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-121512269.png" alt="mark"></p><h2 id="5-双端口RAM和多模块存储器"><a href="#5-双端口RAM和多模块存储器" class="headerlink" title="5. 双端口RAM和多模块存储器"></a>5. 双端口RAM和多模块存储器</h2><h3 id="5-1-双端口RAM"><a href="#5-1-双端口RAM" class="headerlink" title="5.1 双端口RAM"></a>5.1 双端口RAM</h3><ul><li>双端口RAM 设计思路：同一个存储器有左右两个独立的端口，分别具有两组相互独立的地址线，数据线和读写控制线</li><li>允许两个独立的CPU同时异步的访问存储单元</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-150306478.png" alt="mark"></p><ul><li>缺点：CPU可能再对同一地址单元，会因数据的冲突造成数据存储或者读取错误<ul><li>解决方法：使用忙信号</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-150540636.png" alt="mark"></p><h3 id="5-2-多模块存储器"><a href="#5-2-多模块存储器" class="headerlink" title="5.2 多模块存储器"></a>5.2 多模块存储器</h3><ol><li>单体多字存储器：只有一个存储体，每个存储单元存储m个字，总线的宽度也为m个字</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-154813168.png" alt="mark"></p><ol start="2"><li>利用存储周期中：存储体需要对电信号进行恢复的特点可以分为：</li></ol><ul><li>高位交叉编址</li><li>低位交叉编址</li></ul><p><strong>对于连续访问地址而言：</strong></p><ul><li><strong>高位交叉编址：不能提高存储的吞吐率</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-155646155.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-155723417.png" alt="mark"></p><ul><li><strong>低位交叉编址：可以提高存储的吞吐率</strong><ul><li>采用流水线的存取方式</li><li>连续存储m个字的存储时间为：<code>t = T + （m - 1）r</code><ul><li>T 是一个存储周期</li><li>m是存储字</li><li>r是总线的传输周期</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-155748495.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-155805199.png" alt="mark"></p><p><strong>小结：</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-160643563.png" alt="mark" style="zoom:80%;" /><h3 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3 小结"></a>5.3 小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-160830950.png" alt="mark"></p><h2 id="6-高速缓冲存储器"><a href="#6-高速缓冲存储器" class="headerlink" title="6. 高速缓冲存储器"></a>6. 高速缓冲存储器</h2><p><strong>前言：使用高速缓存的原因</strong></p><ul><li>使用并行的多模块存储器之后 ： CPU和存储器的速度差距依旧很大</li><li>这就必须改变存储的体系：Cache（SRAM）-主存(DRAM)</li><li>高速缓存的原理是利用<strong>程序访问的局部性原理来实现的</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-161143553.png" alt="mark"></p><h3 id="6-1-程序访问的局部性原理分析"><a href="#6-1-程序访问的局部性原理分析" class="headerlink" title="6.1 程序访问的局部性原理分析"></a>6.1 程序访问的局部性原理分析</h3><ul><li>程序访问的局部性原理包括<ul><li><strong>时间局部性 ：</strong> 最近未来要使用到的信息，很可能是现在使用的信息</li><li><strong>空间局部性 ：</strong> 最近的未来用到的信息，很可能是现在正在使用信息在存储空间上邻近的，因为指令通常是顺序存放的</li></ul></li></ul><p><strong>举个例子：看下面两段代码来判断谁的性能更好？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">### 程序A</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumarrayrow</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,i &lt; M,i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 程序B</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumarrayrow</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>,j &lt; N,i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;j++)&#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;，</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设M和N都是2048，按字节编址的话，每个元素占用4个字节</span></span><br><span class="line">对于程序A来说 ，对数组的访问是a[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">0</span>][<span class="number">1</span>]...a[<span class="number">0</span>][<span class="number">2047</span>],a[<span class="number">1</span>][<span class="number">0</span>]...a[<span class="number">1</span>][<span class="number">2047</span>]，访问顺序和存放的顺序是一致的，因此空间局部性较好</span><br><span class="line">    </span><br><span class="line">对于程序B来说，对数组的访问是a[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">1</span>][<span class="number">0</span>]...a[<span class="number">2047</span>][<span class="number">0</span>],a[<span class="number">0</span>][<span class="number">1</span>],a[<span class="number">1</span>][<span class="number">1</span>]...a[<span class="number">2047</span>][<span class="number">1</span>],若主存与Cache的交换单位小于<span class="number">8</span>KB，则访问每一个元素都需要装入一个主存块到Cache中，因此没有空间局部性</span><br><span class="line">    </span><br><span class="line">对于时间局部性来说，两个数组的元素都只被访问了一次，因此时间局部性较差。</span><br><span class="line">    </span><br><span class="line">对于<span class="keyword">for</span>循环来说，程序A和程序B的时间局部性和空间局部性都较好，都被执行了<span class="number">2048</span>*<span class="number">2048</span>次</span><br><span class="line">    </span><br><span class="line">在电脑上进行试验，两个程序的所需的时钟周期相差了<span class="number">21</span>倍</span><br></pre></td></tr></table></figure><h3 id="6-2-Cache-的工作原理"><a href="#6-2-Cache-的工作原理" class="headerlink" title="6.2 Cache 的工作原理"></a>6.2 Cache 的工作原理</h3><ul><li>Cache 位于存储器结构的顶层，通常是由SRAM组成</li><li>Cache 块又被叫做Cache 行，每块由若干字节组成，块的长度叫做行长</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-114230905.png" alt="mark" style="zoom:67%;" /><p><strong>工作过程</strong></p><ul><li><strong>当发出读请求时</strong><ul><li>若访问的地址在<strong>Cache 命中</strong>，就将地址转换成Cache 地址，直接对Cache 进行操作，与主存无关</li><li>若访问的地址在<strong>Cache 未命中</strong>，就访问主存，同时将此字所在的块一次调入到Cache 中</li><li>若此时<strong>Cache 已满</strong>，则需要使用你<strong>某种替换算法</strong>，用这个块替换Cache 中原来的某块信息</li></ul></li><li><strong>当发出写请求时</strong><ul><li>若<strong>Cache 命中</strong>，有可能遇到的Cache 与主存中的内容不一致的问题<ul><li>由于CPU写Cache 。把Cache 中的内容从X改为了Y,而主存中的数据依旧是X</li></ul></li><li>若<strong>Cache没有命中</strong>，按照一定的写策略处理，常用的方法是<strong>全写法和写回法</strong></li></ul></li></ul><p><strong>注意：</strong></p><ul><li>Cache 和CPU交换数据是使用字节为单位</li><li>而Cache 和主存之间的交换数据是使用Cache 块为单位</li></ul><p><strong>举个例子：</strong></p><ul><li>未命中的时候: 从主存拉数据</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-165551926.png" alt="mark"></p><ul><li>未命中的时候：从cache拉数据，再访问主存</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-165732376.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-165921629.png" alt="mark"></p><h3 id="6-3-Cache和主存的映射方式"><a href="#6-3-Cache和主存的映射方式" class="headerlink" title="6.3 Cache和主存的映射方式"></a>6.3 Cache和主存的映射方式</h3><ul><li><strong>Cache 会有如下问题的存在</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-171822672.png" alt="mark" style="zoom:67%;" /><ul><li><strong>首先我们来看如何将主存的内容存入到Cache中</strong><ul><li>直接映射 ： 对号入座</li><li>全相联映射 ：全相联映射</li><li>组相联映射 ：组内随意放，按号分组</li></ul></li></ul><p><strong>举个例子：待后续具体分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-173101476.png" alt="mark"></p><h4 id="6-3-1-全相联映射"><a href="#6-3-1-全相联映射" class="headerlink" title="6.3.1 全相联映射"></a>6.3.1 全相联映射</h4><ul><li>主存中的每一块放到Cache 中的任意位置</li><li>优点：空间命中率高，利用率也高</li><li>缺点：标记速度慢，成本高</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-115645043.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-115754961.png" alt="mark"></p><h4 id="6-3-2-直接映射"><a href="#6-3-2-直接映射" class="headerlink" title="6.3.2 直接映射"></a>6.3.2 直接映射</h4><ul><li>主存中的每一块只能装入Cache 中的唯一位置</li><li>若这个位置已经有内容，那么产生块冲突，原来的块将无条件的被替换出去（无须替换算法）</li><li>直接映射的关系为 <code>j = i mod 2^c</code></li><li>标记不需要标记行号</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120113134.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120137931.png" alt="mark"></p><h4 id="6-3-3-组相联映射"><a href="#6-3-3-组相联映射" class="headerlink" title="6.3.3 组相联映射"></a>6.3.3 组相联映射</h4><ul><li>将Cache 空间分成大小相同的组</li><li>主存的一个数据块可以装入一组内的任何位置<ul><li>组间采用直接映射</li><li>组内采用全相联映射</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120609488.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120620998.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120847780.png" alt="mark"></p><h3 id="6-4-Cache-的替换算法"><a href="#6-4-Cache-的替换算法" class="headerlink" title="6.4 Cache 的替换算法"></a>6.4 Cache 的替换算法</h3><ul><li>四种算法预览：</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-105724247.png" alt="mark" style="zoom:67%;" /><p><strong>举个例子：</strong></p><ol><li><strong>使用全相联映射</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-110044764.png" alt="mark"></p><ol start="2"><li><strong>FIFO 内存置换</strong></li></ol><ul><li>最先调入的是4号块，替换Cache 的第0块</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-110231983.png" alt="mark" style="zoom:80%;" /><ol start="3"><li><strong>LRU 内存置换</strong></li></ol><ul><li>最近最少使用的是12号块，替换Cache的第二块</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-110327966.png" alt="mark" style="zoom:80%;" /><ol start="4"><li><strong>LFU 内存置换</strong></li></ol><ul><li>4号块使用了3次，6号块使用了两次，其他几块均使用了1次，需要更多的依据</li></ul><p><strong>小结：</strong></p><ul><li><strong>具体的Cache命中率需要考虑</strong><ul><li><strong>Cache的映射算法</strong></li><li><strong>Cache的替换算法</strong></li></ul></li></ul><h3 id="6-5-Cache-体系结构"><a href="#6-5-Cache-体系结构" class="headerlink" title="6.5 Cache 体系结构"></a>6.5 Cache 体系结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-111225347.png" alt="mark"></p><h3 id="6-6-Cache-与主存的-数据不一致"><a href="#6-6-Cache-与主存的-数据不一致" class="headerlink" title="6.6 Cache 与主存的 数据不一致"></a>6.6 Cache 与主存的 数据不一致</h3><ol><li><strong>写策略 - 命中的情形</strong></li></ol><ul><li><strong>写回法：</strong>当CPU对Cache 写命中的时候，只修改Cache 的内容，而不立即写回到主存中，只有当此块被换出的时候才写回主存。这种方法减少了访存的次数，但存在数据不一致的隐患。<ul><li>采用这种策略，每个Cache行需要设置一个（脏位），以反映是否被CPU修改过</li></ul></li><li><strong>全写法：</strong>当CPU对Cache 写命中的时候，将数据同时写入到Cache 和主存中，当某一块需要替换的时候，不必把这一块写回主存，用新调入的块直接覆盖即可。<ul><li>优点：实现简单，能随时保证主存数据的正确性</li><li>缺点：增加了访存的次数，降低了Cache的效率</li><li><strong>一般要设置 ： 写缓冲（减少主存和CPU之间的损耗）</strong></li><li>写缓冲有可能会溢出</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-111841954.png" alt="mark"></p><ol start="2"><li><strong>写策略：不命中的情形</strong></li></ol><ul><li><strong>写分配法</strong>：未命中时，将主存数据调入到Cache中，然后更新这个Cache块，同时搭配写回法</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-112012818.png" alt="mark"></p><ul><li><strong>非写分配法 ：</strong>  直接改写主存，搭配全写法</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-112226661.png" alt="mark"></p><ul><li><strong>现代计算机一般使用多级Cache</strong>, 如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-112335719.png" alt="mark"></p><ul><li>L1 Cache 和 L2 Cache 之间使用全写法，L2 Cache 对主存使用写回法</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-112511651.png" alt="mark"></p><h3 id="6-7-虚拟存储器"><a href="#6-7-虚拟存储器" class="headerlink" title="6.7 虚拟存储器"></a>6.7 虚拟存储器</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-113029730.png" alt="mark"></p><ul><li><p><strong>主存和辅存共同构成了虚拟存储器</strong></p><ul><li>对于程序员而言，虚拟存储器是透明的</li><li>相当于对实体存储器进行了一层封装</li></ul></li><li><p><strong>虚拟存储器将主存和辅存的地址空间统一编制</strong>，形成一个庞大的地址空间</p><ul><li><strong>用户</strong>编程允许的地址位：虚地址或者<strong>逻辑地址</strong></li><li><strong>实际</strong>的主存单元被称为：是地址或者<strong>物理地址</strong></li><li>实地址对应的是主存空间地址</li></ul></li><li><p>CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储的那元是否已装入到主存中</p><ul><li>若已在主存中，则通过地址变换，CPU可以直接的访问主存的实际存储单元</li><li>若不在主存中，则把对应的一页或者一段调入到主存后再由CPU访问</li><li>若主存已满，则采用替换算法替换主存中的一页或者一段</li></ul></li></ul><p><strong>以下只是简单介绍，具体看操作系统的博客内容</strong></p><h4 id="6-7-1-页式虚拟存储器"><a href="#6-7-1-页式虚拟存储器" class="headerlink" title="6.7.1 页式虚拟存储器"></a>6.7.1 页式虚拟存储器</h4><ul><li>虚拟空间和主存空间都被分为大小相同的页，主存的页叫做实页，虚拟的页叫做虚页</li><li>虚拟地址分为两个字段：<ul><li>虚页号</li><li>页内地址</li></ul></li><li>虚拟地址和物理地址的转换通过页表来实现</li><li>页面的大小是固定的</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-114120279.png" alt="mark"></p><p><strong>例题：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-144149727.png" alt="mark"></p><h4 id="6-7-2-段式虚拟存储器"><a href="#6-7-2-段式虚拟存储器" class="headerlink" title="6.7.2 段式虚拟存储器"></a>6.7.2 段式虚拟存储器</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-114259563.png" alt="mark"></p><ul><li>段的长度是可变的，段表只需要给出各段的起始地址和段的长度</li><li>优点：段的分解与程序的自然分界相对应，易于编译</li><li>缺点 ：长度可变</li></ul><h4 id="6-7-3-段页式虚拟存储器"><a href="#6-7-3-段页式虚拟存储器" class="headerlink" title="6.7.3 段页式虚拟存储器"></a>6.7.3 段页式虚拟存储器</h4><ul><li>先将程序按逻辑分段，每段再划分称为固定大小的页</li><li>虚地址分为 段号 + 段内页号 + 页内地址</li><li>缺点是：变换过程中需要多次查表，系统开销较大</li></ul><h4 id="6-7-4-快表"><a href="#6-7-4-快表" class="headerlink" title="6.7.4 快表"></a>6.7.4 快表</h4><ul><li>页表，段表存放在主存中，收到虚拟地址后需要先访问主存，查询主存中的页表，段表叫做<strong>慢表</strong></li><li><strong>快表的思想：利用高速缓存存放页表项</strong></li><li>利用局部性原理存入Cache</li></ul><h4 id="6-7-5-小结"><a href="#6-7-5-小结" class="headerlink" title="6.7.5 小结"></a>6.7.5 小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-143817051.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-07-存储器&quot;&gt;&lt;a href=&quot;#计算机组成原理-07-存储器&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-07-存储器&quot;&gt;&lt;/a&gt;计算机组成原理-07-存储器&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-224820865.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-06-算数逻辑单元ALU</title>
    <link href="http://zhuuu.work/2021/04/27/Compute_Organization/%E8%AE%A1%E7%BB%84-06-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/"/>
    <id>http://zhuuu.work/2021/04/27/Compute_Organization/%E8%AE%A1%E7%BB%84-06-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/</id>
    <published>2021-04-27T03:02:24.000Z</published>
    <updated>2021-04-29T14:38:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-06-算数逻辑单元ALU"><a href="#计算机组成原理-06-算数逻辑单元ALU" class="headerlink" title="计算机组成原理-06-算数逻辑单元ALU"></a>计算机组成原理-06-算数逻辑单元ALU</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-102318501.png" alt="mark"></p><ul><li><p>回顾 ALU (<code>Arithmetic and Logic Unit</code>)</p><ul><li><strong>功能</strong><ul><li>算数运算：加减乘除</li><li>逻辑运算：与或非 异或</li><li>辅助功能：移位 求补</li></ul></li><li><strong>逻辑结构</strong>如下所示</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-104120309.png" alt="mark" style="zoom:50%;" /></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-104639469.png" alt="mark"></p><ul><li><strong>本节概览</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-202659398.png" alt="mark"></p><a id="more"></a><h2 id="1-逻辑运算-电路表示"><a href="#1-逻辑运算-电路表示" class="headerlink" title="1. 逻辑运算 电路表示"></a>1. 逻辑运算 电路表示</h2><ul><li><strong>门电路的本质：高低电平</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-105015935.png" alt="mark"></p><ul><li><strong>门电路的运算优先级：离散数学</strong><ul><li>与运算 &gt; 或运算</li></ul></li></ul><ul><li><strong>门电路的复合逻辑运算</strong><ul><li>与或</li><li>或非</li><li>异或</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-110322606.png" alt="mark"></p><ul><li><strong>异或门的具体实现</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-110705700.png" alt="mark"></p><ul><li><strong>同或： 对异或的结果进行取反</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-110853101.png" alt="mark"></p><h2 id="2-门电路求-奇偶校验位"><a href="#2-门电路求-奇偶校验位" class="headerlink" title="2. 门电路求 奇偶校验位"></a>2. 门电路求 奇偶校验位</h2><ul><li><strong>偶校验位</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-200647575.png" alt="mark" style="zoom:80%;" /><h2 id="3-加法器原理"><a href="#3-加法器原理" class="headerlink" title="3. 加法器原理"></a>3. 加法器原理</h2><h3 id="3-1-一位全加器"><a href="#3-1-一位全加器" class="headerlink" title="3.1 一位全加器"></a>3.1 一位全加器</h3><ul><li><strong>一位全加器</strong><ul><li>加数A</li><li>加数B</li><li>低位传来的进位</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-201729375.png" alt="mark" style="zoom: 67%;" /><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-201806615.png" alt="mark" style="zoom:67%;" /><p><strong>复杂电路图如下所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-201828538.png" alt="mark"></p><p><strong>简略电路图如下所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-201858175.png" alt="mark"></p><h3 id="3-2-串行加法器"><a href="#3-2-串行加法器" class="headerlink" title="3.2 串行加法器"></a>3.2 串行加法器</h3><ul><li><strong>本质在一位加法器上保存了进位位</strong><ul><li>如果操作数长n位，加法分n次进行，每次产生一位和，并且串行的送回寄存器中</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-202122450.png" alt="mark" style="zoom: 80%;" /><h3 id="3-3-并行加法器"><a href="#3-3-并行加法器" class="headerlink" title="3.3 并行加法器"></a>3.3 并行加法器</h3><h4 id="3-3-1-串行进位"><a href="#3-3-1-串行进位" class="headerlink" title="3.3.1 串行进位"></a>3.3.1 串行进位</h4><ul><li>电路图所下所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-202532894.png" alt="mark"></p><ul><li>缺点 ： 低位运算产生所需要的时间影响最高位运算产生的时间</li></ul><h4 id="3-3-2-并行进位"><a href="#3-3-2-并行进位" class="headerlink" title="3.3.2 并行进位"></a>3.3.2 并行进位</h4><ul><li><strong>优化思路：递归展开到C0(第一个进位)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-203247645.png" alt="mark"></p><p><strong>方式一：单级先行进位方式：组内并行，组间串行</strong></p><ul><li>4位进位电路的CLA加法器</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-204123677.png" alt="mark"></p><p><strong>方式二 ： 多级先行进位方式</strong></p><ul><li><strong>组内并行，组件并行</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-222306836.png" alt="mark"></p><h4 id="3-3-3-ALU优化"><a href="#3-3-3-ALU优化" class="headerlink" title="3.3.3 ALU优化"></a>3.3.3 ALU优化</h4><ul><li>16位的组内并行，组间串行</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-223254793.png" alt="mark"></p><ul><li>16位的组内并行，组间并行</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-223351779.png" alt="mark"></p><ul><li><strong>小结</strong> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行加法器 -&gt; 串行进位的并行加法器 -&gt; 组内并行，组间串行 -&gt;组内并行，组间并行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-06-算数逻辑单元ALU&quot;&gt;&lt;a href=&quot;#计算机组成原理-06-算数逻辑单元ALU&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-06-算数逻辑单元ALU&quot;&gt;&lt;/a&gt;计算机组成原理-06-算数逻辑单元ALU&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-102318501.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;回顾 ALU (&lt;code&gt;Arithmetic and Logic Unit&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;算数运算：加减乘除&lt;/li&gt;
&lt;li&gt;逻辑运算：与或非 异或&lt;/li&gt;
&lt;li&gt;辅助功能：移位 求补&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑结构&lt;/strong&gt;如下所示&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-104120309.png&quot; alt=&quot;mark&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-104639469.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本节概览&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-202659398.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-091-编码方案</title>
    <link href="http://zhuuu.work/2021/04/21/Leetcode/Leetcode-091-%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88/"/>
    <id>http://zhuuu.work/2021/04/21/Leetcode/Leetcode-091-%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88/</id>
    <published>2021-04-21T03:02:24.000Z</published>
    <updated>2021-04-21T01:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-091-解码方法"><a href="#Leetcode-091-解码方法" class="headerlink" title="Leetcode-091-解码方法"></a>Leetcode-091-<a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">解码方法</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p><strong>说明:</strong></p><ul><li><strong>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</strong></li><li>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</li><li>题目数据保证答案肯定是一个 32 位 的整数。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure><h2 id="方案思路：动态规划"><a href="#方案思路：动态规划" class="headerlink" title="方案思路：动态规划"></a>方案思路：动态规划</h2><ul><li><p>对于给定的字符串 s，设它的长度为 n，其中的字符从左到右依次为<code>s[n]s[1],s[2],⋯,s[n]</code>。可以使用动态规划的方法计算出字符串 s 的解码方法数。</p></li><li><p>具体地，<code>f[i]</code>定义：代表的是最后解码方案的个数</p><ul><li>表示字符串 s 的前 i 个字符<code>s[1..i]</code>的解码方法数。</li></ul></li><li><p>在进行状态转移时，可以考虑最后一次解码使用了 s 中的哪些字符，那么会有下面的两种情况：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-094552918.png" alt="mark"></p><ul><li>需要注意的是，只有当 <code>i&gt;1</code>时才能进行转移，否则 <code>s[i-2]</code>不存在。</li></ul></li></ul><ul><li>边界条件：<code>f[0] = 1</code>即<strong>空字符串可以有 1 种解码方法，解码出一个空字符串</strong>。</li></ul><p><strong>注意：</strong></p><ul><li>同时，由于在大部分语言中，字符串的下标是从 0 而不是 1 开始的，因此在代码的编写过程中，我们需要将所有字符串的下标减去 1，与使用的语言保持一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. dp定义：dp代表的是最后解码方案的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 边界条件：空字符串也是一种编码结果</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转移逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 3.1 从数组末尾向前进行动态规划，统计所有的单字符编码方式</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>)&#123;                                     <span class="comment">// 判断条件为s[i - 1] != '0'</span></span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];                                         <span class="comment">// 统计所有的单字符编码方式          </span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 从数组末尾向前进行动态规划，统计所有的双字符编码方式</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">'0'</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">'0'</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) &lt;= <span class="number">26</span>))&#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];                                         <span class="comment">// 统计所有的双字符编码方式 </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 返回最后的方案数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ： O(n) , 遍历一遍数组</li><li>空间复杂度 ： O(n) , dp使用的额外空间</li></ul><h2 id="优化：滚动数组"><a href="#优化：滚动数组" class="headerlink" title="优化：滚动数组"></a>优化：滚动数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划（滚动数组）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// a = f[i-2], b = f[i-1], c=f[i]</span></span><br><span class="line">        <span class="comment">// 1. 定义：三种状态</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 转移逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 2.2 统计所有单字符的方案数</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>) &#123;</span><br><span class="line">                c += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.3 统计所有双字符的方案数</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">'0'</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">'0'</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) &lt;= <span class="number">26</span>)) &#123;</span><br><span class="line">                c += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 滚动数组</span></span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ： O(n) , 遍历一遍数组</li><li>空间复杂度 ： O(1) , 滚动数组仅仅设置三个变量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-091-解码方法&quot;&gt;&lt;a href=&quot;#Leetcode-091-解码方法&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-091-解码方法&quot;&gt;&lt;/a&gt;Leetcode-091-&lt;a href=&quot;https://leetcode-cn.com/problems/decode-ways/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解码方法&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一条包含字母 &lt;code&gt;A-Z&lt;/code&gt; 的消息通过以下映射进行了 &lt;strong&gt;编码&lt;/strong&gt; ：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;A&amp;#39; -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;B&amp;#39; -&amp;gt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;Z&amp;#39; -&amp;gt; 26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;要 &lt;strong&gt;解码&lt;/strong&gt; 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&lt;code&gt;&amp;quot;11106&amp;quot;&lt;/code&gt; 可以映射为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;AAJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(1 1 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;KJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(11 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。&lt;/li&gt;
&lt;li&gt;题目数据保证答案肯定是一个 32 位 的整数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>计组-05-数据的表示(浮点数)</title>
    <link href="http://zhuuu.work/2021/04/20/Compute_Organization/%E8%AE%A1%E7%BB%84-05-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA(%E6%B5%AE%E7%82%B9%E6%95%B0)/"/>
    <id>http://zhuuu.work/2021/04/20/Compute_Organization/%E8%AE%A1%E7%BB%84-05-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA(%E6%B5%AE%E7%82%B9%E6%95%B0)/</id>
    <published>2021-04-20T03:02:24.000Z</published>
    <updated>2021-04-28T02:18:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计组-05-数据的表示-浮点数"><a href="#计组-05-数据的表示-浮点数" class="headerlink" title="计组-05-数据的表示(浮点数)"></a>计组-05-数据的表示(浮点数)</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151330497.png" alt="mark"></p><ul><li><p><strong>定点数的局限性</strong></p><ul><li>在位数有限的情况下，无法增加数的表示范围</li></ul></li><li><p><strong>浮点数</strong></p><ul><li>在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度</li></ul></li><li><p><strong>本章节基本要点</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-152244855.png" alt="mark"></p><h2 id="1-浮点数的表示形式"><a href="#1-浮点数的表示形式" class="headerlink" title="1. 浮点数的表示形式"></a>1. 浮点数的表示形式</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151907866.png" alt="mark"></p><a id="more"></a><ul><li><strong>从科学计数法来理解浮点数的意义</strong><ul><li>r 为阶码的底 ： 浮点数的底，一般<code>r = 2</code></li><li>E 为阶码 :  通常用补码或者移码表示</li><li>M 称为尾数 ： 通常用补码或者原码表示</li><li>数字表示 <code>N = r^E * M</code></li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-152149842.png" alt="mark" style="zoom:67%;" /><ul><li><strong>定点数和浮点数的区别比较</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-152547010.png" alt="mark"></p><p><strong>小结：</strong></p><ul><li>尾数给出了一个小数，阶码指明了小数点要向前/向后移动多少位</li><li>尾数M的数值部分的位数n反映了浮点数的精度</li><li>阶码E反映了浮点数的表示范围以及小数点的实际位置</li></ul><p><strong>举个例子</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-193430512.png" alt="mark" style="zoom:67%;" /><h2 id="2-浮点数尾数的规格化"><a href="#2-浮点数尾数的规格化" class="headerlink" title="2. 浮点数尾数的规格化"></a>2. 浮点数尾数的规格化</h2><ul><li><strong>首先来看个问题</strong><ul><li>尾数的最高位不是一个有效位，会造成精度的损失</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-193547925.png" alt="mark" style="zoom:67%;" /><ul><li><strong>解决问题的方案：</strong><ul><li>规定尾数的最高位数值一定是个有效值</li><li>左规：将尾数算数左移一位，阶码减一</li><li>右规：将尾数算数右移一位，阶码加一<ul><li>右规：当使用双符号位的时候，同时有溢出发生时，可以进行挽救</li></ul></li></ul></li></ul><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-194840202.png" alt="mark"></p><p><strong>规格化的特点：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-195251237.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-200659972.png" alt="mark"></p><h2 id="3-IEEE-754"><a href="#3-IEEE-754" class="headerlink" title="3. IEEE 754"></a>3. IEEE 754</h2><h3 id="3-1-IEEE-754-移码"><a href="#3-1-IEEE-754-移码" class="headerlink" title="3.1 IEEE 754 移码"></a>3.1 IEEE 754 移码</h3><ul><li>之前所说的移码：补码的基础上将符号位取反<ul><li>这里偏置值是<code>128 = 2^（n-1）</code></li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201020345.png" alt="mark" style="zoom:67%;" /><ul><li><strong>移码的定义：移码 = 真值+偏置值</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201255878.png" alt="mark" style="zoom:67%;" /><ul><li><strong>IEEE 754 标准的移码</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201541486.png" alt="mark" style="zoom:67%;" /><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201606628.png" alt="mark"></p><h3 id="3-2-IEEE-754-浮点数表示"><a href="#3-2-IEEE-754-浮点数表示" class="headerlink" title="3.2 IEEE 754 浮点数表示"></a>3.2 IEEE 754 浮点数表示</h3><ul><li><strong>IEEE 754 标准的浮点数</strong><ul><li><strong>尾数采取隐藏位策略的原码表示</strong></li><li><strong>阶码用移码表示的浮点数</strong><ul><li>阶码的全0 和 全1  用作特殊用途</li><li>阶码的真值 = 移码 - 偏置值</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201918766.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-202741226.png" alt="mark"></p><hr><ul><li>将十进制转换为单精度浮点数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-203101005.png" alt="mark"></p><ul><li>将单精度浮点数转换为十进制数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-203410684.png" alt="mark"></p><h3 id="3-3-IEEE-754-表示范围"><a href="#3-3-IEEE-754-表示范围" class="headerlink" title="3.3 IEEE 754 表示范围"></a>3.3 IEEE 754 表示范围</h3><ul><li><strong>单精度浮点数表示范围</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-204358929.png" alt="mark"></p><ul><li><strong>双精度浮点数表示范围</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-204619375.png" alt="mark"></p><ul><li><p><strong>阶码全0 和 全1的作用</strong></p><ul><li><strong>阶码全0 ： 可以表示比原来最小值还要小的数</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-205014557.png" alt="mark"></p><ul><li><strong>阶码全1 ：可以表示比原来最大数还要大的数</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-205315986.png" alt="mark"></p><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><ul><li>由浮点数如何确定真值？<ul><li>根据 ”某浮点数“ 确定数符，阶码，尾数</li><li>确定尾数 1.M (注意补充最高的隐含位)</li><li>确定阶码的真值 = 移码 - 偏置值（可将移码看作无符号数，用无符号数的值减去偏置值）</li><li><code>（-1）^s * 1.M * 2^(E - 偏置值)</code></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-210207046.png" alt="mark"></p><h2 id="4-浮点数的计算"><a href="#4-浮点数的计算" class="headerlink" title="4. 浮点数的计算"></a>4. 浮点数的计算</h2><ul><li>首先还是从10进制浮点数原理开始说起<ul><li>分为几个步骤<ul><li>对阶 ： 小阶向大阶看齐</li><li>尾数加减 ：通常使用双符号位，拯救溢出</li><li>规格化 ： 左规和右规操作</li><li>舍入</li><li>判断溢出</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-092736401.png" alt="mark"></p><h3 id="4-1-二进制浮点数计算"><a href="#4-1-二进制浮点数计算" class="headerlink" title="4.1 二进制浮点数计算"></a>4.1 二进制浮点数计算</h3><ul><li><strong>二进制举个例子</strong><ul><li>无需舍入的例子如下：</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-094057128.png" alt="mark" style="zoom:67%;" /><p><img src="C:%5CUsers%5CZhuuu%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210428095730353.png" alt="image-20210428095730353"></p><h3 id="4-2-舍入的方法"><a href="#4-2-舍入的方法" class="headerlink" title="4.2 舍入的方法"></a>4.2 舍入的方法</h3><ul><li><p><strong>舍入的方式</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-100153984.png" alt="mark" style="zoom:67%;" /><ul><li>0 舍 1 入 法 ： 当舍弃的数字是1的时候，给末尾的数字加1</li><li>恒 置 1 法：无论舍弃的值为什么，把最后一位改为1</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-100405431.png" alt="mark" style="zoom:67%;" /><h2 id="5-浮点数-强制类型转换"><a href="#5-浮点数-强制类型转换" class="headerlink" title="5. 浮点数 强制类型转换"></a>5. 浮点数 强制类型转换</h2><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-100930859.png" alt="mark" style="zoom:67%;" /><ul><li><strong>无损的转换类型(32 位 情况下)</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char -&gt; int -&gt; long -&gt; double</span><br><span class="line">float -&gt; double</span><br><span class="line"></span><br><span class="line">## 注意 ： 在64位的情况下 long -&gt; double 有精度损失</span><br><span class="line"></span><br><span class="line">1. </span><br><span class="line">int -&gt; float : int有效位32 float有效位24 会有精度的损失</span><br><span class="line">float -&gt; int ： 可能会溢出也可能会有精度损失（int 没有小数部分）</span><br></pre></td></tr></table></figure><h2 id="6-浮点数小结"><a href="#6-浮点数小结" class="headerlink" title="6. 浮点数小结"></a>6. 浮点数小结</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-101726149.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计组-05-数据的表示-浮点数&quot;&gt;&lt;a href=&quot;#计组-05-数据的表示-浮点数&quot; class=&quot;headerlink&quot; title=&quot;计组-05-数据的表示(浮点数)&quot;&gt;&lt;/a&gt;计组-05-数据的表示(浮点数)&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151330497.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;定点数的局限性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位数有限的情况下，无法增加数的表示范围&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本章节基本要点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-152244855.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-浮点数的表示形式&quot;&gt;&lt;a href=&quot;#1-浮点数的表示形式&quot; class=&quot;headerlink&quot; title=&quot;1. 浮点数的表示形式&quot;&gt;&lt;/a&gt;1. 浮点数的表示形式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151907866.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-027-移除元素</title>
    <link href="http://zhuuu.work/2021/04/19/Leetcode/Leetcode-027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2021/04/19/Leetcode/Leetcode-027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2021-04-19T03:02:24.000Z</published>
    <updated>2021-04-19T03:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-027-移除元素"><a href="#Leetcode-027-移除元素" class="headerlink" title="Leetcode-027-移除元素"></a>Leetcode-027-移除元素</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</li><li>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</li><li>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</li></ul><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3</span><br><span class="line">输出：2, nums &#x3D; [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2</span><br><span class="line">输出：5, nums &#x3D; [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="方法一-：-双指针"><a href="#方法一-：-双指针" class="headerlink" title="方法一 ： 双指针"></a>方法一 ： 双指针</h2><ul><li>由于题目要求删除数组中等于<code>val</code> 的元素，因此输出数组的长度一定小于等于输入数组的长度，可以把输出的数组直接写在输入数组上。可以使用双指针：右指针<code>fast</code> 指向当前将要处理的元素，左指针<code>slow</code>指向下一个将要赋值的位置。<ul><li>如果右指针指向的元素不等于val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li><li>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</li></ul></li><li>整个过程保持不变的性质是：区间<code>[0,slow)</code> 中的元素都不等于 val。当左右指针遍历完输入数组以后，<code>slow</code>的值就是输出数组的长度。</li><li>这样的算法在最坏情况下（输入数组中没有元素等于 <em>val</em>），左右指针各遍历了数组一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 变量初始化及特判</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;                                   <span class="comment">// 慢指针</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;                                   <span class="comment">// 快指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val != nums[fast])&#123;                      <span class="comment">// 这种情况说明该快指针指向的元素需要被保留</span></span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;                                     <span class="comment">// 说明元素需要删除的，跳过该元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回处理后的末尾元素</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) ，遍历一遍数组</li><li>空间复杂度：O(1) ， 原地修改</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Leetcode-027-移除元素&quot;&gt;&lt;a href=&quot;#Leetcode-027-移除元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-027-移除元素&quot;&gt;&lt;/a&gt;Leetcode-027-移除元素&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-220-存在重复元素III</title>
    <link href="http://zhuuu.work/2021/04/17/Leetcode/Leetcode-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/"/>
    <id>http://zhuuu.work/2021/04/17/Leetcode/Leetcode-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/</id>
    <published>2021-04-17T01:02:24.000Z</published>
    <updated>2021-04-17T02:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-220-存在重复元素-III"><a href="#Leetcode-220-存在重复元素-III" class="headerlink" title="Leetcode-220-存在重复元素 III"></a>Leetcode-220-<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">存在重复元素 III</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在两个下标 i 和 j，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code>，同时又满足 <code>abs(i - j) &lt;= k</code> 。</li><li>如果存在则返回<code>true</code>，不存在返回<code>false。</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,0,1,1], k &#x3D; 1, t &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 10^4</span><br><span class="line">-2^31 &lt;&#x3D; nums[i] &lt;&#x3D; 2^31 - 1</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 10^4</span><br><span class="line">0 &lt;&#x3D; t &lt;&#x3D; 2^31 - 1</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路：滑动窗口"><a href="#算法思路：滑动窗口" class="headerlink" title="算法思路：滑动窗口"></a>算法思路：滑动窗口</h2><ul><li>对于序列中每一个元素 x 左侧的至多 k 个元素，如果这 k 个元素中存在一个元素落在区间<code>[x - t, x + t]</code>中，我们就找到了一对符合条件的元素。</li><li><strong>注意到对于两个相邻的元素，它们各自的左侧的 <em>k</em> 个元素中有 k−1 个是重合的。</strong><ul><li>于是我们可以使用滑动窗口的思路，维护一个大小为 <em>k</em> 的滑动窗口</li><li>每次遍历到元素 <em>x</em> 时，滑动窗口中包含元素 <em>x</em> 前面的最多 <em>k</em> 个元素</li><li>检查窗口中是否存在一个元素落在区间<code>[x - t, x + t]</code>中，我们就找到了一对符合条件的元素。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li><p>如果使用<strong>队列维护滑动窗口内的元素，由于元素是无序的</strong>，我们只能对于每个元素都遍历一次队列来检查是否有元素符合条件。</p><ul><li><strong>如果数组的长度为 <em>n</em>，则使用队列的时间复杂度为 O(nk)，会超出时间限制。</strong></li><li>因此我们希望能够找到一个数据结构维护滑动窗口内的元素，该数据结构需要满足以下操作：<ul><li><strong>支持添加和删除指定元素的操作</strong>，否则我们无法维护滑动窗口；</li><li>内部元素有序，支持二分查找的操作，这样我们可以<strong>快速判断滑动窗口中是否存在元素满足条件</strong></li><li>具体而言，对于元素 x，当我们希望判断滑动窗口中是否存在某个数 y 落在区间<code>[x - t, x + t]</code>中，只需要判断滑动窗口中所有大于等于<code>x - t</code>的元素中的最小元素是否小于等于<code>x + t</code>即可。</li></ul></li></ul></li></ul><p><strong>具体实现：</strong></p><ul><li><p>实现方面，我们在有序集合中查找大于等于 <code>x - t</code>的最小的元素<code>y</code>，如果 y 存在，且 <code>y ≤ x+t</code>，我们就找到了一对符合条件的元素。</p></li><li><p>完成检查后，我们将 <em>x</em> 插入到有序集合中，如果有序集合中元素数量超过了 <em>k</em>，我们将有序集合中最早被插入的元素删除即可。</p></li><li><p>如果当前有序集合中存在相同元素，那么此时程序将直接返回true。因此本题中的有序集合无需处理相同元素的情况。</p></li><li><p>为防止整型 int 溢出，我们既可以使用长整型 long，也可以对查找区间<code>[x - t, x + t]</code>进行限制，使其落在 int 范围内。</p></li></ul><ul><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 使用有序集合来维护大小为k的滑动窗口</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;Long&gt;();                            <span class="comment">// long为了防止溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理逻辑：遍历每个元素，滑动窗口包含了nums[i]的前k个元素，检查是否落在了[nums[i] - t,nums[i] + t]的区间内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 2.1 判断有序集合中是否存在符合条件的元素</span></span><br><span class="line">            Long ceiling = set.ceiling((<span class="keyword">long</span>) nums[i] - (<span class="keyword">long</span>) t);          <span class="comment">// ceiling()：方法返回在这个集合中大于或者等于给定元素的最小元素，如果不存在这样的元素,返回null.</span></span><br><span class="line">            <span class="keyword">if</span> (ceiling != <span class="keyword">null</span> &amp;&amp; ceiling &lt;= (<span class="keyword">long</span>) nums[i] + (<span class="keyword">long</span>) t) &#123;  <span class="comment">// 存在这样一对元素就直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 不存在的话暂时添加到有序集合中</span></span><br><span class="line">            set.add((<span class="keyword">long</span>) nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 维护大小为k的滑动窗口，删除超出范围的最早的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                set.remove((<span class="keyword">long</span>) nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 都不满足返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlog(min(<em>n</em>,<em>k</em>))) , n 是遍历一遍数组，log(min(<em>n</em>,<em>k</em>)) 是对集合的插入和删除操作</li><li>空间复杂度：O((min(<em>n</em>,<em>k</em>))) , 使用大小为k的滑动窗口，最差情况下是数组的大小</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-220-存在重复元素-III&quot;&gt;&lt;a href=&quot;#Leetcode-220-存在重复元素-III&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-220-存在重复元素 III&quot;&gt;&lt;/a&gt;Leetcode-220-&lt;a href=&quot;https://leetcode-cn.com/problems/contains-duplicate-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;存在重复元素 III&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在两个下标 i 和 j，使得 &lt;code&gt;abs(nums[i] - nums[j]) &amp;lt;= t&lt;/code&gt;，同时又满足 &lt;code&gt;abs(i - j) &amp;lt;= k&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;如果存在则返回&lt;code&gt;true&lt;/code&gt;，不存在返回&lt;code&gt;false。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,2,3,1], k &amp;#x3D; 3, t &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,0,1,1], k &amp;#x3D; 1, t &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,5,9,1,5,9], k &amp;#x3D; 2, t &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 2 * 10^4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-2^31 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 2^31 - 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; 10^4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; t &amp;lt;&amp;#x3D; 2^31 - 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-13-分布式事务</title>
    <link href="http://zhuuu.work/2021/04/11/RabbitMQ/RabbitMQ-13-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://zhuuu.work/2021/04/11/RabbitMQ/RabbitMQ-13-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-04-11T10:02:24.000Z</published>
    <updated>2021-04-11T08:08:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-13-分布式事务"><a href="#RabbitMQ-13-分布式事务" class="headerlink" title="RabbitMQ-13-分布式事务"></a>RabbitMQ-13-分布式事务</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><ul><li><p>分布式事务指事务的操作位于不同的节点上，需要保证事务的<code>AICD</code> 特性。</p></li><li><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p></li><li><p>在分布式系统中，要实现分布式事务，无外乎那几种解决方案。</p></li></ul><a id="more"></a><h3 id="2-生产者确认机制"><a href="#2-生产者确认机制" class="headerlink" title="2. 生产者确认机制"></a>2. 生产者确认机制</h3><ul><li>在使用<code>RabbitMQ</code>的时候，可以通过消息持久化操作来解决因为服务器的异常奔溃导致的消息丢失，除此之外我们还会遇到一个问题，当消息的发布者在将消息发送出去之后，消息到底有没有正确到达<code>broker</code>代理服务器呢？<ul><li>如果不进行特殊配置的话，默认情况下发布操作是不会返回任何信息给生产者的，也就是默认情况下我们的生产者是不知道消息有没有正确到达<code>broker</code>的，如果在消息到达<code>broker</code>之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器</li></ul></li></ul><p><strong>RabbitMQ为我们提供了两种方式：</strong></p><ol><li>通过AMQP<strong>事务机制</strong>实现，这也是AMQP协议层面提供的解决方案；</li><li>通过<strong>将channel设置成confirm模式来实现；</strong></li></ol><h4 id="2-1-事务机制"><a href="#2-1-事务机制" class="headerlink" title="2.1 事务机制"></a>2.1 事务机制</h4><ul><li>这里首先探讨下<code>RabbitMQ</code>事务机制。<ul><li><code>RabbitMQ</code>中与事务机制有关的方法有三个：<code>txSelect(), txCommit()以及txRollback(),</code> <code>txSelect</code>用于将当前<code>channel</code>设置成<code>transaction</code>模式，<code>txCommit</code>用于提交事务，txRollback用于回滚事务</li><li>在通过<code>txSelect</code>开启事务之后，我们便可以发布消息给<code>broker</code>代理服务器了</li><li>如果<code>txCommit</code>提交成功了，则消息一定到达了broker了，如果在<code>txCommit</code>执行之前<code>broker</code>异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过<code>txRollback</code>回滚事务了。</li></ul></li></ul><p><strong>关键代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">channel.txCommit();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过wirkshark抓包（ip.addr&#x3D;&#x3D;xxx.xxx.xxx.xxx &amp;&amp; amqp），可以看到：</span><br><span class="line">（注意这里的Tx.Commit与Tx.Commit-Ok之间的时间间隔294ms，由此可见事务还是很耗时的。）</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-105719190.png" alt="mark"></p><ul><li>我们先来看看没有事务的通信过程是什么样的：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-105815820.png" alt="mark"></p><p><strong>可以看到带事务的多了四个步骤：</strong></p><ul><li>client发送<code>Tx.Select</code></li><li>broker发送<code>Tx.Select-Ok(之后publish)</code></li><li>client发送<code>Tx.Commit</code></li><li>broker发送<code>Tx.Commit-Ok</code></li></ul><ul><li>下面我们来看下<strong>事务回滚</strong>是什么样子的。关键代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-110143319.png" alt="mark"></p><p>代码中先是发送了消息至<code>broker</code>中但是这时候发生了异常，之后在捕获异常的过程中进行事务回滚。</p><p><strong>注意：</strong></p><ul><li><p>事务确实能够解决<code>producer</code>与<code>broker</code>之间消息确认的问题，只有消息成功被<code>broker</code>接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发</p></li><li><p>但是使用事务机制的话会降低RabbitMQ的性能，<strong>那么有没有更好的方法既能保障producer知道消息已经正确送到，又能基本上不带来性能上的损失呢？</strong></p><ul><li><strong>从AMQP协议的层面看是没有更好的方法，但是RabbitMQ提供了一个更好的方案，即将channel信道设置成confirm模式。</strong></li></ul></li></ul><h4 id="2-2-Confirm-机制"><a href="#2-2-Confirm-机制" class="headerlink" title="2.2 Confirm 机制"></a>2.2 Confirm 机制</h4><ul><li>上面我们介绍了RabbitMQ可能会遇到的一个问题，即生成者不知道消息是否真正到达broker，随后通过AMQP协议层面为我们提供了事务机制解决了这个问题，但是采用事务机制实现会降低RabbitMQ的消息吞吐量，那么有没有更加高效的解决方式呢？答案是采用Confirm模式。</li><li><strong>实现原理</strong><ul><li>生产者将信道设置成<code>confirm</code>模式，一旦信道进入<code>confirm</code>模式，所有在该信道上面发布的消息都会被指派一个唯一的<code>ID</code>(从1开始)，一旦消息被投递到所有匹配的队列之后，<code>broker</code>就会发送一个确认给生产者（包含消息的唯一<code>ID</code>）,这就使得生产者知道消息已经正确到达目的队列了</li><li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，<strong>broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号</strong>，此外broker也可以设置basic.ack的<code>multiple</code>域，表示到这个序列号之前的所有消息都已经得到了处理。</li><li><strong>confirm模式最大的好处在于他是异步的</strong>，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息</li><li><strong>如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息</strong>，生产者应用程序同样可以在回调方法中处理该nack消息。</li><li>在<code>channel</code>被设置成<code>confirm</code>模式之后，所有被 <code>publish</code>的后续消息都将被<code>confirm</code>（即 ack） 或者被nack一次。</li><li>但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack 。</li></ul></li></ul><p><strong>开启confirm 模式的方式</strong></p><ul><li><strong>生产者通过调用channel的confirmSelect方法将channel设置为confirm模式，如果没有设置no-wait标志的话，broker会返回confirm.select-ok表示同意发送者将当前channel信道设置为confirm模式</strong></li><li>(从目前RabbitMQ最新版本3.6来看，如果调用了channel.confirmSelect方法，默认情况下是直接将no-wait设置成false的，也就是默认情况下broker是必须回传confirm.select-ok的)。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-111340430.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li>已经在<code>transaction</code>事务模式的channel是不能再设置成<code>confirm</code>模式的，<strong>即这两种模式是不能共存的。</strong></li><li>事务机制和<code>publisher confirm</code> 机制作用都是确保消息能够正确的发送到<code>rabbitMQ</code></li></ul><h4 id="2-3-Confirm-编程"><a href="#2-3-Confirm-编程" class="headerlink" title="2.3 Confirm 编程"></a>2.3 Confirm 编程</h4><ul><li>对于固定消息体大小和线程数，<strong>如果消息持久化，生产者confirm(或者采用事务机制)，消费者ack那么对性能有很大的影响.</strong></li><li>消息持久化的优化没有太好方法，用更好的物理存储（SAS, SSD, RAID卡）总会带来改善。</li><li>生产者confirm这一环节的优化则主要在于客户端程序的优化之上。归纳起来，客户端实现生产者confirm有三种编程方式：<ul><li><strong>普通confirm模式：</strong>每发送一条消息后，调用waitForConfirms()方法，等待服务器端confirm。实际上是一种串行confirm了。</li><li><strong>批量confirm模式</strong>：每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。</li><li><strong>异步confirm模式：</strong>提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法。</li></ul></li></ul><p><strong>从编程实现的复杂度上来看：</strong></p><p><strong>第一种：普通confirm 机制</strong></p><ul><li>普通confirm模式最简单，publish一条消息后，等待服务器端confirm,如果服务端返回false或者超时时间内未返回，客户端进行消息重传。</li></ul><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line"><span class="keyword">if</span>(!channel.waitForConfirms())&#123;</span><br><span class="line">System.out.println(<span class="string">"send message failed."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wirkShark抓包可以看到如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-113556012.png" alt="mark"></p><p>(注意这里的Publish与Ack的时间间隔：305ms 4ms 4ms 15ms 5ms… )</p><p><strong>第二种：批量 confirm模式</strong></p><ul><li>批量<code>confirm</code>模式稍微复杂一点，<strong>客户端程序需要定期（每隔多少秒）或者定量（达到多少条）</strong>或者两则结合起来<code>publish</code>消息，然后等待服务器端<code>confirm</code>, 相比普通<code>confirm</code>模式，批量极大提升<code>confirm</code>效率</li><li>是问题在于一旦出现<code>confirm</code>返回<code>false</code>或者超时的情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且，当消息经常丢失时，批量<code>confirm</code>性能应该是不升反降的。</li></ul><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;batchCount;i++)&#123;</span><br><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!channel.waitForConfirms())&#123;</span><br><span class="line">System.out.println(<span class="string">"send message failed."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种：异步 Confirm机制</strong></p><ul><li>异步<code>confirm</code>模式的编程实现最复杂，<strong>Channel对象提供的ConfirmListener()回调方法只包含deliveryTag</strong>（当前<code>Channel</code>发出的消息序号）<ul><li><strong>我们需要自己为每一个Channel维护一个<code>unconfirm</code>的消息序号集合，每<code>publish</code>一条数据，集合中元素加1，每回调一次<code>handleAck</code>方法，<code>unconfirm</code>集合删掉相应的一条（<code>multiple=false</code>）或多条（<code>multiple=true</code>）记录</strong></li><li>从程序运行效率上看，这个<code>unconfirm</code>集合最好采用有序集合<code>SortedSet</code>存储结构。实际上，SDK中的<code>waitForConfirms()</code>方法也是通过<code>SortedSet</code>维护消息序号的。</li></ul></li></ul><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line">channel.confirmSelect();</span><br><span class="line">       channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                   confirmSet.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   confirmSet.remove(deliveryTag);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"Nack, SeqNo: "</span> + deliveryTag + <span class="string">", multiple: "</span> + multiple);</span><br><span class="line">               <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                   confirmSet.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   confirmSet.remove(deliveryTag);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">long</span> nextSeqNo = channel.getNextPublishSeqNo();</span><br><span class="line">           channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">           confirmSet.add(nextSeqNo);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><code>SDK</code>中<code>waitForConfirms</code>方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Set of currently unconfirmed messages (i.e. messages that have</span></span><br><span class="line"><span class="comment"> *  not been ack'd or nack'd by the server yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedSet&lt;Long&gt; unconfirmedSet =</span><br><span class="line">        Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextPublishSeqNo == <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Confirms not selected"</span>);</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">synchronized</span> (unconfirmedSet) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getCloseReason() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> Utility.fixStackTrace(getCloseReason());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (unconfirmedSet.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> aux = onlyAcksReceived;</span><br><span class="line">                onlyAcksReceived = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> aux;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0L</span>) &#123;</span><br><span class="line">                unconfirmedSet.wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsed = System.currentTimeMillis() - startTime;</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt; elapsed) &#123;</span><br><span class="line">                    unconfirmedSet.wait(timeout - elapsed);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">Client端机器和RabbitMQ机器配置：CPU:24核，2600MHZ, 64G内存，1TB硬盘。</span><br><span class="line">Client端发送消息体大小10B，线程数为1即单线程，消息都持久化处理（deliveryMode:2）。</span><br><span class="line">分别采用事务模式、普通confirm模式，批量confirm模式和异步confirm模式进行producer实验，比对各个模式下的发送性能。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-150253989.png" alt="mark"></p><p>发送平均速率：</p><ul><li>事务模式（tx）：1637.484</li><li>普通confirm模式(common)：1936.032</li><li>批量confirm模式(batch)：10432.45</li><li>异步confirm模式(async)：10542.06</li></ul><p><strong>小结：</strong></p><ul><li>可以看到事务模式性能是最差的，普通<code>confirm</code>模式性能比事务模式稍微好点，但是和批量<code>confirm</code>模式还有异步<code>confirm</code>模式相比，还是小巫见大巫。</li><li>批量<code>confirm</code>模式的问题在于<code>confirm</code>之后返回<code>false</code>之后进行重发这样会使性能降低，异步<code>confirm</code>模式(async)编程模型较为复杂，至于采用哪种方式，那是仁者见仁智者见智了。</li></ul><h3 id="3-消费端的消息确认"><a href="#3-消费端的消息确认" class="headerlink" title="3. 消费端的消息确认"></a>3. 消费端的消息确认</h3><ul><li><p>为了保证消息从队列可靠地到达消费者，RabbitMQ提供消息确认机制(<code>message acknowledgment</code>)。</p></li><li><p>消费者在声明队列时，可以指定noAck参数，当<code>noAck=false</code>时，RabbitMQ会等待消费者显式发回ack信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。</p><ul><li>否则，RabbitMQ会在队列中消息被消费后立即删除它。</li></ul></li><li><p>采用消息确认机制后，只要令<code>noAck=false</code>，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为<code>RabbitMQ</code>会一直持有消息直到消费者显式调用<code>basicAck</code>为止。</p></li></ul><hr><ul><li>当<code>noAck=false</code>时，对于RabbitMQ服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；<strong>一部分是已经投递给消费者，但是还没有收到消费者ack信号的消息。</strong><ul><li>如果<strong>服务器端一直没有收到消费者的ack信号</strong>，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。</li><li>RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要<strong>重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</strong></li></ul></li><li><code>RabbitMQ</code>管理平台界面上可以看到当前队列中<code>Ready状态和Unacknowledged</code>状态的消息数<ul><li>分别对应上文中的等待投递给消费者的消息数和已经投递给消费者但是未收到ack信号的消息数</li><li>也可以通过命令行来查看上述信息：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-151011828.png" alt="mark"></p><p><strong>代码示例（关闭自动消息确认，进行手动ack）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">   channel.basicConsume(ConfirmConfig.queueName, <span class="keyword">false</span>, consumer);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">       String msg = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line"><span class="comment">// do something with msg. </span></span><br><span class="line">       channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">broker将在下面的情况中对消息进行confirm：</span><br><span class="line"></span><br><span class="line">1. broker发现当前消息无法被路由到指定的queues中（如果设置了mandatory属性，则broker会发送basic.return）</span><br><span class="line">2. 非持久属性的消息到达了其所应该到达的所有queue中（和镜像queue中）</span><br><span class="line">3. 持久消息到达了其所应该到达的所有queue中（和镜像中），并被持久化到了磁盘（fsync）</span><br><span class="line">4. 持久消息从其所在的所有queue中被consume了（如果必要则会被ack）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">basicRecover：是路由不成功的消息可以使用recovery重新发送到队列中。</span><br><span class="line">basicReject：是接收端告诉服务器这个消息我拒绝接收,不处理,可以设置是否放回到队列中还是丢掉，而且只能一次拒绝一个消息,官网中有明确说明不能批量拒绝消息，为解决批量拒绝消息才有了basicNack。</span><br><span class="line">basicNack：可以一次拒绝N条消息，客户端可以设置basicNack方法的multiple参数为true，服务器会拒绝指定了delivery_tag的所有未确认的消息(tag是一个64位的long值，最大值是9223372036854775807)。</span><br></pre></td></tr></table></figure><h3 id="4-分布式事务解决方案"><a href="#4-分布式事务解决方案" class="headerlink" title="4. 分布式事务解决方案"></a>4. 分布式事务解决方案</h3><h4 id="4-1-2PC"><a href="#4-1-2PC" class="headerlink" title="4.1 2PC"></a>4.1 2PC</h4><ul><li><p>两段式提交(2PC) 需要数据库产商的支持，java组件有atomikos等</p></li><li><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p></li></ul><ol><li><strong>准备阶段</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-215343359.png" alt="mark"></p><ol start="2"><li>提交阶段</li></ol><ul><li>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</li><li>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-220518513.png" alt="mark"></p><p><strong>存在的问题</strong></p><ul><li><p>2.1 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p></li><li><p>2.2 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p></li><li><p>2.3 数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p></li><li><p>2.4 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p></li></ul><h4 id="4-2-TCC"><a href="#4-2-TCC" class="headerlink" title="4.2 TCC"></a>4.2 TCC</h4><ul><li><code>TCC</code> 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：<ul><li><code>Try</code> 阶段主要是对业务系统做检测及资源预留</li><li><code>Confirm</code>阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行<code>Confirm</code>阶段时，默认 - - - <code>Confirm</code>阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li><li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用</span><br><span class="line">1：首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</span><br><span class="line">2：在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</span><br><span class="line">3：如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</span><br></pre></td></tr></table></figure><ul><li>优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些</li><li>缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</li></ul><h4 id="4-3-本地消息表"><a href="#4-3-本地消息表" class="headerlink" title="4.3 本地消息表"></a>4.3 本地消息表</h4><ul><li><p>（异步确保）比如：支付宝、微信支付主动查询支付状态，对账单的形式</p></li><li><p><strong>本地消息表与业务数据表处于同一个数据库中</strong>，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，<strong>并且使用了消息队列来保证最终一致性。</strong></p><ul><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-221109158.png" alt="mark"></p><ul><li>优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li><li>缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li></ul><h4 id="4-4-MQ事务"><a href="#4-4-MQ事务" class="headerlink" title="4.4 MQ事务"></a>4.4 MQ事务</h4><ul><li>有一些第三方的MQ是支持事务消息的，比如<code>RocketMQ</code>，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 Kafka 不支持。</li><li>以阿里的 <code>RocketMQ</code>中间件为例，其思路大致为：<ul><li>第一阶段<code>Prepared</code>消息，会拿到消息的地址。 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</li><li>也就是说在业务方法内要向消息队列提交两次请求，一次发送消息和一次确认消息。<ul><li>如果确认消息发送失败了.<code>RocketMQ</code>会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认</li><li>所以生产方需要实现一个check接口，<code>RocketMQ</code>会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-221710984.png" alt="mark"></p><p><strong>优缺点分析</strong></p><ul><li>优点： 实现了最终一致性，不需要依赖本地数据库事务。</li><li>缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。</li></ul><h3 id="5-rabbitMQ-实现可靠生产与消费"><a href="#5-rabbitMQ-实现可靠生产与消费" class="headerlink" title="5. rabbitMQ 实现可靠生产与消费"></a>5. rabbitMQ 实现可靠生产与消费</h3><ol><li><strong>可靠生产</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-224418881.png" alt="mark"></p><ul><li>所谓的MQ可靠生产：就是利用<strong>消息冗余</strong>的方式（增加一个status的状态）<ul><li>如果成功：修改状态</li><li>如果失败：定时器重新执行</li><li><strong>本质利用的是消息队列的ack应答机制</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-223012091.png" alt="mark"></p><ol start="2"><li><strong>可靠消费</strong></li></ol><ul><li>需要注意的是：消费者在消费过程中出现异常，rabbitMQ会一直进行不停的重试（即代码进入死循环）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-224513979.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-225012520.png" alt="mark"></p><ul><li><strong>解决方案</strong><ul><li>控制重发的次数 + 死信队列</li><li>用<code>try catch</code> 和 手动<code>ack</code> <ul><li>注意这里无法再设置重发次数，如果设置了重发，那么还是会进入死循环</li><li>这里<code>try catch</code> 和 手动<code>ack</code> 会造成消息的丢失</li><li>解决方法是方案三：用<code>try catch</code>和 手动<code>ack</code> + 死信队列</li></ul></li><li>用<code>try catch</code>和 手动<code>ack</code> + 死信队列</li></ul></li></ul><ul><li>注意事项<ul><li>要考虑数据的<strong>幂等性</strong>：若死信消费者和普通消费者同时保存订单，那么就不满足幂等性了<ul><li>如下订单的方式：可以使用<strong>订单id作为一个唯一主键来保证幂等性</strong></li><li><strong>分布式锁来解决这个问题</strong></li></ul></li></ul></li></ul><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><ul><li>通过本文我们总结并对比了几种分布式分解方案的优缺点，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择吧。</li><li>阿里<code>RocketMQ</code>去实现的分布式事务，现在也有除了很多分布式事务的协调器，比如<code>LCN</code>等，大家可以多去尝试。</li></ul><p><strong>基于MQ的优点</strong></p><p>1、通用性强<br>2、拓展方便<br>3、耦合度低，方案也比较成熟</p><p><strong>基于MQ分布式事务的缺点</strong></p><p>1、基于消息中间件，只适合异步场景<br>2、消息会延迟处理，需要业务上能够容忍</p><p><strong>建议</strong></p><p>1、尽量去避免分布式事务<br>2、尽量将非核心业务做成异步</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-13-分布式事务&quot;&gt;&lt;a href=&quot;#RabbitMQ-13-分布式事务&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-13-分布式事务&quot;&gt;&lt;/a&gt;RabbitMQ-13-分布式事务&lt;/h2&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分布式事务指事务的操作位于不同的节点上，需要保证事务的&lt;code&gt;AICD&lt;/code&gt; 特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在分布式系统中，要实现分布式事务，无外乎那几种解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-12-集群搭建</title>
    <link href="http://zhuuu.work/2021/04/10/RabbitMQ/RabbitMQ-12-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://zhuuu.work/2021/04/10/RabbitMQ/RabbitMQ-12-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</id>
    <published>2021-04-10T08:02:24.000Z</published>
    <updated>2021-04-10T14:04:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-12-集群搭建"><a href="#RabbitMQ-12-集群搭建" class="headerlink" title="RabbitMQ-12-集群搭建"></a>RabbitMQ-12-集群搭建</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><ul><li><code>RabbitMQ</code>这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，<code>RabbitMQ天然支持Clustering</code>。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。</li><li>集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。</li><li>在<strong>实际使用过程中多采取多机多实例部署方式</strong>，为了便于同学们练习搭建，有时候你不得不在一台机器上去搭建一个rabbitmq集群，<strong>本章主要针对单机多实例这种方式来进行开展。</strong></li></ul><p><strong>注意：</strong></p><ul><li>主要参考官方文档：<a href="https://www.rabbitmq.com/clustering.html" target="_blank" rel="noopener">https://www.rabbitmq.com/clustering.html</a></li></ul><a id="more"></a><h3 id="2-单机多实例搭建演示"><a href="#2-单机多实例搭建演示" class="headerlink" title="2. 单机多实例搭建演示"></a>2. 单机多实例搭建演示</h3><h4 id="2-1-前提准备"><a href="#2-1-前提准备" class="headerlink" title="2.1 前提准备"></a>2.1 前提准备</h4><ul><li>配置的前提是你的rabbitmq可以运行起来，比如<code>”ps aux|grep rabbitmq”</code>你能看到相关进程，又比如运行<code>“rabbitmqctl status”</code>你可以看到类似如下信息，而不报错：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep rabbitmq</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-201101022.png" alt="mark"></p><ul><li>注意：确保RabbitMQ可以运行的，确保完成之后，把单机版的RabbitMQ服务停止，后台看不到RabbitMQ的进程为止</li></ul><h4 id="2-2-单机多实例搭建"><a href="#2-2-单机多实例搭建" class="headerlink" title="2.2 单机多实例搭建"></a>2.2 单机多实例搭建</h4><ul><li><strong>场景：</strong>假设有两个rabbitmq节点，分别为rabbit-1, rabbit-2，rabbit-1作为主节点，rabbit-2作为从节点。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动命令：RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbitmq-server -detached</span><br><span class="line">结束命令：rabbitmqctl -n rabbit-1 stop</span><br></pre></td></tr></table></figure><ol><li><strong>启动第一个节点</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbitmq-server start &amp;</span><br><span class="line">...............省略...................</span><br><span class="line">  <span class="comment">##########  Logs: /var/log/rabbitmq/rabbit-1.log</span></span><br><span class="line">  <span class="comment">######  ##        /var/log/rabbitmq/rabbit-1-sasl.log</span></span><br><span class="line">  <span class="comment">##########</span></span><br><span class="line">              Starting broker...</span><br><span class="line"> completed with 7 plugins.</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动第二个节点</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注意：web管理插件端口占用,所以还要指定其web插件占用的端口号</span><br><span class="line">RABBITMQ_SERVER_START_ARGS=”-rabbitmq_management listener [&#123;port,15673&#125;]”</span><br><span class="line"></span><br><span class="line">sudo RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=<span class="string">"-rabbitmq_management listener [&#123;port,15673&#125;]"</span> RABBITMQ_NODENAME=rabbit-2 rabbitmq-server start &amp;</span><br><span class="line">..............省略..................</span><br><span class="line">  <span class="comment">##########  Logs: /var/log/rabbitmq/rabbit-2.log</span></span><br><span class="line">  <span class="comment">######  ##        /var/log/rabbitmq/rabbit-2-sasl.log</span></span><br><span class="line">  <span class="comment">##########</span></span><br><span class="line">              Starting broker...</span><br><span class="line"> completed with 7 plugins.</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>检查是否启动成功</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq  2022  2.7  0.4 5349380 77020 ?       Sl   11:03   0:06 /usr/lib/erlang/erts-9.2/bin/beam.smp -W w -A 128 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K <span class="literal">true</span> -B i -- -root /usr/lib/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/ebin -noshell -noinput -s rabbit boot -sname rabbit-1 -boot start_sasl -kernel inet_default_connect_options [&#123;nodelay,<span class="literal">true</span>&#125;] -rabbit tcp_listeners [&#123;<span class="string">"auto"</span>,5672&#125;] -sasl errlog_type error -sasl sasl_error_logger <span class="literal">false</span> -rabbit error_logger &#123;file,<span class="string">"/var/log/rabbitmq/rabbit-1.log"</span>&#125; -rabbit sasl_error_logger &#123;file,<span class="string">"/var/log/rabbitmq/rabbit-1-sasl.log"</span>&#125; -rabbit enabled_plugins_file <span class="string">"/etc/rabbitmq/enabled_plugins"</span> -rabbit plugins_dir <span class="string">"/usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/plugins"</span> -rabbit plugins_expand_dir <span class="string">"/var/lib/rabbitmq/mnesia/rabbit-1-plugins-expand"</span> -os_mon start_cpu_sup <span class="literal">false</span> -os_mon start_disksup <span class="literal">false</span> -os_mon start_memsup <span class="literal">false</span> -mnesia dir <span class="string">"/var/lib/rabbitmq/mnesia/rabbit-1"</span> -kernel inet_dist_listen_min 25672 -kernel inet_dist_listen_max 25672 start</span><br><span class="line">rabbitmq  2402  4.2  0.4 5352196 77196 ?       Sl   11:05   0:05 /usr/lib/erlang/erts-9.2/bin/beam.smp -W w -A 128 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K <span class="literal">true</span> -B i -- -root /usr/lib/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/ebin -noshell -noinput -s rabbit boot -sname rabbit-2 -boot start_sasl -kernel inet_default_connect_options [&#123;nodelay,<span class="literal">true</span>&#125;] -rabbit tcp_listeners [&#123;<span class="string">"auto"</span>,5673&#125;] -sasl errlog_type error -sasl sasl_error_logger <span class="literal">false</span> -rabbit error_logger &#123;file,<span class="string">"/var/log/rabbitmq/rabbit-2.log"</span>&#125; -rabbit sasl_error_logger &#123;file,<span class="string">"/var/log/rabbitmq/rabbit-2-sasl.log"</span>&#125; -rabbit enabled_plugins_file <span class="string">"/etc/rabbitmq/enabled_plugins"</span> -rabbit plugins_dir <span class="string">"/usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/plugins"</span> -rabbit plugins_expand_dir <span class="string">"/var/lib/rabbitmq/mnesia/rabbit-2-plugins-expand"</span> -os_mon start_cpu_sup <span class="literal">false</span> -os_mon start_disksup <span class="literal">false</span> -os_mon start_memsup <span class="literal">false</span> -mnesia dir <span class="string">"/var/lib/rabbitmq/mnesia/rabbit-2"</span> -rabbitmq_management listener [&#123;port,15673&#125;] -kernel inet_dist_listen_min 25673 -kernel inet_dist_listen_max 25673 start</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>rabbit-1作为主节点</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#停止应用</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-1 stop_app</span><br><span class="line"><span class="comment">#目的是清除节点上的历史数据（如果不清除，无法将节点加入到集群）</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-1 reset</span><br><span class="line"><span class="comment">#启动应用</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-1 start_app</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>rabbit-2作为从节点</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止应用</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-2 stop_app</span><br><span class="line"><span class="comment"># 目的是清除节点上的历史数据（如果不清除，无法将节点加入到集群）</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-2 reset</span><br><span class="line"><span class="comment"># 将rabbit2节点加入到rabbit1（主节点）集群当中【Server-node服务器的主机名】</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-2 join_cluster rabbit-1@<span class="string">'Server-node'</span></span><br><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-2 start_app</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>查看集群的状态</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo rabbitmqctl cluster_status -n rabbit-1</span><br><span class="line">//集群有两个节点：rabbit-1@Server-node、rabbit-2@Server-node</span><br><span class="line">[&#123;nodes,[&#123;disc,[<span class="string">'rabbit-1@Server-node'</span>,<span class="string">'rabbit-2@Server-node'</span>]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[<span class="string">'rabbit-2@Server-node'</span>,<span class="string">'rabbit-1@Server-node'</span>]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;<span class="string">"rabbit-1@Server-node.localdomain"</span>&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;<span class="string">'rabbit-2@Server-node'</span>,[]&#125;,&#123;<span class="string">'rabbit-1@Server-node'</span>,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure><h4 id="2-3-启动Web-监控"><a href="#2-3-启动Web-监控" class="headerlink" title="2.3 启动Web 监控"></a>2.3 启动Web 监控</h4><ul><li>注意在访问的时候：web结面的管理需要给15672 node-1 和15673的node-2 设置用户名和密码。如下:</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl -n rabbit-1 add_user admin admin</span><br><span class="line">rabbitmqctl -n rabbit-1 set_user_tags admin administrator</span><br><span class="line">rabbitmqctl -n rabbit-1 set_permissions -p / admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line">rabbitmqctl -n rabbit-2 add_user admin admin</span><br><span class="line">rabbitmqctl -n rabbit-2 set_user_tags admin administrator</span><br><span class="line">rabbitmqctl -n rabbit-2 set_permissions -p / admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-201712378.png" alt="mark"></p><h4 id="2-4-多机部署的注意事项"><a href="#2-4-多机部署的注意事项" class="headerlink" title="2.4 多机部署的注意事项"></a>2.4 多机部署的注意事项</h4><ul><li><p>如果采用多机部署方式，需读取其中一个节点的cookie, 并复制到其他节点（节点之间通过cookie确定相互是否可通信）。</p></li><li><p>cookie存放在<code>/var/lib/rabbitmq/.erlang.cookie</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：主机名分别为rabbit-1、rabbit-2</span><br><span class="line">1、逐个启动各节点</span><br><span class="line">2、配置各节点的hosts文件( vim &#x2F;etc&#x2F;hosts)</span><br><span class="line">​ ip1：rabbit-1</span><br><span class="line">​ ip2：rabbit-2</span><br><span class="line">其它步骤雷同单机部署方式</span><br></pre></td></tr></table></figure><p><strong>参考博客 ：</strong> <a href="https://honeypps.com/mq/rabbitmq-multiple-instances-in-one-machine/" target="_blank" rel="noopener">https://honeypps.com/mq/rabbitmq-multiple-instances-in-one-machine/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-12-集群搭建&quot;&gt;&lt;a href=&quot;#RabbitMQ-12-集群搭建&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-12-集群搭建&quot;&gt;&lt;/a&gt;RabbitMQ-12-集群搭建&lt;/h2&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RabbitMQ&lt;/code&gt;这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，&lt;code&gt;RabbitMQ天然支持Clustering&lt;/code&gt;。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。&lt;/li&gt;
&lt;li&gt;集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;实际使用过程中多采取多机多实例部署方式&lt;/strong&gt;，为了便于同学们练习搭建，有时候你不得不在一台机器上去搭建一个rabbitmq集群，&lt;strong&gt;本章主要针对单机多实例这种方式来进行开展。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要参考官方文档：&lt;a href=&quot;https://www.rabbitmq.com/clustering.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/clustering.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-11-存储机制</title>
    <link href="http://zhuuu.work/2021/04/09/RabbitMQ/RabbitMQ-11-%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2021/04/09/RabbitMQ/RabbitMQ-11-%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2021-04-09T08:02:24.000Z</published>
    <updated>2021-04-10T09:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-11-存储机制"><a href="#RabbitMQ-11-存储机制" class="headerlink" title="RabbitMQ-11-存储机制"></a>RabbitMQ-11-存储机制</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-102548246.png" alt="mark"></p><h3 id="1-存储机制"><a href="#1-存储机制" class="headerlink" title="1. 存储机制"></a>1. 存储机制</h3><ul><li><strong>持久化消息</strong><ul><li>RabbitMQ的持久化队列分为：<br>1：队列持久化<br>2：消息持久化<br>3：交换机持久化</li></ul></li><li><strong>非持久消息：</strong>是指当内存不够用的时候，会把消息和数据转移到磁盘，但是重启以后非持久化队列消息就丢失。</li></ul><a id="more"></a><ul><li>不论是持久化的消息还是非持久化的消息都可以写入到磁盘中，只不过非持久的是等内存不足的情况下才会被写入到磁盘中。<ul><li>持久化的消息在到达队列的时候就被写入到磁盘，并且如果可以，持久化的消息会在内存中保存一份备份，这样就可以提高一定的性能，当内存吃紧的时候就会从内存中清除</li><li>非持久化的消息一般只保存在内存中，当内存吃紧的时候就会被换入到磁盘中，以节省空间</li><li>这两种类型的消息落盘处都是RabbitMQ的持久层完成的。</li></ul></li></ul><h4 id="1-1-队列的持久化"><a href="#1-1-队列的持久化" class="headerlink" title="1.1 队列的持久化"></a>1.1 队列的持久化</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-110401035.png" alt="mark"></p><ul><li>queue的持久化是通过<code>durable=true</code>来实现的。</li><li>一般程序中这么使用：关键的是第二个参数设置为<code>true,即durable=true.</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.queueDeclare(<span class="string">"queue.persistent.name"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><ul><li>Channel类中<code>queueDeclare</code>的完整定义如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Declare a queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Queue.Declare</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Queue.DeclareOk</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue the name of the queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> durable true if we are declaring a durable queue (the queue will survive a server restart)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exclusive true if we are declaring an exclusive queue (restricted to this connection)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments other properties (construction arguments) for the queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a declaration-confirm method to indicate the queue was successfully declared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">queue：queue的名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">exclusive：排他队列，如果一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除。这里需要注意三点：1. 排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一连接创建的排他队列；2.“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；3.即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">autoDelete：自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列。</span></span><br></pre></td></tr></table></figure><ul><li><code>queueDeclare</code>相关的有4种方法，分别是：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueDeclareNoWait</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclarePassive</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">其中需要说明的是queueDeclarePassive(String queue)可以用来检测一个queue是否已经存在。如果该队列存在，则会返回true；如果不存在，就会返回异常，但是不会创建新的队列。</span></span><br></pre></td></tr></table></figure><h4 id="1-2-消息的持久化"><a href="#1-2-消息的持久化" class="headerlink" title="1.2 消息的持久化"></a>1.2 消息的持久化</h4><ul><li><p>如过将queue的持久化标识durable设置为true,则代表是一个持久的队列，那么在服务重启之后，也会存在，因为服务会把持久化的queue存放在硬盘上，当服务重启的时候，会重置被持久化的queue。</p></li><li><p><strong>队列是可以被持久化，但是里面的消息是否为持久化那还要看消息的持久化设置。</strong></p><ul><li>也就是说，重启之前那个queue里面还没有发出去的消息的话，重启之后那队列里面是不是还存在原来的消息，这个就要取决于发生着在发送消息时对消息的设置了。</li></ul></li><li><p>如果要在重启后保持消息的持久化必须设置消息是持久化的标识。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">"exchange.persistent"</span>, <span class="string">"persistent"</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"persistent_test_message"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的关键是：MessageProperties.PERSISTENT_TEXT_PLAIN</span></span><br></pre></td></tr></table></figure><ul><li>首先看一下<code>basicPublish</code>的方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, BasicProperties props, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, <span class="keyword">boolean</span> immediate, BasicProperties props, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">exchange表示exchange的名称</span></span><br><span class="line"><span class="comment">routingKey表示routingKey的名称</span></span><br><span class="line"><span class="comment">body代表发送的消息体</span></span><br></pre></td></tr></table></figure><ul><li>这里关键的是<code>BasicProperties props</code>这个参数了，这里看下<code>BasicProperties</code>的定义：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasicProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String contentType,//消息类型如：text/plain</span></span></span><br><span class="line"><span class="function"><span class="params">            String contentEncoding,//编码</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String,Object&gt; headers,</span></span></span><br><span class="line"><span class="function"><span class="params">            Integer deliveryMode,//<span class="number">1</span>:nonpersistent <span class="number">2</span>:persistent</span></span></span><br><span class="line"><span class="function"><span class="params">            Integer priority,//优先级</span></span></span><br><span class="line"><span class="function"><span class="params">            String correlationId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String replyTo,//反馈队列</span></span></span><br><span class="line"><span class="function"><span class="params">            String expiration,//expiration到期时间</span></span></span><br><span class="line"><span class="function"><span class="params">            String messageId,</span></span></span><br><span class="line"><span class="function"><span class="params">            Date timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">            String type,</span></span></span><br><span class="line"><span class="function"><span class="params">            String userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String appId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String clusterId)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的deliveryMode=1代表不持久化，deliveryMode=2代表持久化。</span></span></span><br></pre></td></tr></table></figure><ul><li>上面的实现代码使用的是<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code>，那么这个又是什么呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BasicProperties PERSISTENT_TEXT_PLAIN =</span><br><span class="line">    <span class="keyword">new</span> BasicProperties(<span class="string">"text/plain"</span>,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="number">2</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//可以看到这其实就是讲deliveryMode设置为2的BasicProperties的对象，为了方便编程而出现的一个东东。</span></span><br></pre></td></tr></table></figure><ul><li>换一种实现方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">builder.deliveryMode(<span class="number">2</span>);</span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line">channel.basicPublish(<span class="string">"exchange.persistent"</span>, <span class="string">"persistent"</span>,properties, <span class="string">"persistent_test_message"</span>.getBytes());</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>设置了队列和消息的持久化之后，当broker服务重启的之后，消息依旧存在。</strong></li><li>单只设置队列持久化，重启之后消息会丢失；单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</li></ul><h4 id="1-3-交换机的持久化"><a href="#1-3-交换机的持久化" class="headerlink" title="1.3 交换机的持久化"></a>1.3 交换机的持久化</h4><ul><li><p>上面阐述了队列的持久化和消息的持久化，如果不设置exchange的持久化对消息的可靠性来说没有什么影响，<strong>但是同样如果exchange不设置持久化，那么当broker服务重启之后，exchange将不复存在</strong>，那么既而发送方rabbitmq producer就无法正常发送消息。</p></li><li><p>这里博主建议，同样设置exchange的持久化。exchange的持久化设置也特别简单，方法如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangeDeclareNoWait</span><span class="params">(String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclarePassive</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般只需要：channel.exchangeDeclare(exchangeName, “direct/topic/header/fanout”, true);即在声明的时候讲durable字段设置为true即可。</span></span><br></pre></td></tr></table></figure><h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><ul><li><strong>将queue，exchange, message等都设置了持久化之后就能保证100%保证数据不丢失了嚒？</strong><br><strong>答案是否定的。</strong></li></ul><ol><li><p>首先，从consumer端来说，如果这时<code>autoAck=true</code>，那么当consumer接收到相关消息之后，还没来得及处理就crash掉了，那么这样也算数据丢失，这种情况也好处理，只需将autoAck设置为false(方法定义如下)，然后在正确处理完消息之后进行手动ack（<code>channel.basicAck</code>）.</p></li><li><p>其次，关键的问题是消息在正确存入RabbitMQ之后，还需要有一段时间（这个时间很短，但不可忽视）才能存入磁盘之中，RabbitMQ并不是为每条消息都做fsync的处理，可能仅仅保存到cache中而不是物理磁盘上，在这段时间内<code>RabbitMQ broker</code>发生<code>crash</code>, 消息保存到cache但是还没来得及落盘，那么这些消息将会丢失。</p></li></ol><ul><li>那么这个怎么解决呢？<ul><li>首先可以引入RabbitMQ的mirrored-queue即镜像队列，这个相当于配置了副本，当master在此特殊时间内crash掉，可以自动切换到slave，这样有效的保障了HA, 除非整个集群都挂掉，这样也不能完全的100%保障RabbitMQ不丢消息，但比没有mirrored-queue的要好很多，很多现实生产环境下都是配置了mirrored-queue的。</li><li>还有要在<code>producer</code>引入事务机制或者<code>Confirm</code>机制来确保消息已经正确的发送至broker端，有关RabbitMQ的事务机制或者<code>Confirm</code>机制.<code>RabbitMQ</code>的可靠性涉及producer端的确认机制、broker端的镜像队列的配置以及consumer端的确认机制，要想确保消息的可靠性越高，那么性能也会随之而降，鱼和熊掌不可兼得，关键在于选择和取舍。</li></ul></li></ul><ul><li><strong>消息什么时候刷到磁盘？</strong></li></ul><ol><li><p>写入文件前会有一个Buffer,大小为1M,数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）。</p></li><li><p>有个固定的刷盘时间：25ms,也就是不管Buffer满不满，每个25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘。</p></li><li><p>每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用Erlang的<code>receive x after 0</code>实现，只要进程的信箱里没有消息，则产生一个timeout消息，而timeout会触发刷盘操作。</p></li></ol><h3 id="2-内存磁盘告警"><a href="#2-内存磁盘告警" class="headerlink" title="2. 内存磁盘告警"></a>2. 内存磁盘告警</h3><ul><li>当内存使用超过配置的阈值或者磁盘空间剩余空间对于配置的阈值时，RabbitMQ会暂时阻塞客户端的连接，并且停止接收从客户端发来的消息，以此避免服务器的崩溃，客户端与服务端的心态检测机制也会失效。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-111715431.png" alt="mark"></p><ul><li>当出现<code>blocking</code>或<code>blocked</code>话说明到达了阈值和以及高负荷运行了。<ul><li><code>blocking :</code>并不试图关闭发送消息的Connection,比如消费者的Connection。这种情况下Connection可以继续运行</li><li><code>blocked :</code>对应于一直有消息发送的Connection。这种情况下Connection会停止发送消息</li><li>如果一个Broker的内存或者磁盘受限，都会引起所有的Connection被阻塞。</li></ul></li><li>理想的情况是当发生阻塞的时候可以阻止生产者的同时而又不影响消费者，但是在AMQP协议中，一个channel 上可以同时承载生产者和消费者，同一个Connection 中也可以同时承载若干个生产者和消费者的信道和消费者信道，这样就会使得逻辑错乱。<ul><li>这里建议生产和消费的逻辑可以分摊到独立的Connection 中而不发生任何的交集。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li><p><strong>当出现警告的时候，可以通过配置去修改和调整</strong></p></li><li><p>参考帮助文档：<a href="https://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">https://www.rabbitmq.com/configure.html</a></p></li></ul><h4 id="2-1-内存告警"><a href="#2-1-内存告警" class="headerlink" title="2.1 内存告警"></a>2.1 内存告警</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-165736223.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-165751461.png" alt="mark"></p><ul><li><p><code>rabbitMQ</code>执行<code>rabbitmqctl set_vm_memory_high_watermarkfraction</code> 可以设置<strong>内存的阈值，默认是0.4</strong></p><ul><li>表示当内存使用超过40%的时候，就会产生内存告警并且阻塞当前所有生产者的连接。</li><li>在最坏的情况下，Erlang 的垃圾回收机制会导致两倍的内存消耗，也就是80%的占用比</li></ul></li><li><p>内存的阈值可以通过以下两种方式来设置（百分比，绝对内存大小）</p><ul><li><p><strong>百分比方式</strong></p><ul><li>配置文件：重启才会生效 。当前配置文件：<code>/etc/rabbitmq/rabbitmq.conf</code></li><li>命令行： 重启会失效  <code>rabbitmqctl set_vm_memory_high_watermark &lt;fraction&gt;</code></li><li>大小设置在0.4到0.66之间，不建议超过0.7</li></ul></li><li><p><strong>绝对内存大小</strong></p><ul><li>配置文件：重启才会生效。当前配置文件：<code>/etc/rabbitmq/rabbitmq.conf</code></li><li>命令行：重启会失效 <code>rabbitmqctl set_vm_memory_high_watermark absolute 50MB</code></li></ul></li><li><p>fraction/value 为内存阈值。默认情况是：0.4/2GB。代表的含义是：当RabbitMQ的内存超过40%时，就会产生警告并且阻塞所有生产者的连接。通过此命令修改阈值在Broker重启以后将会失效，通过修改配置文件方式设置的阈值则不会随着重启而消失，但修改了配置文件一样要重启broker才会生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#默认</span><br><span class="line">#vm_memory_high_watermark.relative = 0.4</span><br><span class="line"># 使用relative相对值进行设置fraction,建议取值在04~0.7之间，不建议超过0.7.</span><br><span class="line">vm_memory_high_watermark.relative = 0.6</span><br><span class="line"># 使用absolute的绝对值的方式，但是是KB,MB,GB对应的命令如下</span><br><span class="line">vm_memory_high_watermark.absolute = 2GB</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-2-换页"><a href="#2-2-换页" class="headerlink" title="2.2 换页"></a>2.2 换页</h4><ul><li><p><strong>默认情况下，在内存达到阈值的50%的时候会进行换页的操作</strong></p><ul><li>在某个Broker节点及内存阻塞生产者之前，它会尝试将队列中的消息换页到磁盘以释放内存空间，持久化和非持久化的消息都会写入磁盘中，其中持久化的消息本身就在磁盘中有一个副本，所以在转移的过程中持久化的消息会先从内存中清除掉。</li><li>也就是说，在默认情况下该内存的阈值是0.4的情况下，当内存超过<code>0.4*0.5=0.2</code>时，会进行换页动作。</li><li>比如有<code>1000MB</code>内存，当内存的使用率达到了<code>400MB</code>,已经达到了极限，但是因为配置的换页内存0.5，这个时候会在达到极限<code>400mb</code>之前，会把内存中的<code>200MB</code>进行转移到磁盘中。从而达到稳健的运行。</li></ul></li><li><p>可以通过设置 <code>vm_memory_high_watermark_paging_ratio</code> 来进行调整</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm_memory_high_watermark.relative = 0.4</span><br><span class="line">vm_memory_high_watermark_paging_ratio = 0.7（设置小于1的值）</span><br></pre></td></tr></table></figure><ul><li>此时，如果将<code>vm_memory_high_watermark_paging_ratio</code> 设置为大于1的浮点数的话，这种配置相当于仅用了换页的功能</li></ul><h4 id="2-3-磁盘预警"><a href="#2-3-磁盘预警" class="headerlink" title="2.3 磁盘预警"></a>2.3 磁盘预警</h4><ul><li><p>当剩余磁盘空间低于确定阈值的时候，RabbitMQ同样会阻塞生产者，这样可以避免因非持久化消息持续换页而耗尽磁盘空间导致服务崩溃</p><ul><li><strong>默认情况下，磁盘阈值为50MB</strong></li><li>这个阈值可以减小，但是不能完全的消除因磁盘耗尽而导致崩溃的可能性。比如在两次磁盘空间的检查空隙内，第一次检查是：60MB ，第二检查可能就是1MB,就会出现警告。</li></ul></li><li><p><strong>通过命令方式</strong>修改如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_disk_free_limit  &lt;disk_limit&gt;</span><br><span class="line">rabbitmqctl set_disk_free_limit memory_limit  &lt;fraction&gt;</span><br><span class="line">disk_limit：固定单位 KB MB GB</span><br><span class="line">fraction ：是相对阈值，建议范围在:1.0~2.0之间。（相对于内存）</span><br></pre></td></tr></table></figure><ul><li><strong>通过配置文件</strong>配置如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disk_free_limit.relative = 3.0</span><br><span class="line">disk_free_limit.absolute = 50mb</span><br></pre></td></tr></table></figure><h3 id="3-惰性队列"><a href="#3-惰性队列" class="headerlink" title="3. 惰性队列"></a>3. 惰性队列</h3><ul><li><p><code>RabbitMQ从3.6.0</code>版本开始引入了惰性队列（<code>Lazy Queue</code>）的概念。<strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。</strong>当消费者由于各种各样的原因（比如消费者下线、宕机亦或者是由于维护而关闭等）而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p></li><li><p>默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份</p><ul><li>当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。</li><li>虽然RabbitMQ的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</li></ul></li><li><p>惰性队列会将接收到的消息直接存入文件系统中，而不管是持久化的或者是非持久化的，这样可以减少了内存的消耗，但是会增加I/O的使用，</p><ul><li>如果消息是持久化的，那么这样的I/O操作不可避免，惰性队列和持久化消息可谓是“最佳拍档”。</li><li>注意如果惰性队列中存储的是非持久化的消息，内存的使用率会一直很稳定，但是重启之后消息一样会丢失。</li></ul></li><li><p>队列具备两种模式：default和lazy。默认的为default模式，在3.6.0之前的版本无需做任何变更。lazy模式即为惰性队列的模式，可以通过调用<code>channel.queueDeclare</code>方法的时候在参数中设置，也可以通过Policy的方式设置</p><ul><li>如果一个队列同时使用这两种方式设置的话，那么Policy的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</li><li>在队列声明的时候可以通过<strong>“x-queue-mode”</strong>参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-queue-mode"</span>, <span class="string">"lazy"</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对应的Policy设置方式为：</span><br><span class="line">    rabbitmqctl set_policy Lazy <span class="string">"^myqueue$"</span> <span class="string">'&#123;"queue-mode":"lazy"&#125;'</span> --apply-to queues</span><br></pre></td></tr></table></figure><ul><li>惰性队列和普通队列相比，只有很小的内存开销。这里很难对每种情况给出一个具体的数值，但是我们可以类比一下：当发送1千万条消息，每条消息的大小为1KB，并且此时没有任何的消费者，那么普通队列会消耗1.2GB的内存，而惰性队列只消耗1.5MB的内存。<ul><li>据官网测试数据显示，<ul><li><strong>对于普通队列</strong>，如果要发送1千万条消息，需要耗费801秒，平均发送速度约为13000条/秒。</li><li><strong>如果使用惰性队列</strong>，那么发送同样多的消息时，耗时是421秒，平均发送速度约为24000条/秒。出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近40MB的空间来发送消息，对于一个消费者的情况，平均的消费速度约为14000条/秒。</li></ul></li><li><strong>如果要将普通队列转变为惰性队列，那么我们需要忍受同样的性能损耗。</strong><ul><li>当转变为惰性队列的时候，首先需要将缓存中的消息换页至磁盘中，然后才能接收新的消息。</li><li>反之，当将一个惰性队列转变为普通队列的时候，和恢复一个队列执行同样的操作，会将磁盘中的消息批量的导入到内存中。</li></ul></li></ul></li></ul><p><strong>参考博客系列</strong> ： <a href="https://blog.csdn.net/u013256816/article/details/54743481" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/54743481</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-11-存储机制&quot;&gt;&lt;a href=&quot;#RabbitMQ-11-存储机制&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-11-存储机制&quot;&gt;&lt;/a&gt;RabbitMQ-11-存储机制&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-102548246.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-存储机制&quot;&gt;&lt;a href=&quot;#1-存储机制&quot; class=&quot;headerlink&quot; title=&quot;1. 存储机制&quot;&gt;&lt;/a&gt;1. 存储机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;持久化消息&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;RabbitMQ的持久化队列分为：&lt;br&gt;1：队列持久化&lt;br&gt;2：消息持久化&lt;br&gt;3：交换机持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非持久消息：&lt;/strong&gt;是指当内存不够用的时候，会把消息和数据转移到磁盘，但是重启以后非持久化队列消息就丢失。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-LCP002-分式化简</title>
    <link href="http://zhuuu.work/2021/04/09/Leetcode/Leetcode-LCP002-%E5%88%86%E5%BC%8F%E5%8C%96%E7%AE%80/"/>
    <id>http://zhuuu.work/2021/04/09/Leetcode/Leetcode-LCP002-%E5%88%86%E5%BC%8F%E5%8C%96%E7%AE%80/</id>
    <published>2021-04-09T03:02:24.000Z</published>
    <updated>2021-04-09T01:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-LCP002-分式化简"><a href="#Leetcode-LCP002-分式化简" class="headerlink" title="Leetcode-LCP002-分式化简"></a>Leetcode-LCP002-<a href="https://leetcode-cn.com/problems/deep-dark-fraction/" target="_blank" rel="noopener">分式化简</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-093002540.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。</span><br><span class="line"></span><br><span class="line">输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n &#x2F; m，且n, m最大公约数为1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：cont &#x3D; [3, 2, 0, 2]</span><br><span class="line">输出：[13, 4]</span><br><span class="line">解释：原连分数等价于3 + (1 &#x2F; (2 + (1 &#x2F; (0 + 1 &#x2F; 2))))。注意[26, 8], [-13, -4]都不是正确答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：cont &#x3D; [0, 0, 3]</span><br><span class="line">输出：[3, 1]</span><br><span class="line">解释：如果答案是整数，令分母为1即可。</span><br></pre></td></tr></table></figure><ul><li><p><strong>提示：</strong></p><ul><li><p><code>cont[i] &gt;=</code>0<br><code>1 &lt;= cont的长度 &lt;= 10</code><br><code>cont最后一个元素不等于0</code></p></li><li><p>答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。</p></li></ul></li></ul><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><strong>思路</strong></p><ul><li><strong>找规律</strong><ul><li>从后往前，分子分母交替计算。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fraction(<span class="keyword">int</span>[] cont) &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化条件</span></span><br><span class="line">        <span class="keyword">int</span> n = cont[cont.length - <span class="number">1</span>],</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. for循环处理逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cont.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 2.1 上下交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">            <span class="comment">// 2.2 乘法操作</span></span><br><span class="line">            n += cont[i - <span class="number">1</span>]*m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;n,m&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-LCP002-分式化简&quot;&gt;&lt;a href=&quot;#Leetcode-LCP002-分式化简&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-LCP002-分式化简&quot;&gt;&lt;/a&gt;Leetcode-LCP002-&lt;a href=&quot;https://leetcode-cn.com/problems/deep-dark-fraction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分式化简&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-093002540.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n &amp;#x2F; m，且n, m最大公约数为1。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：cont &amp;#x3D; [3, 2, 0, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[13, 4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：原连分数等价于3 + (1 &amp;#x2F; (2 + (1 &amp;#x2F; (0 + 1 &amp;#x2F; 2))))。注意[26, 8], [-13, -4]都不是正确答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：cont &amp;#x3D; [0, 0, 3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[3, 1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如果答案是整数，令分母为1即可。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cont[i] &amp;gt;=&lt;/code&gt;0&lt;br&gt;&lt;code&gt;1 &amp;lt;= cont的长度 &amp;lt;= 10&lt;/code&gt;&lt;br&gt;&lt;code&gt;cont最后一个元素不等于0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-10-死信队列</title>
    <link href="http://zhuuu.work/2021/04/07/RabbitMQ/RabbitMQ-10-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    <id>http://zhuuu.work/2021/04/07/RabbitMQ/RabbitMQ-10-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</id>
    <published>2021-04-07T08:02:24.000Z</published>
    <updated>2021-04-09T00:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-10-死信队列"><a href="#RabbitMQ-10-死信队列" class="headerlink" title="RabbitMQ-10-死信队列"></a>RabbitMQ-10-死信队列</h2><h3 id="1-死信产生的原因"><a href="#1-死信产生的原因" class="headerlink" title="1. 死信产生的原因"></a>1. 死信产生的原因</h3><ul><li><p><code>DLX</code>，全称为<code>Dead-Letter-Exchange</code> , 可以称之为死信交换机，也有人称之为死信邮箱。</p></li><li><p>当消息在一个队列中变成死信(<code>dead message</code>)之后，<strong>它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。</strong></p></li><li><p><strong>消息变成死信，可能是由于以下的原因：</strong></p><ul><li><strong>消息被拒绝</strong></li><li><strong>消息过期</strong></li><li><strong>队列达到最大长度</strong></li></ul></li><li><p><strong>DLX也是一个正常的交换机，和一般的交换机没有区别</strong>，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。</p><ul><li><strong>当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。</strong></li><li>要想使用死信队列，只需要在定义队列的时候设置队列参数 <code>x-dead-letter-exchange</code> 指定交换机即可。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-160554479.png" alt="mark"></p><a id="more"></a><h3 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2. 代码演示"></a>2. 代码演示</h3><ol><li>首先需要设置死信队列的<code>exchange和queue</code>，然后进行绑定：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exchange: dlx.exchange</span><br><span class="line">Queue: dlx.queue</span><br><span class="line">RoutingKey: <span class="comment">#</span></span><br><span class="line"><span class="comment">#表示只要有消息到达了Exchange，那么都会路由到这个queue上</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后需要有一个监听，去监听这个队列进行处理</p></li><li><p>然后我们进行正常声明交换机、队列、绑定，只不过我们需要在队列加上一个参数即可：<code>arguments.put(&quot; x-dead-letter-exchange&quot;，&quot;dlx.exchange&quot;);</code>，这样消息在过期、<code>requeue</code>、 队列在达到最大长度时，消息就可以直接路由到死信队列！</p></li></ol><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"ip"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//2 获取Connection</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3 通过Connection创建一个新的Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        String exchange = <span class="string">"test_dlx_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"dlx.save"</span>;</span><br><span class="line">        </span><br><span class="line">        String msg = <span class="string">"Hello RabbitMQ DLX Message"</span>;</span><br><span class="line">        </span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                .contentEncoding(<span class="string">"UTF-8"</span>)</span><br><span class="line">                .expiration(<span class="string">"10000"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        channel.basicPublish(exchange, routingKey, <span class="keyword">true</span>, properties, msg.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><ul><li>声明正常处理消息的交换机、队列及绑定规则</li><li><strong>在正常交换机上指定死信发送的Exchange</strong></li><li><strong>声明死信交换机、队列及绑定规则</strong></li><li><strong>监听死信队列，进行后续处理，这里省略</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.43.157"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        </span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明一个普通的交换机 和 队列 以及路由</span></span><br><span class="line">        String exchangeName = <span class="string">"test_dlx_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"dlx.#"</span>;</span><br><span class="line">        String queueName = <span class="string">"test_dlx_queue"</span>;</span><br><span class="line">        </span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//指定死信发送的Exchange</span></span><br><span class="line">        Map&lt;String, Object&gt; agruments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        agruments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"dlx.exchange"</span>);</span><br><span class="line">        <span class="comment">//这个agruments属性，要设置到声明队列上</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, agruments);</span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//要进行死信队列的声明</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"dlx.exchange"</span>, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">"dlx.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">"dlx.queue"</span>, <span class="string">"dlx.exchange"</span>, <span class="string">"#"</span>);</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> MyConsumer(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果演示</strong></p><ul><li>启动消费端，此时查看管控台，新增了两个Exchange，两个Queue。在<code>test_dlx_queue</code>上我们设置了DLX，也就代表死信消息会发送到指定的Exchange上，最终其实会路由到<code>dlx.queue</code>上。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-161354031.png" alt="mark"></p><ul><li>此时关闭消费端，然后启动生产端，查看管控台队列的消息情况，<code>test_dlx_queue</code>的值为1，而<code>dlx_queue</code>的值为0。<br> 10s后的队列结果如图，由于生产端发送消息时指定了消息的过期时间为10s，而此时没有消费端进行消费，消息便被路由到死信队列中。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-161417816.png" alt="mark"></p><ul><li>实际环境我们还需要对死信队列进行一个监听和处理，当然具体的处理逻辑和业务相关，这里只是简单演示死信队列是否生效。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-10-死信队列&quot;&gt;&lt;a href=&quot;#RabbitMQ-10-死信队列&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-10-死信队列&quot;&gt;&lt;/a&gt;RabbitMQ-10-死信队列&lt;/h2&gt;&lt;h3 id=&quot;1-死信产生的原因&quot;&gt;&lt;a href=&quot;#1-死信产生的原因&quot; class=&quot;headerlink&quot; title=&quot;1. 死信产生的原因&quot;&gt;&lt;/a&gt;1. 死信产生的原因&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;DLX&lt;/code&gt;，全称为&lt;code&gt;Dead-Letter-Exchange&lt;/code&gt; , 可以称之为死信交换机，也有人称之为死信邮箱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当消息在一个队列中变成死信(&lt;code&gt;dead message&lt;/code&gt;)之后，&lt;strong&gt;它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;消息变成死信，可能是由于以下的原因：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息被拒绝&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息过期&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队列达到最大长度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DLX也是一个正常的交换机，和一般的交换机没有区别&lt;/strong&gt;，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;要想使用死信队列，只需要在定义队列的时候设置队列参数 &lt;code&gt;x-dead-letter-exchange&lt;/code&gt; 指定交换机即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-160554479.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-09-过期时间TTL</title>
    <link href="http://zhuuu.work/2021/04/07/RabbitMQ/RabbitMQ-09-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4TTL/"/>
    <id>http://zhuuu.work/2021/04/07/RabbitMQ/RabbitMQ-09-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4TTL/</id>
    <published>2021-04-07T06:02:24.000Z</published>
    <updated>2021-04-07T08:02:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-09-过期时间TTL"><a href="#RabbitMQ-09-过期时间TTL" class="headerlink" title="RabbitMQ-09-过期时间TTL"></a>RabbitMQ-09-过期时间TTL</h2><h3 id="1-TTL的概念"><a href="#1-TTL的概念" class="headerlink" title="1. TTL的概念"></a>1. TTL的概念</h3><ul><li><p>过期时间<code>TTL</code>表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。</p></li><li><p>RabbitMQ可以对<strong>消息和队列</strong>设置TTL。目前有两种方法可以设置。</p><ul><li><strong>第一种方法是通过队列属性设置</strong>，队列中所有消息都有相同的过期时间。</li><li><strong>第二种方法是对消息进行单独设置</strong>，每条消息TTL可以不同。</li></ul></li><li><p>如果上述两种方法同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。</p></li><li><p>消息在队列的生存时间一旦超过设置的TTL值，就称为dead message被投递到死信队列， 消费者将无法再收到该消息。</p></li></ul><p><strong>TTL的标识</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-154021368.png" alt="mark"></p><a id="more"></a><h4 id="1-1-方式一：通过队列设置TTL"><a href="#1-1-方式一：通过队列设置TTL" class="headerlink" title="1.1 方式一：通过队列设置TTL"></a>1.1 方式一：通过队列设置TTL</h4><ul><li><p><strong>参数</strong>：<code>x-message-ttl</code></p></li><li><p>通过在<code>channel.queueDeclare</code>设置参数</p></li><li><p><strong>核心代码</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; args2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args2.put(<span class="string">"x-message-ttl"</span>,<span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"ttl.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args2);</span><br></pre></td></tr></table></figure><h4 id="1-2-方式二：通过设置单条消息的TTL"><a href="#1-2-方式二：通过设置单条消息的TTL" class="headerlink" title="1.2 方式二：通过设置单条消息的TTL"></a>1.2 方式二：通过设置单条消息的TTL</h4><ul><li><p>通过设置每条消息的TTL 是在 <code>channel.basicPublish</code> 方法中加入<code>expiration</code>的属性参数</p></li><li><p><strong>核心代码</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6： 准备发送消息的内容</span></span><br><span class="line">String message = <span class="string">"你好，学相伴！！！"</span>;</span><br><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">headers.put(<span class="string">"x"</span>, <span class="string">"1"</span>);</span><br><span class="line">headers.put(<span class="string">"y"</span>, <span class="string">"1"</span>);</span><br><span class="line">AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">    .deliveryMode(<span class="number">2</span>) <span class="comment">// 传送方式</span></span><br><span class="line">    .priority(<span class="number">1</span>)</span><br><span class="line">    .contentEncoding(<span class="string">"UTF-8"</span>) <span class="comment">// 编码方式</span></span><br><span class="line">    .expiration(<span class="string">"5000"</span>) <span class="comment">// 过期时间</span></span><br><span class="line">    .headers(headers).build(); <span class="comment">//自定义属性</span></span><br><span class="line"><span class="comment">// 7: 发送消息给中间件rabbitmq-server</span></span><br><span class="line"><span class="comment">// @params1: 交换机exchange</span></span><br><span class="line"><span class="comment">// @params2: 队列名称/routing</span></span><br><span class="line"><span class="comment">// @params3: 属性配置</span></span><br><span class="line"><span class="comment">// @params4: 发送消息的内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">    channel.basicPublish(<span class="string">""</span>, <span class="string">"ttl.queue2"</span>, basicProperties, message.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"消息发送成功!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-两种方式的区别"><a href="#1-3-两种方式的区别" class="headerlink" title="1.3 两种方式的区别"></a>1.3 两种方式的区别</h4><ul><li>第一种方法里，队列已过期的消息肯定在队列的头部，RabbitMQ 只要定期扫描从队列的头部扫描是否有过期消息即可</li><li>第二种方式，每条消息的国企时间不同，如果要删除所有的过期消息势必要扫描整个队列，所以步入等到此消息即将被消息时再判定是否过期，如果过期再进行删除即可。</li></ul><h3 id="2-队列的TTL"><a href="#2-队列的TTL" class="headerlink" title="2. 队列的TTL"></a>2. 队列的TTL</h3><ul><li>通过在<code>channel.queueDeclare</code>方法中的<code>x-expires</code> 参数可以控制队列被自动删除前处于多久未使用的状态<ul><li>未使用的意思是队列上没有任何消费者，队列也没有被重新声明，并且这段时间内也灭有调用过<code>Basic.Get()</code> 命令</li></ul></li><li><strong>核心代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; args2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args2.put(<span class="string">"x-expires"</span>,<span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"ttl.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-09-过期时间TTL&quot;&gt;&lt;a href=&quot;#RabbitMQ-09-过期时间TTL&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-09-过期时间TTL&quot;&gt;&lt;/a&gt;RabbitMQ-09-过期时间TTL&lt;/h2&gt;&lt;h3 id=&quot;1-TTL的概念&quot;&gt;&lt;a href=&quot;#1-TTL的概念&quot; class=&quot;headerlink&quot; title=&quot;1. TTL的概念&quot;&gt;&lt;/a&gt;1. TTL的概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;过期时间&lt;code&gt;TTL&lt;/code&gt;表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ可以对&lt;strong&gt;消息和队列&lt;/strong&gt;设置TTL。目前有两种方法可以设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一种方法是通过队列属性设置&lt;/strong&gt;，队列中所有消息都有相同的过期时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二种方法是对消息进行单独设置&lt;/strong&gt;，每条消息TTL可以不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果上述两种方法同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息在队列的生存时间一旦超过设置的TTL值，就称为dead message被投递到死信队列， 消费者将无法再收到该消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TTL的标识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-154021368.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-080-删除有序数组中的重复项II</title>
    <link href="http://zhuuu.work/2021/04/06/Leetcode/Leetcode-080-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/"/>
    <id>http://zhuuu.work/2021/04/06/Leetcode/Leetcode-080-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/</id>
    <published>2021-04-06T04:02:24.000Z</published>
    <updated>2021-04-06T03:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-080-删除有序数组中的重复项-II"><a href="#Leetcode-080-删除有序数组中的重复项-II" class="headerlink" title="Leetcode-080- 删除有序数组中的重复项 II"></a>Leetcode-080-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener"> 删除有序数组中的重复项 II</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</li><li>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</li></ul><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums &#x3D; [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums &#x3D; [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="方法一-：-双指针"><a href="#方法一-：-双指针" class="headerlink" title="方法一 ： 双指针"></a>方法一 ： 双指针</h2><ul><li><p>因为给定数组是有序的，所以相同元素必然连续。我们可以使用双指针解决本题，<strong>遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。</strong></p></li><li><p>具体地，我们定义两个指针slow 和 fast 分别为慢指针和快指针，其中<strong>慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度</strong></p><ul><li><code>nums[fast]</code> : 为第一个待检查的元素</li><li><em>nums</em>[<em>slow</em>−1] 为上一个应该被保留的元素所移动到的指定位置。</li></ul></li><li><p>本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 <code>nums[slow−2]</code>是否和当前待检查元素<code>nums[fast]</code> 相同。</p><ul><li>若<code>nums[slow - 2] == nums[fast]</code> 则当前元素不应该被保留</li><li>当前<code>nums[slow−2]=nums[slow−1]=nums[fast]</code></li></ul></li></ul><p>  <strong>最后slow即为数组的长度</strong></p><p>  <strong>特别地，</strong></p><p>  数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，</p><p>  对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判及初始化 : 长度小于等于二直接满足条件</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 双指针逻辑 : 从下标为2开始检查</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">2</span>;                               <span class="comment">// fast代表待检查的元素</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">2</span>;                               <span class="comment">// slow代表已经检查完的长度</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[slow - <span class="number">2</span>] != nums[fast])&#123;        <span class="comment">// 说明中间产生了重复元素</span></span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回值</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) ，遍历一遍数组</li><li>空间复杂度：O(1) ， 原地修改</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Leetcode-080-删除有序数组中的重复项-II&quot;&gt;&lt;a href=&quot;#Leetcode-080-删除有序数组中的重复项-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-080- 删除有序数组中的重复项 II&quot;&gt;&lt;/a&gt;Leet
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-026-删除有序数组中的重复元素</title>
    <link href="http://zhuuu.work/2021/04/06/Leetcode/Leetcode-026-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2021/04/06/Leetcode/Leetcode-026-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-04-06T03:02:24.000Z</published>
    <updated>2021-04-06T03:21:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-026-删除有序数组中的重复项"><a href="#Leetcode-026-删除有序数组中的重复项" class="headerlink" title="Leetcode-026-删除有序数组中的重复项"></a>Leetcode-026-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除有序数组中的重复项</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</li><li>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</li></ul><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：2, nums &#x3D; [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums &#x3D; [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="方法一-：-双指针"><a href="#方法一-：-双指针" class="headerlink" title="方法一 ： 双指针"></a>方法一 ： 双指针</h2><ul><li>数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 <code>nums[i] == nums[j]</code>，我们就增加 j 以跳过重复项。<ul><li>其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度</li></ul></li><li>当我们遇到<code>nums[i] != nums[j]</code> 时，跳过重复项的运行已经结束，<ul><li>将 <code>i++</code> 并且将 <code>nums[i] = nums[j]</code></li><li>作用：为了覆盖重复的元素</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化及特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;                                  <span class="comment">// i慢指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 双指针逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; len;j++)&#123;                 <span class="comment">// j快指针</span></span><br><span class="line">            <span class="comment">// 2.1 如果nums[j] != nums[i]</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] != nums[i])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];                  <span class="comment">// i++ 并将重复元素直接覆盖 </span></span><br><span class="line">            &#125;                                       <span class="comment">// 否则如果 nums[j] == nums[i] 直接外层for循环跳到下一个j</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回慢指针长度</span></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) ，遍历一遍数组</li><li>空间复杂度：O(1) ， 原地修改</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Leetcode-026-删除有序数组中的重复项&quot;&gt;&lt;a href=&quot;#Leetcode-026-删除有序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-026-删除有序数组中的重复项&quot;&gt;&lt;/a&gt;Leetcode-026-&lt;
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-783-二叉搜索树节点最小距离</title>
    <link href="http://zhuuu.work/2021/04/06/Leetcode/Leetcode-783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"/>
    <id>http://zhuuu.work/2021/04/06/Leetcode/Leetcode-783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/</id>
    <published>2021-04-06T03:02:24.000Z</published>
    <updated>2021-04-16T01:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-783-二叉搜索树节点最小距离"><a href="#Leetcode-783-二叉搜索树节点最小距离" class="headerlink" title="Leetcode-783-二叉搜索树节点最小距离"></a>Leetcode-783-<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">二叉搜索树节点最小距离</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-090527376.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-090547189.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 105</code></li><li>差值是一个正数，其数值等于两值之差的绝对值</li></ul><a id="more"></a><h2 id="算法思路：中序遍历"><a href="#算法思路：中序遍历" class="headerlink" title="算法思路：中序遍历"></a>算法思路：中序遍历</h2><ul><li>一看到二叉搜索树：中序遍历就对了(转为升序数组)</li><li>考虑对升序数组 <em>a</em> 求任意两个元素之差的最小值，<strong>答案一定为相邻两个元素之差的最小值</strong>，即其他任意间隔距离大于等于 2 的下标对 (<em>i</em>,<em>j</em>) 的元素之差一定大于下标对 (<em>i</em>,<em>i</em>+1) 的元素之差，故不需要再被考虑。</li><li><strong>回到本题，本题要求二叉搜索树任意两节点差的最小值，而我们知道二叉搜索树有个性质为二叉搜索树中序遍历得到的值序列是递增有序的，因此我们只要得到中序遍历后的值序列即能用上文提及的方法来解决。</strong></li><li>朴素的方法是经过一次中序遍历将值保存在一个数组中再进行遍历求解<ul><li>我们也可以在中序遍历的过程中用 <em>pre</em> 变量保存前驱节点的值，这样即能边遍历边更新答案</li><li>不再需要显式创建数组来保存，需要注意的是 <em>pre</em> 的初始值需要设置成任意负数标记开头，下文代码中设置为 −1。</li><li>二叉树的中序遍历有多种方式，包括递归、栈、Morris 遍历等，读者可选择自己最擅长的来实现。下文代码提供最普遍的递归方法来实现</li><li>其他遍历方法的介绍可以详细看「<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/" target="_blank" rel="noopener">94. 二叉树的中序遍历的官方题解</a>」，这里不再赘述。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-091725798.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>; <span class="comment">//pre 用于保存前一个root.val</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 中序遍历</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans,root.val - pre);</span><br><span class="line">            pre = root.val; <span class="comment">// pre更新为当前节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：<em>O</em>(<em>N</em>)，因为每个节点只访问了一次；</li><li>空间复杂度：<em>O</em>(<em>N</em>)，因为递归用了系统栈。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-783-二叉搜索树节点最小距离&quot;&gt;&lt;a href=&quot;#Leetcode-783-二叉搜索树节点最小距离&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-783-二叉搜索树节点最小距离&quot;&gt;&lt;/a&gt;Leetcode-783-&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树节点最小距离&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个二叉搜索树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回 &lt;strong&gt;树中任意两不同节点值之间的最小差值&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-090527376.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [4,2,6,1,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-090547189.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [1,0,48,null,null,12,49]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树中节点数目在范围 &lt;code&gt;[2, 100]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= Node.val &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;差值是一个正数，其数值等于两值之差的绝对值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-08-SpringBoot整合使用</title>
    <link href="http://zhuuu.work/2021/04/05/RabbitMQ/RabbitMQ-08-SpringBoot%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhuuu.work/2021/04/05/RabbitMQ/RabbitMQ-08-SpringBoot%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-05T06:02:24.000Z</published>
    <updated>2021-04-07T07:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-08-SpringBoot整合使用"><a href="#RabbitMQ-08-SpringBoot整合使用" class="headerlink" title="RabbitMQ-08-SpringBoot整合使用"></a>RabbitMQ-08-SpringBoot整合使用</h2><h2 id="1-使用场景概述"><a href="#1-使用场景概述" class="headerlink" title="1. 使用场景概述"></a>1. 使用场景概述</h2><ul><li><strong>rabbitMQ的作用 ： 解耦 削峰 异步</strong></li></ul><h3 id="1-1-同步异步的问题（串行）"><a href="#1-1-同步异步的问题（串行）" class="headerlink" title="1.1 同步异步的问题（串行）"></a>1.1 同步异步的问题（串行）</h3><ul><li>串行方式：将订单信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-140556054.png" alt="mark"></p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 :保存订单 </span></span><br><span class="line">    orderService.saveOrder();</span><br><span class="line">    <span class="comment">// 2： 发送短信服务</span></span><br><span class="line">    messageService.sendSMS(<span class="string">"order"</span>);<span class="comment">//1-2 s</span></span><br><span class="line">    <span class="comment">// 3： 发送email服务</span></span><br><span class="line">    emailService.sendEmail(<span class="string">"order"</span>);<span class="comment">//1-2 s</span></span><br><span class="line">    <span class="comment">// 4： 发送APP服务</span></span><br><span class="line">    appService.sendApp(<span class="string">"order"</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2-并行方式-异步线程池"><a href="#1-2-并行方式-异步线程池" class="headerlink" title="1.2 并行方式 异步线程池"></a>1.2 并行方式 异步线程池</h3><ul><li>并行方式：将订单信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-140723072.png" alt="mark"></p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 :保存订单 </span></span><br><span class="line">    orderService.saveOrder();</span><br><span class="line">   <span class="comment">// 相关发送</span></span><br><span class="line">   relationMessage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relationMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">     theadpool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">// 2： 发送短信服务  </span></span><br><span class="line">             messageService.sendSMS(<span class="string">"order"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">     theadpool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="comment">// 3： 发送email服务</span></span><br><span class="line">            emailService.sendEmail(<span class="string">"order"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">      <span class="comment">// 异步</span></span><br><span class="line">     theadpool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">// 4： 发送短信服务</span></span><br><span class="line">             appService.sendApp(<span class="string">"order"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">      <span class="comment">// 异步</span></span><br><span class="line">         theadpool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">// 4： 发送短信服务</span></span><br><span class="line">             appService.sendApp(<span class="string">"order"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在问题：</strong><br>1：耦合度高<br>2：需要自己写线程池自己维护成本太高<br>3：出现了消息可能会丢失，需要你自己做消息补偿<br>4：如何保证消息的可靠性你自己写<br>5：如果服务器承载不了，你需要自己去写高可用</p><h3 id="1-3-异步消息队列模式"><a href="#1-3-异步消息队列模式" class="headerlink" title="1.3 异步消息队列模式"></a>1.3 异步消息队列模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-140820922.png" alt="mark"></p><p><strong>好处</strong><br>1：完全解耦，用MQ建立桥接<br>2：有独立的线程池和运行模型<br>3：出现了消息可能会丢失，MQ有持久化功能<br>4：如何保证消息的可靠性，死信队列和消息转移的等<br>5：如果服务器承载不了，你需要自己去写高可用，HA镜像模型高可用。<br>按照以上约定，用户的响应时间相当于是订单信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 :保存订单 </span></span><br><span class="line">    orderService.saveOrder();   </span><br><span class="line">    rabbitTemplate.convertSend(<span class="string">"ex"</span>,<span class="string">"2"</span>,<span class="string">"消息内容"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>之后若进行服务的扩展（高内聚 低耦合的特点）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-141007724.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-141032549.png" alt="mark"></p><ul><li>还有以下场景的使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">04、分布式事务的可靠消费和可靠生产</span><br><span class="line">05、索引、缓存、静态化处理的数据同步</span><br><span class="line">06、流量监控</span><br><span class="line">07、日志监控（ELK）</span><br><span class="line">08、下单、订单分发、抢票</span><br></pre></td></tr></table></figure><h2 id="2-SpringBoot-fanout-模式"><a href="#2-SpringBoot-fanout-模式" class="headerlink" title="2. SpringBoot - fanout 模式"></a>2. SpringBoot - fanout 模式</h2><ul><li>使用<code>springboot</code>完成<code>rabbitmq</code>的消费模式<code>-Fanout</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210406-142051131.png" alt="mark"></p><p><strong>步骤概览：</strong></p><p>1：创建生产者工程：<code>springboot-rabbitmq-fanout-producer</code><br>2：创建消费者工程：<code>springboot-rabbitmq-fanout-consumer</code><br>3：引入<code>spring-boot-rabbitmq</code>的依赖<br>4：进行消息的分发和测试<br>5：查看和观察web控制台的状况</p><p><strong>代码实现：生产者和消费者都需要配置</strong></p><ol><li><strong>引入依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在application.yml进行配置</strong></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 配置rabbitmq服务</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">ip</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure><h3 id="2-1-生产者"><a href="#2-1-生产者" class="headerlink" title="2.1 生产者"></a>2.1 生产者</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210406-155414551.png" alt="mark"></p><ul><li><code>OrderService</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 1: 定义交换机</span></span><br><span class="line">    <span class="keyword">private</span> String exchangeName = <span class="string">"fanout_order_exchange"</span>;</span><br><span class="line">    <span class="comment">// 2: 路由key</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1： 模拟用户下单</span></span><br><span class="line">        String orderNumer = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 2: 根据商品id productId 去查询商品的库存</span></span><br><span class="line">        <span class="comment">// int numstore = productSerivce.getProductNum(productId);</span></span><br><span class="line">        <span class="comment">// 3:判断库存是否充足</span></span><br><span class="line">        <span class="comment">// if(num &gt;  numstore )&#123; return  "商品库存不足..."; &#125;</span></span><br><span class="line">        <span class="comment">// 4: 下单逻辑</span></span><br><span class="line">        <span class="comment">// orderService.saveOrder(order);</span></span><br><span class="line">        <span class="comment">// 5: 下单成功要扣减库存</span></span><br><span class="line">        <span class="comment">// 6: 下单完成以后</span></span><br><span class="line">        System.out.println(<span class="string">"用户 "</span> + userId + <span class="string">",订单编号是："</span> + orderNumer);</span><br><span class="line">        <span class="comment">// 发送订单信息给RabbitMQ fanout</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routeKey, orderNumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>FanoutConfig</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutOrderExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  return new DirectExchange("TestDirectExchange",true,true);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanout_order_exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">emailQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"email.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">smsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"sms.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">weixinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"weixin.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutweixinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(weixinQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutsmsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutemailQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-消费者"><a href="#2-2-消费者" class="headerlink" title="2.2 消费者"></a>2.2 消费者</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210406-155652005.png" alt="mark"></p><p><strong>邮件服务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">// bindings其实就是用来确定队列消费者绑定关系</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings =<span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">// email.fanout.queue 是队列名字，这个名字你可以自定随便定义。</span></span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"email.fanout.queue"</span>,autoDelete = <span class="string">"false"</span>),</span><br><span class="line">        <span class="comment">// order.fanout 交换机的名字 必须和生产者保持一致</span></span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanout_order_exchange"</span>,</span><br><span class="line">                <span class="comment">// 这里是确定的rabbitmq模式是：fanout 是以广播模式 、 发布订阅模式</span></span><br><span class="line">                type = ExchangeTypes.FANOUT)</span><br><span class="line">))</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @RabbitHandler 代表此方法是一个消息接收的方法。该不要有返回值</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messagerevice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处省略发邮件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"email--------------&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>短信服务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">// bindings其实就是用来确定队列和消费者绑定关系</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings =<span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">// email.fanout.queue 是队列名字，这个名字你可以自定随便定义。</span></span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"sms.fanout.queue"</span>,autoDelete = <span class="string">"false"</span>),</span><br><span class="line">        <span class="comment">// order.fanout 交换机的名字 必须和生产者保持一致</span></span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanout_order_exchange"</span>,</span><br><span class="line">                <span class="comment">// 这里是确定的rabbitmq模式是：fanout 是以广播模式 、 发布订阅模式</span></span><br><span class="line">                type = ExchangeTypes.FANOUT)</span><br><span class="line">))</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @RabbitHandler 代表此方法是一个消息接收的方法。该不要有返回值</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messagerevice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处省略发邮件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"sms--------------&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>微信服务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">// bindings其实就是用来确定队列和消费者绑定关系</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings =<span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">// email.fanout.queue 是队列名字，这个名字你可以自定随便定义。</span></span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"weixin.fanout.queue"</span>,autoDelete = <span class="string">"false"</span>),</span><br><span class="line">        <span class="comment">// order.fanout 交换机的名字 必须和生产者保持一致</span></span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanout_order_exchange"</span>,</span><br><span class="line">                <span class="comment">// 这里是确定的rabbitmq模式是：fanout 是以广播模式 、 发布订阅模式</span></span><br><span class="line">                type = ExchangeTypes.FANOUT)</span><br><span class="line">))</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @RabbitHandler 代表此方法是一个消息接收的方法。该不要有返回值</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messagerevice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处省略发邮件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"weixin--------------&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-结果"><a href="#2-3-结果" class="headerlink" title="2.3 结果"></a>2.3 结果</h3><ul><li>启动项目 结果预览</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210406-155838578.png" alt="mark"></p><h2 id="3-SpringBoot-Direct-模式"><a href="#3-SpringBoot-Direct-模式" class="headerlink" title="3. SpringBoot - Direct 模式"></a>3. SpringBoot - Direct 模式</h2><ul><li>环境设置同第二节</li></ul><h3 id="3-1-生产者"><a href="#3-1-生产者" class="headerlink" title="3.1 生产者"></a>3.1 生产者</h3><ul><li><code>orderService</code> : 不同的是交换的名字还有类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 1: 定义交换机</span></span><br><span class="line">    <span class="keyword">private</span> String exchangeName = <span class="string">"direct_order_exchange"</span>;</span><br><span class="line">    <span class="comment">// 2: 路由key</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1： 模拟用户下单</span></span><br><span class="line">        String orderNumer = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 2: 根据商品id productId 去查询商品的库存</span></span><br><span class="line">        <span class="comment">// int numstore = productSerivce.getProductNum(productId);</span></span><br><span class="line">        <span class="comment">// 3:判断库存是否充足</span></span><br><span class="line">        <span class="comment">// if(num &gt;  numstore )&#123; return  "商品库存不足..."; &#125;</span></span><br><span class="line">        <span class="comment">// 4: 下单逻辑</span></span><br><span class="line">        <span class="comment">// orderService.saveOrder(order);</span></span><br><span class="line">        <span class="comment">// 5: 下单成功要扣减库存</span></span><br><span class="line">        <span class="comment">// 6: 下单完成以后</span></span><br><span class="line">        System.out.println(<span class="string">"用户 "</span> + userId + <span class="string">",订单编号是："</span> + orderNumer);</span><br><span class="line">        <span class="comment">// 发送订单信息给RabbitMQ fanout</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routeKey, orderNumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DirectRabbitConfig</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">emailQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"email.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">smsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"sms.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">weixinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"weixin.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. Direct交换机 起名：TestDirectExchange</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directOrderExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  return new DirectExchange("TestDirectExchange",true,true);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"direct_order_exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 绑定  将队列和交换机绑定, 并设置用于匹配键：TestDirectRouting</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(weixinQueue()).to(directOrderExchange()).with(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(directOrderExchange()).with(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(directOrderExchange()).with(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-消费者"><a href="#3-2-消费者" class="headerlink" title="3.2 消费者"></a>3.2 消费者</h3><p><strong>结构如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-145848520.png" alt="mark"></p><ul><li>代码如上2.2 雷同，这里不再详细写出</li></ul><h2 id="4-SpringBoot-Topic-模式"><a href="#4-SpringBoot-Topic-模式" class="headerlink" title="4. SpringBoot - Topic 模式"></a>4. SpringBoot - Topic 模式</h2><ul><li>代码如上雷同，这里不再详细写出</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-08-SpringBoot整合使用&quot;&gt;&lt;a href=&quot;#RabbitMQ-08-SpringBoot整合使用&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-08-SpringBoot整合使用&quot;&gt;&lt;/a&gt;RabbitMQ-08-SpringBoot整合使用&lt;/h2&gt;&lt;h2 id=&quot;1-使用场景概述&quot;&gt;&lt;a href=&quot;#1-使用场景概述&quot; class=&quot;headerlink&quot; title=&quot;1. 使用场景概述&quot;&gt;&lt;/a&gt;1. 使用场景概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;rabbitMQ的作用 ： 解耦 削峰 异步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-同步异步的问题（串行）&quot;&gt;&lt;a href=&quot;#1-1-同步异步的问题（串行）&quot; class=&quot;headerlink&quot; title=&quot;1.1 同步异步的问题（串行）&quot;&gt;&lt;/a&gt;1.1 同步异步的问题（串行）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;串行方式：将订单信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-140556054.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeOrder&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1 :保存订单 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    orderService.saveOrder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2： 发送短信服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    messageService.sendSMS(&lt;span class=&quot;string&quot;&gt;&quot;order&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//1-2 s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3： 发送email服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    emailService.sendEmail(&lt;span class=&quot;string&quot;&gt;&quot;order&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//1-2 s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 4： 发送APP服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    appService.sendApp(&lt;span class=&quot;string&quot;&gt;&quot;order&quot;&lt;/span&gt;);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1143-最长公共子序列</title>
    <link href="http://zhuuu.work/2021/04/03/Leetcode/Leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://zhuuu.work/2021/04/03/Leetcode/Leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-04-03T03:02:24.000Z</published>
    <updated>2021-04-04T12:46:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1143-最长公共子序列"><a href="#Leetcode-1143-最长公共子序列" class="headerlink" title="Leetcode-1143-最长公共子序列"></a>Leetcode-1143-<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</li><li>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li><li>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line"></span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul></li></ul><a id="more"></a><h2 id="算法思路：动态规划"><a href="#算法思路：动态规划" class="headerlink" title="算法思路：动态规划"></a>算法思路：动态规划</h2><p><strong>思路</strong></p><ul><li>最长公共子序列问题是典型的二维动态规划问题。</li></ul><p><strong>算法：动态规划</strong></p><ol><li><strong>定义dp数组</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210404-204250982.png" alt="mark"></p><ol start="2"><li><strong>初始化边界</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210404-204319577.png" alt="mark"></p><ol start="3"><li><strong>转移规律</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210404-204410567.png" alt="mark"></p><ol start="4"><li><strong>返回结果</strong></li></ol><ul><li>最终计算得到<code>return dp[m][n];</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化条件:dp[m + 1][n + 1]</span></span><br><span class="line">        <span class="keyword">int</span> m = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 边界条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;++j)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. dp 转移逻辑</span></span><br><span class="line">        <span class="keyword">char</span> char_i = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">char</span> char_j = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i)&#123;                                                  <span class="comment">// </span></span><br><span class="line">            char_i = text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                char_j = text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 3.1 如果text[i] == text[j] :dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line">                <span class="keyword">if</span>(char_i == char_j)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3.2 如果text[i] ！= text[j] dp[i][j] = max(dp[i][j - 1],dp[i -1][j]);</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>],dp[i -<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(mn) 。对m 行 n 列元素进行一一遍历</li><li>空间复杂度 ： O(mn) 。二维dp数组的大小</li></ul><h2 id="打表过程"><a href="#打表过程" class="headerlink" title="打表过程"></a>打表过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210404-204453590.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1143-最长公共子序列&quot;&gt;&lt;a href=&quot;#Leetcode-1143-最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1143-最长公共子序列&quot;&gt;&lt;/a&gt;Leetcode-1143-&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最长公共子序列&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定两个字符串 &lt;code&gt;text1&lt;/code&gt; 和 &lt;code&gt;text2&lt;/code&gt;，返回这两个字符串的最长 &lt;strong&gt;公共子序列&lt;/strong&gt; 的长度。如果不存在 &lt;strong&gt;公共子序列&lt;/strong&gt; ，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;一个字符串的 &lt;strong&gt;子序列&lt;/strong&gt; 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; 的子序列，但 &lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt; 不是 &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; 的子序列。&lt;/li&gt;
&lt;li&gt;两个字符串的 &lt;strong&gt;公共子序列&lt;/strong&gt; 是这两个字符串所共同拥有的子序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：text1 &amp;#x3D; &amp;quot;abcde&amp;quot;, text2 &amp;#x3D; &amp;quot;ace&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最长公共子序列是 &amp;quot;ace&amp;quot; ，它的长度为 3 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：text1 &amp;#x3D; &amp;quot;abc&amp;quot;, text2 &amp;#x3D; &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最长公共子序列是 &amp;quot;abc&amp;quot; ，它的长度为 3 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：text1 &amp;#x3D; &amp;quot;abc&amp;quot;, text2 &amp;#x3D; &amp;quot;def&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：两个字符串没有公共子序列，返回 0 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= text1.length, text2.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text1&lt;/code&gt; 和 &lt;code&gt;text2&lt;/code&gt; 仅由小写英文字符组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-面试题17.21-直方图的水量</title>
    <link href="http://zhuuu.work/2021/04/02/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9817.21-%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/"/>
    <id>http://zhuuu.work/2021/04/02/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9817.21-%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/</id>
    <published>2021-04-02T03:02:24.000Z</published>
    <updated>2021-04-02T14:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-面试题17-21-直方图的水量"><a href="#Leetcode-面试题17-21-直方图的水量" class="headerlink" title="Leetcode-面试题17.21-直方图的水量"></a>Leetcode-面试题17.21-<a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/" target="_blank" rel="noopener">直方图的水量</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-093642478.png" alt="mark"></p><ul><li>上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路一-：-单调栈"><a href="#思路一-：-单调栈" class="headerlink" title="思路一 ： 单调栈"></a>思路一 ： 单调栈</h2><p><strong>算法思路</strong></p><ul><li><p>维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 <em>height</em> 中的元素递减。（单调递减栈）</p></li><li><p>从左到右遍历数组，遍历到下标 i 时，如果栈内至少有两个元素，记栈顶元素为 top，top 的栈内下面一个元素是left，则一定有 <code>height[left]≥height[top]。</code></p></li><li><p>如果 <code>height[i]&gt;height[top]</code>，则得到一个可以接雨水的区域，该区域的宽度是 <code>i−left−1</code>，高度是<code>min(height[left],height[i])−height[top]</code>，根据宽度和高度即可计算得到该区域能接的水的量。</p><ul><li>为了得到left , 需要将top 进行出栈。在对<code>top</code>计算能接的水量之后，<code>left</code>变成新的<code>top</code>。 </li><li>重复上述操作，直到栈变为空，或者栈顶下标对应的<code>height</code>中元素大于或等于 <code>height[i]</code></li><li>在对下标<code>i</code> 处计算能接的水量之后，将i入栈，继续遍历后面的下标，计算能接的水量</li><li>遍历结束之后累加和就是能接的总水量</li></ul></li></ul><p><strong>下面用一个例子<code>height=[0,1,0,2,1,0,1,3,2,1,2,1]</code>来帮助理解单调栈的做法。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095132375.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095139991.png" alt="mark"></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095149597.png" alt="mark" /><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095149597.png" alt="mark"  /><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095208256.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095215424.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095223482.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095229807.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095236306.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095242251.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095247559.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095256468.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095303684.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095309385.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095315519.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095321578.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095327520.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095334609.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095341286.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095347231.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095353479.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化变量和栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;                                                            <span class="comment">// 用于记录最终结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理逻辑:遍历数组中每一个元素的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()])&#123;        <span class="comment">// 保证栈内元素对应的数组中的值是单调递减的</span></span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();                                          <span class="comment">// 拿到栈顶的元素,并且弹出</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;                                            <span class="comment">// 如果此时栈为空，说明没有left的存在，即无法围成面积</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();                                        <span class="comment">// 拿到此时对应的left，不弹出</span></span><br><span class="line">                <span class="keyword">int</span> currwidth  = i - left - <span class="number">1</span>;                                  <span class="comment">// 宽</span></span><br><span class="line">                <span class="keyword">int</span> currHeight = Math.min(height[i],height[left]) - height[top];<span class="comment">// 高</span></span><br><span class="line">                ans += currHeight * currwidth;                                  <span class="comment">// 面积进行累加 </span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 3. 当前区域面积计算完，对新元素入栈</span></span><br><span class="line">            stack.push(i);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;                                                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是数组 height 的长度。从 0 到 n−1 的每个下标最多只会入栈和出栈各一次。</p></li><li><p>空间复杂度：O(n)，其中 n 是数组 height 的长度。空间复杂度主要取决于栈空间，栈的大小不会超过 n。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-面试题17-21-直方图的水量&quot;&gt;&lt;a href=&quot;#Leetcode-面试题17-21-直方图的水量&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-面试题17.21-直方图的水量&quot;&gt;&lt;/a&gt;Leetcode-面试题17.21-&lt;a href=&quot;https://leetcode-cn.com/problems/volume-of-histogram-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;直方图的水量&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-093642478.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面是由数组 &lt;code&gt;[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt;表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://zhuuu.work/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1006-笨阶乘</title>
    <link href="http://zhuuu.work/2021/03/31/Leetcode/Leetcode-1006-%E7%AC%A8%E9%98%B6%E4%B9%98/"/>
    <id>http://zhuuu.work/2021/03/31/Leetcode/Leetcode-1006-%E7%AC%A8%E9%98%B6%E4%B9%98/</id>
    <published>2021-03-31T03:02:24.000Z</published>
    <updated>2021-04-02T14:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1006-笨阶乘"><a href="#Leetcode-1006-笨阶乘" class="headerlink" title="Leetcode-1006-笨阶乘"></a>Leetcode-1006-<a href="https://leetcode-cn.com/problems/clumsy-factorial/" target="_blank" rel="noopener">笨阶乘</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。</code></p></li><li><p>相反，我们设计了一个笨阶乘<code>clumsy：</code>在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p><p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。</code>然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p></li><li><p>另外，我们使用的除法是地板除法<code>（floor division）</code>，所以 <code>10 * 9 / 8</code>等于 11。这保证结果是一个整数。</p><p><strong>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：4</span><br><span class="line">输出：7</span><br><span class="line">解释：7 &#x3D; 4 * 3 &#x2F; 2 + 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：10</span><br><span class="line">输出：12</span><br><span class="line">解释：12 &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= N &lt;= 10000</code></li><li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code> （答案保证符合 32 位整数。）</li></ol><a id="more"></a><h2 id="思路-：-栈"><a href="#思路-：-栈" class="headerlink" title="思路 ： 栈"></a>思路 ： 栈</h2><ul><li><p>根据求解问题<strong>「150. 逆波兰表达式求值」、「224. 基本计算器」、「227. 基本计算器 II」的经验，表达式的计算一般可以借助数据结构「栈」完成，特别是带有括号的表达式。</strong></p></li><li><p>将暂时还不能确定的数据存入栈，确定了优先级最高以后，一旦可以计算出结果，我们就把数据从栈里取出，<strong>整个过程恰好符合了「后进先出」的规律</strong>。本题也不例外。</p></li><li><p>根据题意，<strong>「笨阶乘」没有显式括号，运算优先级是先「乘除」后「加减」。我们可以从 N 开始，枚举 N , N−1、N−2 直到 1 ，枚举这些数的时候，认为它们之前的操作符按照「乘」「除」「加」「减」交替进行。</strong></p><ul><li>出现乘法、除法的时候可以把栈顶元素取出，与当前的 <em>N</em> 进行乘法运算、除法运算（除法运算需要注意先后顺序），并将运算结果重新压入栈中；</li><li>出现加法、减法的时候，把减法视为加上一个数的相反数，然后压入栈，等待以后遇见「乘」「除」法的时候取出。</li><li>最后将栈中元素累加即为答案。由于加法运算交换律成立，可以将栈里的元素依次出栈相加。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 类似波兰表达式，使用栈结构</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(N);</span><br><span class="line">        N--;                                                        <span class="comment">// 首元素入栈</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理逻辑</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;                                              <span class="comment">// 用于处理乘 除 加 法 的顺序逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                stack.push(stack.pop() * N);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index % <span class="number">4</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(stack.pop() / N);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index % <span class="number">4</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                stack.push(N);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(-N);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 最后把所有栈内数字相加即是结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(N)  ，每个元素入栈出栈一次</li><li>空间复杂度 ： O(N)  ,由于「乘」「除」运算在进栈、出栈过程中被计算出来，最后一步弹出栈之前，栈里保存的是「加」「减」法项。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1006-笨阶乘&quot;&gt;&lt;a href=&quot;#Leetcode-1006-笨阶乘&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1006-笨阶乘&quot;&gt;&lt;/a&gt;Leetcode-1006-&lt;a href=&quot;https://leetcode-cn.com/problems/clumsy-factorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;笨阶乘&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，&lt;code&gt;factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相反，我们设计了一个笨阶乘&lt;code&gt;clumsy：&lt;/code&gt;在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。&lt;/code&gt;然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外，我们使用的除法是地板除法&lt;code&gt;（floor division）&lt;/code&gt;，所以 &lt;code&gt;10 * 9 / 8&lt;/code&gt;等于 11。这保证结果是一个整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：7 &amp;#x3D; 4 * 3 &amp;#x2F; 2 + 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：12 &amp;#x3D; 10 * 9 &amp;#x2F; 8 + 7 - 6 * 5 &amp;#x2F; 4 + 3 - 2 * 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= N &amp;lt;= 10000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= answer &amp;lt;= 2^31 - 1&lt;/code&gt; （答案保证符合 32 位整数。）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="波兰表达式" scheme="http://zhuuu.work/tags/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-074-搜索二维矩阵</title>
    <link href="http://zhuuu.work/2021/03/30/Leetcode/Leetcode-074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://zhuuu.work/2021/03/30/Leetcode/Leetcode-074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</id>
    <published>2021-03-30T03:02:24.000Z</published>
    <updated>2021-04-02T14:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-074-搜索二维矩阵"><a href="#Leetcode-074-搜索二维矩阵" class="headerlink" title="Leetcode-074-搜索二维矩阵"></a>Leetcode-074-<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>编写一个高效的算法来判断 <code>m x n</code>矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210330-095448593.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210330-095518901.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br><span class="line">-10^4 &lt;&#x3D; matrix[i][j], target &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><strong>思路</strong></p><ul><li><p>由于每行的第一个元素大于前一行的最后一个元素，且每行元素是升序的，所以每行的第一个元素大于前一行的第一个元素，<strong>因此矩阵第一列的元素是升序的。</strong></p></li><li><p>我们可以<strong>对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素</strong>，</p></li><li><p><strong>然后在该元素所在行中二分查找目标值是否存在。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rowIndex = searchColumn(matrix,target);             <span class="comment">// 搜索在哪一行</span></span><br><span class="line">        <span class="keyword">if</span>(rowIndex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;                                       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> searchRow(matrix[rowIndex],target);              <span class="comment">// 找到所在行号后，再在行内进行搜索</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次二分：搜索target在哪一行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchColumn</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high + low + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;                    <span class="comment">// + 1：目的是为了防止死循环的发生（left = mid 这种情况都需要+1）</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &lt;= target)&#123;                        <span class="comment">// 比较每一行第一个元素与target 判断在哪一行</span></span><br><span class="line">                low = mid;                                       <span class="comment">// 下一轮搜索的区间是 [mid, high]</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;                                  <span class="comment">// 下一轮搜索的区间是 [low, mid]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次二分：确定行号后进行行内查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchRow</span><span class="params">(<span class="keyword">int</span>[] row,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = row.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(row[mid] &lt; target)&#123;                              <span class="comment">// 小于 target 的元素一定不是解      </span></span><br><span class="line">                low = mid + <span class="number">1</span>;                                  <span class="comment">// 下一轮搜索的区间是 [mid + 1, high]</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;                                     <span class="comment">// 下一轮搜索的区间是 [low, mid]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确认一下结果是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(row[low] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O（logm） + O(logn) = O(logmn)</li><li>空间复杂度 ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-074-搜索二维矩阵&quot;&gt;&lt;a href=&quot;#Leetcode-074-搜索二维矩阵&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-074-搜索二维矩阵&quot;&gt;&lt;/a&gt;Leetcode-074-&lt;a href=&quot;https://leetcode-cn.com/problems/search-a-2d-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;搜索二维矩阵&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编写一个高效的算法来判断 &lt;code&gt;m x n&lt;/code&gt;矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210330-095448593.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix &amp;#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210330-095518901.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix &amp;#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &amp;#x3D; 13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;m &amp;#x3D;&amp;#x3D; matrix.length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n &amp;#x3D;&amp;#x3D; matrix[i].length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; m, n &amp;lt;&amp;#x3D; 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10^4 &amp;lt;&amp;#x3D; matrix[i][j], target &amp;lt;&amp;#x3D; 10^4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="(i,j,k)" scheme="http://zhuuu.work/tags/i-j-k/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-07-交换机类型</title>
    <link href="http://zhuuu.work/2021/03/28/RabbitMQ/RabbitMQ-07-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhuuu.work/2021/03/28/RabbitMQ/RabbitMQ-07-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-03-28T08:02:24.000Z</published>
    <updated>2021-03-28T07:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-07-交换机类型"><a href="#RabbitMQ-07-交换机类型" class="headerlink" title="RabbitMQ-07-交换机类型"></a>RabbitMQ-07-交换机类型</h2><h2 id="1-交换机的类型"><a href="#1-交换机的类型" class="headerlink" title="1. 交换机的类型"></a>1. 交换机的类型</h2><p><strong>AMQP 0-9-1 的代理提供了四种交换机：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-150948908.png" alt="mark"></p><ul><li>参考官网：<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">https://www.rabbitmq.com/getstarted.html</a></li></ul><a id="more"></a><ul><li><p><strong>交换机可以有两个状态：持久（durable）、暂存（transient）。</strong></p></li><li><p><strong>持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。</strong></p></li><li><p>在正式介绍五种交换机（包括默认交换机）前，在这里重申一下，发布者生产的消息中包含了交换机类型。<strong>消息中声明的交换机类型不同，路由规则也就不同，也就会采取不同的规则将消息投入队列。</strong></p></li></ul><h3 id="1-1-默认交换机"><a href="#1-1-默认交换机" class="headerlink" title="1.1 默认交换机"></a>1.1 默认交换机</h3><ul><li><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的<strong>直连交换机（direct exchange）。</strong></p></li><li><p>它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p><ul><li>举个栗子：当你声明了一个名为<code>“search-indexing-online”</code>的队列，AMQP 代理会自动将其绑定到默认交换机上，绑定（<code>binding</code>）的路由键名称也是为 <code>“search-indexing-online”。</code></li><li>因此，当携带着名为 “search-indexing-online” 的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为 “search-indexing-online” 的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列.</li></ul></li></ul><h3 id="1-2-Direct"><a href="#1-2-Direct" class="headerlink" title="1.2 Direct"></a>1.2 Direct</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-151430656.png" alt="mark"></p><ul><li><p>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应绑定键的队列。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。下边介绍它是如何工作的：</p><ul><li>将一个队列绑定到某个交换机上时，赋予该绑定一个绑定键（Binding Key），假设为R；</li><li>当一个携带着路由键（Routing Key）为R的消息被发送给直连交换机时，交换机会把它路由给绑定键为R的队列。</li></ul></li><li><p>直连交换机的队列通常是循环分发任务给多个消费者（我们称之为轮询）。比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。</p></li><li><p>综上，我们很容易得出一个结论，在 AMQP 0-9-1 中，<strong>消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</strong></p></li></ul><p><strong>如图举例</strong></p><ul><li><p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p></li><li><p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p></li></ul><p><strong>注意：</strong></p><ul><li><code>BindingKey</code>和 <code>RoutingKey</code> 的区别<ul><li><code>BindingKey</code> : <strong>在绑定的时候</strong>，其中需要的路由键是<code>BindingKey</code>，涉及的客户端方法为<code>channel.exchangeBind,channel.queueBind</code><ul><li><code>RoutingKey</code>  : <strong>在发送消息的时候</strong>，其中需要的路由键是<code>RoutingKey</code> ，涉及的客户端方法如<code>channel.basicPublish</code> 对应的AMQP命令为<code>Basic.Publish</code></li></ul></li></ul></li></ul><h3 id="1-3-fanout"><a href="#1-3-fanout" class="headerlink" title="1.3 fanout"></a>1.3 fanout</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-152013014.png" alt="mark"></p><ul><li><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，<strong>而不理会绑定的路由键。</strong></p></li><li><p>如果 N 个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的 N 个队列。</p></li><li><p>扇型用来交换机处理消息的广播路由（broadcast routing）。</p><ul><li>因为扇型交换机投递消息的拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：<ul><li>大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件</li><li>体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li><li>分发系统使用它来广播各种状态和配置更新</li><li>在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP 没有内置 presence 的概念，因此 XMPP 可能会是个更好的选择）</li></ul></li></ul></li></ul><p><strong>如图举例</strong></p><ul><li>上图所示，生产者（P）生产消息 1 将消息 1 推送到 <code>Exchange</code>，由于 <code>Exchange Type=fanout</code>这时候会遵循 <code>fanout</code>的规则将消息推送到所有与它绑定<code>Queue</code>，也就是图上的两个 <code>Queue</code>最后两个消费者消费。</li></ul><h3 id="1-4-Topic"><a href="#1-4-Topic" class="headerlink" title="1.4 Topic"></a>1.4 Topic</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-153449817.png" alt="mark"></p><ul><li>前面提到的 direct 规则是<strong>严格意义上的匹配</strong>，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.</li><li>而Topic 的路由规则是一种<strong>模糊匹配</strong>，可以通过通配符满足一部分规则就可以传送。<ul><li>binding key 中可以存在两种特殊字符 <code>“*” 与“#”，</code>用于做模糊匹配，其中 <code>“*”</code>用于匹配一个单词，<code>“#”</code>用于匹配多个单词（可以是零个）<ul><li><code>“*”</code> : 一定要有一个匹配 （只有一个）</li><li><code>“#”</code> ：0个 1个 多个  （都可以匹配）</li></ul></li><li><code>routing key</code>为一个句点号 <code>“.”</code> 分隔的字符串（我们将被句点号 <code>“. ”</code> 分隔开的每一段独立的字符串称为一个单词），如<code>“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”binding key 与 routing key</code>一样也是句点号<code>“.”</code>分隔的字符串</li></ul></li></ul><p><strong>如图举例</strong></p><ul><li>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue1 中</li><li>如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</li></ul><p><strong>注意：</strong></p><ul><li><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 <strong>多消费者 / 多应用（multiple consumers/applications） 的时候</strong>，主题交换机都可以被列入考虑范围。</p></li><li><p><strong>使用场景：</strong></p><ul><li>分发有关于特定地理位置的数据，例如销售点</li><li>由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务</li><li>股票价格更新（以及其他类型的金融数据更新）</li><li>涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）</li><li>云端的不同种类服务的协调</li><li>分布式架构 / 基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</li></ul></li></ul><h3 id="1-5-headers"><a href="#1-5-headers" class="headerlink" title="1.5 headers"></a>1.5 headers</h3><ul><li><p><code>headers</code> 类型的 <code>Exchange</code> 不依赖于<code>routing key</code> 与 <code>binding key</code>的匹配规则来路由消息，而是根据发送的消息内容中的 <code>headers</code> 属性进行匹配。</p></li><li><p><strong>头交换机可以视为直连交换机的另一种表现形式。但直连交换机的路由键必须是一个字符串，而头属性值则没有这个约束</strong></p><ul><li>它们甚至可以是整数或者哈希值（字典）等。</li><li>灵活性更强（但实际上我们很少用到头交换机）。</li></ul></li><li><p><strong>工作流程：</strong></p><ul><li>绑定一个队列到头交换机上时，会同时绑定多个用于匹配的头<code>header</code>。</li><li>传来的消息会携带<code>header</code>，以及会有一个 <code>“x-match”</code>参数。<ul><li>当 “x-match” 设置为 “any” 时，消息头的任意一个值被匹配就可以满足条件</li><li>当 “x-match” 设置为 “all” 的时候，就需要消息头的所有值都匹配成功。</li></ul></li></ul></li></ul><h3 id="1-6-交换机小结"><a href="#1-6-交换机小结" class="headerlink" title="1.6 交换机小结"></a>1.6 交换机小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-165226361.png" alt="mark"></p><ul><li><strong>何时创建交换机或者队列的问题？</strong><ul><li><code>rabbitMQ</code> 的消息都存储在队列中，因此交换机的使用不用真正的耗费服务器的性能，但是队列是会的</li><li>所以衡量<code>rabbitMQ</code> 当前的QPS只需要看当前的队列即可</li><li>按照<code>rabbitMQ</code> 官方的建议，生产者和消费者都应该尝试创建队列<ul><li>这是一个很好的建议，但是不适用于所有的情况</li><li>如果业务架构之初已经考虑好了所有的情况，这样的话业务可以免去声明的过程，直接使用</li><li>还有一个好处的：可以确保交换机和队列之间正确的绑定<ul><li>这样不会出现发送的消息和交换器没有绑定任何队列造成的消息丢失</li><li>同时路由键无法与现存的队列进行匹配</li></ul></li><li>后期超过预定的QPS，只需要对集群进行扩容或者队列进行迁移即可</li></ul></li><li>总之，动态创建或者静态创建的方式需要从业务的逻辑去考虑</li></ul></li></ul><h2 id="2-入门代码演示"><a href="#2-入门代码演示" class="headerlink" title="2. 入门代码演示"></a>2. 入门代码演示</h2><h3 id="2-1-核心流程再讲"><a href="#2-1-核心流程再讲" class="headerlink" title="2.1 核心流程再讲"></a>2.1 核心流程再讲</h3><p><strong>生产者</strong></p><ul><li>生产者链接到<code>rabbitMQ Broker</code>,建立一个Connection并且开启一个信道</li><li>生产者声明一个交换器，并设置相关的属性，比如交换器的类型，是否持久化等</li><li>生产者声明一个队列并设置相关属性：是否排他，是否持久化，是否自动删除等</li><li>生产者通过路由键将交换器和队列绑定起来</li><li>生产者发送消息到<code>rabbitMQ Broker</code>，其中包含路由键，浇花器等信息</li><li>相应的交换器把接收到的路由key查找相匹配的队列<ul><li>如果找到，则将生产者发送过来的消息存入相应的队列中</li><li>如果没有找到，则根据生产者的配置属性选择丢弃还是退还给生产者</li></ul></li><li>关闭信道</li><li>关闭连接</li></ul><p><strong>消费者</strong></p><ul><li>消费者连接到 <code>rabbitMQ Broker</code>，建立一个连接并且开启一个信道</li><li>消费者向<code>rabbitMQ Broker</code>请求消费相应队列中的消息，可能会设置回调函数之类的</li><li>等待<code>rabbitMQ Broker</code>的回应并且投递相应队列中的消息</li><li>消费者确认（ACK）接收到的消息</li><li><code>rabbitMQ Broker</code> 从队列中删除相应的被确认的消息</li><li>关闭信道</li><li>关闭连接</li></ul><h3 id="2-2-fanout-发布-订阅"><a href="#2-2-fanout-发布-订阅" class="headerlink" title="2.2 fanout (发布/订阅)"></a>2.2 fanout (发布/订阅)</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-105512613.png" alt="mark"></p><ul><li>特点：Fanout—发布与订阅模式，是一种广播机制，它是没有路由key的模式。</li></ul><p><strong>生产者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"fanout"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队列的名字</span></span><br><span class="line">        <span class="keyword">final</span> String queueName = Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.接收消息并且处理异常</span></span><br><span class="line">            Channel finalchannel = channel;</span><br><span class="line">            finalchannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息是"</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收消息失败！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动三个线程去执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong><ul><li><strong><code>Connection</code> 可以用来创建多个<code>Channel</code> 实例，但是<code>Channel</code> 实例不能在线程间共享，应用程序应该为每一个线程开辟一个Channel。</strong></li><li>在某些情况下<code>Channel</code> 的操作可以并发的运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时会影响发送方的确认机制，所以多线程间共享channel是非线程安全的</li></ul></li></ul><h3 id="2-3-Direct"><a href="#2-3-Direct" class="headerlink" title="2.3 Direct"></a>2.3 Direct</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-152219269.png" alt="mark"></p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"direct"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">"你的路由key"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Topic"><a href="#2-4-Topic" class="headerlink" title="2.4 Topic"></a>2.4 Topic</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-152409430.png" alt="mark"></p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"topic"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">"模糊匹配"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-注意事项小结"><a href="#2-5-注意事项小结" class="headerlink" title="2.5 注意事项小结"></a>2.5 注意事项小结</h3><p><strong>注意</strong></p><ul><li><strong><code>Connection</code> 可以用来创建多个<code>Channel</code> 实例，但是<code>Channel</code> 实例不能在线程间共享，应用程序应该为每一个线程开辟一个Channel。</strong></li><li>在某些情况下<code>Channel</code> 的操作可以并发的运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时会影响发送方的确认机制，所以多线程间共享channel是非线程安全的</li></ul><ul><li><p><strong>生产者和消费者都可以声明一个交换器和队列。</strong></p><ul><li><p>如果声明的一个已经存在的交换器或者队列，只要声明的参数完全匹配现存的交换器或者队列，rabbitMQ就什么都不做</p></li><li><p>否则的话，就会抛出异常（<code>ShutdownSignalException</code>）</p></li></ul></li></ul><p><strong>应答AutoAck</strong></p><ul><li><strong>在生产实践中需要显示的设置<code>autoAck</code>为false,然后再接收到消息之后进行显示的ack操作（<code>channel.basicAck</code>） ，对于消费者来说这个是十分必要的，可以防止消息不必要的丢失</strong></li><li>当<code>autoAck</code>为false的时候，对于<code>rabbitMQ</code>服务器而言，队列的消息分为了两个部分<ul><li>一个是等待投递给消费者的消息</li><li>一个是已经投递给消费者，但是还没有收到确认的消息</li></ul></li><li>如果<code>rabbitMQ</code>服务器一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开了连接，那么<code>rabbitMQ</code>服务器会重新安排该消息进入队列，等待下一个消费者，可能这个消费者就是原来的那个消费者</li><li>如果将消息进行拒绝（<code>channel.basicReject 和 channel.basicNack</code>）中的 <code>requeue</code> 设置为false,那么将启用<strong>“死信队列”功能</strong><ul><li>死信队列可以通过检测被拒绝的消息或者未送达的消息来追踪问题</li></ul></li></ul><p><strong>对于消费和的推(push) 和 拉（pull）模式而言</strong></p><ul><li><code>Basic.Consume</code> 将 channel 设置为投递模式（push），直到取消队列的订阅为止。在投递消息的期间，RabbitMQ会不断的将消息推送给消费者，当然推送消息的个数还是收到<code>Basic.Qos</code>的限制</li><li>如果只想要获得带条消息而不是持续的订阅，建议还是使用<code>Basic.Get()</code>方法进行消费。(pull)</li><li>建议消费者应该使用<code>Basic.Consume</code> 来提高吞吐量</li></ul><h3 id="2-6-完整版本生产者"><a href="#2-6-完整版本生产者" class="headerlink" title="2.6 完整版本生产者"></a>2.6 完整版本生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 声明交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line">            String type = <span class="string">"direct"</span>;</span><br><span class="line">            channel.exchangeDeclare(exchangeName,type,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 路由key和声明队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">"queue5"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">"queue6"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">"queue7"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            String routingKey = <span class="string">"你的路由key"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 绑定队列</span></span><br><span class="line">            channel.queueBind(<span class="string">"queue5"</span>,exchangeName,routingKey);</span><br><span class="line">            channel.queueBind(<span class="string">"queue6"</span>,exchangeName,routingKey);</span><br><span class="line">            channel.queueBind(<span class="string">"queue7"</span>,exchangeName,routingKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 10. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 11. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>操作结果如下</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-165147022.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-165202693.png" alt="mark"></p><ul><li><strong>绑定的关系既可以在web界面进行声明也可以如上使用代码进行绑定</strong></li><li>最好使用代码的方式进行绑定</li><li><strong>如果队列或者交换机没有进行声明是会抛异常的</strong><ul><li><strong>同时消费者和生产者中声明队列和交换机都是可以的</strong></li><li><strong>因为channel是双向可以创建的</strong></li></ul></li></ul><h2 id="3-Worker-模式"><a href="#3-Worker-模式" class="headerlink" title="3. Worker 模式"></a>3. Worker 模式</h2><ul><li><strong>这里需要单独列出的是Woker模式</strong><ul><li>因为工作队列模式中有两种机制</li><li>分别是轮询模式和公平分发</li></ul></li></ul><ul><li><strong>如何均衡消费者消费信息的多少呢?</strong></li><li>主要有两种模式：<br>1、<strong>轮询模式</strong>的分发：一个消费者一条，<strong>按均分配；</strong><br>2、<strong>公平分发</strong>：根据消费者的消费能力进行公平分发，处理快的处理的多，处理慢的处理的少；<strong>按劳分配；</strong></li></ul><h3 id="3-1-轮询分发"><a href="#3-1-轮询分发" class="headerlink" title="3.1 轮询分发"></a>3.1 轮询分发</h3><ul><li>特点：该模式接收消息是当有多个消费者接入时，消息的分配模式是一个消费者分配一条，直至消息消费完成；</li><li><strong>默认情况下，rabbitMQ是轮询分发</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-113640288.png" alt="mark"></p><p><strong>代码样例</strong></p><ol><li><strong>生产者：生产消息进行投递</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line">            String queuename = <span class="string">"queue1"</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.queueDeclare(queuename,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//消息的内容</span></span><br><span class="line">                String msg = <span class="string">"朱酱酱:"</span> + i;</span><br><span class="line">                <span class="comment">// 7: 发送消息给中间件rabbitmq-server</span></span><br><span class="line">                <span class="comment">// @params1: 交换机exchange</span></span><br><span class="line">                <span class="comment">// @params2: 队列名称/routingkey</span></span><br><span class="line">                <span class="comment">// @params3: 属性配置</span></span><br><span class="line">                <span class="comment">// @params4: 发送消息的内容</span></span><br><span class="line">                channel.basicPublish(<span class="string">""</span>, <span class="string">"queue1"</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>消费者 worker1</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work1-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work1-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2：worker2(代码几乎一摸一样)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work2-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work2-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预览结果如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-152557735.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-152615219.png" alt="mark"></p><ul><li><strong>小结：可以看到的是，轮询分发不会因为服务器的性能差异而产生竞争消费，而是依次消费</strong></li><li>案例采用的是自动应答模式</li></ul><h3 id="3-2-公平分发"><a href="#3-2-公平分发" class="headerlink" title="3.2 公平分发"></a>3.2 公平分发</h3><ul><li>特点：由于消息接收者处理消息的能力不同，存在处理快慢的问题，我们就需要能者多劳，处理快的多处理，处理慢的少处理；</li><li><strong>公平分发：一定要将应答模式改为手动应答</strong></li></ul><p><strong>案例分析：</strong></p><ol><li><strong>生产者：代码不变</strong></li></ol><ol start="2"><li><strong>消费者1：关闭自动应答，设置手动应答</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.fair;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work1-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work1-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>消费者2：关闭自动应答，设置手动应答</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.fair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work2-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work2-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果预览</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-153656542.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-153708362.png" alt="mark"></p><ul><li><strong>小结：可以看到的是，消费者2由于性能较高，对消费者1的工作进行了截取</strong><ul><li>公平分发需要消费者开启手动应答，关闭自动应答</li><li>关闭自动应答代码channel.BasicConsume(“queue_test”, false, consumer);</li><li>消费者开启手动应答代码：channel.BasicAck(ea.DeliveryTag, false);</li><li>消费者一次接收一条消息，代码channel.BasicQos(0, 1, false);</li></ul></li></ul><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><ul><li>当队列里消息较多时，我们通常会开启多个消费者处理消息；公平分发和轮询分发都是我们经常使用的模式。</li><li>轮询分发的主要思想是“按均分配”，不考虑消费者的处理能力，所有消费者均分；这种情况下，处理能力弱的服务器，一直都在处理消息，而处理能力强的服务器，在处理完消息后，处于空闲状态；</li><li>公平分发的主要思想是”能者多劳”，按需分配，能力强的干的多。</li><li>Qos 在线上环境建议不要设置的太大，会影响服务器的性能</li><li><strong>默认情况下，rabbitMQ是轮询分发</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-07-交换机类型&quot;&gt;&lt;a href=&quot;#RabbitMQ-07-交换机类型&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-07-交换机类型&quot;&gt;&lt;/a&gt;RabbitMQ-07-交换机类型&lt;/h2&gt;&lt;h2 id=&quot;1-交换机的类型&quot;&gt;&lt;a href=&quot;#1-交换机的类型&quot; class=&quot;headerlink&quot; title=&quot;1. 交换机的类型&quot;&gt;&lt;/a&gt;1. 交换机的类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;AMQP 0-9-1 的代理提供了四种交换机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-150948908.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考官网：&lt;a href=&quot;https://www.rabbitmq.com/getstarted.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/getstarted.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-04-数据的表示</title>
    <link href="http://zhuuu.work/2021/03/27/Compute_Organization/%E8%AE%A1%E7%BB%84-04-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA(%E5%AE%9A%E7%82%B9%E6%95%B0)/"/>
    <id>http://zhuuu.work/2021/03/27/Compute_Organization/%E8%AE%A1%E7%BB%84-04-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA(%E5%AE%9A%E7%82%B9%E6%95%B0)/</id>
    <published>2021-03-27T03:02:24.000Z</published>
    <updated>2021-04-21T07:11:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-04-数据的表示"><a href="#计算机组成原理-04-数据的表示" class="headerlink" title="计算机组成原理-04-数据的表示"></a>计算机组成原理-04-数据的表示</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>本篇内容多涉及计算，内容较为硬核，请耐心观看</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205829908.png" alt="mark"></p><h2 id="1-定点数和浮点数的区别"><a href="#1-定点数和浮点数的区别" class="headerlink" title="1. 定点数和浮点数的区别"></a>1. 定点数和浮点数的区别</h2><ul><li><p>根据小数点的位置是否固定，在计算机内有两种数据格式</p><ul><li>定点数</li><li>浮点数</li></ul></li><li><p>定点表示：约定机器数中的小数点位置固定不变，小数点不再用“,”表示，而是约定了它的位置</p></li></ul><h2 id="2-无符号数和有符号数"><a href="#2-无符号数和有符号数" class="headerlink" title="2. 无符号数和有符号数"></a>2. 无符号数和有符号数</h2><ul><li><strong>无符号数</strong>：指整个机器字长的全部二进制位均为数值位，没有符号位。若机器字长为8位，则数的表示范围 <code>0~2^8-1</code> , 即<code>0~255</code>。<ul><li>无符号数一般只代表整数，不代表小数</li></ul></li><li><strong>有符号数</strong>：在机器中，数的正负我们无法识别，但是我们可以用<strong>二进制数来代替正负号。一般‘0’为正，‘1’为负</strong>，符号位一般在有效数的最前面。若机器字长为8位，是有符号数，则数的表示范围为 -2^7<del>2^7-1 ，即-128</del>127。</li></ul><a id="more"></a><h2 id="3-定点数的表示"><a href="#3-定点数的表示" class="headerlink" title="3. 定点数的表示"></a>3. 定点数的表示</h2><ul><li>定点小数：一般将小数点的位置固定在数据的<code>最高位之前</code>。</li><li>定点整数：一般将小数点的位置固定在数据的<code>最低位之后</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091024201.png" alt="mark"></p><h3 id="3-1-原码"><a href="#3-1-原码" class="headerlink" title="3.1 原码"></a>3.1 原码</h3><ul><li>用机器数的最高位来代表该数的符号，其余的各位表示数的绝对值    </li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091658245.png" alt="mark"></p><h3 id="3-2-反码"><a href="#3-2-反码" class="headerlink" title="3.2 反码"></a>3.2 反码</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091855834.png" alt="mark"></p><ul><li>反码通常用于原码求补码的中间过渡</li><li>反码<ul><li>若符号位为0，则反码和原码相同</li><li>若符号位为1，则数值位全部取反</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-092022869.png" alt="mark"></p><h3 id="3-3-补码"><a href="#3-3-补码" class="headerlink" title="3.3 补码"></a>3.3 补码</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093338403.png" alt="mark"></p><ul><li>正数的补码和原码相同</li><li>负数的补码<ul><li>先求出反码</li><li>反码的基础上+1（需要注意进位的问题）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093400463.png" alt="mark"></p><ul><li>补码如何求原码？<ul><li>正数的补码和原码一样</li><li><strong>负数 ：数值位全部取反，然后+1</strong></li></ul></li></ul><h3 id="3-4-移码"><a href="#3-4-移码" class="headerlink" title="3.4 移码"></a>3.4 移码</h3><ul><li><strong>移码的特性：非常方便比较大小</strong></li><li>只能用于表示整数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093731979.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093824082.png" alt="mark"></p><h3 id="3-5-例题小结"><a href="#3-5-例题小结" class="headerlink" title="3.5 例题小结"></a>3.5 例题小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-094010561.png" alt="mark"></p><ul><li><strong>如何从[x]补 求得 [-x]补</strong><ul><li><strong>技巧：符号位 数值位 全部取反</strong></li><li><strong>并且末尾+1</strong></li></ul></li><li><strong>转换技巧小结</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-094226591.png" alt="mark"></p><h2 id="4-补码的作用和由来"><a href="#4-补码的作用和由来" class="headerlink" title="4. 补码的作用和由来"></a>4. 补码的作用和由来</h2><ul><li><strong>原因：原码的加减法和无符号的加减法的差异</strong><ul><li>因此需要涉及一种算法：用加法代替减法</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-204046237.png" alt="mark"></p><ul><li><strong>模m计算法则（详情请学习离散数学）</strong><ul><li>如采用时钟，则相当于对12取模（-3和9的地位是等价的）</li><li>(mod 12)相当于把所有的整数分为了12类（余数为0-11）</li><li>mod12 属于相同的数，都是属于同一类，是等价的</li><li><strong>图示如下：这样就相当于把-3 改为了 +9等等（加法代替了减法）</strong></li><li><strong>这里的 -3 和 9 互为补数，他们的绝对值之和是等于模的（12）</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-204307371.png" alt="mark"></p><ul><li>如计算机的<strong>机器字长是8bit</strong>，那么超出这个范围的话，只保留8为，那么就<strong>相当于mod 2^8 的条件</strong><ul><li>那么<strong>补数 = 2^8 - 负数的绝对值</strong></li><li><strong>补数 就是 补码的原生定义</strong></li><li>针对上个例子如图所示</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205012290.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205148396.png" alt="mark"></p><ul><li><strong>再来看个例子</strong><ul><li>补码的加减法：符号位一起加入计算</li><li>注意：加法会有溢出的产生</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205556014.png" alt="mark"></p><h2 id="5-定点数的移位运算"><a href="#5-定点数的移位运算" class="headerlink" title="5. 定点数的移位运算"></a>5. 定点数的移位运算</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205917524.png" alt="mark"></p><h3 id="5-1-算数移位"><a href="#5-1-算数移位" class="headerlink" title="5.1 算数移位"></a>5.1 算数移位</h3><h4 id="5-1-1-原码的移位规则"><a href="#5-1-1-原码的移位规则" class="headerlink" title="5.1.1 原码的移位规则"></a>5.1.1 原码的移位规则</h4><ol><li><strong>整数的算数右移</strong><ul><li>相当于除以2的操作</li><li>高位补0，低位舍弃</li><li>若舍弃的位不等于0，那么会造成精度的丢失</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-210129544.png" alt="mark"></p><ol start="2"><li><strong>整数的算数左移</strong><ul><li>相当于乘以2的规则</li><li>低位补0，高位舍弃</li><li>若舍弃的位不等于0，则会造成严重的精度错误</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-210327660.png" alt="mark"></p><ol start="3"><li><strong>小数的原理同整数</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-210550762.png" alt="mark"></p><h4 id="5-1-2-反码的算数移位"><a href="#5-1-2-反码的算数移位" class="headerlink" title="5.1.2 反码的算数移位"></a>5.1.2 反码的算数移位</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-210741679.png" alt="mark"></p><ol><li><strong>正数的反码移位</strong></li></ol><ul><li>同原码</li></ul><ol start="2"><li><strong>负数的反码移位</strong></li></ol><ul><li>右移除2，高位补1，低位舍弃</li><li>左移乘2，低位补1，高位舍弃</li><li>因为原码和反码的0和1互为相反</li></ul><h4 id="5-1-3-补码的算数移位"><a href="#5-1-3-补码的算数移位" class="headerlink" title="5.1.3 补码的算数移位"></a>5.1.3 补码的算数移位</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-211035647.png" alt="mark"></p><ol><li><strong>正数的反码移位</strong></li></ol><ul><li>同原码</li></ul><ol start="2"><li><strong>负数的反码移位</strong></li></ol><ul><li>右移除2，补位同反码 ，高位补1，低位舍弃</li><li>左移乘2，补码同原码 ，低位补0，高位舍弃</li><li>负数补码 = 反码末尾+1<ul><li>导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止</li></ul></li><li><strong>规律 ： 负数补码中，最右边的1及其右边同原码，最右边的左边同反码</strong></li></ul><h4 id="5-1-4-算数移位小结"><a href="#5-1-4-算数移位小结" class="headerlink" title="5.1.4 算数移位小结"></a>5.1.4 算数移位小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213119125.png" alt="mark"></p><h3 id="5-2-逻辑移位"><a href="#5-2-逻辑移位" class="headerlink" title="5.2 逻辑移位"></a>5.2 逻辑移位</h3><ul><li>看作对<strong>无符号数的算数移位</strong></li><li>左移右移都补0</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213352208.png" alt="mark"></p><ol><li><strong>RGB的应用</strong></li></ol><ul><li>用3B来存储RGB的值</li><li>不断的右移就是RGB对应的机器码</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213528606.png" alt="mark"></p><h3 id="5-3-循环移位"><a href="#5-3-循环移位" class="headerlink" title="5.3 循环移位"></a>5.3 循环移位</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213703982.png" alt="mark"></p><ul><li>对于加法产生的进位超过数据字长<ul><li>计算机采用进位位（CF）来记录进位值的大小</li><li>具体左移右移如下所示</li><li><strong>作用：适合将数据的高位和低位进行调换（大端存储和小端存储）</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213834957.png" alt="mark"></p><h3 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213948591.png" alt="mark"></p><h2 id="6-定点数的溢出"><a href="#6-定点数的溢出" class="headerlink" title="6. 定点数的溢出"></a>6. 定点数的溢出</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-223331029.png" alt="mark"></p><p><strong>发生的原因及分类</strong></p><ul><li>上溢：两个正数相加得到一个负数</li><li>下溢：两个负数相加得到一个正数</li></ul><p><strong>举例描述</strong></p><ul><li>三位二进制位的原码加法</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-221009343.png" alt="mark"></p><h3 id="6-1-原码加法的规则"><a href="#6-1-原码加法的规则" class="headerlink" title="6.1 原码加法的规则"></a>6.1 原码加法的规则</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-214826290.png" alt="mark"></p><h3 id="6-2-采用一位符号位"><a href="#6-2-采用一位符号位" class="headerlink" title="6.2 采用一位符号位"></a>6.2 采用一位符号位</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-221219755.png" alt="mark"></p><ul><li><strong>符合规律</strong><ul><li>正 + 正 = 负</li><li>负 + 负 = 正</li></ul></li></ul><h3 id="6-3-采用一位符号位并判断进位"><a href="#6-3-采用一位符号位并判断进位" class="headerlink" title="6.3 采用一位符号位并判断进位"></a>6.3 采用一位符号位并判断进位</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-221821701.png" alt="mark"></p><ul><li><p>符号位的进位和最高数位的进位C1</p><ul><li>相同则说明没有溢出</li><li>否则表示发生了溢出</li></ul></li><li><p>计算机可以简单的通过异或两个进位的值运算得到是否产生溢出</p></li></ul><h3 id="6-4-采用双符号位"><a href="#6-4-采用双符号位" class="headerlink" title="6.4 采用双符号位"></a>6.4 采用双符号位</h3><ul><li><strong>双符号位又叫做模4补码</strong></li><li>正数的符号位是00</li><li>负数的符号位是11</li></ul><p><strong>结果规则：</strong></p><ul><li>符号位00 ：结果为正 无溢出</li><li>符号位11 :   结果为负 无溢出</li><li>10 ： 1表示原来的应该是负的 结果却是正的</li><li>01 ： 0表示原来的应该是正的 结果却是负的</li></ul><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-222201396.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li>使用双符号位：并不是有两个符号位，而是机器复制了一个符号位，这样并不会造成数据的扩展</li></ul><h3 id="6-5-溢出的原因"><a href="#6-5-溢出的原因" class="headerlink" title="6.5 溢出的原因"></a>6.5 溢出的原因</h3><ul><li><strong>目前的计算结果超出了机器字长所能表示的范围</strong></li></ul><p><strong>符号扩展</strong></p><ul><li><strong>正整数的扩展</strong><ul><li>在符号位后的高位补上0</li></ul></li><li><strong>负整数的扩展</strong><ul><li>原码：在符号位和数值位之间补0</li><li>反码：在符号位和数值位之间补1</li><li><strong>补码：在符号位和数值位之间补1</strong><ul><li>找到最右边的1</li><li>右半部分同原码</li><li>左半部分同反码</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-222841325.png" alt="mark"></p><p><strong>小数的扩展</strong></p><ul><li><strong>正小数</strong><ul><li>在尾部添加0</li></ul></li><li><strong>负小数</strong><ul><li>原码 ：在末尾添0</li><li>反码 ： 在末尾添1</li><li>补码 ： 在末尾添0<ul><li>找到最右边的1</li><li>右半部分同原码</li><li>左半部分同反码</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-223229253.png" alt="mark"></p><h2 id="7-定点数的乘-除法原理"><a href="#7-定点数的乘-除法原理" class="headerlink" title="7. 定点数的乘/除法原理"></a>7. 定点数的乘/除法原理</h2><h3 id="7-1-乘法原理"><a href="#7-1-乘法原理" class="headerlink" title="7.1 乘法原理"></a>7.1 乘法原理</h3><ol><li><strong>首先看看10进制乘法原理</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-220141435.png" alt="mark"></p><ol start="2"><li><strong>二进制的原码乘法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-220334359.png" alt="mark"></p><ol start="3"><li>以上是手算的方式，如果考虑用计算机如何实现？<ul><li>实际的数字有正负，符号位如何处理</li><li>乘积的位数扩大一倍，如何处理？</li><li>4个位积都要保存下来，最后统一相加？</li></ul></li></ol><h4 id="7-1-1-原码一位乘法计算"><a href="#7-1-1-原码一位乘法计算" class="headerlink" title="7.1.1 原码一位乘法计算"></a>7.1.1 原码一位乘法计算</h4><ul><li>首先回忆一下运算器的组成</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-220936083.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-221034940.png" alt="mark"></p><ul><li><strong>对于乘法而言（实现方法：先加法再移位 重复n次）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-221056544.png" alt="mark"></p><ul><li><strong>原码一位乘法计算方法：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-223316038.png" alt="mark"></p><p><strong>举个例子</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-221454132.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-221722710.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-222411004.png" alt="mark"></p><ul><li><strong>手算做题过程：采用双符号位</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-222742601.png" alt="mark"></p><ul><li><strong>本质 ： n 轮的加法和逻辑右移</strong></li></ul><h4 id="7-1-2-补码的一位乘法（Booth-算法）"><a href="#7-1-2-补码的一位乘法（Booth-算法）" class="headerlink" title="7.1.2 补码的一位乘法（Booth 算法）"></a>7.1.2 补码的一位乘法（Booth 算法）</h4><ul><li><strong>计算方式</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-223407997.png" alt="mark"></p><ul><li><p>所谓的辅助位：初始化就是在最后加了一位0</p></li><li><p>实现方式： n 轮加法 和 补码的算数移位（最后还需多一轮加法，符号位）</p></li></ul><p><strong>举个例子 ： 需要采用双符号位</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-223600933.png" alt="mark"></p><ul><li><strong>手算过程 ： 双符号位</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-224133466.png" alt="mark"></p><h4 id="7-1-3-小结"><a href="#7-1-3-小结" class="headerlink" title="7.1.3 小结"></a>7.1.3 小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-224526001.png" alt="mark"></p><h3 id="7-2-除法原理"><a href="#7-2-除法原理" class="headerlink" title="7.2 除法原理"></a>7.2 除法原理</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-224715815.png" alt="mark"></p><ul><li><strong>首先来看看十进制除法（思想：尽可能拼凑出余数）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-105343294.png" alt="mark"></p><ul><li><strong>手算二进制除法举例</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-165502051.png" alt="mark" style="zoom:80%;" /><ul><li>再来回顾运算器的组成</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-165709748.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-165724089.png" alt="mark"></p><h4 id="7-2-1-原码的一位除法（恢复余数法）"><a href="#7-2-1-原码的一位除法（恢复余数法）" class="headerlink" title="7.2.1 原码的一位除法（恢复余数法）"></a>7.2.1 原码的一位除法（恢复余数法）</h4><ul><li><strong>符号单独用异或来确定。</strong></li><li><strong>计算机会默认上商1，如果搞错了再商0，并且恢复余数。</strong></li></ul><p><strong>计算方式如下所示：</strong></p><ul><li>数值位为 n , 逻辑左移需要作n 次</li><li>加法 n + 1次  </li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-171502583.png" alt="mark"></p><p><strong>举个例子</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-170430344.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-170548702.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-171143595.png" alt="mark"></p><ul><li><strong>恢复余数法（手算）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-171353550.png" alt="mark"></p><h4 id="7-2-2-原码的一位除法（不恢复余数法）"><a href="#7-2-2-原码的一位除法（不恢复余数法）" class="headerlink" title="7.2.2 原码的一位除法（不恢复余数法）"></a>7.2.2 原码的一位除法（不恢复余数法）</h4><p><strong>计算方法如下</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-172331806.png" alt="mark"></p><ul><li>上面那个例子，中间过程推导一下，如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-171745622.png" alt="mark"></p><ul><li><strong>操作合并为 ：（余数*2 + 除数）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-172034278.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-172211278.png" alt="mark"></p><p><strong>小结：</strong></p><ul><li>加/ 减 共 <code>n + 1</code> 次，每次加减确定一位商</li><li>左移 n 次，最后一次加减完不移位</li><li>最后因为余数可能为负，还需要一次的恢复余数</li></ul><h4 id="7-2-3-补码的一位除法运算"><a href="#7-2-3-补码的一位除法运算" class="headerlink" title="7.2.3 补码的一位除法运算"></a>7.2.3 补码的一位除法运算</h4><p><strong>补码除法</strong></p><ul><li>符号位参与运算</li><li>被除数/余数，除数采用双符号位</li></ul><p><strong>规则如下</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-173050847.png" alt="mark" style="zoom:67%;" /><p><strong>举个例子</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-173247343.png" alt="mark"></p><p><strong>注意</strong></p><ul><li>末位的商恒为1，这样带来的误差是非常小的</li><li>补码商最后一步，不需要恢复余数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-173442600.png" alt="mark"></p><p><strong>除法小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-173458313.png" alt="mark"></p><h2 id="8-C语言中的强制类型转换"><a href="#8-C语言中的强制类型转换" class="headerlink" title="8. C语言中的强制类型转换"></a>8. C语言中的强制类型转换</h2><ul><li>前提 ： C语言中的定点整数使用补码进行表示的</li><li>注意：数值范围没有负数的则为无符号位的数，有负数范围的则为有符号位的数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-104820948.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出时：</span><br><span class="line">%u无符号十进制整数</span><br><span class="line">%d有符号十进制整数</span><br><span class="line">%0无符号八进制</span><br><span class="line">%x无符号十六进制整数</span><br><span class="line">在计算机中数据都是以补码形式存储的，%u无符号输出，没有符号位，是正数；%d有符号输出，有符号位，符号位在最高位。</span><br></pre></td></tr></table></figure><h3 id="8-1-有符号和无符号的转换"><a href="#8-1-有符号和无符号的转换" class="headerlink" title="8.1 有符号和无符号的转换"></a>8.1 有符号和无符号的转换</h3><ul><li>C语言中常利用强制类型转换，有时候强制类型转换的结果却不是我们希望得到的，因为计算机存储数据是以<code>补码</code>形式存储的。</li><li>有时候强制类型转换可能会改变数值，可能是数据类型有无符号位导致的。<ul><li>无符号位是正数就不用转换，因为正数原码=补码</li><li>有符号位的数，根据符号位是0还是1来判断是否需要转换，那么如果符号位是1，是负数就要转换，数值当然会不同。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">short x=<span class="number">-4321</span>;</span><br><span class="line"><span class="keyword">unsigned</span> short y=(<span class="keyword">unsigned</span> short)x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d,y=%u\n"</span>,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105040654.png" alt="mark"></p><ul><li>可以看出y值和x值没有一点关系，咱们将其都转换成二进制，我们便知道了为什么。且看二进制转换表；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105102281.png" alt="mark"></p><ul><li>由于电脑是64位，所以转换就是64个二进制数，至于为什么16位往左所有数都是1，这就涉及到了符号扩展</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105138559.png" alt="mark"></p><p><strong>小结：</strong></p><ul><li>可以看出，强制类型转换结果相应位置的值不变，仅仅只改变了解释这些位的方式，是short解释，还是<code>unsigned short</code> 解释，这两种方式。</li></ul><p>同样的我们再看一段代码仔细揣摩揣摩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> short x=<span class="number">65535</span>;</span><br><span class="line">short y=(short)x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%u,y=%d\n"</span>,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105350695.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105358683.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105404461.png" alt="mark"></p><ul><li>相应位置数值相等，但是表示结果不同，那是因为解释方式不同；unsigned short 和short两种解释 方式。</li></ul><h3 id="8-2-不同字长的整数之间的转换"><a href="#8-2-不同字长的整数之间的转换" class="headerlink" title="8.2 不同字长的整数之间的转换"></a>8.2 不同字长的整数之间的转换</h3><h4 id="8-2-1-大字长变量向小字长变量强制类型转换"><a href="#8-2-1-大字长变量向小字长变量强制类型转换" class="headerlink" title="8.2.1 大字长变量向小字长变量强制类型转换"></a>8.2.1 大字长变量向小字长变量强制类型转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">165537</span>,u=<span class="number">-34991</span>;  <span class="comment">//int 4B  </span></span><br><span class="line">short y=(short)x,v=(short)u; <span class="comment">// short 2B</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d,y=%d\n"</span>,x,y);   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"u=%d,v=%d\n"</span>,u,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当大字长变量向小字长变量强制类型转换时，系统将多余的高位字长部分直接截断舍去，低位直接赋值</span></span><br></pre></td></tr></table></figure><p><strong>结果显示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105544482.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105805700.png" alt="mark"></p><p><strong>小结：</strong></p><ul><li>当大字长变量向小字长变量强制类型转换时，系统将多余的高位字长部分直接截断舍去，低位直接赋值</li></ul><h4 id="8-2-2-小字长变量向大字长变量强制类型转换"><a href="#8-2-2-小字长变量向大字长变量强制类型转换" class="headerlink" title="8.2.2 小字长变量向大字长变量强制类型转换"></a>8.2.2 小字长变量向大字长变量强制类型转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">short x=<span class="number">-4321</span>; <span class="comment">// short 2B</span></span><br><span class="line"><span class="keyword">int</span> y=x; <span class="comment">//int 4B</span></span><br><span class="line"><span class="keyword">unsigned</span> short u=(<span class="keyword">unsigned</span> short)x; <span class="comment">//无符号数的符号拓展直接高位添0即可</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v=u;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d,y=%d\n"</span>,x,y);   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"u=%u,v=%u\n"</span>,u,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果显示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-111957718.png" alt="mark"></p><ul><li>这里我们转换成十六进制输出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">short x=<span class="number">-4321</span>; <span class="comment">// short 2B</span></span><br><span class="line"><span class="keyword">int</span> y=x; <span class="comment">//int 4B</span></span><br><span class="line"><span class="keyword">unsigned</span> short u=(<span class="keyword">unsigned</span> short)x;<span class="comment">//无符号数的符号拓展直接高位添0即可</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v=u;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d,y=%d\n"</span>,x,y);   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"u=%x,v=%u\x"</span>,u,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-112042907.png" alt="mark"></p><p><strong>小结</strong></p><ul><li><p>短字长整数到长字长整数的转换，不仅要使相应的位置相等，<code>高位部分还会扩展为原数字的符号位</code>。</p></li><li><p>char类型为8位ASCII码整数，转换成int型时，高位部分补0即可。ASCII码由7位二进制数字组成。</p></li><li><p>无符号数的符号拓展直接高位添0即可</p></li></ul><h2 id="9-数据的存储和排列（大小端模式）"><a href="#9-数据的存储和排列（大小端模式）" class="headerlink" title="9. 数据的存储和排列（大小端模式）"></a>9. 数据的存储和排列（大小端模式）</h2><ul><li><p>注意：<code>在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit</code>。</p><ul><li><strong>现代计算机基本都采用的是字节编址，即每个地址编号中存放1个字节的数据</strong>。</li><li><strong>多字节的数据都存放在连续的字节序列中</strong>，根据数据中各字节在连续字节序列中的排位顺序不同，可以分为<ul><li>大端模式</li><li>小端模式</li></ul></li></ul></li><li><p><code>大端模式</code>：<code>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</code>，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p><ul><li><strong>符合人类阅读的习惯</strong></li><li>高地址：存放最低有效字节</li><li>低地址：存放最高有效字节</li></ul></li><li><p><code>小端模式</code>：<code>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</code>，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p><ul><li><strong>符合机器的处理方式</strong></li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-113449083.png" alt="mark" style="zoom:67%;" /><h3 id="9-1-大小端的原因？"><a href="#9-1-大小端的原因？" class="headerlink" title="9.1 大小端的原因？"></a>9.1 大小端的原因？</h3><ul><li><code>在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit</code>。</li><li>在C语言中除了<code>8bit</code>的<code>char</code>之外，还有<code>16bit</code>的<code>short</code>型，<code>32bit的long</code>型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。 因此就导致了大端存储模式和小端存储模式</li></ul><hr><ul><li>对于 大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。</li><li>小端模式，刚好相反。<strong>我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。</strong>有些ARM处理器还可以随时在程序中(在ARM Cortex 系列使用REV、REV16、REVSH指令 )进行大小端的切换。</li></ul><h3 id="9-2-边界对齐的存储方式"><a href="#9-2-边界对齐的存储方式" class="headerlink" title="9.2 边界对齐的存储方式"></a>9.2 边界对齐的存储方式</h3><ul><li>假设存储字长32位，可按<strong>字节、半字和字寻址。</strong><ul><li><code>位、字节、字是计算机数据存储的单位。</code></li><li><code>位是最小的存储单位，每一个位存储一个1位的二进制码，</code></li><li><code>一个字节由8位组成。</code></li><li><code>而字通常为16、32或64个位组成。</code></li><li><code>一个存储字可以是多个字节组成。</code></li></ul></li><li><strong>对于32位计算机，数据以<code>边界对齐</code>方式存储，半字地址一定是2的整数倍，字地址一定是4的整数倍</strong>，这样无论所取的数据是字节、半字还是字。<strong>均可一次访存取出。</strong><ul><li>所存储的数据不满足上诉要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但是却<code>提高了取指令和取数据的速度</code>。</li></ul></li><li><strong>不按边界对齐方式存储的缺点</strong>：半字长或字长的指令可能会存储在两个存储字中，此时需要<strong>两次访存</strong><ul><li>并且对高低字节的位置进行调整、连接后才能得到想要的完整指令或数据，从而影响了指令的执行效率和速度。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151000210.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-150339300.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-150506377.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li><strong>边界对齐的存储方式使用了空间换时间的策略</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-04-数据的表示&quot;&gt;&lt;a href=&quot;#计算机组成原理-04-数据的表示&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-04-数据的表示&quot;&gt;&lt;/a&gt;计算机组成原理-04-数据的表示&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本篇内容多涉及计算，内容较为硬核，请耐心观看&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205829908.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-定点数和浮点数的区别&quot;&gt;&lt;a href=&quot;#1-定点数和浮点数的区别&quot; class=&quot;headerlink&quot; title=&quot;1. 定点数和浮点数的区别&quot;&gt;&lt;/a&gt;1. 定点数和浮点数的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据小数点的位置是否固定，在计算机内有两种数据格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定点数&lt;/li&gt;
&lt;li&gt;浮点数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定点表示：约定机器数中的小数点位置固定不变，小数点不再用“,”表示，而是约定了它的位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-无符号数和有符号数&quot;&gt;&lt;a href=&quot;#2-无符号数和有符号数&quot; class=&quot;headerlink&quot; title=&quot;2. 无符号数和有符号数&quot;&gt;&lt;/a&gt;2. 无符号数和有符号数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无符号数&lt;/strong&gt;：指整个机器字长的全部二进制位均为数值位，没有符号位。若机器字长为8位，则数的表示范围 &lt;code&gt;0~2^8-1&lt;/code&gt; , 即&lt;code&gt;0~255&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;无符号数一般只代表整数，不代表小数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有符号数&lt;/strong&gt;：在机器中，数的正负我们无法识别，但是我们可以用&lt;strong&gt;二进制数来代替正负号。一般‘0’为正，‘1’为负&lt;/strong&gt;，符号位一般在有效数的最前面。若机器字长为8位，是有符号数，则数的表示范围为 -2^7&lt;del&gt;2^7-1 ，即-128&lt;/del&gt;127。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-06-核心组成部分</title>
    <link href="http://zhuuu.work/2021/03/26/RabbitMQ/RabbitMQ-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/"/>
    <id>http://zhuuu.work/2021/03/26/RabbitMQ/RabbitMQ-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</id>
    <published>2021-03-26T08:02:24.000Z</published>
    <updated>2021-04-12T01:41:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-06-核心组成部分"><a href="#RabbitMQ-06-核心组成部分" class="headerlink" title="RabbitMQ-06-核心组成部分"></a>RabbitMQ-06-核心组成部分</h2><h2 id="1-核心组成概览"><a href="#1-核心组成概览" class="headerlink" title="1. 核心组成概览"></a>1. 核心组成概览</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-114609454.png" alt="mark"></p><p><strong>核心概念：</strong></p><ul><li><strong>Server</strong>：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server</li><li><strong>Connection</strong>：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手</li><li><strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。</li><li><strong>Message</strong> :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。</li><li><strong>Virtual Host</strong> 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机可以有若干个Exhange和Queue，同一个虚拟主机里面不能有相同名字的Exchange</li><li><strong>Exchange</strong>：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)</li><li><strong>Bindings</strong>：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.</li><li><strong>Routing key</strong>：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。</li><li><strong>Queue</strong>：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144505890.png" alt="mark"></p><a id="more"></a><h2 id="2-运行流程"><a href="#2-运行流程" class="headerlink" title="2. 运行流程"></a>2. 运行流程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144556342.png" alt="mark"></p><ul><li><strong>Producer ：</strong> 生产者创建消息，然后发布到RabbitMQ中，消息一般包含两个部分：消息体和标签（Label）。消息体也可以称为<code>payload</code>, 在实际的应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JSON字符串，当然可以进一步对这个 消息体进行序列化操作。</li><li><strong>Consumer :</strong> 消费者连接到rabbitMQ服务器，并订阅到该队列上。当消费者消费一条消息的时候，只是消费消息体（payload）。在消息路由的过程中，消息的标签会被丢弃，存入到队列的消息只有消息体，消费者也只会得到消息体，也就是不知道消息的生产者是谁，，当然消费者也不需要知道这些。</li><li><strong>Broker :</strong> 对于rabbitMQ来说，一个rabbitMQ broker 可以看作一台服务节点，也就是服务器</li></ul><p><strong>注意</strong></p><ul><li><p>真实的情况是，生产者将消息发送到<code>Exchange</code>,而不是将消息发送到队列中，由交换机将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。</p></li><li><p>如果不填，默认是一定存在一个交换机的</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-145855934.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-145901162.png" alt="mark"></p><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h2><ul><li>AMQP 中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。</li></ul><h3 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h3><p>队列跟交换机共享某些属性，<strong>但是队列也有一些另外的属性。</strong></p><ul><li><p>Name</p></li><li><p>Durable（消息代理重启后，队列依旧存在）</p></li><li><p>Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）</p></li><li><p>Auto-delete（当最后一个消费者退订后即被删除</p></li><li><p>Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）</p></li></ul><h3 id="3-2-队列的创建"><a href="#3-2-队列的创建" class="headerlink" title="3.2 队列的创建"></a>3.2 队列的创建</h3><ul><li>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。</li><li>如果声明的队列已经存在，并且属性<strong>完全相同</strong>，那么此次声明不会对原有队列产生任何影响。</li><li>如果声明中的属性与已存在队列的<strong>属性有差异</strong>，那么一个错误代码为 406 的通道级异常就会被抛出。</li></ul><h3 id="3-3-队列的持久化"><a href="#3-3-队列的持久化" class="headerlink" title="3.3 队列的持久化"></a>3.3 队列的持久化</h3><ul><li><p><strong>持久化队列<code>（Durable queues）</code>会被存储在磁盘</strong>上，当消息代理<code>（broker）</code>重启的时候，它依旧存在。</p></li><li><p><strong>没有被持久化的队列称作暂存队列</strong>（<code>Transient queues</code>）。并不是所有的场景和案例都需要将队列持久化。</p></li><li><p><strong>持久化的队列并不会使得路由到它的消息也具有持久性</strong>。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p></li></ul><h2 id="4-消费者"><a href="#4-消费者" class="headerlink" title="4. 消费者"></a>4. 消费者</h2><h3 id="4-1-消费模式"><a href="#4-1-消费模式" class="headerlink" title="4.1  消费模式"></a>4.1  消费模式</h3><ul><li><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。在 AMQP 0-9-1 模型中，有两种途径可以达到此目的：</p><ul><li>将消息投递给应用 <strong>(“push API”)</strong></li><li>应用根据需要主动获取消息 <strong>(“pull API”)</strong></li></ul></li><li><p><strong>使用 push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。</strong>如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p></li><li><p><strong>每个消费者（订阅者）都有一个叫做消费者标签的标识符</strong>。它可以被用来退订消息。消费者标签实际上是一个字符串。</p></li></ul><hr><ul><li>消息中间件有很多种，进程也会拿几个来对比对比，其中一种对比项就是消费模式。</li><li><strong>消息的消费模式分Push、Pull两种，或者两者兼具。</strong></li><li><strong>RabbitMQ的消费模式就是兼具Push和Pull。</strong></li></ul><h4 id="4-1-1-push-模式"><a href="#4-1-1-push-模式" class="headerlink" title="4.1.1 push 模式"></a>4.1.1 push 模式</h4><ul><li>发送端向broker端发送数据，数据内容为：<code>RabbitMQ Demo Test, Send Messages 0；RabbitMQ Demo Test, Send Messages 1；RabbitMQ Demo Test, Send Messages 2</code>，依次类推……</li></ul><p>下面是消费端的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = factory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, <span class="string">"consumer_zzh"</span>,consumer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">    String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">    System.out.println(<span class="string">" [X] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行输出：RabbitMQ Demo Test, Send Messages 0</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>wirkshark</code>工具来查看上面示例代码的整个AMQP的过程（图1）：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-152428837.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上图可以对照实例代码来看，</span><br><span class="line">比如图中：Basic.Qos和Basic.Qos-Ok就是示例代码中的：channel.basicQos(1);</span><br><span class="line">再比如图中的Basic.Ack就是示例代码中的channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br><span class="line">对于上图中的带蓝色背影的那行（即No.545，展开如下图，broker to client）</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-152554232.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以看到&#96;Delivery-Tag &#x3D; 1&#96;, 消息内容：“RabbitMQ Demo Test, Send Messages 0”。</span><br><span class="line">展开No.546，即Basic.Ack这行：</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-152717935.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以看到client to broker的Ack:delievery-tag&#x3D;1,和上面的符合。</span><br><span class="line">仔细的朋友可以看到No.548同样是broker向client发送了一条数据，通过展开数据可知：</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-152853666.png" alt="mark"></p><ul><li><p>其内包含的数据正好是下一条的消息——“RabbitMQ Demo Test, Send Messages 1”。但是在运行实例的时候是没有打印出来的，<strong>可以看图1，是broker端主动向client端发送的数据，client端没有请求。</strong></p></li><li><p><strong>在broker端发送第一条数据，即”RabbitMQ Demo Test, Send Messages 0”之后发送Ack，之后关闭Channel,到真正关闭完channel之间，broker端还是会发送(push)数据给Client, 此时Client不会在Ack此条数据了。</strong></p></li><li><p><strong>那么这样这条消息会不会丢失呢？答案是否定的，你可以再运行下consumer程序，就能消费到这条消息，rabbitmq对设置autoAck=false之后没有被Ack的消息是不会清除掉的。</strong></p></li></ul><p><strong>注意：</strong></p><ul><li>实际上如果不设置<code>channel.basicQos(1),</code>那么broker端会一次推送多条数据<br>RabbitMQ的每一数据帧（Frame）都是以0xCE结尾。</li></ul><h4 id="4-1-2-pull-模式"><a href="#4-1-2-pull-模式" class="headerlink" title="4.1.2 pull 模式"></a>4.1.2 pull 模式</h4><ul><li>同样采用wirkshark工具来观察pull模式的AMQP过程，pull模式主要是通过<code>channel,basicGet</code>方法来获取消息，示例代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><ul><li><code>wireshark</code>抓包结果：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-153157619.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以观察No.122, No.123, No.124，这些对于上面的示例代码。</span><br><span class="line">首先是client端发送Get请求，然后broker响应请求回传消息，最后client端发送Ack. </span><br><span class="line"></span><br><span class="line">可以看到有别于push模式，broker端不会在client端没有请求的情况下来回传消息。</span><br></pre></td></tr></table></figure><h3 id="4-2-消息分发"><a href="#4-2-消息分发" class="headerlink" title="4.2 消息分发"></a>4.2 消息分发</h3><ul><li>当<code>rabbitMQ</code>有多个消费者的时候，队列收到的消息以<strong>轮询的方式</strong>分发给消费者（默认情况下）</li><li>如果有n个消费者，那么<code>rabbitMQ</code> 会把第m 条消息发给第<code>m % n</code>（取余数的方式）个消费者<ul><li><code>rabbitMQ</code>不管消息是否消费并已经（<code>Basic.Ack</code>）了消息</li><li>此时，如果当前的消费者任务繁重，而其他消费者由于性能较好很快处理完了自己的消息，那么就会造成整体吞吐量的下降<ul><li>解决的方案：<code>channel.basicQos</code> 方法限制信道上消费者所能保持最大的未确认消息的数量（即消费的最大能力，类似于TCP的滑动窗口）</li><li>但是此方法对拉模式的消费方式无效</li></ul></li></ul></li></ul><h3 id="4-3-消息的顺序性"><a href="#4-3-消息的顺序性" class="headerlink" title="4.3 消息的顺序性"></a>4.3 消息的顺序性</h3><ul><li><strong>目前很多资料显示 rabbitMQ  能够保证消息的顺序性，这是不正确的，或者说这个观点有很大的局限性</strong><ul><li>在不使用任何 rabbitMQ 的高级特性，也没有消息丢失，网络故障之类的情况发生的，并且只有一个消费者的情况下，最好也只有一个消费者的情况下可以保障消息的顺序性（即生产者发送的消息分别为 <code>msg1 msg2 msg3</code>, 那么消费者必然也是按照 <code>msg1 msg2 msg3</code> 的顺序进行消费的）</li></ul></li><li><strong>那么现在有哪些情况下消息的顺序性会被打破呢？</strong><ul><li>如果生产者使用了事务机制，在发送消息的时候遇到异常进行了回滚，那么需要重新补偿发送的这条消息，如果补偿发送实在另外一个线程实现的，那么消息在生产者这个源头就错序了。同样的，使用 <code>publisher confirm</code>时，在发生超时，中断，又或者是收到<code>Basic.Nack</code>命令的时候，那么同样需要进行补偿发送，结果会和事务机制一样发生错序。（这种情况下，我们可以认为rabbitMQ 消息的顺序性保障是从存入队列之后开始的，而不是从发送的时候就开始了）</li><li>如果生产者设置了消息的不同超时时间，并且也设置了死信队列，整体来说这样就相当于是一个延迟队列，那么消费者在消费这个队列的时候，消息消费的顺序必然不会和生产者发送的消息顺序一致</li><li>另外一种情况，如果消息设置了优先级，那么消费者消费到的顺序也必然不是一致的。</li><li>还有一种情况，如果消息以轮询的方式发送给消费者，而消费者拒绝消息从而消息重新入队的话，那么消息的消费顺序也是不一致的。</li></ul></li></ul><h3 id="4-4-弃用-QueueingConsumer"><a href="#4-4-弃用-QueueingConsumer" class="headerlink" title="4.4 弃用 QueueingConsumer"></a>4.4 弃用 QueueingConsumer</h3><ul><li><code>QueueingConsumer 在 rabbitMQ 3.x</code>版本用的如火如荼，但是在4.x 版本标记位 <code>@Deprecated</code>, 那么这个类一定有很大的缺陷</li><li><code>QueueingConsumer</code> 有几大缺陷<ul><li>首当其冲的就是内存溢出的假死问题，由于某些原因，队列中堆积了太多的消息，那么JVM就会爆出<code>java.lang.OutOfMemoryERROR</code><ul><li>这个问题可以通过<code>channel.basicQos</code>方法进行有效的解决<ul><li>原因是：<code>QueueingConsumer</code>内部使用的是<code>LinkedBlockingQueue</code> 来存储消息，而<code>basicQos</code>限制了队列的大小</li></ul></li></ul></li><li>同步递归调用<code>QueueingConsumer</code>会产生死锁</li><li><code>QueueingConsumer</code>会拖累同一个connection 下的所有信道性能</li></ul></li><li><strong>为了避免不必要的麻烦，建议全部继承<code>DefaultConsumer</code></strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-06-核心组成部分&quot;&gt;&lt;a href=&quot;#RabbitMQ-06-核心组成部分&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-06-核心组成部分&quot;&gt;&lt;/a&gt;RabbitMQ-06-核心组成部分&lt;/h2&gt;&lt;h2 id=&quot;1-核心组成概览&quot;&gt;&lt;a href=&quot;#1-核心组成概览&quot; class=&quot;headerlink&quot; title=&quot;1. 核心组成概览&quot;&gt;&lt;/a&gt;1. 核心组成概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-114609454.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Server&lt;/strong&gt;：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connection&lt;/strong&gt;：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Channel&lt;/strong&gt;：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message&lt;/strong&gt; :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Virtual Host&lt;/strong&gt; 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机可以有若干个Exhange和Queue，同一个虚拟主机里面不能有相同名字的Exchange&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exchange&lt;/strong&gt;：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bindings&lt;/strong&gt;：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Routing key&lt;/strong&gt;：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt;：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144505890.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-03-校验码</title>
    <link href="http://zhuuu.work/2021/03/26/Compute_Organization/%E8%AE%A1%E7%BB%84-03-%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
    <id>http://zhuuu.work/2021/03/26/Compute_Organization/%E8%AE%A1%E7%BB%84-03-%E6%A0%A1%E9%AA%8C%E7%A0%81/</id>
    <published>2021-03-26T03:02:24.000Z</published>
    <updated>2021-03-27T12:43:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-03-校验码"><a href="#计算机组成原理-03-校验码" class="headerlink" title="计算机组成原理-03-校验码"></a>计算机组成原理-03-校验码</h2><h2 id="1-校验码概述"><a href="#1-校验码概述" class="headerlink" title="1. 校验码概述"></a>1. 校验码概述</h2><ul><li><p>校验码：指能够<code>发现</code>或能够<code>自动纠正错误</code>的数据编码，也称检错纠错编码。</p></li><li><p>实现原理：通过加一<code>冗余码</code>，来检验或纠错编码</p></li><li><p>码距：简单来说就是两个二进制数比较，在同一数位的地方，数位值不同的个数有多少个，即码距，也称海明距离；</p></li><li><p>两种方法计算码距。比如0100和1111<br><code>直接观察法</code>：可以看出，有3个数位值不同，所以码距为3.<br><code>异或计算法</code>：0100⊕1111=1011 ，结果为1011，里面有几个1就代表有多少个数位值不同，即码距是多少，这里码距是3。</p></li></ul><a id="more"></a><h2 id="2-奇偶校验码"><a href="#2-奇偶校验码" class="headerlink" title="2. 奇偶校验码"></a>2. 奇偶校验码</h2><ul><li>实现原理： 在原编码中加一个校验位，则<code>原编码就变成了校验码</code>，它的码距为2，可以检查出奇数位错误，但不能检查出偶数位错误，增加的冗余位为奇偶校验位，一般校验位设置在原编码的最左边或最右边。</li><li>奇校验码：整个校验码（信息位+校验位）中1的个数位奇数</li><li>偶校验码：整个校验码（信息位+校验位）中1的个数位偶数</li></ul><h3 id="2-1-奇校验"><a href="#2-1-奇校验" class="headerlink" title="2.1 奇校验"></a>2.1 奇校验</h3><p><strong>如何检测出错误？</strong></p><ul><li>首先在计算机中，我们<strong>就要约定好，数据是采用奇校验还是偶校验</strong>，下面分奇校验和偶校验来说明一下奇偶校验如何检查在计算机传输数据的过程中数据是否正确。</li><li>假设我们的原始编码是<code>10110111</code>，因为我们规定计算机采用<code>奇校验</code>，所以我们在原编码最左边多加了一个校验位，并置为1，那么原编码就变成了奇校验码，有奇数（7）个1。<ul><li><code>传输过程中奇数个数据改变</code>：在传输过程中有<code>奇数个数位值发生了改变</code>，那么我们通过<code>奇校验运算</code>，可以发现现在变成了6个1，和奇校验码相比有3个数位值发生了改变，奇校验码不再有奇数个1，而是变成了偶数个1，可以判断我们的数据发生了改变，可以检查出错误。</li><li><code>传输过程中有偶数个数据改变</code>：在传输过程中有<code>偶数个数位值发生了改变</code>，那么我们通过<code>奇校验运算</code>，都是奇数，这时我们便无法通过奇校验运算判断数据是否发生了改变，<code>即无法检查出偶数个错误</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-093122129.png" alt="mark"></p><h3 id="2-2-偶校验"><a href="#2-2-偶校验" class="headerlink" title="2.2 偶校验"></a>2.2 偶校验</h3><ul><li>假设我们的原始编码是<code>10110111</code>，因为我们规定计算机采用<code>偶校验</code>，所以我们在原编码最左边多加了一个校验位，并置为0，那么原编码就变成了偶校验码，有偶数（6）个1。<ul><li><code>传输过程中奇数个数据改变</code>：在传输过程中有<code>奇数个数位值发生了改变</code>，那么我们通过<code>偶校验运算</code>，可以发现现在变成了5个1，和偶校验码相比有3个数位值发生了改变，偶校验码不再有偶数个1，而是变成了奇数个1，可以判断我们的数据发生了改变，可以检查出错误。</li><li><code>传输过程中有偶数个数据改变</code>：在传输过程中有<code>偶数个数位值发生了改变</code>，那么我们通过<code>偶校验运算</code>，可以发现现在变成了6个1，和原偶校验码6个1一样，都是偶数，这时我们便无法通过偶校验运算判断数据是否发生了改变，<code>即无法检查出偶数个错误</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-093311353.png" alt="mark"></p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><ul><li>通过上述奇偶校验两种方式校验数据，<strong>可以比较得出奇偶校验可以检测出奇数个错误而无法检查出偶数个错误，也无法纠正错误，无法定位错误位置。</strong></li></ul><h2 id="3-汉明校验码"><a href="#3-汉明校验码" class="headerlink" title="3. 汉明校验码"></a>3. 汉明校验码</h2><ul><li>一种多重奇偶校验码。</li><li><strong>实现原理</strong>：在有效信息位中加入几个校验位形成海明码，并把海明码的每一个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化。</li><li>特点：可以发现错误，定位错误位置，自动纠正错误。 <code>可以检测双比特错误，但只能纠正单比特错误</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">纠错理论：L-1&#x3D;D+C且D≥C</span><br><span class="line">编码最小码距L越大，其检测错误的位数D越大，纠正错误的位数C也越大，且纠错能力恒小于检错能力</span><br></pre></td></tr></table></figure><h3 id="3-1-例题讲解"><a href="#3-1-例题讲解" class="headerlink" title="3.1 例题讲解"></a>3.1 例题讲解</h3><ul><li>信息为 n=4 , 校验位 k=3,求1010的海明码</li></ul><ol><li><strong>确定海明码的位数</strong></li></ol><ul><li>根据公式：<strong>2k ≥ n+k+1</strong>（若要检测两位错，则需再增加1位校验位，即k+1位）</li><li>海明码位数n+k=7，公式 <strong>2^3 ≥ n+k+1=8</strong>成立，n,k有效。设置变量来表示信息位、校验位、海明码。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203146422.png" alt="mark"></p><ol start="2"><li><strong>确定校验位的分布</strong></li></ol><ul><li>规定校验位 pi 在海明位号位 2^(i-1) 的位置上，所以：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203249694.png" alt="mark"></p><ol start="3"><li><strong>分组形成校验关系</strong></li></ol><ul><li>每个数据位用多个校验位来检验。</li><li>必须满足条件：<code>被校验数据位的海明码位号 = 校验该数据位的各校验位海明位号之和</code>，比如校验D3，它的海明位号H6为6，那么校验它的校验位为P3和P2，因为他们的海明位号H4和H2加起来等于6。（化为二进制的位数）</li><li>校验位不需要再被校验</li><li>分组关系如图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203511638.png" alt="mark"></p><ol start="4"><li><strong>校验位的取值</strong></li></ol><ul><li>Pi的值 = 第 i 组所有数据位求异或⨁</li><li>P1=D1⨁D2⨁D4=0</li><li>P2=D1⨁D3⨁D4=1</li><li>P3=D2⨁D3⨁D4=0</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203558634.png" alt="mark"></p><ol start="5"><li><strong>海明码的校验原理</strong></li></ol><ul><li><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，即异或运算⨁，构成k个校验方程。</p><ul><li>S1=P1⨁D1⨁D2⨁D4</li><li>S2=P2⨁D1⨁D3⨁D4</li><li>S3=P3⨁D2⨁D3⨁D4</li></ul></li><li><p>若S1S2S3=000,则说明无错，否则说明出错。</p></li><li><p>这个数的值就是出错的位置，如S1S2S3=001,表示第1位出错，即H1出错，直接将该位取反就可以达到<code>纠错</code>的目的。</p></li></ul><h2 id="4-循环冗余CRC码"><a href="#4-循环冗余CRC码" class="headerlink" title="4. 循环冗余CRC码"></a>4. 循环冗余CRC码</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203807533.png" alt="mark"></p><ul><li>基本思想：校验码中的一种。在K位信息位后拼接R位检验位，组成CRC码，这种编码也称(N,R)码</li><li>特点：可以发现错误，定位错误位置，自动纠正错误。<code>可检测出所有奇数位错，所有双比特的错和所有小于、等于校验位长度的突发错</code></li></ul><ol><li><strong>生成多项式</strong></li></ol><ul><li>首先，发送端和接受端会有一个生成多项式G(x)约定,生成多项式G(x)的最高次幂为<code>R</code>。任意一个二进制数码都可用一个系数为0或1的多项式与之对应。比如：二进制数码 1101 对应的G(x)=1<em>X^3+1</em>X^2+0<em>X^1+1</em>X^0= X^3+X^2+1</li><li>在发送端，将要传送的K位二进制信息码左移R位，将它与生成多项式G(x)所对应的的二进制数码进行<code>模2除法</code>，产生余数，生成一个R位检验码，并附在信息码后，构成一个新的二进制码（CRC）码，共K+R位。</li></ul><h3 id="4-1-例题讲解"><a href="#4-1-例题讲解" class="headerlink" title="4.1 例题讲解"></a>4.1 例题讲解</h3><ul><li>例题： 设生成多项式G(x)=X^3+X^2+1 ,信息码为 101001 ，求对应的CRC码 。</li></ul><p><strong>分析</strong></p><ul><li>分析：校验位长度：R=3 , 信息码长度：K=6 , CRC码长度：N=R+K= 9</li><li>生成多项式对应二进制码：1101</li></ul><ol><li><strong>信息码左移R位</strong></li></ol><ul><li>发送端将原信息码左移R位，低位补0：101001 000</li></ul><ol start="2"><li><strong>模2除得到余数</strong></li></ol><ul><li>方法：发送端用移位后的信息码 101001000 除以G(x)所对应的二进制数码 1101 求余数，余数除得够就写1，不够就写0，直到余数小于 1101 ，余数即为校验位的数值。</li><li>图中即为具体计算步骤，得到最后的结果CRC码为：101001 001，然后发送端将CRC码101001 001发送给接收端。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-204223140.png" alt="mark"></p><ol start="3"><li><strong>如何检错和纠错？</strong></li></ol><ul><li><p>接收端收到CRC码后，用生成的CRC码除以生成多项式G(x)所对应的的二进制数码，<strong>若余数为0，则信息码在传输过程中没有产生错误，数据正确。</strong></p></li><li><p>若接受到的CRC码为<code>C9C8C7C6C5C4C3C2C1= 101001011</code>,除以G(x)所对应的二进制码1101得到余数为010，不为0，说明数据在传输过程中产生错误。<code>010=2（10）</code>说明C2出错，将C2取反即可纠正错误。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-03-校验码&quot;&gt;&lt;a href=&quot;#计算机组成原理-03-校验码&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-03-校验码&quot;&gt;&lt;/a&gt;计算机组成原理-03-校验码&lt;/h2&gt;&lt;h2 id=&quot;1-校验码概述&quot;&gt;&lt;a href=&quot;#1-校验码概述&quot; class=&quot;headerlink&quot; title=&quot;1. 校验码概述&quot;&gt;&lt;/a&gt;1. 校验码概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;校验码：指能够&lt;code&gt;发现&lt;/code&gt;或能够&lt;code&gt;自动纠正错误&lt;/code&gt;的数据编码，也称检错纠错编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现原理：通过加一&lt;code&gt;冗余码&lt;/code&gt;，来检验或纠错编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;码距：简单来说就是两个二进制数比较，在同一数位的地方，数位值不同的个数有多少个，即码距，也称海明距离；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两种方法计算码距。比如0100和1111&lt;br&gt;&lt;code&gt;直接观察法&lt;/code&gt;：可以看出，有3个数位值不同，所以码距为3.&lt;br&gt;&lt;code&gt;异或计算法&lt;/code&gt;：0100⊕1111=1011 ，结果为1011，里面有几个1就代表有多少个数位值不同，即码距是多少，这里码距是3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-02-进制与编码</title>
    <link href="http://zhuuu.work/2021/03/25/Compute_Organization/%E8%AE%A1%E7%BB%84-02-%E8%BF%9B%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <id>http://zhuuu.work/2021/03/25/Compute_Organization/%E8%AE%A1%E7%BB%84-02-%E8%BF%9B%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/</id>
    <published>2021-03-25T03:02:24.000Z</published>
    <updated>2021-03-26T01:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-02-数据的表示和运算"><a href="#计算机组成原理-02-数据的表示和运算" class="headerlink" title="计算机组成原理-02-数据的表示和运算"></a>计算机组成原理-02-数据的表示和运算</h2><h2 id="1-进制概述"><a href="#1-进制概述" class="headerlink" title="1. 进制概述"></a>1. 进制概述</h2><ol><li><strong>使用二进制的原因</strong><ul><li>二进制只有两种状态，物理电路的高电平和低电平可以很好的表示0和1</li><li>二进制的0和1正好可以分别代表 true 和 false</li><li>二进制的运算规则特别适合逻辑门电路的计算</li></ul></li></ol><a id="more"></a><ul><li><strong>10进制</strong></li></ul><blockquote><p>先说 我们最 熟悉的 10进制 , 就是 用 0~9 的数表示 , 逢 10 进 1 .</p></blockquote><ul><li><strong>16进制</strong></li></ul><blockquote><p>如果是 16 进制 , 它就是 由 0-9，A-F组成， 与10进制的对应关系是：0-9 对应 0-9；A-F对应10-15；<br>字母不区分大小写。</p></blockquote><ul><li><strong>2进制 和 8进制</strong></li></ul><blockquote><p>2进制 由 0-1组成</p><p>8进制 由 0-7组成</p></blockquote><p><strong>再看几个特别的例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 写出各个进制1-20</span><br><span class="line"></span><br><span class="line"># 一进制 </span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"># 三进制</span><br><span class="line">0 1 2</span><br><span class="line">101112</span><br><span class="line">202122</span><br><span class="line">100101102</span><br><span class="line">110111112</span><br><span class="line">120121122</span><br><span class="line">1000 .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 七进制</span><br><span class="line">0123456</span><br><span class="line">10111213141516</span><br><span class="line">20212223242526</span><br><span class="line">30313233343536</span><br><span class="line"></span><br><span class="line"># 十进制(自己定义)</span><br><span class="line">0 1 2 3 4 5 6 7 8 9        10  11 12</span><br><span class="line">0 2 4 6 8 9 a c d f    20  22 24</span><br></pre></td></tr></table></figure><ul><li><strong>八进制</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 八进制计算下面结果</span><br><span class="line"></span><br><span class="line">2 + 3 &#x3D; 5</span><br><span class="line">2 * 3 &#x3D; 6</span><br><span class="line">4 + 5 &#x3D; 11</span><br><span class="line">4 * 5 &#x3D; 24</span><br><span class="line"></span><br><span class="line"># 运算的本质就是查数</span><br><span class="line">0 1 2 3 4 5 6 7 </span><br><span class="line">10 11 12 13 14 15 16 17</span><br><span class="line">20 21 22 23 24 25 26 27</span><br><span class="line"></span><br><span class="line">八进制计算  (进位和计算)</span><br><span class="line">277 + 333 &#x3D; </span><br><span class="line">276 * 54 &#x3D; </span><br><span class="line">237 - 54 &#x3D; </span><br><span class="line">234 &#x2F; 4 &#x3D;</span><br></pre></td></tr></table></figure><ul><li><strong>各种进制的乘法表</strong>：<a href="https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**八进制乘法表**</span><br></pre></td></tr></table></figure><table><thead><tr><th>1*1 = 1</th><th>1*2 = 2</th><th>1*3 = 3</th><th>1*4 =4</th><th>1*5 =5</th><th>1*6 = 6</th><th>1*7 = 7</th></tr></thead><tbody><tr><td>2*2 = 2</td><td>2*3 = 6</td><td>2*4 = 10</td><td>2*5 = 12</td><td>2*6 = 14</td><td>2*7 = 16</td><td></td></tr><tr><td>3*3 = 11</td><td>3*4 = 14</td><td>3*5 = 17</td><td>3* 6 = 22</td><td>3*7 = 25</td><td></td><td></td></tr><tr><td>4*4 = 20</td><td>4 * 5= 24</td><td>4*6 = 30</td><td>4*7 = 34</td><td></td><td></td><td></td></tr><tr><td>5*5 = 31</td><td>5*6 = 36</td><td>5*7 = 43</td><td></td><td></td><td></td><td></td></tr><tr><td>6*6 = 44</td><td>6*7 = 52</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7*7 = 61</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h2><ul><li>所谓进位计数法是一种计数方法，咱们最常用的莫过于十进制了，除此之外还有八进制、十六进制等。</li><li>这里不得不提几个概念术语：<ul><li>基数：比如说十进制、八进制和十六进制，它们的基数分别为10（0<del>9）、8（0</del>7）、16（0~15）</li><li>数位：比如二进制数1010，这里就有4个数位，从高位到低位依次的数码值为1、0、1、1</li><li>数码：比如八进制，那么数码，即数码值的范围为（0~7）</li><li>基数和数码的关系：每个数位所用到的不同数码的个数称为基</li><li>位权：每个数码所表示的数值等于该数码值乘以一个与它所在位有关的常数，这个常数称为位权。</li></ul></li></ul><ol start="2"><li><strong>二进制转换为八进制和十六进制</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-085929193.png" alt="mark"></p><ol start="3"><li><strong>十进制转换成二进制</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090058906.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li><strong>不是每一个十进制小数都可以准确的用二进制表示<code>，比如：0.3转换为二进制数，无论经过多少次</code>乘二取整<code>都</code>无法获得精确<code>的结果。</code>但任意一个二进制小数都可以用十进制小数表示！！！</strong></li></ul><h2 id="3-真值，机器数"><a href="#3-真值，机器数" class="headerlink" title="3. 真值，机器数"></a>3. 真值，机器数</h2><ul><li><strong>真值</strong>：我们日常见到的，有<code>“+”、“-”</code>号的数为真值，比如：+5，-7。真值是机器数所代表的实际值，一般为十进制数。</li><li><strong>机器数</strong>：将<code>“符号-&gt;数字化”</code>的数。一般为二进制数，比如带符号位的4位二进制数<strong>0</strong>110，最高位<code>0</code>就是符号位，这个数的<code>真值就是+6</code>。通常<code>0</code>代表“+”号，<code>1</code>代表<code>-</code>号。</li></ul><h2 id="4-BCD-码"><a href="#4-BCD-码" class="headerlink" title="4. BCD 码"></a>4. BCD 码</h2><ul><li><p>简单来说：就是用<strong>4位二进制数来表示1位十进制数（0—9）</strong>，是一种用二进制编码来代替十进制编码的方式。</p></li><li><p>BCD码可分为两类：<code>有权码和无权码</code></p></li><li><p>这种编码方法使得二进制数和十进制数之间的转换十分的快速，但4位二进制数字可以转换出16中代码的组合，因此会有6种冗余的状态。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090452539.png" alt="mark"></p><h3 id="4-1-8421码"><a href="#4-1-8421码" class="headerlink" title="4.1 8421码"></a>4.1 8421码</h3><ul><li><strong>其中最常用的BCD码就是8421码</strong></li><li>当两个8421码进行计算时，如果结果<code>小于等于9</code>，则不作任何操作</li><li>如果计算结果<code>大于9</code>则需要进行+6的修正操作（10-18（9+9）需要进行修正，1010-10010范围）需要进行修正操作，并向高位进位</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090727440.png" alt="mark"></p><h2 id="5-ASCII-码"><a href="#5-ASCII-码" class="headerlink" title="5. ASCII 码"></a>5. ASCII 码</h2><p>ASCII码大致由三部分组成： </p><ol><li><strong>ASCII 打印字符：</strong>数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。注：十进制32代表空格 ，十进制数字 127 代表 DELETE 命令。下面是ASCII码和相应数字的对照表</li></ol><table><thead><tr><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td></td><td></td><td></td></tr><tr><td>032</td><td>20</td><td></td><td></td><td>056</td><td>38</td><td>8</td><td></td><td>080</td><td>50</td><td>P</td><td></td><td>104</td><td>68</td><td>h</td></tr><tr><td>033</td><td>21</td><td>!</td><td></td><td>057</td><td>39</td><td>9</td><td></td><td>081</td><td>51</td><td>Q</td><td></td><td>105</td><td>69</td><td>i</td></tr><tr><td>034</td><td>22</td><td>“</td><td></td><td>058</td><td>3A</td><td>:</td><td></td><td>082</td><td>52</td><td>R</td><td></td><td>106</td><td>6A</td><td>j</td></tr><tr><td>035</td><td>23</td><td>#</td><td></td><td>059</td><td>3B</td><td>;</td><td></td><td>083</td><td>53</td><td>S</td><td></td><td>107</td><td>6B</td><td>k</td></tr><tr><td>036</td><td>24</td><td>$</td><td></td><td>060</td><td>3C</td><td>&lt;</td><td></td><td>084</td><td>54</td><td>T</td><td></td><td>108</td><td>6C</td><td>l</td></tr><tr><td>037</td><td>25</td><td>%</td><td></td><td>061</td><td>3D</td><td>=</td><td></td><td>085</td><td>55</td><td>U</td><td></td><td>109</td><td>6D</td><td>m</td></tr><tr><td>038</td><td>26</td><td>&amp;</td><td></td><td>062</td><td>3E</td><td>&gt;</td><td></td><td>086</td><td>56</td><td>V</td><td></td><td>110</td><td>6E</td><td>n</td></tr><tr><td>039</td><td>27</td><td>‘</td><td></td><td>063</td><td>3F</td><td>?</td><td></td><td>087</td><td>57</td><td>W</td><td></td><td>111</td><td>6F</td><td>o</td></tr><tr><td>040</td><td>28</td><td>(</td><td></td><td>064</td><td>40</td><td>@</td><td></td><td>088</td><td>58</td><td>X</td><td></td><td>112</td><td>70</td><td>p</td></tr><tr><td>041</td><td>29</td><td>)</td><td></td><td>065</td><td>41</td><td>A</td><td></td><td>089</td><td>59</td><td>Y</td><td></td><td>113</td><td>71</td><td>q</td></tr><tr><td>042</td><td>2A</td><td>*</td><td></td><td>066</td><td>42</td><td>B</td><td></td><td>090</td><td>5A</td><td>Z</td><td></td><td>114</td><td>72</td><td>r</td></tr><tr><td>043</td><td>2B</td><td>+</td><td></td><td>067</td><td>43</td><td>C</td><td></td><td>091</td><td>5B</td><td>[</td><td></td><td>115</td><td>73</td><td>s</td></tr><tr><td>044</td><td>2C</td><td>,</td><td></td><td>068</td><td>44</td><td>D</td><td></td><td>092</td><td>5C</td><td>\</td><td></td><td>116</td><td>74</td><td>t</td></tr><tr><td>045</td><td>2D</td><td>-</td><td></td><td>069</td><td>45</td><td>E</td><td></td><td>093</td><td>5D</td><td>]</td><td></td><td>117</td><td>75</td><td>u</td></tr><tr><td>046</td><td>2E</td><td>.</td><td></td><td>070</td><td>46</td><td>F</td><td></td><td>094</td><td>5E</td><td>^</td><td></td><td>118</td><td>76</td><td>v</td></tr><tr><td>047</td><td>2F</td><td>/</td><td></td><td>071</td><td>47</td><td>G</td><td></td><td>095</td><td>5F</td><td>_</td><td></td><td>119</td><td>77</td><td>w</td></tr><tr><td>048</td><td>30</td><td>0</td><td></td><td>072</td><td>48</td><td>H</td><td></td><td>096</td><td>60</td><td>`</td><td></td><td>120</td><td>78</td><td>x</td></tr><tr><td>049</td><td>31</td><td>1</td><td></td><td>073</td><td>49</td><td>I</td><td></td><td>097</td><td>61</td><td>a</td><td></td><td>121</td><td>79</td><td>y</td></tr><tr><td>050</td><td>32</td><td>2</td><td></td><td>074</td><td>4A</td><td>J</td><td></td><td>098</td><td>62</td><td>b</td><td></td><td>122</td><td>7A</td><td>z</td></tr><tr><td>051</td><td>33</td><td>3</td><td></td><td>075</td><td>4B</td><td>K</td><td></td><td>099</td><td>63</td><td>c</td><td></td><td>123</td><td>7B</td><td>{</td></tr><tr><td>052</td><td>34</td><td>4</td><td></td><td>076</td><td>4C</td><td>L</td><td></td><td>100</td><td>64</td><td>d</td><td></td><td>124</td><td>7C</td><td>|</td></tr><tr><td>053</td><td>35</td><td>5</td><td></td><td>077</td><td>4D</td><td>M</td><td></td><td>101</td><td>65</td><td>e</td><td></td><td>125</td><td>7D</td><td>}</td></tr><tr><td>054</td><td>36</td><td>6</td><td></td><td>078</td><td>4E</td><td>N</td><td></td><td>102</td><td>66</td><td>f</td><td></td><td>126</td><td>7E</td><td>~</td></tr><tr><td>055</td><td>37</td><td>7</td><td></td><td>079</td><td>4F</td><td>O</td><td></td><td>103</td><td>67</td><td>g</td><td></td><td>127</td><td>7F</td><td>DEL</td></tr></tbody></table><ol start="2"><li><strong>ASCII 非打印控制字符：</strong>ASCII 表上的数字 0–31 分配给了控制字符，用于控制像打印机等一些外围设备。例如，12 代表换页/新页功能。此命令指示打印机跳到下一页的开头。</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-091133175.png" alt="mark"></p><ol start="3"><li><strong>扩展 ASCII 打印字符：</strong>扩展的 ASCII 字符满足了对更多字符的需求。扩展的 ASCII 包含 ASCII 中已有的 128 个字符（数字 0–32 显示在下图中），又增加了 128 个字符，总共是 256 个。即使有了这些更多的字符，许多语言还是包含无法压缩到 256 个字符中的符号。因此，出现了一些 ASCII 的变体来囊括地区性字符和符号.</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-091206473.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li>0-9的ASCII码值位48（0110000）-57（0111001）</li><li>即去掉高3位，只保留四位的话，正好是二进制的0-9</li><li>大写字母和小写字母转换成二进制也是同样的道理</li></ul><h2 id="6-汉字编码"><a href="#6-汉字编码" class="headerlink" title="6. 汉字编码"></a>6. 汉字编码</h2><ul><li><code>分类</code>：计算机中汉字的表示也是用二进制编码，同样是人为编码的。根据应用目的的不同，汉字编码分为外码、交换码、机内码和字形码。</li></ul><ol><li>外码（输入码）</li></ol><ul><li>外码也叫输入码，是用来将汉字输入到计算机中的一组键盘符号。常用的输入码有拼音码、五笔字型码、自然码、表形码、认知码、区位码和电报码等</li></ul><ol start="2"><li>交换码(国标码)</li></ol><ul><li>计算机内部处理的信息，都是用二进制代码表示的，汉字也不例外。</li><li>而二进制代码使用起来是不方便的，于是需要采用信息交换码。中国标准总局1981年制定了中华人民共和国国家标准GB2312–80《信息交换用汉字编码字符集–基本集》<strong>，即国标码。</strong></li><li>区位码是国标码的另一种表现形式，把国标GB2312–80中的汉字、图形符号组成一个<strong>94×94的方阵，分为94个“区”</strong>，每区包含94个“位”，其中“区”的序号由01至94，“位”的序号也是从01至94。</li><li>94个区中位置总数=94×94=8836个，其中7445个汉字和图形字符中的每一个占一个位置后，还剩下1391个空位，这1391个位置空下来保留备用。</li></ul><ol start="3"><li>机内码</li></ol><ul><li>根据国标码的规定，每一个汉字都有了确定的二进制代码，在微机内部汉字代码都用机内码<strong>，在磁盘上记录汉字代码也使用机内码。</strong></li></ul><ol start="4"><li>字形码</li></ol><ul><li>字形码是汉字的输出码，输出汉字时都采用图形方式，无论汉字的笔画多少，每个汉字都可以写在同样大小的方块中。通常用16×16点阵来显示汉字。</li><li>其实也就是0101的网格 （类似于Banner）</li></ul><p><strong>转换关系</strong></p><ul><li>国际码 = （区位码）+ 2020H<ul><li>20H = 32 ：为了传输的时候避开前32个控制字符</li></ul></li><li>汉字内码 = （国际码）+ 8080H<ul><li>80H = 128: 为了与英文的ASCII码兼容</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-02-数据的表示和运算&quot;&gt;&lt;a href=&quot;#计算机组成原理-02-数据的表示和运算&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-02-数据的表示和运算&quot;&gt;&lt;/a&gt;计算机组成原理-02-数据的表示和运算&lt;/h2&gt;&lt;h2 id=&quot;1-进制概述&quot;&gt;&lt;a href=&quot;#1-进制概述&quot; class=&quot;headerlink&quot; title=&quot;1. 进制概述&quot;&gt;&lt;/a&gt;1. 进制概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用二进制的原因&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;二进制只有两种状态，物理电路的高电平和低电平可以很好的表示0和1&lt;/li&gt;
&lt;li&gt;二进制的0和1正好可以分别代表 true 和 false&lt;/li&gt;
&lt;li&gt;二进制的运算规则特别适合逻辑门电路的计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--083-删除排序链表中的重复元素I</title>
    <link href="http://zhuuu.work/2021/03/25/Leetcode/Leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0I/"/>
    <id>http://zhuuu.work/2021/03/25/Leetcode/Leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0I/</id>
    <published>2021-03-25T03:02:24.000Z</published>
    <updated>2021-03-27T02:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–083-删除排序链表中的重复元素"><a href="#Leetcode–083-删除排序链表中的重复元素" class="headerlink" title="Leetcode–083-删除排序链表中的重复元素"></a>Leetcode–083-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</li><li>返回同样按升序排列的结果链表。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095204452.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095226721.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><a id="more"></a><h2 id="算法与思路"><a href="#算法与思路" class="headerlink" title="算法与思路"></a>算法与思路</h2><ul><li>由于给定的链表是排好序的，因此<strong>重复的元素在链表中出现的位置是连续的</strong>，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</li><li>具体地，从指针cur 指向链表的头节点，随后开始对链表进行遍历<ul><li>如果当前的<em>cur</em> 与 <code>cur.next</code>对应元素相同，那么我们就将<code>cur.next</code> 从链表中移除；</li><li>否则说明链表中已经不存在其它与<code>cur</code>对应元素相同的节点，因此可以将<code>cur</code> 指向 <code>cur.next</code></li></ul></li><li>当遍历完整个链表之后，返回链表的头节点即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 处理逻辑</span></span><br><span class="line">        ListNode cur = head;                    <span class="comment">// cur 指向头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;                <span class="comment">// 遍历一次链表</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val)&#123;        <span class="comment">// 如果相邻的链表节点是重复的</span></span><br><span class="line">                cur.next = cur.next.next;       <span class="comment">// 跳过这个节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                          </span><br><span class="line">                cur = cur.next;                 <span class="comment">// 否则cur向前移动一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) 遍历一次链表所花费的时间</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–083-删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#Leetcode–083-删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–083-删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;Leetcode–083-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除排序链表中的重复元素&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存在一个按升序排列的链表，给你这个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你删除所有重复的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;返回同样按升序排列的结果链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095204452.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095226721.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,2,3,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中节点数目在范围 &lt;code&gt;[0, 300]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证链表已经按升序排列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-05-AMQP协议</title>
    <link href="http://zhuuu.work/2021/03/24/RabbitMQ/RabbitMQ-05-AMQP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2021/03/24/RabbitMQ/RabbitMQ-05-AMQP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-24T07:02:24.000Z</published>
    <updated>2021-03-24T08:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-05-AMQP协议"><a href="#RabbitMQ-05-AMQP协议" class="headerlink" title="RabbitMQ-05-AMQP协议"></a>RabbitMQ-05-AMQP协议</h2><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h2><ul><li>AMQP全称：<code>Advanced Message Queuing Protocol</code>(高级消息队列协议)。</li><li><strong>是应用层协议的一个开发标准，为面向消息的中间件设计。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-162118081.png" alt="mark"></p><ul><li><strong>工作过程：</strong><ul><li>发布者（Publisher）发布消息（Message），经由交换机（Exchange）。</li><li>交换机根据<strong>路由规则</strong>将收到的消息分发给与该交换机绑定的队列（Queue）。</li><li>最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</li></ul></li></ul><a id="more"></a><h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><ul><li>发布者、交换机、队列、消费者都可以有多个。同时因为 AMQP 是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以分别存在于不同的设备上。</li><li>发布者发布消息时可以给消息指定各种消息属性（Message Meta-data）。有些属性有可能会被消息代理（Brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。</li><li>从安全角度考虑，网络是不可靠的，又或是消费者在处理消息的过程中意外挂掉，这样没有处理成功的消息就会丢失。基于此原因，AMQP 模块包含了一个消息确认（Message Acknowledgements）机制：当一个消息从队列中投递给消费者后，不会立即从队列中删除，直到它收到来自消费者的确认回执（Acknowledgement）后，才完全从队列中删除。</li><li>在某些情况下，例如当一个消息无法被成功路由时（无法从交换机分发到队列），消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。</li></ul><h2 id="3-AMQP-生产者流转过程"><a href="#3-AMQP-生产者流转过程" class="headerlink" title="3. AMQP 生产者流转过程"></a>3. AMQP 生产者流转过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-163035448.png" alt="mark"></p><ul><li>当客户端与<code>Broker</code>建立链接的时候，会调用<code>factory.newConnection()</code> 方法，这个方法会进一步封装成<code>Protocol Header 0-9-1</code>的报文头发送给<code>Broker</code>，以此通知<code>Broker</code>本次交互采用的是<code>AMQP 0-9-1</code>协议，紧接着<code>Broker</code>返回<code>Connection.Start</code> 来建立链接，在链接的过程中涉及的交互命令如图上过程1所示</li><li>当客户端调用<code>Connection.createChannel()</code>时候准备开启信道，其中包含的<code>Channel.Open</code> 发送给<code>Broker</code>，等待确认<code>Channel.Open-ok</code> </li><li>当客户端发送消息的时候，需要调用<code>Basic.Publish</code> ，注意这个命令和前面设计的命令有所不同，这个命令还包含了<code>Content Header</code> 和 <code>Content Body</code>, <code>Content Header</code>里面包含的是消息体的属性，例如投递模式和优先级等等，而<code>Content Body</code>包含了消息体的本身</li><li>当客户端断开资源的时候，如图过程4所示。</li></ul><h2 id="4-AMQP-消费者流转过程"><a href="#4-AMQP-消费者流转过程" class="headerlink" title="4. AMQP 消费者流转过程"></a>4. AMQP 消费者流转过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-163757877.png" alt="mark"></p><ul><li>当客户端与<code>Broker</code>建立链接的时候，会调用<code>factory.newConnection()</code> 方法，这个方法会进一步封装成<code>Protocol Header 0-9-1</code>的报文头发送给<code>Broker</code>，以此通知<code>Broker</code>本次交互采用的是<code>AMQP 0-9-1</code>协议，紧接着<code>Broker</code>返回<code>Connection.Start</code> 来建立链接，在链接的过程中涉及的交互命令如图上过程1所示</li><li>当客户端调用<code>Connection.createChannel()</code>时候准备开启信道，其中包含的<code>Channel.Open</code> 发送给<code>Broker</code>，等待确认<code>Channel.Open-ok</code> </li><li><strong>上面都和生产者一样</strong></li><li>在真正消费之前，消费者客户端需要向<code>Broker</code>发送<code>Basic.Consume</code>命令（channel.BasicConsume 方法）将Channel 设置为接收的模式，之后<code>Broker</code>向消费者客户端推送消息（即<code>Basic.Deliver</code> 命令），有意思的是这个<code>Basic.Deliver</code> 命令一样会携带<code>Content Header</code> 和 <code>Content Body</code></li><li>消费者接收到消息并且真正确实消费之后，向<code>Broker</code> 发送确认，即<code>Basic.Ack</code>命令</li><li>在消费者停止消费之后，主动关闭链接，这点和生产者一样</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-05-AMQP协议&quot;&gt;&lt;a href=&quot;#RabbitMQ-05-AMQP协议&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-05-AMQP协议&quot;&gt;&lt;/a&gt;RabbitMQ-05-AMQP协议&lt;/h2&gt;&lt;h2 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1. 概要&quot;&gt;&lt;/a&gt;1. 概要&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;AMQP全称：&lt;code&gt;Advanced Message Queuing Protocol&lt;/code&gt;(高级消息队列协议)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是应用层协议的一个开发标准，为面向消息的中间件设计。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-162118081.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作过程：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;发布者（Publisher）发布消息（Message），经由交换机（Exchange）。&lt;/li&gt;
&lt;li&gt;交换机根据&lt;strong&gt;路由规则&lt;/strong&gt;将收到的消息分发给与该交换机绑定的队列（Queue）。&lt;/li&gt;
&lt;li&gt;最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-04-Simple模式</title>
    <link href="http://zhuuu.work/2021/03/24/RabbitMQ/RabbitMQ-04-Simple%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2021/03/24/RabbitMQ/RabbitMQ-04-Simple%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-24T06:02:24.000Z</published>
    <updated>2021-03-24T07:57:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-04-Simple模式"><a href="#RabbitMQ-04-Simple模式" class="headerlink" title="RabbitMQ-04-Simple模式"></a>RabbitMQ-04-Simple模式</h2><h2 id="1-rabbitMQ角色分类"><a href="#1-rabbitMQ角色分类" class="headerlink" title="1. rabbitMQ角色分类"></a>1. rabbitMQ角色分类</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-103601463.png" alt="mark"></p><ol><li><strong>none</strong></li></ol><ul><li>不能访问<code>management plugin</code></li></ul><ol start="2"><li><strong>management : 查看自己的相关节点信息</strong></li></ol><ul><li>列出自己可以通过AMQP登入的虚拟机</li><li>查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息</li><li>查看和关闭自己的channels和connections</li><li>查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。</li></ul><ol start="3"><li><strong>Policymaker</strong></li></ol><ul><li>包含management所有权限</li><li>查看和创建和删除自己的virtual hosts所属的policies和parameters信息。</li></ul><a id="more"></a><ol start="4"><li><strong>Monitoring</strong></li></ol><ul><li>包含management所有权限</li><li>罗列出所有的virtual hosts，包括不能登录的virtual hosts。</li><li>查看其他用户的connections和channels信息</li><li>查看节点级别的数据如clustering和memory使用情况</li><li>查看所有的virtual hosts的全局统计信息。</li></ul><ol start="5"><li><strong>Administrator</strong></li></ol><ul><li>最高权限</li><li>可以创建和删除virtual hosts</li><li>可以查看，创建和删除users</li><li>查看创建permisssions</li><li>关闭所有用户的connections</li></ul><h2 id="2-工作模式预览"><a href="#2-工作模式预览" class="headerlink" title="2. 工作模式预览"></a>2. 工作模式预览</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113120197.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113216449.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113232003.png" alt="mark"></p><h2 id="3-Simple-简单模式"><a href="#3-Simple-简单模式" class="headerlink" title="3. Simple 简单模式"></a>3. Simple 简单模式</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>1：jdk1.8<br>2：构建一个maven工程<br>3：导入rabbitmq的maven依赖<br>4：启动rabbitmq-server服务<br>5：定义生产者<br>6：定义消费者<br>7：观察消息的在rabbitmq-server服务中的过程</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-111925099.png" alt="mark"></p><ul><li><strong>导入maven依赖</strong></li></ul><ol><li><strong>Java原生依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Spring依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>SpringBoot 依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>番外：</strong>rabbitmq和spring同属一个公司开放的产品，所以他们的支持也是非常完善，这也是为什么推荐使用rabbitmq的一个原因。</li><li>上面根据自己的项目环境进行选择即可。</li></ul><h3 id="2-2-生产者-Provider"><a href="#2-2-生产者-Provider" class="headerlink" title="2.2 生产者 (Provider)"></a>2.2 生产者 (Provider)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line">            String queuename = <span class="string">"queue1"</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.queueDeclare(queuename, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, queuename, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行完毕后，这个时候可以在web控制台查看到这个队列queue的信息</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151035330.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151110538.png" alt="mark"></p><ul><li><strong>我们可以进行对队列的消息进行预览和测试如下：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151211114.png" alt="mark"></p><ul><li>进行预览和获取消息进行测试</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151235934.png" alt="mark"></p><h3 id="2-3-消费者（Consumer）"><a href="#2-3-消费者（Consumer）" class="headerlink" title="2.3 消费者（Consumer）"></a>2.3 消费者（Consumer）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.接收消息并且处理异常</span></span><br><span class="line">            channel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息是"</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收消息失败！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>持久化的消息是会进行存盘的，随着服务重启还在</strong></li><li><strong>非持久化的消息也会进行存盘，但是重启就没有了</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-04-Simple模式&quot;&gt;&lt;a href=&quot;#RabbitMQ-04-Simple模式&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-04-Simple模式&quot;&gt;&lt;/a&gt;RabbitMQ-04-Simple模式&lt;/h2&gt;&lt;h2 id=&quot;1-rabbitMQ角色分类&quot;&gt;&lt;a href=&quot;#1-rabbitMQ角色分类&quot; class=&quot;headerlink&quot; title=&quot;1. rabbitMQ角色分类&quot;&gt;&lt;/a&gt;1. rabbitMQ角色分类&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-103601463.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;none&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;不能访问&lt;code&gt;management plugin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;management : 查看自己的相关节点信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;列出自己可以通过AMQP登入的虚拟机&lt;/li&gt;
&lt;li&gt;查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息&lt;/li&gt;
&lt;li&gt;查看和关闭自己的channels和connections&lt;/li&gt;
&lt;li&gt;查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;strong&gt;Policymaker&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;包含management所有权限&lt;/li&gt;
&lt;li&gt;查看和创建和删除自己的virtual hosts所属的policies和parameters信息。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-03-安装与入门</title>
    <link href="http://zhuuu.work/2021/03/18/RabbitMQ/RabbitMQ-03-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/"/>
    <id>http://zhuuu.work/2021/03/18/RabbitMQ/RabbitMQ-03-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-18T06:02:24.000Z</published>
    <updated>2021-03-24T02:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-03-安装与入门"><a href="#RabbitMQ-03-安装与入门" class="headerlink" title="RabbitMQ-03-安装与入门"></a>RabbitMQ-03-安装与入门</h2><p><strong>简单概述：</strong></p><ul><li><p>RabbitMQ是一个开源的<strong>遵循AMQP协议实现的基于Erlang语言编写</strong>，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。</p></li><li><p>官网：<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">https://www.rabbitmq.com/</a></p></li><li><p>下载地址 ： <a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a></p></li><li><p><strong>环境准备：CentOS7.x+ / Erlang</strong></p><ul><li>RabbitMQ是采用Erlang语言开发的，所以系统环境必须提供Erlang环境，第一步就是安装Erlang。</li></ul></li></ul><a id="more"></a><h2 id="1-普通方式安装"><a href="#1-普通方式安装" class="headerlink" title="1. 普通方式安装"></a>1. 普通方式安装</h2><h3 id="1-1-Erlang-安装"><a href="#1-1-Erlang-安装" class="headerlink" title="1.1 Erlang 安装"></a>1.1 Erlang 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参考地址：https://www.erlang-solutions.com/downloads/</span><br><span class="line"></span><br><span class="line">1. 安装下载</span><br><span class="line">wget https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm</span><br><span class="line">rpm -Uvh erlang-solutions-2.0-1.noarch.rpm</span><br><span class="line">2. 安装成功</span><br><span class="line">yum install -y erlang</span><br><span class="line">3. erl -v</span><br><span class="line">4. 安装socat</span><br><span class="line">yum install -y socat</span><br><span class="line">5. 安装rabbitmq</span><br></pre></td></tr></table></figure><h3 id="2-rabbitMQ-下载"><a href="#2-rabbitMQ-下载" class="headerlink" title="2. rabbitMQ 下载"></a>2. rabbitMQ 下载</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-154059327.png" alt="mark"></p><ol><li>下载<code>rabbitmq</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;releases&#x2F;download&#x2F;v3.8.13&#x2F;rabbitmq-server-3.8.13-1.el8.noarch.rpm</span><br><span class="line">&gt; rpm -Uvh rabbitmq-server-3.8.13-1.el8.noarch.rpm</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动服务</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动服务</span><br><span class="line">&gt; systemctl start rabbitmq-server</span><br><span class="line"># 查看服务状态</span><br><span class="line">&gt; systemctl status rabbitmq-server</span><br><span class="line"># 停止服务</span><br><span class="line">&gt; systemctl stop rabbitmq-server</span><br><span class="line"># 开机启动服务</span><br><span class="line">&gt; systemctl enable rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>rabbitMQ的配置</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RabbitMQ默认情况下有一个配置文件，定义了RabbitMQ的相关配置信息，默认情况下能够满足日常的开发需求。如果需要修改需要，需要自己创建一个配置文件进行覆盖。</span><br><span class="line">参考官网：</span><br><span class="line">1:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;documentation.html</span><br><span class="line">2:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;configure.html</span><br><span class="line">3:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;configure.html#config-items</span><br><span class="line">4：https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;blob&#x2F;add-debug-messages-to-quorum_queue_SUITE&#x2F;docs&#x2F;rabbitmq.conf.example</span><br></pre></td></tr></table></figure><h3 id="3-rabbitMQ-端口"><a href="#3-rabbitMQ-端口" class="headerlink" title="3. rabbitMQ 端口"></a>3. rabbitMQ 端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5672:RabbitMQ的通讯端口</span><br><span class="line">25672:RabbitMQ的节点间的CLI通讯端口是</span><br><span class="line">15672:RabbitMQ HTTP_API的端口，管理员用户才能访问，用于管理RabbitMQ,需要启动Management插件。</span><br><span class="line">1883，8883：MQTT插件启动时的端口。</span><br><span class="line">61613、61614：STOMP客户端插件启用的时候的端口。</span><br><span class="line">15674、15675：基于webscoket的STOMP端口和MOTT端口</span><br></pre></td></tr></table></figure><h3 id="4-可视化管理节面"><a href="#4-可视化管理节面" class="headerlink" title="4. 可视化管理节面"></a>4. 可视化管理节面</h3><ol><li>默认情况下，rabbitmq是没有安装web端的客户端插件，需要安装才可以生效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><ol start="2"><li>安装完毕以后，重启服务即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="3"><li>在浏览器访问</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-154907967.png" alt="mark"></p><h3 id="5-授权账号和登录级别"><a href="#5-授权账号和登录级别" class="headerlink" title="5. 授权账号和登录级别"></a>5. 授权账号和登录级别</h3><ol><li><strong>新增用户</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>分配权限操作</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>对应级别</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户级别：</span><br><span class="line"></span><br><span class="line">1、administrator 可以登录控制台、查看所有信息、可以对rabbitmq进行管理</span><br><span class="line">2、monitoring 监控者 登录控制台，查看所有信息</span><br><span class="line">3、policymaker 策略制定者 登录控制台,指定策略</span><br><span class="line">4、managment 普通管理员 登录控制台</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>添加级别权限</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat set_permissions -p &#x2F; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>常用命令小结</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user 账号 密码</span><br><span class="line">rabbitmqctl set_user_tags 账号 administrator</span><br><span class="line">rabbitmqctl change_password Username Newpassword 修改密码</span><br><span class="line">rabbitmqctl delete_user Username 删除用户</span><br><span class="line">rabbitmqctl list_users 查看用户清单</span><br><span class="line">rabbitmqctl set_permissions -p &#x2F; 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 为用户设置administrator角色</span><br><span class="line">rabbitmqctl set_permissions -p &#x2F; root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="2-Docker方式安装"><a href="#2-Docker方式安装" class="headerlink" title="2. Docker方式安装"></a>2. Docker方式安装</h2><ol><li><strong>未安装Docker–&gt;安装Docker</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">（1）yum 包更新到最新</span><br><span class="line">&gt; yum update</span><br><span class="line">（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><br><span class="line">&gt; yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">（3）设置yum源为阿里云</span><br><span class="line">&gt; yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">（4）安装docker</span><br><span class="line">&gt; yum install docker-ce -y</span><br><span class="line">（5）安装后查看docker版本</span><br><span class="line">&gt; docker -v</span><br><span class="line"> (6) 安装加速镜像</span><br><span class="line"> sudo mkdir -p /etc/docker</span><br><span class="line"> sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://0wrdwnn6.mirror.aliyuncs.com"</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> EOF</span><br><span class="line"> sudo systemctl daemon-reload</span><br><span class="line"> sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>docker 常用命令</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker：</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 停止docker：</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment"># 重启docker：</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看docker状态：</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 开机启动：  </span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl unenable docker</span><br><span class="line"><span class="comment"># 查看docker概要信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="comment"># 查看docker帮助文档</span></span><br><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>安装rabbitMQ</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考网站：</span><br><span class="line">1：https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;download.html</span><br><span class="line">2：https:&#x2F;&#x2F;registry.hub.docker.com&#x2F;_&#x2F;rabbitmq&#x2F;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>拉取rabbitMQ镜像</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>创建容器并且执行</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myrabbit -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>不用进容器设置就创建镜像</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">—hostname：指定容器主机名称</span><br><span class="line">—name:指定容器名称</span><br><span class="line">-p:将mq端口号映射到本地</span><br><span class="line">或者运行时设置用户和密码</span><br><span class="line"></span><br><span class="line">docker run -di --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果你按照之前操作安装了docker , 那么现在需要将服务给停掉</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>查看docker 中的rabbitmq日志</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f myrabbit</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-03-安装与入门&quot;&gt;&lt;a href=&quot;#RabbitMQ-03-安装与入门&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-03-安装与入门&quot;&gt;&lt;/a&gt;RabbitMQ-03-安装与入门&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;简单概述：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ是一个开源的&lt;strong&gt;遵循AMQP协议实现的基于Erlang语言编写&lt;/strong&gt;，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网：&lt;a href=&quot;https://www.rabbitmq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载地址 ： &lt;a href=&quot;https://www.rabbitmq.com/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/download.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;环境准备：CentOS7.x+ / Erlang&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RabbitMQ是采用Erlang语言开发的，所以系统环境必须提供Erlang环境，第一步就是安装Erlang。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-02-消息队列</title>
    <link href="http://zhuuu.work/2021/03/16/RabbitMQ/RabbitMQ-02-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://zhuuu.work/2021/03/16/RabbitMQ/RabbitMQ-02-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2021-03-16T11:02:24.000Z</published>
    <updated>2021-04-11T07:19:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-02-消息队列"><a href="#RabbitMQ-02-消息队列" class="headerlink" title="RabbitMQ-02-消息队列"></a>RabbitMQ-02-消息队列</h2><h2 id="1-消息队列协议"><a href="#1-消息队列协议" class="headerlink" title="1. 消息队列协议"></a>1. 消息队列协议</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-210932098.png" alt="mark"></p><ul><li><strong>消息中间件负责数据的传递，存储，和分发消费三个部分</strong>，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，你是采用底层的TCP/IP，UDP协议还是其他的自己取构建等，而这些约定成俗的规范就称之为：协议。</li><li><strong>所谓协议是指：</strong><ul><li>计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有<strong>遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。</strong></li><li>和<strong>一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。</strong></li><li>协议对数据格式和计算机之间交换数据都必须<strong>严格遵守规范。</strong></li></ul></li></ul><a id="more"></a><h2 id="2-网络协议需要遵循的要素"><a href="#2-网络协议需要遵循的要素" class="headerlink" title="2. 网络协议需要遵循的要素"></a>2. 网络协议需要遵循的要素</h2><p><strong>1. 语法</strong>。语法是用户数据与控制信息的<strong>结构与格式,</strong>以及数据出现的顺序。<br><strong>2. 语义</strong>。语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息,以及<strong>完成的动作与做出什么样的响应。</strong><br><strong>3. 时序</strong>。时序是对<strong>事件发生顺序</strong>的详细说明。</p><ul><li><strong>而消息中间件采用的并不是http协议</strong>，而常见的消息中间件协议有：<code>OpenWire、AMQP、MQTT、Kafka，</code>OpenMessage协议。</li><li><strong>面试题：为什么消息中间件不直接使用http协议呢？</strong><ul><li><strong>1: 因为http请求报文头和响应报文头是比较复杂的</strong>，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，<strong>一定要追求的是高性能。尽量简洁，快速。</strong></li><li><strong>2:大部分情况下http大部分都是短链接</strong>，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就<strong>会造成请求的丢失</strong>。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</li></ul></li></ul><h2 id="3-消息队列协议"><a href="#3-消息队列协议" class="headerlink" title="3. 消息队列协议"></a>3. 消息队列协议</h2><h3 id="3-1AMQP协议"><a href="#3-1AMQP协议" class="headerlink" title="3.1AMQP协议"></a>3.1AMQP协议</h3><ul><li>AMQP：(全称：Advanced Message Queuing Protocol) 是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</li><li>基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等。</li></ul><p><strong>特性：</strong><br>1：分布式事务支持。<br>2：消息的持久化支持。<br>3：高性能和高可靠的消息处理优势。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141250242.png" alt="mark"></p><h3 id="3-2MQTT协议"><a href="#3-2MQTT协议" class="headerlink" title="3.2MQTT协议"></a>3.2MQTT协议</h3><ul><li><strong>MQTT协议：</strong>（Message Queueing Telemetry Transport）消息队列是IBM开放的一个即时通讯协议，<strong>物联网系统架构中的重要组成部分。</strong></li><li><strong>特点：</strong><br>1：轻量<br>2：结构简单<br>3：传输快，不支持事务<br>4：没有持久化设计。</li><li><strong>应用场景：</strong><br>1：适用于计算能力有限<br>2：低带宽<br>3：网络不稳定的场景。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141351884.png" alt="mark"></p><h3 id="3-3-OpenMessage协议"><a href="#3-3-OpenMessage协议" class="headerlink" title="3.3 OpenMessage协议"></a>3.3 OpenMessage协议</h3><ul><li>是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式消息中间件、流处理等领域的应用开发标准。</li><li><strong>特点：</strong><br>1：结构简单<br>2：解析速度快<br>3：支持事务和持久化设计。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141428320.png" alt="mark"></p><h3 id="3-4-Kafka协议"><a href="#3-4-Kafka协议" class="headerlink" title="3.4 Kafka协议"></a>3.4 Kafka协议</h3><ul><li><p><strong>Kafka协议是基于TCP/IP的二进制协议</strong>。消息内部是通过长度来分割，由一些基本数据类型组成。</p></li><li><p><strong>特点是</strong>：<br>1：结构简单<br>2：解析速度快<br>3：无事务支持<br>4：有持久化设计</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141511555.png" alt="mark"></p><h2 id="4-消息队列的持久化"><a href="#4-消息队列的持久化" class="headerlink" title="4. 消息队列的持久化"></a>4. 消息队列的持久化</h2><ul><li>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142053516.png" alt="mark"></p><ul><li>常见的持久化方式</li></ul><table><thead><tr><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th><th></th></tr></thead><tbody><tr><td>文件存储</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据库</td><td>支持</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><h2 id="5-消息的分发策略"><a href="#5-消息的分发策略" class="headerlink" title="5. 消息的分发策略"></a>5. 消息的分发策略</h2><ul><li><strong>MQ消息队列有如下几个角色</strong><br>1：生产者<br>2：存储消息<br>3：消费者</li><li><strong>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？</strong><ul><li>一般获取数据的方式无外乎<strong>推（push）或者拉（pull）两种方式，</strong></li><li><strong>典型的git就有推拉机制</strong>，我们发送的http请求就是一种典型的拉取数据库数据返回的过程。</li><li><strong>而消息队列MQ是一种推送的过程</strong>，而这些推机制会适用到很多的业务场景也有很多对应推机制策略。</li></ul></li></ul><h3 id="5-1-场景一"><a href="#5-1-场景一" class="headerlink" title="5.1 场景一"></a>5.1 场景一</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142306233.png" alt="mark"></p><ul><li>比如我在APP上下了一个订单，我们的系统和服务很多，我们如何得知这<strong>个消息被那个系统或者那些服务或者系统进行消费，那这个时候就需要一个分发的策略</strong>。这就需要消费策略。或者称之为消费的方法论。</li></ul><h3 id="5-2-场景二"><a href="#5-2-场景二" class="headerlink" title="5.2 场景二"></a>5.2 场景二</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142359085.png" alt="mark"></p><ul><li>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费MQ接受，<strong>订单系统出现故障，导致用户支付失败</strong>，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，<strong>消息不丢失还可以进行重发。</strong></li><li><strong>小结如下：</strong></li></ul><table><thead><tr><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th><th></th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>公平分发</td><td>/</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>/</td><td>支持</td></tr><tr><td>消息拉取</td><td>/</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><h2 id="6-消息队列高可用和高可靠"><a href="#6-消息队列高可用和高可靠" class="headerlink" title="6. 消息队列高可用和高可靠"></a>6. 消息队列高可用和高可靠</h2><h3 id="6-1-高可用"><a href="#6-1-高可用" class="headerlink" title="6.1 高可用"></a>6.1 高可用</h3><ul><li><strong>高可用：</strong>是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力。<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU,内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以<strong>消息中间件必须支持集群部署。来达到高可用的目的。</strong></li></ul><ul><li><h3 id="集群模式1-Master-slave主从共享数据的部署方式"><a href="#集群模式1-Master-slave主从共享数据的部署方式" class="headerlink" title="集群模式1 - Master-slave主从共享数据的部署方式"></a>集群模式1 - Master-slave主从共享数据的部署方式</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142651818.png" alt="mark"></p><p>生产者将消费发送到Master节点，所有的都连接这个消息队列共享这块数据区域，Master节点负责写入，一旦Master挂掉，slave节点继续服务。从而形成高可用，</p><ul><li><h3 id="集群模式2-Master-slave主从同步部署方式"><a href="#集群模式2-Master-slave主从同步部署方式" class="headerlink" title="集群模式2 - Master- slave主从同步部署方式"></a>集群模式2 - Master- slave主从同步部署方式</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142728662.png" alt="mark"></p><p>这种模式写入消息同样在Master主节点上，但是主节点会同步数据到slave节点形成副本，和zookeeper或者redis主从机制很类同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点就行消费，以为消息的拷贝和同步会暂用很大的带宽和网络资源。在后续的rabbtmq中会有使用。</p><ul><li><h3 id="集群模式3-多主集群同步部署模式"><a href="#集群模式3-多主集群同步部署模式" class="headerlink" title="集群模式3 - 多主集群同步部署模式"></a>集群模式3 - 多主集群同步部署模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142830807.png" alt="mark"></p></li></ul><p><strong>解释：</strong></p><p>如果你插入的数据是broker-1中，元数据信息会存储数据的相关描述和记录存放的位置（队列）。<br>它会对描述信息也就是元数据信息就行同步，如果消费者在broker-2中进行消费，发现自己几点没有对应的消息，可以从<strong>对应的元数据信息中去查询</strong>，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他会去联系其他的黄牛询问，如果有就返回。</p><ul><li><h3 id="集群模式5-Master-slave与Broker-cluster组合的方案"><a href="#集群模式5-Master-slave与Broker-cluster组合的方案" class="headerlink" title="集群模式5 Master-slave与Broker-cluster组合的方案"></a>集群模式5 Master-slave与Broker-cluster组合的方案</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142935098.png" alt="mark"></p><p><strong>解释：</strong>实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</p><p><strong>反正终归三句话：</strong><br><strong>1：要么消息共享，</strong><br><strong>2：要么消息同步</strong><br><strong>3：要么元数据共享</strong></p><h3 id="6-2-高可靠"><a href="#6-2-高可靠" class="headerlink" title="6.2 高可靠"></a>6.2 高可靠</h3><ul><li><strong>高可靠</strong>：是指系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</li><li>在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</li><li>如何保证<strong>中间件消息的可靠性</strong>呢？可以从两个方面考虑：<br><strong>1：消息的传输：通过协议来保证系统间数据解析的正确性。</strong><br><strong>2：消息的存储可靠：通过持久化来保证消息的可靠性。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-02-消息队列&quot;&gt;&lt;a href=&quot;#RabbitMQ-02-消息队列&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-02-消息队列&quot;&gt;&lt;/a&gt;RabbitMQ-02-消息队列&lt;/h2&gt;&lt;h2 id=&quot;1-消息队列协议&quot;&gt;&lt;a href=&quot;#1-消息队列协议&quot; class=&quot;headerlink&quot; title=&quot;1. 消息队列协议&quot;&gt;&lt;/a&gt;1. 消息队列协议&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-210932098.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息中间件负责数据的传递，存储，和分发消费三个部分&lt;/strong&gt;，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，你是采用底层的TCP/IP，UDP协议还是其他的自己取构建等，而这些约定成俗的规范就称之为：协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所谓协议是指：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有&lt;strong&gt;遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;和&lt;strong&gt;一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;协议对数据格式和计算机之间交换数据都必须&lt;strong&gt;严格遵守规范。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-01-中间件概述</title>
    <link href="http://zhuuu.work/2021/03/15/RabbitMQ/RabbitMQ-01-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2021/03/15/RabbitMQ/RabbitMQ-01-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2021-03-15T11:02:24.000Z</published>
    <updated>2021-04-11T07:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-01-中间件概述"><a href="#RabbitMQ-01-中间件概述" class="headerlink" title="RabbitMQ-01-中间件概述"></a>RabbitMQ-01-中间件概述</h2><h2 id="1-中间件简介"><a href="#1-中间件简介" class="headerlink" title="1. 中间件简介"></a>1. 中间件简介</h2><ul><li><p><code>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件=平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。</code></p></li><li><p>为解决分布异构问题，人们提出了中间件(middleware)的概念。中间件是位于平台(硬件和操作系统)和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口和协议规范的多种实现。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195441380.png" alt="mark"></p><a id="more"></a><ul><li>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。<strong>这使得中间件一定是可替换的。如果一个系统设计中，中间件是不可替换的，不是架构、框架设计有问题，那么就是这个中间件，在 别处可能是个中间件，在这个系统内是引擎</strong>。哈。</li></ul><h2 id="2-中间件的使用时机"><a href="#2-中间件的使用时机" class="headerlink" title="2. 中间件的使用时机"></a>2. 中间件的使用时机</h2><ul><li>在项目的架构和重构中，使用任何技术和架构的改变我们都需要谨慎斟酌和思考，因为任何技术的融入和变化都可能人员，技术，和成本的增加，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果你仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而追求的背后一定是业务的驱动和项目的驱动，因为一旦追求就意味着你的学习成本，公司的人员结构以及服务器成本，维护和运维的成本都会增加，所以需要谨慎选择和考虑。</li><li>但是作为一个开放人员，一定要有学习中间件技术的能力和思维，否则很容易当项目发展到一个阶段在去掌握估计或者在面试中提及，就会给自己带来不小的困扰，在当今这个时代这些技术也并不是什么新鲜的东西，如果去掌握和挖掘最关键的还是自己花时间和花精力去探讨和研究。</li></ul><h2 id="3-单体架构和分布式架构"><a href="#3-单体架构和分布式架构" class="headerlink" title="3. 单体架构和分布式架构"></a>3. 单体架构和分布式架构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195713227.png" alt="mark"></p><p>在实际的项目中，大部分的企业项目开发中，在早期都采用的是<strong>单体的架构模式</strong>，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200010624.png" alt="mark"></p><p>在企业开发的中，大部分的初期架构都采用的是单体架构的模式进行架构，而这种架构的典型的特点：就是把所有的业务和模块，源代码，静态资源文件等都放在一个一工程中，如果其中的一个模块升级或者迭代发生一个很小变动都会重新编译和重新部署项目。 这种的架构存在的问题就是：<br>1：耦合度太高<br>2：运维的成本过高<br>3：不易维护<br>4：服务器的成本高<br>5：以及升级架构的复杂度也会增大<br>这样就有后续的分布式架构系统。如下</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200044247.png" alt="mark"></p><p><strong>通俗一点：就是一个请求由服务器端的多个服务（服务或者系统）协同处理完成</strong></p><ul><li>和单体架构不同的是，单体架构是一个请求发起jvm调度线程（确切的是tomcat线程池）分配线程Thread来处理请求直到释放，而分布式是系统是：一个请求是由多个系统共同来协同完成，jvm和环境都可能是独立。如果生活中的比喻的话，单体架构就想建设一个小房子很快就能够搞定，如果你要建设一个鸟巢或者大型的建筑，你就必须是各个环节的协同和分布，这样目的也是项目发展都后期的时候要去部署和思考的问题。</li></ul><h2 id="4-消息中间件概念"><a href="#4-消息中间件概念" class="headerlink" title="4. 消息中间件概念"></a>4. 消息中间件概念</h2><p><strong>应用场景</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1:跨系统数据传递</span><br><span class="line">2:高并发的流量削峰</span><br><span class="line">3:数据的分发和异步处理</span><br><span class="line">4:大数据分析与传递</span><br><span class="line">5:分布式事务</span><br></pre></td></tr></table></figure><p>比如你有一个数据要进行迁移或者请求并发过多的时候，比如你有10W的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行。</p><p><strong>常见的消息中间件</strong></p><ul><li>ActiveMQ、RabbitMQ、Kafka、RocketMQ等。</li></ul><p><strong>同时消息中间件是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200352244.png" alt="mark"></p><p>谁来生产消息，存储消息和消费消息呢？</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200408369.png" alt="mark"></p><h2 id="5-消息中间件的两种模式"><a href="#5-消息中间件的两种模式" class="headerlink" title="5. 消息中间件的两种模式"></a>5. 消息中间件的两种模式</h2><ol><li><strong>点对点模式 P2P</strong></li></ol><ul><li>点对点模式是基于队列的，消息的生产者发送消息到队列，消息的消费者从队列中接收消息，队列的存在使得消息的异步传输成为可能</li></ul><ol start="2"><li><strong>发布订阅模式</strong></li></ol><ul><li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic）,主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题中，而消息的订阅者从主题中订阅消息。</li></ul><p><strong>参考博客系列 ：</strong> <a href="https://blog.csdn.net/u013256816/article/details/54743481" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/54743481</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-01-中间件概述&quot;&gt;&lt;a href=&quot;#RabbitMQ-01-中间件概述&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-01-中间件概述&quot;&gt;&lt;/a&gt;RabbitMQ-01-中间件概述&lt;/h2&gt;&lt;h2 id=&quot;1-中间件简介&quot;&gt;&lt;a href=&quot;#1-中间件简介&quot; class=&quot;headerlink&quot; title=&quot;1. 中间件简介&quot;&gt;&lt;/a&gt;1. 中间件简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件=平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为解决分布异构问题，人们提出了中间件(middleware)的概念。中间件是位于平台(硬件和操作系统)和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口和协议规范的多种实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195441380.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-01-计算机系统概述</title>
    <link href="http://zhuuu.work/2021/03/15/Compute_Organization/%E8%AE%A1%E7%BB%84-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2021/03/15/Compute_Organization/%E8%AE%A1%E7%BB%84-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-22T07:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-01-计算机系统概述"><a href="#计算机组成原理-01-计算机系统概述" class="headerlink" title="计算机组成原理-01-计算机系统概述"></a>计算机组成原理-01-计算机系统概述</h2><h2 id="1-计算机的四代变化"><a href="#1-计算机的四代变化" class="headerlink" title="1. 计算机的四代变化"></a>1. 计算机的四代变化</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105224626.png" alt="mark"></p><p><strong>1）摩尔定律。</strong>摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度 。尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法 。</p><p><strong>2）半导体存储器的发展。</strong>1970年仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代；单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB、1GB。</p><p>3）微处理器的发展。微处理器位数：8-&gt;16-&gt;32-&gt;64，这里的32、64指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。</p><a id="more"></a><h2 id="2-计算机的组成"><a href="#2-计算机的组成" class="headerlink" title="2. 计算机的组成"></a>2. 计算机的组成</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105756753.png" alt="mark"></p><p><strong>软件分类如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105842514.png" alt="mark"></p><p><strong>语言等级</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105934707.png" alt="mark"></p><h2 id="3-冯·诺依曼机"><a href="#3-冯·诺依曼机" class="headerlink" title="3. 冯·诺依曼机"></a>3. 冯·诺依曼机</h2><ul><li><p>美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。</p><ul><li>“程序存储”：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</li></ul></li><li><p><strong>计算机的五大功能部件</strong>：<code>输入设备、输出设备、存储器、运算器、控制器</code></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-111632056.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-111934913.png" alt="mark"></p><h2 id="4-现代计算机的结构"><a href="#4-现代计算机的结构" class="headerlink" title="4. 现代计算机的结构"></a>4. 现代计算机的结构</h2><ul><li>在微处理器问世之前，运算器与控制器分离。而且存储器容量小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递，如上图所示。</li><li>随着微电子技术的进步，同时计算机需要处理的信息也越来越多，大量I/O设备的速度和CPU的速度差距悬殊，因此需要更新换代计算机的组织结构以适应新的需求。计算机发展为了以存储器为中心，使I/O设备尽可能的绕过CPU，直接在I/O设备与存储器之间完成操作，以提高整体效率。其结构如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-112030679.png" alt="mark"></p><h2 id="5-主存储器"><a href="#5-主存储器" class="headerlink" title="5. 主存储器"></a>5. 主存储器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113400653.png" alt="mark"></p><ul><li>存储体：存放二进制信息</li><li>地址寄存器（MAR-Memory Address Register）:存放访存地址，经过地址译码后找到所选的逻辑单元</li><li>数据寄存器（MDR-Memory Data Register）:暂存要从存储器中读或写的信息</li><li>时序控制逻辑：用于产生存储器操作所需的各种时序信号</li><li>地址寄存器（MAR-Memory Address Register）用于寻址，其位数对应着存储单元的个数，如MAR为10位，则有2^10^=1024个存储单元，记为1K。MAR的长度与PC（程序计数器）长度相等。</li><li>MDR位数=存储字长，一般为字节(B)的二次幂的整数倍</li><li>MAR和MDR虽然是存储器的一部分，但在现代CPU中却是存在于CPU中的；另外高速缓存（Cache）也存在于CPU中<br><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113700559.png" alt="mark"></li></ul><h2 id="6-运算器"><a href="#6-运算器" class="headerlink" title="6. 运算器"></a>6. 运算器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113919523.png" alt="mark"></p><ul><li>运算器：ALU 算数逻辑单元是最主要的组成部件，运算器包含若干通用寄存器，用于暂存操作数和中间结果。</li></ul><h2 id="7-控制器"><a href="#7-控制器" class="headerlink" title="7. 控制器"></a>7. 控制器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-114103653.png" alt="mark"></p><ul><li>控制器是计算机的<code>指挥中心</code>，它指挥着各部件自动协调地进行工作</li></ul><h2 id="8-工作过程小结"><a href="#8-工作过程小结" class="headerlink" title="8. 工作过程小结"></a>8. 工作过程小结</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-115017372.png" alt="mark"></p><ul><li><p><code>总线</code>中有<code>地址、数据、控制</code>三组信号线</p></li><li><p><code>CPU与主存</code>之间通过一组<code>总线</code>相连</p></li><li><p><code>MAR</code>中的地址信息会直接送到<code>地址线</code>上，用于指向<code>读/写</code>操作的<code>主存存储单元</code></p></li><li><p><code>控制线</code>中有<code>读/写</code>信号线，指出数据是从CPU<code>写入</code>主存还是从主存<code>读出</code>到<code>CPU</code></p></li><li><p>根据<code>读</code>操作还是<code>写</code>操作来控制将<code>MDR中的数据</code>是直接<code>送到数据线上</code>还是将数据线上的数据<code>接收到MDR</code>中</p></li></ul><h2 id="9-计算机的工作过程"><a href="#9-计算机的工作过程" class="headerlink" title="9. 计算机的工作过程"></a>9. 计算机的工作过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-151055001.png" alt="mark"></p><ul><li>这里以UNIX系统中的GCC编译器程序为例，将C语言源程序转换为<code>可执行文件（以二进制磁盘文件形式存储）</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-151153003.png" alt="mark"></p><p> 例题：以取数指令（即将指令地址码指示的存储单元中的操作数取出后送至运算器的累加器(ACC)中）为例进行说明。其信息流程如下：</p><blockquote><p>累加器ACC：二进制8位寄存器，存放操作数或运算结果。<br>M : 主存储器</p></blockquote><ol><li><strong>取指令</strong>  ：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</li></ol><ul><li><code>根据PC取指令到IR</code>。将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读/写信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接受指令信息，并传送到IR中。</li></ul><ol start="2"><li><strong>分析指令</strong> ： OP(IR)-&gt;CU</li></ol><ul><li><code>指令译码器解释操作码OP(IR)并送出控制信号</code>。指令寄存器（IR）将操作码OP(IR)送至指令译码器（ID）进行解释翻译，将翻译的信息送至操作控制器（OC），OC生成相应的控制信号，送到不同的执行部件。</li></ul><ol start="3"><li><strong>执行指令</strong> ： Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</li></ol><ul><li><code>取数操作</code>。将IR中的指令地址码送MAR，MAR将内容送至地址线，同时控制器将读/写信号送读/写线，从主存指定单元读出操作数，并通过数据线送至MDR，再传送到ACC中。</li></ul><ol start="4"><li><strong>每取完一条指令，(PC)+1-&gt;PC，取下一条指令的地址。</strong></li></ol><h2 id="10-计算机的层次结构"><a href="#10-计算机的层次结构" class="headerlink" title="10. 计算机的层次结构"></a>10. 计算机的层次结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-150749119.png" alt="mark"></p><h2 id="11-计算机的主要性能指标"><a href="#11-计算机的主要性能指标" class="headerlink" title="11. 计算机的主要性能指标"></a>11. 计算机的主要性能指标</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-152255067.png" alt="mark"></p><p><strong>性能指标：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-152429772.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-01-计算机系统概述&quot;&gt;&lt;a href=&quot;#计算机组成原理-01-计算机系统概述&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-01-计算机系统概述&quot;&gt;&lt;/a&gt;计算机组成原理-01-计算机系统概述&lt;/h2&gt;&lt;h2 id=&quot;1-计算机的四代变化&quot;&gt;&lt;a href=&quot;#1-计算机的四代变化&quot; class=&quot;headerlink&quot; title=&quot;1. 计算机的四代变化&quot;&gt;&lt;/a&gt;1. 计算机的四代变化&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105224626.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）摩尔定律。&lt;/strong&gt;摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度 。尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）半导体存储器的发展。&lt;/strong&gt;1970年仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代；单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB、1GB。&lt;/p&gt;
&lt;p&gt;3）微处理器的发展。微处理器位数：8-&amp;gt;16-&amp;gt;32-&amp;gt;64，这里的32、64指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--082-删除排序链表中的重复元素II</title>
    <link href="http://zhuuu.work/2021/03/15/Leetcode/Leetcode-082-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/"/>
    <id>http://zhuuu.work/2021/03/15/Leetcode/Leetcode-082-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-25T11:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–082-删除排序链表中的重复元素-II"><a href="#Leetcode–082-删除排序链表中的重复元素-II" class="headerlink" title="Leetcode–082-删除排序链表中的重复元素 II"></a>Leetcode–082-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素 II</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</li><li>返回同样按升序排列的结果链表。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185810569.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185829197.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><a id="more"></a><h2 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h2><ul><li>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（<code>dummy node</code>）指向链表的头节点。</li><li>具体地，首先从指针<code>cur</code>指向链表的哑节点，<ul><li>随后开始对链表进行遍历。如果当前<code>cur.next</code>与<code>cur.next.next</code>对应的元素相同，那么我们就需要将<code>cur.next</code> 以及所有后面拥有相同元素值的链表节点全部删除。</li><li>记下这个元素值 x，随后不断将<code>cur.next</code>从链表中移除，直到 <code>cur.next</code>为空节点或者其元素值不等于<code>x</code> 为止。此时，将链表中所有元素值为<code>x</code>的节点全部删除。</li></ul></li><li>如果当前<code>cur.next</code> 与<code>cur.next.next</code> 对应的元素不相同，那么说明链表中只有一个元素值为<code>cur.next</code> 的节点，那么就可以将 <code>cur</code> 指向 <code>cur.next</code>。</li></ul><ul><li>当遍历完整个链表之后，我们返回链表的的哑节点的下一个节点 <em>dummy.next</em> 即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 如果链表为空</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 创建哑节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 处理逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123; <span class="comment">// 如果是重复元素的话</span></span><br><span class="line">                <span class="keyword">int</span> x = cur.next.val;<span class="comment">// 为了在删除前记录重复的值大小</span></span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == x)&#123;<span class="comment">// 循环删除重复元素</span></span><br><span class="line">                    cur.next = cur.next.next;<span class="comment">// 删除这个重复元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 如果不是重复元素的话</span></span><br><span class="line">                cur = cur.next;<span class="comment">// 指针向前走一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 返回dummy.next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是链表的长度。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–082-删除排序链表中的重复元素-II&quot;&gt;&lt;a href=&quot;#Leetcode–082-删除排序链表中的重复元素-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–082-删除排序链表中的重复元素 II&quot;&gt;&lt;/a&gt;Leetcode–082-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除排序链表中的重复元素 II&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存在一个按升序排列的链表，给你这个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 &lt;strong&gt;没有重复出现&lt;/strong&gt; 的数字。&lt;/li&gt;
&lt;li&gt;返回同样按升序排列的结果链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185810569.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,2,3,3,4,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,5]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185829197.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中节点数目在范围 &lt;code&gt;[0, 300]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证链表已经按升序排列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--456-132模式</title>
    <link href="http://zhuuu.work/2021/03/15/Leetcode/Leetcode-456-132%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2021/03/15/Leetcode/Leetcode-456-132%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-27T01:43:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–456-132-模式"><a href="#Leetcode–456-132-模式" class="headerlink" title="Leetcode–456-132 模式"></a>Leetcode–456-<a href="https://leetcode-cn.com/problems/132-pattern/" target="_blank" rel="noopener">132 模式</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成</li><li>并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</li></ul><p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>注意：</strong></p><p><strong>进阶：</strong>很容易想到时间复杂度为 <code>O(n^2)</code> 的解决方案，你可以设计一个时间复杂度为 <code>O(n logn)</code> 或 <code>O(n)</code> 的解决方案吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：序列中不存在 132 模式的子序列。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [3,1,4,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,3,2,0]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><strong>思路</strong></p><ul><li><strong>由于本题中的<code>n</code> 最大值为10^4，因此对一个满足132的三元组下标（i,j,k），枚举其中两个下标的时间复杂度是O(n^2),很容易超出时间的限制</strong></li><li><strong>因此我们可以考虑枚举其中的 1个下标，并使用合适的数据结构维护另外的 2 个下标的可能值。</strong></li></ul><p><strong>算法：枚举3</strong></p><ul><li>枚举 3 是容易想到并且也是最容易实现的。由于 3 是模式中的最大值，并且其出现在 1 和 2 的中间，因此我们只需要从左到右枚举 3 的下标 j，那么：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-093150639.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判 : 少于三个元素不能构成132</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 定义左侧最小值</span></span><br><span class="line">        <span class="keyword">int</span> leftMin = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将右侧所有元素放进到有序集合中</span></span><br><span class="line">        TreeMap&lt;Integer,Integer&gt; rightAll = <span class="keyword">new</span> TreeMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>;k &lt; n;++k)&#123;</span><br><span class="line">            rightAll.put(nums[k],rightAll.getOrDefault(nums[k],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 枚举3</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n - <span class="number">1</span>;++j)&#123;</span><br><span class="line">            <span class="comment">// 3.1 满足132中的nums[i] &lt; nums[j]的条件</span></span><br><span class="line">            <span class="keyword">if</span>(leftMin &lt; nums[j])&#123;              </span><br><span class="line">                Integer next = rightAll.ceilingKey(leftMin + <span class="number">1</span>);        <span class="comment">// ceilingKey：方法调用返回的最小的大于或等于的键，如果不存在这样的键在则返回null。（这里的作用是返回TreeMap 中的大于leftMin的最小值）</span></span><br><span class="line">                <span class="keyword">if</span>(next != <span class="keyword">null</span> &amp;&amp; next &lt; nums[j])&#123;                     <span class="comment">// 如果这个最小值存在且小于nums[j]:说明满足132的整体条件</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.2 不满足132中：nums[i] &lt; nums[j] 条件</span></span><br><span class="line">            leftMin = Math.min(leftMin, nums[j]);                       <span class="comment">// 更新leftMin（nums[i]）的值</span></span><br><span class="line">            rightAll.put(nums[j + <span class="number">1</span>], rightAll.get(nums[j + <span class="number">1</span>]) - <span class="number">1</span>);   <span class="comment">// 将有序集合中的nums[j + 1]对应的键值-1 相当于将“窗口”右移一位</span></span><br><span class="line">            <span class="keyword">if</span>(rightAll.get(nums[j + <span class="number">1</span>]) == <span class="number">0</span>)&#123;                         <span class="comment">// 若有序集合中的nums[j + 1]对应的键值==0 删除这个键值对</span></span><br><span class="line">                rightAll.remove(nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举结束未找到返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-094311749.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–456-132-模式&quot;&gt;&lt;a href=&quot;#Leetcode–456-132-模式&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–456-132 模式&quot;&gt;&lt;/a&gt;Leetcode–456-&lt;a href=&quot;https://leetcode-cn.com/problems/132-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;132 模式&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，数组中共有 &lt;code&gt;n&lt;/code&gt; 个整数。&lt;strong&gt;132 模式的子序列&lt;/strong&gt; 由三个整数 &lt;code&gt;nums[i]&lt;/code&gt;、&lt;code&gt;nums[j]&lt;/code&gt; 和 &lt;code&gt;nums[k]&lt;/code&gt; 组成&lt;/li&gt;
&lt;li&gt;并同时满足：&lt;code&gt;i &amp;lt; j &amp;lt; k&lt;/code&gt; 和 &lt;code&gt;nums[i] &amp;lt; nums[k] &amp;lt; nums[j]&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 &lt;code&gt;nums&lt;/code&gt; 中存在 &lt;strong&gt;132 模式的子序列&lt;/strong&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;很容易想到时间复杂度为 &lt;code&gt;O(n^2)&lt;/code&gt; 的解决方案，你可以设计一个时间复杂度为 &lt;code&gt;O(n logn)&lt;/code&gt; 或 &lt;code&gt;O(n)&lt;/code&gt; 的解决方案吗？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中不存在 132 模式的子序列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [3,1,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1,3,2,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == nums.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^9 &amp;lt;= nums[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="(i,j,k)" scheme="http://zhuuu.work/tags/i-j-k/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-697-数组的度</title>
    <link href="http://zhuuu.work/2021/02/15/Leetcode/Leetcode-697-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/"/>
    <id>http://zhuuu.work/2021/02/15/Leetcode/Leetcode-697-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</id>
    <published>2021-02-15T07:52:53.000Z</published>
    <updated>2021-02-20T05:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-697-数组的度"><a href="#Leecode-697-数组的度" class="headerlink" title="Leecode-697-数组的度"></a>Leecode-697-<a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">数组的度</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。</p></li><li><p>你的任务是在 <code>nums</code> 中找到与 <code>nums</code>拥有<strong>相同大小的度的最短连续子数组，返回其长度。</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[1, 2, 2, 3, 1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">输入数组的度是2，因为元素1和2的出现频数最大，均为2.</span><br><span class="line">连续子数组里面拥有相同度的有如下所示:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">最短连续子数组[2, 2]的长度为2，所以返回2.</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[1,2,2,3,1,4,2]</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">nums.length 在1到 50,000 区间范围内。</span><br><span class="line">nums[i] 是一个在 0 到 49,999 范围内的整数。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路：哈希表-贪心"><a href="#思路：哈希表-贪心" class="headerlink" title="思路：哈希表+贪心"></a>思路：哈希表+贪心</h2><ul><li>记原数组中出现次数最多的数为 x<em>，那么和原数组的度相同的最短连续子数组，必然包含了原数组中的全部 x</em>，<strong>且两端恰为 x 第一次出现和最后一次出现的位置。</strong></li><li>因为符合条件的 x可能有多个，即多个不同的数在原数组中出现次数相同。所以为了找到这个子数组，我们需要统计每一个数出现的次数，同时还需要统计每一个数第一次出现和最后一次出现的位置。<ul><li>使用哈希表实现该功能，每一个数映射到一个长度为 3 的数组，</li><li>数组中的三个元素分别代表这个数出现的次数、这个数在原数组中第一次出现的位置和这个数在原数组中最后一次出现的位置。</li></ul></li><li>当我们记录完所有信息后，我们需要遍历该哈希表，找到元素出现次数最多，且前后位置差最小的数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 哈希表记录：遍历一次哈希表</span></span><br><span class="line">            <span class="comment">// 1.数字出现的次数</span></span><br><span class="line">            <span class="comment">// 2.该数字第一次出现的下标</span></span><br><span class="line">            <span class="comment">// 3.该数字最后一次出现的下标</span></span><br><span class="line">        Map&lt;Integer,<span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.get(nums[i])[<span class="number">0</span>]++;                      <span class="comment">// 当前数字出现次数加1</span></span><br><span class="line">                map.get(nums[i])[<span class="number">2</span>] = i;                    <span class="comment">// 更新出现的最后一次下标</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,i,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 统计哈希表</span></span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;                                     <span class="comment">// 出现次数最多的数字</span></span><br><span class="line">        <span class="keyword">int</span> minLen = <span class="number">0</span>;                                     <span class="comment">// 第一次出现和最后一次出现的间隔</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,<span class="keyword">int</span>[]&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = entry.getValue();                   <span class="comment">// 遍历哈希表拿到每个数字对应的数组</span></span><br><span class="line">            <span class="keyword">if</span>(maxNum &lt; arr[<span class="number">0</span>])&#123;                            <span class="comment">// 如果不是出现次数最多的</span></span><br><span class="line">                maxNum = arr[<span class="number">0</span>];</span><br><span class="line">                minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxNum == arr[<span class="number">0</span>])&#123;                     <span class="comment">// 如果出现次数是最多的数字</span></span><br><span class="line">                <span class="keyword">if</span>(minLen &gt; arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;                                      <span class="comment">// 返回子数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是原数组的长度，我们需要遍历原数组和哈希表各一次，它们的大小均为 O(n)。</p></li><li><p>空间复杂度：O(n)，其中 n 是原数组的长度，最坏情况下，哈希表和原数组等大。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-697-数组的度&quot;&gt;&lt;a href=&quot;#Leecode-697-数组的度&quot; class=&quot;headerlink&quot; title=&quot;Leecode-697-数组的度&quot;&gt;&lt;/a&gt;Leecode-697-&lt;a href=&quot;https://leetcode-cn.com/problems/degree-of-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组的度&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个非空且只包含非负数的整数数组 &lt;code&gt;nums&lt;/code&gt;，数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你的任务是在 &lt;code&gt;nums&lt;/code&gt; 中找到与 &lt;code&gt;nums&lt;/code&gt;拥有&lt;strong&gt;相同大小的度的最短连续子数组，返回其长度。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1, 2, 2, 3, 1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入数组的度是2，因为元素1和2的出现频数最大，均为2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;连续子数组里面拥有相同度的有如下所示:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最短连续子数组[2, 2]的长度为2，所以返回2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,2,2,3,1,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums.length 在1到 50,000 区间范围内。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums[i] 是一个在 0 到 49,999 范围内的整数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-703-数据流中的第K大元素</title>
    <link href="http://zhuuu.work/2021/02/11/Leetcode/Leetcode-703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2021/02/11/Leetcode/Leetcode-703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2021-02-11T05:24:53.000Z</published>
    <updated>2021-02-11T06:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-703-数据流中的第-K-大元素"><a href="#Leetcode-703-数据流中的第-K-大元素" class="headerlink" title="Leetcode-703- 数据流中的第 K 大元素"></a>Leetcode-703-<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener"> 数据流中的第 K 大元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p></li><li><p>请实现 <code>KthLargest</code>类：</p><ul><li><code>KthLargest(int k, int[] nums)</code> 使用整数 k 和整数流 <code>nums</code>初始化对象。<br><code>int add(int val)</code>将 val 插入数据流 <code>nums</code>后，返回当前数据流中第 k 大的元素。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]</span><br><span class="line">[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, 4, 5, 5, 8, 8]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest &#x3D; new KthLargest(3, [4, 5, 8, 2]);</span><br><span class="line">kthLargest.add(3);   &#x2F;&#x2F; return 4</span><br><span class="line">kthLargest.add(5);   &#x2F;&#x2F; return 5</span><br><span class="line">kthLargest.add(10);  &#x2F;&#x2F; return 5</span><br><span class="line">kthLargest.add(9);   &#x2F;&#x2F; return 8</span><br><span class="line">kthLargest.add(4);   &#x2F;&#x2F; return 8</span><br><span class="line"></span><br><span class="line">**注意:**</span><br><span class="line"></span><br><span class="line">- 提示：</span><br><span class="line">  1 &lt;&#x3D; k &lt;&#x3D; 104</span><br><span class="line">  0 &lt;&#x3D; nums.length &lt;&#x3D; 104</span><br><span class="line">  -104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</span><br><span class="line">  -104 &lt;&#x3D; val &lt;&#x3D; 104</span><br><span class="line">  最多调用 add 方法 10^4 次</span><br><span class="line">  题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-优先队列"><a href="#思路-：-优先队列" class="headerlink" title="思路 ： 优先队列"></a>思路 ： 优先队列</h2><ul><li>使用一个大小为 k 的优先队列来存储前 k大的元素，其中优先队列的队头为队列中最小的元素，也就是第 k 大的元素。</li><li>在单次插入的操作中，我们首先将元素 val 加入到优先队列中。</li><li>如果此时优先队列的大小大于 k，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 <em>k</em>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. k大元素逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.offer(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><h2 id="时间复杂度：O-nlogk"><a href="#时间复杂度：O-nlogk" class="headerlink" title="时间复杂度：O(nlogk)"></a>时间复杂度：O(nlogk)</h2></li><li>空间复杂度：O(k) 使用大小为k的优先队列</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-703-数据流中的第-K-大元素&quot;&gt;&lt;a href=&quot;#Leetcode-703-数据流中的第-K-大元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-703- 数据流中的第 K 大元素&quot;&gt;&lt;/a&gt;Leetcode-703-&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 数据流中的第 K 大元素&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请实现 &lt;code&gt;KthLargest&lt;/code&gt;类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KthLargest(int k, int[] nums)&lt;/code&gt; 使用整数 k 和整数流 &lt;code&gt;nums&lt;/code&gt;初始化对象。&lt;br&gt;&lt;code&gt;int add(int val)&lt;/code&gt;将 val 插入数据流 &lt;code&gt;nums&lt;/code&gt;后，返回当前数据流中第 k 大的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;KthLargest&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[null, 4, 5, 5, 8, 8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;KthLargest kthLargest &amp;#x3D; new KthLargest(3, [4, 5, 8, 2]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(3);   &amp;#x2F;&amp;#x2F; return 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(5);   &amp;#x2F;&amp;#x2F; return 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(10);  &amp;#x2F;&amp;#x2F; return 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(9);   &amp;#x2F;&amp;#x2F; return 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(4);   &amp;#x2F;&amp;#x2F; return 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**注意:**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- 提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  0 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -104 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -104 &amp;lt;&amp;#x3D; val &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  最多调用 add 方法 10^4 次&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="优先队列" scheme="http://zhuuu.work/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-643-子数组最大平均数1</title>
    <link href="http://zhuuu.work/2021/02/04/Leetcode/Leetcode-643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B01/"/>
    <id>http://zhuuu.work/2021/02/04/Leetcode/Leetcode-643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B01/</id>
    <published>2021-02-04T07:52:53.000Z</published>
    <updated>2021-02-04T02:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-643-子数组最大平均数-I"><a href="#Leetcode-643-子数组最大平均数-I" class="headerlink" title="Leetcode-643-子数组最大平均数 I"></a>Leetcode-643-<a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">子数组最大平均数 I</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 30,000。</span><br><span class="line">所给数据范围 [-10,000，10,000]。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-滑动窗口"><a href="#方法一-：-滑动窗口" class="headerlink" title="方法一 ： 滑动窗口"></a>方法一 ： 滑动窗口</h2><ul><li><strong>由于规定了子数组的长度为 k，因此可以通过寻找子数组的最大元素和的方式寻找子数组的最大平均数，元素和最大的子数组对应的平均数也是最大的。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设两个不同的子数组的长度都是 k，这两个子数组的元素和分别是 x 和 y，</span><br><span class="line">则这两个子数组的平均数分别是 x&#x2F;k 和 y&#x2F;k。</span><br><span class="line">如果 x≥y，则有 x&#x2F;k ≥ y&#x2F;k，即如果一个子数组的元素和更大，则该子数组的平均数也更大。</span><br></pre></td></tr></table></figure><ul><li><strong>为了找到子数组的最大元素和，需要对数组中的每个长度为k的子数组为别计算元素和。对于长度为n的数组，当k &lt;= n的时候，有n - k + 1个长度为k的子数组</strong></li><li>如果直接计算每个子数组的元素和，则时间复杂度过高，无法通过全部测试用例，因此需要使用时间复杂度更低的方法计算每个子数组的元素和。</li></ul><hr><p><strong>滑动窗口推导</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102250831.png" alt="mark"></p><ul><li><p>上述过程可以看成维护一个长度为k的滑动窗口。当滑动窗口的下标范围从<code>[i - k,i - 1]</code> 到 <code>[i - k + 1,i]</code>时，<code>nums[i - k]</code> 从窗口移除，<code>nums[i]</code> 进入到窗口内</p></li><li><p>利用上述关系，可以在O(1) 的时候内通过<code>sum_i-1</code> 得到 <code>sum_i</code></p></li><li><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102651739.png" alt="mark"></p></li><li><p>在上述过程中维护最大的子数组元素和，记为maxSum，子数组的最大平均数即为 maxSum/k。</p></li><li><p>需要注意返回值是浮点型，因此计算除法时需要进行数据类型转换。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102557416.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102613774.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102624973.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102630741.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102636265.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 长度小于k的时候，直接初始化sum</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 长度大于等于k的时候，比较最大的连续子数组和</span></span><br><span class="line">        <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; n;i++)&#123;</span><br><span class="line">            sum = sum - nums[i - k] + nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回浮点结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * maxSum/k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度  : O(n)</li><li>空间复杂度 ：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-643-子数组最大平均数-I&quot;&gt;&lt;a href=&quot;#Leetcode-643-子数组最大平均数-I&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-643-子数组最大平均数 I&quot;&gt;&lt;/a&gt;Leetcode-643-&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-average-subarray-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;子数组最大平均数 I&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个整数，找出平均数最大且长度为 &lt;code&gt;k&lt;/code&gt; 的连续子数组，并输出该最大平均数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,12,-5,-6,50,3], k &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：12.75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最大平均数 (12-5-6+50)&amp;#x2F;4 &amp;#x3D; 51&amp;#x2F;4 &amp;#x3D; 12.75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 30,000。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所给数据范围 [-10,000，10,000]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-424-替换后的最长重复字符</title>
    <link href="http://zhuuu.work/2021/02/03/Leetcode/Leetcode-424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
    <id>http://zhuuu.work/2021/02/03/Leetcode/Leetcode-424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</id>
    <published>2021-02-03T03:52:53.000Z</published>
    <updated>2021-02-04T13:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-424-替换后的最长重复字符"><a href="#Leetcode-424-替换后的最长重复字符" class="headerlink" title="Leetcode-424-替换后的最长重复字符"></a>Leetcode-424-<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">替换后的最长重复字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p>注意：字符串长度 和 k 不会超过 104。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;ABAB&quot;, k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#39;A&#39;替换为两个&#39;B&#39;,反之亦然。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;AABABBA&quot;, k &#x3D; 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将中间的一个&#39;A&#39;替换为&#39;B&#39;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-滑动窗口"><a href="#方法一-：-滑动窗口" class="headerlink" title="方法一 ： 滑动窗口"></a>方法一 ： 滑动窗口</h2><p><strong>说一下暴力解法：</strong></p><ul><li><p>如果一个问题暂时没有思路，可以先考虑暴力解法（不一定要实现）。<strong>当前问题的暴力解法是：枚举输入字符串的 所有 子串，对于每一个子串：</strong></p><ul><li>如果子串里所有的字符都一样，就考虑长度更长的子串；</li><li>如果当前子串里出现了至少两种字符，要想使得替换以后所有的字符都一样，并且重复的、连续的部分更长，<strong>应该替换掉出现次数最多字符 以外 的字符。</strong></li></ul></li></ul><p><strong>暴力解法的缺点：</strong></p><ul><li>做了重复的工作，子串和子串有很多重合的部分，重复扫描它们是不划算的；</li><li>做了很多没有必要的工作：<ul><li><strong>如果找到了一个长度为 L 且替换 k 个字符以后全部相等的子串</strong>，就没有必要考虑长度小于等于 L 的子串，因为题目只让我们找到符合题意的最长的长度；</li><li><strong>如果找到了一个长度为 L 且替换 k 个字符以后不能全部相等的子串</strong>，左边界相同、长度更长的子串一定不符合要求（原因我们放在最后说）。</li></ul></li></ul><hr><p><strong>滑动窗口</strong></p><ul><li>以 <code>s = AABCABBB</code>，<code>k = 2</code> 为例，寻找替换 <code>k</code> 次以后字符全部相等的最长子串的长度的过程如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104646614.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104658660.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104706538.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104713644.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104722926.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104731243.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104740342.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/112527361.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113537783.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113631793.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113644299.png" alt="mark"></p><hr><ul><li><p>整个过程，我们使用了两个表示边界的变量，一前一后，交替在字符串上前进</p></li><li><p>右边界先向右移动，直到不能移动了为止，左边界再继续向右移动，整个过程像极了一条滑动的窗口在线段上移动。</p></li><li><p>除此之外，考虑的子串中最多出现的字符是次数，因此须要一个频数数组，记录每个字符出现的次数。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/114022723.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;                                <span class="comment">// 长度为0或1</span></span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化条件</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];                   <span class="comment">// 记录字符出现的频率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历一次字符数组</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 3.1 在这里维护maxCount,因为每一次右边界读入一个字符，字符的频率增加，才会使得maxCount增加</span></span><br><span class="line">            freq[charArray[right] - <span class="string">'A'</span>]++;</span><br><span class="line">            maxCount = Math.max(maxCount,freq[charArray[right] - <span class="string">'A'</span>]);</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 </span></span><br><span class="line">            <span class="keyword">if</span>(right - left &gt; maxCount + k)&#123;        <span class="comment">// 说明此时的k不够用，其他不适 最多出现的字符替换以后，都不能填满这个滑动窗口</span></span><br><span class="line">                freq[charArray[left] - <span class="string">'A'</span>]--;      <span class="comment">// 移出滑动窗口的时候，频数数组须要相应地做减法</span></span><br><span class="line">                left++;                             <span class="comment">// 左边界向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.3 </span></span><br><span class="line">            res = Math.max(res,right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是输入字符串 <code>S</code> 的长度；</li><li>空间复杂度：O(A)，这里 A<em>A</em> 是输入字符串 <code>S</code> 出现的字符 ASCII 值的范围</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-424-替换后的最长重复字符&quot;&gt;&lt;a href=&quot;#Leetcode-424-替换后的最长重复字符&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-424-替换后的最长重复字符&quot;&gt;&lt;/a&gt;Leetcode-424-&lt;a href=&quot;https://leetcode-cn.com/problems/longest-repeating-character-replacement/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;替换后的最长重复字符&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。&lt;/p&gt;
&lt;p&gt;注意：字符串长度 和 k 不会超过 104。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;ABAB&amp;quot;, k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：用两个&amp;#39;A&amp;#39;替换为两个&amp;#39;B&amp;#39;,反之亦然。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;AABABBA&amp;quot;, k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;将中间的一个&amp;#39;A&amp;#39;替换为&amp;#39;B&amp;#39;,字符串变为 &amp;quot;AABBBBA&amp;quot;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;子串 &amp;quot;BBBB&amp;quot; 有最长重复字母, 答案为 4。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-888-公平的糖果交换</title>
    <link href="http://zhuuu.work/2021/02/01/Leetcode/Leetcode-888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/"/>
    <id>http://zhuuu.work/2021/02/01/Leetcode/Leetcode-888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/</id>
    <published>2021-02-01T02:52:53.000Z</published>
    <updated>2021-02-03T12:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-888-公平的糖果棒交换"><a href="#Leetcode-888-公平的糖果棒交换" class="headerlink" title="Leetcode-888-公平的糖果棒交换"></a>Leetcode-888-<a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">公平的糖果棒交换</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。</p></li><li><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</p></li><li><p>返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。</p></li><li><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,1], B &#x3D; [2,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2], B &#x3D; [2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2], B &#x3D; [1,3]</span><br><span class="line">输出：[2,3]</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2,5], B &#x3D; [2,4]</span><br><span class="line">输出：[5,4]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; B.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; A[i] &lt;&#x3D; 100000</span><br><span class="line">1 &lt;&#x3D; B[i] &lt;&#x3D; 100000</span><br><span class="line">保证爱丽丝与鲍勃的糖果总量不同。</span><br><span class="line">答案肯定存在。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-哈希表"><a href="#方法一-：-哈希表" class="headerlink" title="方法一 ： 哈希表"></a>方法一 ： 哈希表</h2><ul><li>记爱丽丝的糖果棒的总大小为sumA，鲍勃的糖果棒的总大小为sumB。</li><li>设答案为 {x,y}，即爱丽丝的大小为 x 的糖果棒与鲍勃的大小为 y 的糖果棒交换，则有如下等式：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210203/202301960.png" alt="mark"></p><ul><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210203/202316825.png" alt="mark"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fairCandySwap(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">        <span class="comment">// 1. 分别求出数组A和B的和</span></span><br><span class="line">        <span class="keyword">int</span> sumA = Arrays.stream(A).sum();</span><br><span class="line">        <span class="keyword">int</span> sumB = Arrays.stream(B).sum();</span><br><span class="line">        <span class="keyword">int</span> delta = (sumA - sumB)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将A的数字存入哈希表 方便查询</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];                             <span class="comment">// 结果集</span></span><br><span class="line">        Set&lt;Integer&gt; setA = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:A)&#123;</span><br><span class="line">            setA.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历B中每一个元素，看A中是否存在可以交换的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y:B)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = y + delta;</span><br><span class="line">            <span class="keyword">if</span>(setA.contains(x))&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = x;</span><br><span class="line">                ans[<span class="number">1</span>] = y;</span><br><span class="line">                <span class="keyword">break</span>;                                     <span class="comment">// 存在一组立即结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度 ： O(m + n) ，最差情况下两个数组都需要进行遍历</li><li>空间复杂度 ： O(n)  , n 为 数组A的长度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-888-公平的糖果棒交换&quot;&gt;&lt;a href=&quot;#Leetcode-888-公平的糖果棒交换&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-888-公平的糖果棒交换&quot;&gt;&lt;/a&gt;Leetcode-888-&lt;a href=&quot;https://leetcode-cn.com/problems/fair-candy-swap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公平的糖果棒交换&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有多个答案，你可以返回其中任何一个。保证答案存在。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,1], B &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2], B &amp;#x3D; [2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2], B &amp;#x3D; [1,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2,5], B &amp;#x3D; [2,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[5,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; B.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 100000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; B[i] &amp;lt;&amp;#x3D; 100000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;保证爱丽丝与鲍勃的糖果总量不同。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;答案肯定存在。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-724-寻找数组的中心索引</title>
    <link href="http://zhuuu.work/2021/01/28/Leetcode/Leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
    <id>http://zhuuu.work/2021/01/28/Leetcode/Leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</id>
    <published>2021-01-28T05:24:53.000Z</published>
    <updated>2021-01-28T01:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-724-寻找数组的中心索引"><a href="#Leetcode-724-寻找数组的中心索引" class="headerlink" title="Leetcode-724-寻找数组的中心索引"></a>Leetcode-724-<a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">寻找数组的中心索引</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p></li><li><p>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p></li><li><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">索引 <span class="number">3</span> (nums[<span class="number">3</span>] = <span class="number">6</span>) 的左侧数之和 (<span class="number">1</span> + <span class="number">7</span> + <span class="number">3</span> = <span class="number">11</span>)，与右侧数之和 (<span class="number">5</span> + <span class="number">6</span> = <span class="number">11</span>) 相等。</span><br><span class="line">同时, <span class="number">3</span> 也是第一个符合要求的中心索引。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li></ul><a id="more"></a><h2 id="方法一-：-前缀和"><a href="#方法一-：-前缀和" class="headerlink" title="方法一 ： 前缀和"></a>方法一 ： 前缀和</h2><ul><li><p><strong>记录数组的全部元素之和为total</strong></p></li><li><p>当遍历到第i个元素的时候，设其左侧元素之和为sum,右侧之和就是<code>total - sum - nums[i]</code></p></li><li><p>左右侧元素相等 <code>sum = total - nums[i] - sum</code> ，即 <code>2 * sum + nums[i] = total</code></p></li><li><p>当中心索引左侧或右侧没有元素时，即为零个项相加，<strong>这在数学上称作「空和」（empty sum）。在程序设计中我们约定「空和是零」。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 计算全部元素之和</span></span><br><span class="line">        <span class="keyword">int</span> total = Arrays.stream(nums).sum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 左侧元素之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 左右侧元素之和相等</span></span><br><span class="line">        <span class="comment">// sum = total - nums[i] - sum</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * sum + nums[i] == total)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 不存在的话</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)</li><li>空间复杂度 ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-724-寻找数组的中心索引&quot;&gt;&lt;a href=&quot;#Leetcode-724-寻找数组的中心索引&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-724-寻找数组的中心索引&quot;&gt;&lt;/a&gt;Leetcode-724-&lt;a href=&quot;https://leetcode-cn.com/problems/find-pivot-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;寻找数组的中心索引&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;索引 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; (nums[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) 的左侧数之和 (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;)，与右侧数之和 (&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) 相等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;同时, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 也是第一个符合要求的中心索引。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组中不存在满足此条件的中心索引。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; 的长度范围为 &lt;code&gt;[0, 10000]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;任何一个 &lt;code&gt;nums[i]&lt;/code&gt; 将会是一个范围在 &lt;code&gt;[-1000, 1000]&lt;/code&gt;的整数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-989-数组形式的加法</title>
    <link href="http://zhuuu.work/2021/01/22/Leetcode/Leetcode-989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95/"/>
    <id>http://zhuuu.work/2021/01/22/Leetcode/Leetcode-989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95/</id>
    <published>2021-01-22T07:52:53.000Z</published>
    <updated>2021-01-22T02:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-989-数组形式的整数加法"><a href="#Leetcode-989-数组形式的整数加法" class="headerlink" title="Leetcode-989-数组形式的整数加法"></a>Leetcode-989-<a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">数组形式的整数加法</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 <code>X = 1231</code>，那么其数组形式为<code>[1,2,3,1]</code>。</p></li><li><p>给定非负整数 X 的数组形式 A，返回整数<code>X+K</code>的数组形式。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2,0,0], K &#x3D; 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 &#x3D; 1234</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2,7,4], K &#x3D; 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 &#x3D; 455</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2,1,5], K &#x3D; 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 &#x3D; 1021</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [9,9,9,9,9,9,9,9,9,9], K &#x3D; 1</span><br><span class="line">输出：[1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">解释：9999999999 + 1 &#x3D; 10000000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">0 &lt;&#x3D; A[i] &lt;&#x3D; 9</span><br><span class="line">0 &lt;&#x3D; K &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-模拟按位相加"><a href="#方法一-：-模拟按位相加" class="headerlink" title="方法一 ： 模拟按位相加"></a>方法一 ： 模拟按位相加</h2><ul><li>逐位将数字加在一起。例如计算 123+912，我们从低位到高位依次计算 3+2、2+1 和 1+9。任何时候，若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中，所以最终结果为 1035。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化参数</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从后往前逐位相加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 1.1 逐位相加</span></span><br><span class="line">            <span class="keyword">int</span> sum = A[i] + K % <span class="number">10</span>;         <span class="comment">// 每次重置sum</span></span><br><span class="line">            K /= <span class="number">10</span>;    </span><br><span class="line">            <span class="comment">// 1.2 处理两位相加 进位的情况</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                K++;                        <span class="comment">// 进位到K的末尾</span></span><br><span class="line">                sum -= <span class="number">10</span>;                  <span class="comment">// 进位清掉</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.2 当前相加的结果 添加到结果集</span></span><br><span class="line">            res.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. K的数字长度大于数组的数字长度</span></span><br><span class="line">        <span class="keyword">for</span>(;K &gt; <span class="number">0</span>;K /= <span class="number">10</span>)&#123;                <span class="comment">// 每次K左移一位</span></span><br><span class="line">            res.add(K % <span class="number">10</span>);                <span class="comment">// 添加到结果集</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将结果集翻转即是所求答案</span></span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : O(max(n,logK)) , 其中K是数组的长度</li><li>空间复杂度 : O(max(n,logK))</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-989-数组形式的整数加法&quot;&gt;&lt;a href=&quot;#Leetcode-989-数组形式的整数加法&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-989-数组形式的整数加法&quot;&gt;&lt;/a&gt;Leetcode-989-&lt;a href=&quot;https://leetcode-cn.com/problems/add-to-array-form-of-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组形式的整数加法&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 &lt;code&gt;X = 1231&lt;/code&gt;，那么其数组形式为&lt;code&gt;[1,2,3,1]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定非负整数 X 的数组形式 A，返回整数&lt;code&gt;X+K&lt;/code&gt;的数组形式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2,0,0], K &amp;#x3D; 34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：1200 + 34 &amp;#x3D; 1234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2,7,4], K &amp;#x3D; 181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,5,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：274 + 181 &amp;#x3D; 455&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2,1,5], K &amp;#x3D; 806&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,0,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：215 + 806 &amp;#x3D; 1021&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [9,9,9,9,9,9,9,9,9,9], K &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,0,0,0,0,0,0,0,0,0,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：9999999999 + 1 &amp;#x3D; 10000000000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; K &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://zhuuu.work/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1232-缀点成线</title>
    <link href="http://zhuuu.work/2021/01/17/Leetcode/Leetcode-1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/"/>
    <id>http://zhuuu.work/2021/01/17/Leetcode/Leetcode-1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/</id>
    <published>2021-01-17T07:52:53.000Z</published>
    <updated>2021-01-17T06:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1232-缀点成线"><a href="#Leetcode-1232-缀点成线" class="headerlink" title="Leetcode-1232-缀点成线"></a>Leetcode-1232-缀点成线</h1><h2 id="思路：深度优先遍历-DFS"><a href="#思路：深度优先遍历-DFS" class="headerlink" title="思路：深度优先遍历/DFS"></a>思路：深度优先遍历/DFS</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p></li><li><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。</p></li></ul><p><strong>示例1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135800973.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coordinates &#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135821014.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coordinates &#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-数学直线知识"><a href="#思路-：-数学直线知识" class="headerlink" title="思路 ： 数学直线知识"></a>思路 ： 数学直线知识</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/140102900.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 将所有点向(-deltax,-deltay) 方向进行平移 : 第一个点就移到了原点</span></span><br><span class="line">        <span class="keyword">int</span> deltaX = coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> deltaY = coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            coordinates[i][<span class="number">0</span>] -= deltaX;</span><br><span class="line">            coordinates[i][<span class="number">1</span>] -= deltaY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 两点确定一条直线 设直线方程为 Ax + By = 0 带入(-deltax_1,-deltay_1)坐标</span></span><br><span class="line">        <span class="keyword">int</span> A = coordinates[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> B = -coordinates[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 判断从原点和第一个点以外的所有点是否在这条直线上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = coordinates[i][<span class="number">0</span>];<span class="comment">// 每个点的横坐标</span></span><br><span class="line">            <span class="keyword">int</span> y = coordinates[i][<span class="number">1</span>];<span class="comment">// 每个点的纵坐标</span></span><br><span class="line">            <span class="keyword">if</span>(A * x + B * y != <span class="number">0</span>)&#123;             <span class="comment">// 说明不在直线上</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是数组中的元素数量。</li><li>时间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-1232-缀点成线&quot;&gt;&lt;a href=&quot;#Leetcode-1232-缀点成线&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1232-缀点成线&quot;&gt;&lt;/a&gt;Leetcode-1232-缀点成线&lt;/h1&gt;&lt;h2 id=&quot;思路：深度优先遍历-DFS&quot;&gt;&lt;a href=&quot;#思路：深度优先遍历-DFS&quot; class=&quot;headerlink&quot; title=&quot;思路：深度优先遍历/DFS&quot;&gt;&lt;/a&gt;思路：深度优先遍历/DFS&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135800973.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：coordinates &amp;#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135821014.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：coordinates &amp;#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://zhuuu.work/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-228-汇总区间</title>
    <link href="http://zhuuu.work/2021/01/10/Leetcode/Leetcode-228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2021/01/10/Leetcode/Leetcode-228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</id>
    <published>2021-01-10T00:33:53.000Z</published>
    <updated>2021-01-10T01:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-228-汇总区间"><a href="#Leetcode-228-汇总区间" class="headerlink" title="Leetcode-228-汇总区间"></a>Leetcode-228-<a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noopener">汇总区间</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p></li><li><p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p></li><li><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-双指针"><a href="#思路-：-双指针" class="headerlink" title="思路 ： 双指针"></a>思路 ： 双指针</h2><ul><li><strong>从数组的位置 0 出发，向右遍历。</strong></li><li>每次遇到相邻元素之间的差值大于 1 时，我们就找到了一个区间。遍历完数组之后，就能得到一系列的区间的列表。</li><li>在遍历过程中，<strong>维护下标 low 和 high 分别记录区间的起点和终点</strong><ul><li>对于任何区间都有 <code>low &lt;= high</code></li><li><strong>当得到一个区间的时候，根据low 和 high 的值生成区间的字符串表示</strong><ul><li><code>low &lt;= high</code> ，区间的字符串表示为<code>“nums[low] -&gt;nums[high]”</code></li><li><code>low == high</code> ，区间的字符串表表示为<code>&quot;nums[low]&quot;</code></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();                               <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(idx &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 1.1 区间扩大 ： 区间未断开</span></span><br><span class="line">            <span class="keyword">int</span> low = idx;                                                      <span class="comment">// 记录区间的起</span></span><br><span class="line">            idx++;                                                              <span class="comment">// ++到下一个位置 </span></span><br><span class="line">            <span class="keyword">while</span>(idx &lt; n &amp;&amp; nums[idx] == nums[idx - <span class="number">1</span>] + <span class="number">1</span>)&#123;                   <span class="comment">// 如果区间没有断开</span></span><br><span class="line">                idx++;                                                          <span class="comment">// 将区间进行扩大</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.2 记录区间的终点 ： 断开退出循环</span></span><br><span class="line">            <span class="keyword">int</span> high = idx - <span class="number">1</span>;                                                 <span class="comment">// 记录区间的终点</span></span><br><span class="line">            <span class="comment">// 1.3 处理结果</span></span><br><span class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder(Integer.toString(nums[low]));<span class="comment">// 首先加入起点位置,如果low &lt; high，当前区间为nums[low]]本身</span></span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)&#123;                                                     <span class="comment">// low &lt; high 说明是一个完整连续的区间</span></span><br><span class="line">                temp.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">                temp.append(Integer.toString(nums[high]));                      <span class="comment">// low -&gt; high</span></span><br><span class="line">            &#125;                   </span><br><span class="line">            <span class="comment">// 1.4 加入到结果集中</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)  其中n 为数组的长度</li><li>空间复杂度 ： O(1) 没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-228-汇总区间&quot;&gt;&lt;a href=&quot;#Leetcode-228-汇总区间&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-228-汇总区间&quot;&gt;&lt;/a&gt;Leetcode-228-&lt;a href=&quot;https://leetcode-cn.com/problems/summary-ranges/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汇总区间&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个无重复元素的有序整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列表中的每个区间范围 &lt;code&gt;[a,b]&lt;/code&gt; 应该按如下格式输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a-&amp;gt;b&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a != b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a == b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0,1,2,4,5,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：区间范围是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,2] --&amp;gt; &amp;quot;0-&amp;gt;2&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,5] --&amp;gt; &amp;quot;4-&amp;gt;5&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[7,7] --&amp;gt; &amp;quot;7&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0,2,3,4,6,8,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0&amp;quot;,&amp;quot;2-&amp;gt;4&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;8-&amp;gt;9&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：区间范围是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,0] --&amp;gt; &amp;quot;0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2,4] --&amp;gt; &amp;quot;2-&amp;gt;4&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[6,6] --&amp;gt; &amp;quot;6&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[8,9] --&amp;gt; &amp;quot;8-&amp;gt;9&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;-1&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 5：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>图像学-色温、白平衡与色彩恒常性</title>
    <link href="http://zhuuu.work/2021/01/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E6%B8%A9%E3%80%81%E7%99%BD%E5%B9%B3%E8%A1%A1%E4%B8%8E%E8%89%B2%E5%BD%A9%E6%81%92%E5%B8%B8%E6%80%A7/"/>
    <id>http://zhuuu.work/2021/01/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E6%B8%A9%E3%80%81%E7%99%BD%E5%B9%B3%E8%A1%A1%E4%B8%8E%E8%89%B2%E5%BD%A9%E6%81%92%E5%B8%B8%E6%80%A7/</id>
    <published>2021-01-09T09:38:38.000Z</published>
    <updated>2021-05-16T03:10:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-色温、白平衡与色彩恒常性"><a href="#图像学-色温、白平衡与色彩恒常性" class="headerlink" title="图像学-色温、白平衡与色彩恒常性"></a>图像学-色温、白平衡与色彩恒常性</h1><h2 id="1-色温"><a href="#1-色温" class="headerlink" title="1. 色温"></a>1. 色温</h2><ul><li><strong>色温这个概念是从黑体辐射来的。</strong></li><li>根据日常的经验我们可以知道，给一个铁块加热，随着温度升高，铁块开始是暗红色，逐渐变成亮红色，如果能达到炼钢炉里那样的高温，铁融化成铁水，发出耀眼的金黄色光芒。</li><li>而天文学家也告诉我们，宇宙中的恒星可以看做一个个黑体，随着恒星温度的升高，恒星的颜色也是从红色到黄色，非常高温度的恒星甚至发出偏蓝色的光。</li></ul><p>直接渲染了不同温度下黑体辐射的颜色。下图就是渲染出的不同温度黑体的颜色。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/160318930.png" alt="mark"></p><p>​                                                                            （黑体辐射的颜色）</p><a id="more"></a><ul><li><p>从这个例子里可以看出，随着温度的升高，黑体的颜色从暗红到亮红，逐渐到金黄色，再慢慢到蓝色。</p></li><li><p>在下面这个色品图上可以看得更清楚，随着温度升高，黑体颜色在色品图上移动，形成一条曲线轨迹</p></li><li><p>这条轨迹从右下角的红色区域出发，经过黄色区域，中间的白色区域，到达左侧的蓝色区域。这条轨迹就叫做 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Planckian_locus">普朗克轨迹</a>。下图显示了色品图上的普朗克轨迹（来自维基百科 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Planckian_locus">普朗克轨迹</a>）</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/161107925.png" alt="mark"></p><p>​                                                                                （普朗克轨迹）</p><ul><li>我们日常生活中，最重要的光源就是太阳，太阳发出的光很接近黑体光谱。我们的太阳表面温度约为 5500K，这个温度的黑体发出的光，基本就是白色。</li><li>读过本专栏之前文章的读者朋友肯定能理解，这当然不是巧合。在色彩空间中我们需要定义一个白点，而常见的一些标准白点，就是以 5500K 左右的黑体辐射（也就是我们的太阳）为基础的。</li><li>CIE 委员会规定的几种标准白点中，D50、D55 和 D65 是常用的白点，参照了 5000K、5500K 和 6500K 的黑体辐射来定义，模拟了不同条件下（比如地平线方向的光照，上下午的室外，正午室外）的光照。</li><li>色彩空间 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/SRGB">sRGB</a> 所依赖的白点就是 D65。</li></ul><hr><p>注意：</p><ul><li>对于色温，通常有几个误解。<strong>第一个误解是</strong>混淆了色温和情感上的温度倾向。我们必须理解，色温是根据黑体辐射温度来定义的，是物理上的温度，而不是情感上的温度。<ul><li>从我们的情感上来说，橙色红色给人感觉温暖，蓝色给人感觉寒冷。但从色温的定义来看，红色橙色是温度较低的黑体发出的颜色，而温度高的黑体颜色反而是蓝色。</li></ul></li><li><strong>第二个误解</strong>是混淆了色温针对的对象。狭义上来说，色温是针对光源的。比如晴朗正午的室外，光源是太阳（以及部分蓝天），这个时候的光源接近标准光源 D65，色温接近 6500K；<ul><li>又比如说傍晚日落，经过大气层的散射，阳光中的蓝光大大减少，光线颜色偏黄，光源颜色也许接近 3500K 的黑体。</li></ul></li></ul><h2 id="2-白平衡"><a href="#2-白平衡" class="headerlink" title="2. 白平衡"></a>2. 白平衡</h2><ul><li><p>物理世界里是无所谓「颜色」这个概念的，一切都是 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Spectral_power_distribution">光谱功率分布</a>，所谓的「颜色」，是人类视觉过程产生的一种感受。</p></li><li><p>正是如此，我们才有了「三原色」理论，我们才可以用三种颜色的光来模拟世间万物的颜色。</p></li><li><p>生活常识告诉我们，光源的颜色不同，照射到同一个物体上，会引起物体颜色的变化。从单纯的物理的角度来看，这个事情再正常不过了。</p></li><li><p>光源有光谱功率分布，物体对不同波长的光线又有不同的反射率，那么光源照射到物体上，再反射到眼睛里的光，它的光谱功率分布就和光源密切相关了。</p></li><li><p>不同的光源，照射到同样的物体上，物体反射光的光谱功率分布就会不一样。</p></li></ul><p>下图展示了一个例子，物体的反射率是对蓝色光更高，对红色光更低。</p><ul><li>第一行的光源是一个接近白色的光源，照射到物体上之后，反射的光线就是蓝色；</li><li>而第二行的光源是一个黄色的光源，照射到物体上之后，反射的光线是偏棕红色的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/164802986.png" alt="mark"></p><p>​                                                            （不同光源下物体有不同颜色）</p><ul><li>这里需要再强调一下，物理上没有所谓的「颜色」的概念，只有「光谱功率分布」、「反射率」这些概念。一个物体的反射率是固定不变的，但是这个物体的「颜色」在不同条件下是不一样的。<ul><li>我们可以用一个标准白点（比如 D65）作为光源，照射到物体上。我们认为这个时候物体表现出来的「颜色」就是物体「本来」的颜色，可以定义为物体的「固有色」。</li><li>很显然，固有色的光谱功率分布曲线与物体本身的反射率曲线两者是很接近的（参见上图中第一行的例子）。</li></ul></li></ul><ul><li><p><strong>白平衡（<a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Color_balance">White Balance</a>）要做的</strong>，就是在不同的光线条件下，根据当时得到的物体颜色，尽量恢复物体的「固有色」，</p><ul><li>或者说，尽量减小光源颜色对物体颜色的影响。（在下一节会继续讨论这个定义的合理性，本小节中先按照这个定义进行讨论）。</li><li>我们可以在色彩转换的过程中根据光源的情况指定不同的白点，从而得到相应正确的色彩转换结果。举例来说，在晴天正午室外拍摄的一张照片，光源近似于标准白点 D65，那么我们就用 D65 点作为白点进行色彩转换（实际上就是直接用 sRGB 空间进行展示）。</li><li>又比如在黄昏的光线下拍摄了照片，<strong>此时光源接近 2500K 的黑体</strong>，那么我们从普朗克曲线上找到 2500K 的点，作为新的白点，进行色彩转换，就能得到正确的颜色。</li><li><strong>由于色彩空间的线性性质，这个转换过程就是一个矩阵乘法</strong>，非常方便。详细的计算过程可以参见之前的文章，这里不再赘述。</li></ul></li><li><p><strong>这就是相机上色温调节的原理。</strong></p><ul><li>也就是说，相机上的色温选项，<strong>调节的是色彩转换中的白点的位置，在普朗克曲线上选取与色温相对应的点作为白点进行色彩转换，从而得到正确的颜色。</strong></li><li><strong>这个色温选项，是要与拍摄时的光源色温相匹配的</strong>，这也是为什么在晴朗的白天拍摄，色温控制在 5000K ~ 6000K 是比较合适的，而在黄昏时候拍摄，色温需要设置成 2500K ~ 3000K 才比较合适。</li></ul></li></ul><hr><p>注意：</p><ul><li>可以看到，沿着普朗克线移动白点，总体上是调节了画面偏蓝或者偏黄的色彩倾向。</li><li>当然，<strong>完整的白平衡要求白点可以任意设置，所以必须增加第二个移动方向。</strong><ul><li><strong>最合理的选择就是与普朗克线正交的另一个方向</strong></li><li>从色品图上看大致是从左上角到右下侧直线边的方向，也就是绿色到品红的方向。</li></ul></li><li>正因为如此，我们可以看到，<code>Photoshop、Lightroom</code>这样的照片处理软件，白平衡的面板上总是会有两个调节滑块<ul><li>一个调节黄-蓝平衡，<strong>通常叫色温（<code>Temperature</code>）</strong></li><li>一个调节绿-品红平衡，<strong>通常叫色调（Tint）</strong></li><li>这两个方向互相配合，才能使得白点位于色品图中的任意位置，才能对任意光线条件下拍摄的照片进行白平衡的调节。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/165816640.png" alt="mark"></p><p>​                                                        <strong>（Photoshop 中的白平衡调节面板）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/165629562.png" alt="mark"></p><p>​                                                                <strong>（色温和色调调节）</strong></p><h2 id="3-色彩恒常性"><a href="#3-色彩恒常性" class="headerlink" title="3. 色彩恒常性"></a>3. 色彩恒常性</h2><ul><li>白平衡解决了「怎样才能正确得到白色」的问题，在上一小节中，我提出白平衡的目的是「在不同的光线条件下，根据当时得到的物体颜色，尽量恢复物体的固有色」，这句话看似简单，仔细想想，却又并不那么显然</li><li>一个很明显的疑问是：我们怎么知道什么是物体的固有色？白炽灯照明下的一张白纸，与阳光照明下的一张橙黄色的纸，两者从物理上而言可以是几乎一样的，或者说两者的光谱功率分布函数，可以是几乎一样的。那么我们凭什么说一张是白纸，一张是橙黄色的纸呢？</li></ul><p>答案是，不能区分。如果仅仅看这张纸的话，我们不能区分哪张是白纸，哪张是黄纸。</p><hr><ul><li><p>但是，我们不仅仅只看了纸，我们还看到了周围的景物，也许是摆放纸张的书桌，也许是周围的植物盆景，也许是旁边的水果，甚至是我们自己的手。</p></li><li><p>所有这一切，都帮助我们认识周围的环境，根据环境去推测这张纸本来的颜色。</p></li><li><p>人类视觉过程不仅仅有视网膜的参与，更重要的还有大脑的参与。视觉是人类获取外界信息最重要的手段，在日复一日的使用中，人类大脑对外界环境建立起了复杂的感知和对应。我们的大脑早就知道，植物叶子是绿色的，樱桃是红色的，我们的皮肤是黄色</p></li><li><p><strong>通过对这些周围环境的感知，我们的大脑推断出了这个时候光源的情况——是白炽灯还是阳光，从而自动完成了「白平衡」的过程，使得我们迅速感知到一个物体本来的颜色是什么。这就是人类视觉的色彩恒常性。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/150214753.png" alt="mark"></p><p>​                                                            没有红色的草莓</p><ul><li>上图是一个很好的例子（图片来自 <a href="https://link.zhihu.com/?target=http%3A//www.psy.ritsumei.ac.jp/~akitaoka/colorconstancy6e.html">Color constancy</a>），在这幅图中，如果我们单独一个一个像素点来看，没有一个像素点是红色的，所有的像素点都是绿色、青色、灰色，图中选取的几个像素点的 RGB 值也充分说明了这一点</li><li>但是当我们从整体来这张图，立刻会产生「红色草莓」、「黄色木桌」、「白色盘子」的印象。<strong>这就是我们大脑根据一些「先验知识」进行自动白平衡的结果。</strong></li></ul><hr><p>当然，在没有一个强有力的先验知识的情况下，人类也很容易给出错误的答案。君不见引起网络大撕逼的「白金、蓝黑」神奇衣服？</p><ul><li><p>在我看来，这些争论都是没什么意义的，因为图片提供的场景信息太少，人类的大脑还不足以利用先验知识，建立对当场光源的感知，只能凭借自身的经验进行推断，而每个人自身经验千差万别，自然也没办法正确推断衣服的颜色了。</p></li><li><p>如果大家能在现场看一眼，或者图片作者能上传一段附带周围环境的视频，我想大概就不会有人对这件衣服的颜色有疑问了。</p></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/151159127.png" alt="mark" style="zoom:80%;" /><p>​                                                    <strong>（白金？蓝黑？）</strong></p><hr><p>当然，我们可以有意识地利用这种错觉，造成一些有趣的结果。比如下图中，绿色条纹和蓝色条纹，其实是同一种颜色（图片来自 <a href="https://link.zhihu.com/?target=http%3A//www.independent.co.uk/news/weird-news/forget-the-dress-theres-another-optical-illusion-blowing-our-minds-10076727.html">independent</a>）。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/151241238.png" alt="mark"></p><p>​                                                            <strong>（绿色？蓝色？）</strong></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol><li><p><strong>色温是根据黑体辐射进行定义的，橙黄色色温低，蓝色色温高；</strong></p></li><li><p><strong>相机中的色温设置，需要与当时光源的色温相匹配；</strong></p></li><li><p><strong>白平衡的目的，是希望在不同光线条件下，都能正确得到物体的固有色；</strong></p></li><li><p><strong>白平衡本质上是调节两个参数：色温和色调</strong></p><ul><li>色温条件蓝-&gt;黄 的色调</li><li>色调调节绿-&gt;品红偏色</li><li>白平衡通过调节两个参数，来设置白点的位置，从而得到正确的色彩转换</li></ul></li><li><p><strong>人类视觉具有色彩恒常性，是大脑对外界环境感知的反应。当外界环境信息不足时，无法建立正确的色彩恒常感知。</strong></p></li></ol><p><strong>参考博客</strong> ： <a href="https://zhuanlan.zhihu.com/p/27165715" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27165715</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-色温、白平衡与色彩恒常性&quot;&gt;&lt;a href=&quot;#图像学-色温、白平衡与色彩恒常性&quot; class=&quot;headerlink&quot; title=&quot;图像学-色温、白平衡与色彩恒常性&quot;&gt;&lt;/a&gt;图像学-色温、白平衡与色彩恒常性&lt;/h1&gt;&lt;h2 id=&quot;1-色温&quot;&gt;&lt;a href=&quot;#1-色温&quot; class=&quot;headerlink&quot; title=&quot;1. 色温&quot;&gt;&lt;/a&gt;1. 色温&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;色温这个概念是从黑体辐射来的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根据日常的经验我们可以知道，给一个铁块加热，随着温度升高，铁块开始是暗红色，逐渐变成亮红色，如果能达到炼钢炉里那样的高温，铁融化成铁水，发出耀眼的金黄色光芒。&lt;/li&gt;
&lt;li&gt;而天文学家也告诉我们，宇宙中的恒星可以看做一个个黑体，随着恒星温度的升高，恒星的颜色也是从红色到黄色，非常高温度的恒星甚至发出偏蓝色的光。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接渲染了不同温度下黑体辐射的颜色。下图就是渲染出的不同温度黑体的颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/160318930.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;​                                                                            （黑体辐射的颜色）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-547-省份数量</title>
    <link href="http://zhuuu.work/2021/01/07/Leetcode/Leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <id>http://zhuuu.work/2021/01/07/Leetcode/Leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</id>
    <published>2021-01-07T07:21:53.000Z</published>
    <updated>2021-01-07T02:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-547-省份数量"><a href="#Leetcode-547-省份数量" class="headerlink" title="Leetcode-547-省份数量"></a>Leetcode-547-<a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener">省份数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p></li><li><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p></li><li><p>给你一个 n x n 的矩阵<code>isConnected</code>，其中<code>isConnected[i][j] = 1</code> 表示第 i 个城市和第 j 个城市直接相连，而<code>isConnected[i][j] = 0</code>表示二者不直接相连。</p></li><li><p>返回矩阵中 省份 的数量。</p></li></ul><p><strong>示例一 ：</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093358281.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093431219.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 200</span><br><span class="line">n &#x3D;&#x3D; isConnected.length</span><br><span class="line">n &#x3D;&#x3D; isConnected[i].length</span><br><span class="line">isConnected[i][j] 为 1 或 0</span><br><span class="line">isConnected[i][i] &#x3D;&#x3D; 1</span><br><span class="line">isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>可以把 n个城市和它们之间的相连关系看成图，城市是图中的节点，相连关系是图中的边，</p></li><li><p>给定的矩阵 <code>isConnected</code> 即为图的邻接矩阵，</p></li><li><p>省份即为图中的连通分量。</p></li></ul><p>计算省份总数，等价于计算图中的连通分量数，<strong>可以通过深度优先搜索或广度优先搜索实现，也可以通过并查集实现。</strong></p><h2 id="方法一-：-DFS"><a href="#方法一-：-DFS" class="headerlink" title="方法一 ： DFS"></a>方法一 ： DFS</h2><ul><li>深度优先搜索的思路很直观<ul><li>遍历所有的城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索</li><li>通过矩阵<code>isConnected</code> 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量</li><li>然后对这些城市继续进行深度优先搜索，直到同一个连通分量的所有城市都被访问到，即可得到一个省份</li><li>遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始需要的变量</span></span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;                 <span class="comment">// 城市数量</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[provinces];         <span class="comment">// 标记该城市是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;                                    <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历所有的城市</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; provinces;i++)&#123;</span><br><span class="line">            <span class="comment">// 2.1 对于该城市尚未被访问过，从该城市开始深度优先搜索</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;                                <span class="comment">// 该城市没有被访问过</span></span><br><span class="line">                dfs(isConnected,visited,provinces,i);       <span class="comment">// 2.2 dfs 逻辑</span></span><br><span class="line">                circles++;                                  <span class="comment">// 直到同一个连通分量的所有城市都被访问到，即可得到一个省份</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.2 dfs 逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] isConnected,<span class="keyword">boolean</span>[] visited,<span class="keyword">int</span> provinces,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; provinces;j++)&#123;                  <span class="comment">// i : 作为起点 ，遍历 i 行元素，得到这一行元素（城市） 哪些是连通的</span></span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;     <span class="comment">// 如果到达一个没有访问过且可达的元素（城市）</span></span><br><span class="line">                visited[j] = <span class="keyword">true</span>;                         <span class="comment">// 标记为访问过           </span></span><br><span class="line">                dfs(isConnected,visited,provinces,j);      <span class="comment">// j : 作为起点， 遍历 j 行元素，得到这一行元素（城市） 哪些是连通的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n^2)，其中 <em>n</em> 是城市的数量。需要遍历矩阵 n 中的每个元素。</li><li>空间复杂度：  O(n)，其中 n 是城市的数量。<ul><li>需要使用数组visited 记录每个城市是否被访问过，数组长度是 n，</li><li>递归调用栈的深度不会超过 n。</li></ul></li></ul><h2 id="方法二-：-BFS"><a href="#方法二-：-BFS" class="headerlink" title="方法二 ： BFS"></a>方法二 ： BFS</h2><ul><li>对于每个城市，如果该城市尚未被访问过，则从该城市开始广度优先搜索，直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始需要的变量</span></span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;                         <span class="comment">// 城市数量</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[provinces];                 <span class="comment">// 标记该城市是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;                                            <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. BFS 逻辑</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();                  <span class="comment">// 2.1 队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; provinces;i++)&#123;                           <span class="comment">// 遍历每个城市</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;                                        <span class="comment">// 如果该城市未被访问过</span></span><br><span class="line">                queue.offer(i);                                     <span class="comment">// 从该城市开始BFS搜索</span></span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;                            <span class="comment">// 2.2 BFS逻辑</span></span><br><span class="line">                    <span class="keyword">int</span> j = queue.poll();                           <span class="comment">// 弹出该城市</span></span><br><span class="line">                    visited[j] = <span class="keyword">true</span>;                              <span class="comment">// 标记该城市为访问过</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; provinces;k++)&#123;               <span class="comment">// 遍历与该城市所有邻接的城市</span></span><br><span class="line">                        <span class="keyword">if</span>(isConnected[j][k] == <span class="number">1</span> &amp;&amp; !visited[k])&#123;  <span class="comment">// 如果可以访问到</span></span><br><span class="line">                            queue.offer(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                circles++;                                          <span class="comment">// 直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n^2)，其中 <em>n</em> 是城市的数量。需要遍历<code>isConnected</code>中的每个元素</li><li>空间复杂度：  O(n)，其中 n 是城市的数量。<ul><li>visited 数组长度不会超过n</li><li>广度优先搜索队列元素不会超过n</li></ul></li></ul><h2 id="方法三-：-并查集"><a href="#方法三-：-并查集" class="headerlink" title="方法三 ： 并查集"></a>方法三 ： 并查集</h2><ul><li>待学习</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[provinces];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; provinces; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    union(parent, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">                circles++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-547-省份数量&quot;&gt;&lt;a href=&quot;#Leetcode-547-省份数量&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-547-省份数量&quot;&gt;&lt;/a&gt;Leetcode-547-&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-provinces/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;省份数量&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给你一个 n x n 的矩阵&lt;code&gt;isConnected&lt;/code&gt;，其中&lt;code&gt;isConnected[i][j] = 1&lt;/code&gt; 表示第 i 个城市和第 j 个城市直接相连，而&lt;code&gt;isConnected[i][j] = 0&lt;/code&gt;表示二者不直接相连。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回矩阵中 省份 的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例一 ：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093358281.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：isConnected &amp;#x3D; [[1,1,0],[1,1,0],[0,0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093431219.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：isConnected &amp;#x3D; [[1,0,0],[0,1,0],[0,0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n &amp;#x3D;&amp;#x3D; isConnected.length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n &amp;#x3D;&amp;#x3D; isConnected[i].length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][j] 为 1 或 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][i] &amp;#x3D;&amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][j] &amp;#x3D;&amp;#x3D; isConnected[j][i]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="并查集" scheme="http://zhuuu.work/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="BFS" scheme="http://zhuuu.work/tags/BFS/"/>
    
      <category term="DFS" scheme="http://zhuuu.work/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-830-较大分组的位置</title>
    <link href="http://zhuuu.work/2021/01/05/Leetcode/Leetcode-830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://zhuuu.work/2021/01/05/Leetcode/Leetcode-830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-01-05T00:52:53.000Z</published>
    <updated>2021-01-05T01:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-830-较大分组的位置"><a href="#Leetcode-830-较大分组的位置" class="headerlink" title="Leetcode-830-较大分组的位置"></a>Leetcode-830-较大分组的位置</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p></li><li><p>例如，在字符串<code>s = &quot;abbxxxxzyy&quot;</code>中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p></li><li><p>分组可以用区间 <code>[start, end]</code>表示,其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p></li><li><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p></li><li><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abbxxxxzzy&quot;</span><br><span class="line">输出：[[3,6]]</span><br><span class="line">解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出：[[3,5],[6,9],[12,14]]</span><br><span class="line">解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;aba&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅含小写英文字母</li></ul><a id="more"></a><h2 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();                <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span> n   = s.length();                                       <span class="comment">// 字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;                                                <span class="comment">// 用于记录分组长度 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 一次遍历该字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="comment">// 2.1 如果下一个字符与当前字符不同,或者已经枚举到字符串尾部,就说明当前字符为当前分组的尾部</span></span><br><span class="line">            <span class="keyword">if</span>(i == n - <span class="number">1</span> || s.charAt(i) != s.charAt(i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= <span class="number">3</span>)&#123;                                       <span class="comment">// 如果分组长度达到3</span></span><br><span class="line">                    res.add(Arrays.asList(i - num + <span class="number">1</span>,i));          <span class="comment">// 记录结果</span></span><br><span class="line">                &#125;   </span><br><span class="line">                num = <span class="number">1</span>;                                            <span class="comment">// 重置分组长度</span></span><br><span class="line">            <span class="comment">// 2.2 字符重复的情况</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num++;                                              <span class="comment">// ++字符分区长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回结果集</span></span><br><span class="line">        <span class="keyword">return</span> res;                                                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)</li><li>空间复杂度 ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-830-较大分组的位置&quot;&gt;&lt;a href=&quot;#Leetcode-830-较大分组的位置&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-830-较大分组的位置&quot;&gt;&lt;/a&gt;Leetcode-830-较大分组的位置&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如，在字符串&lt;code&gt;s = &amp;quot;abbxxxxzyy&amp;quot;&lt;/code&gt;中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分组可以用区间 &lt;code&gt;[start, end]&lt;/code&gt;表示,其中 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分别表示该分组的起始和终止位置的下标。上例中的 &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt; 分组用区间表示为 &lt;code&gt;[3,6]&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们称所有包含大于或等于三个连续字符的分组为 &lt;strong&gt;较大分组&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;找到每一个 &lt;strong&gt;较大分组&lt;/strong&gt; 的区间，&lt;strong&gt;按起始位置下标递增顺序排序后&lt;/strong&gt;，返回结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abbxxxxzzy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[3,6]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&amp;quot;xxxx&amp;quot; 是一个起始于 3 且终止于 6 的较大分组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot; 和 &amp;quot;c&amp;quot; 均不是符合要求的较大分组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abcdddeeeeaabbbcd&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[3,5],[6,9],[12,14]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：较大分组为 &amp;quot;ddd&amp;quot;, &amp;quot;eeee&amp;quot; 和 &amp;quot;bbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;aba&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅含小写英文字母&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-509-斐波那契数</title>
    <link href="http://zhuuu.work/2021/01/04/Leetcode/Leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://zhuuu.work/2021/01/04/Leetcode/Leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2021-01-04T00:52:53.000Z</published>
    <updated>2021-01-04T01:19:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-509-斐波那契数"><a href="#Leetcode-509-斐波那契数" class="headerlink" title="Leetcode-509-斐波那契数"></a>Leetcode-509-<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路一-：-动态规划"><a href="#思路一-：-动态规划" class="headerlink" title="思路一 ： 动态规划"></a>思路一 ： 动态规划</h2><ul><li><p>斐波那契数的边界条件是 <code>F(0) =0</code> 和 <code>F(1)=1</code>。</p></li><li><p>n&gt;1时，每一项的和都等于前两项的和，因此有如下递推关系：</p><ul><li>​                                            F<em>(</em>n<em>)=*F</em>(<em>n</em>−1)+<em>F</em>(<em>n</em>−2)</li></ul></li></ul><ul><li><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 F(0) 和 F(1)。</p></li><li><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n) 的实现。</p></li><li><p><strong>由于 F(n) 只和 F(n-1)与 F(n-2)有关，因此可以使用「滚动数组思想」把空间复杂度优化成 O(1)。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/085317533.gif" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.初始化变量</span></span><br><span class="line">        <span class="keyword">int</span> dp_a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 3. 滚动数组：动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp_a = dp_b;</span><br><span class="line">            dp_b = dp_i;</span><br><span class="line">            dp_i = dp_a + dp_b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h2 id="思路二-：-数学通项"><a href="#思路二-：-数学通项" class="headerlink" title="思路二 ： 数学通项"></a>思路二 ： 数学通项</h2><ul><li>斐波那契数 F(n)是齐次线性递推，根据递推方程 F(n)=F(n-1)+F(n-2)可以写出这样的特征方程：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/090716393.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/091850906.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt_5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fib_n  = Math.pow((<span class="number">1</span> + sqrt_5)/<span class="number">2</span>,n) - Math.pow((<span class="number">1</span> - sqrt_5)/<span class="number">2</span>,n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.round(fib_n/sqrt_5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>与各个语言的pow 函数有关</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-509-斐波那契数&quot;&gt;&lt;a href=&quot;#Leetcode-509-斐波那契数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-509-斐波那契数&quot;&gt;&lt;/a&gt;Leetcode-509-&lt;a href=&quot;https://leetcode-cn.com/problems/fibonacci-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;斐波那契数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt;，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) &amp;#x3D; 0，F(1) &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(n) &amp;#x3D; F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;给你 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(2) &amp;#x3D; F(1) + F(0) &amp;#x3D; 1 + 0 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(3) &amp;#x3D; F(2) + F(1) &amp;#x3D; 1 + 1 &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(4) &amp;#x3D; F(3) + F(2) &amp;#x3D; 2 + 1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-205-同构字符串</title>
    <link href="http://zhuuu.work/2020/12/27/Leetcode/Leetcode-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/12/27/Leetcode/Leetcode-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-12-27T00:52:53.000Z</published>
    <updated>2021-01-17T02:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-205-同构字符串"><a href="#Leetcode-205-同构字符串" class="headerlink" title="Leetcode-205-同构字符串"></a>Leetcode-205-<a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">同构字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定两个字符串 <strong><em>s</em></strong> 和 <em>t</em>，判断它们是否是同构的。</li><li>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <em>t</em> ，那么这两个字符串是同构的。</li><li>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">你可以假设 s 和 t 具有相同的长度。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-集合论双射"><a href="#思路-：-集合论双射" class="headerlink" title="思路 ： 集合论双射"></a>思路 ： 集合论双射</h2><ul><li><p>此题是「290. 单词规律」的简化版，</p></li><li><p><strong>需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。</strong></p><ul><li>以示例 2 为例，t 中的字符 a 和 r 虽然有唯一的映射 o，但对于 s 中的字符 o 来说其存在两个映射 {a,r}，故不满足条件。</li></ul></li></ul><ul><li>因此 ， 我们需要维护两张哈希表。<ul><li>第一张哈希表s2t : 以s中的字符为键，t中的字符为值</li><li>第二张哈希表t2s : 以t中的字符为键，s中的字符为值</li></ul></li></ul><p><strong>算法整体</strong></p><ol><li>从左直右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突，说明两个字符无法构成同构，返回false</li><li>如果遍历没有发生冲突，说明两个字符串是同构的 ， 返回true 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Leetcode__205;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringtostring</span><span class="params">(String input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">booleanToString</span><span class="params">(<span class="keyword">boolean</span> input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input?<span class="string">"True"</span>:<span class="string">"False"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String s = stringtostring(line);</span><br><span class="line">            line = in.readLine();</span><br><span class="line">            String t = stringtostring(line);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> ret = <span class="keyword">new</span> Solution().isIsomorphic(s,t);</span><br><span class="line">            String out = booleanToString(ret);</span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化</span></span><br><span class="line">        Map&lt;Character,Character&gt; s2t = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Character&gt; t2s = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            <span class="comment">// 2.1 拿到当前字符做判断</span></span><br><span class="line">            <span class="keyword">char</span> curr_s = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> curr_t = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>((s2t.containsKey(curr_s) &amp;&amp; s2t.get(curr_s) != curr_t) || (t2s.containsKey(curr_t) &amp;&amp; t2s.get(curr_t) != curr_s))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.2 不在map中就放入到map中</span></span><br><span class="line">            s2t.put(curr_s,curr_t);</span><br><span class="line">            t2s.put(curr_t,curr_s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度：O(n)，其中 n 为字符串的长度。</strong>我们只需同时遍历一遍字符串 s和 t 即可。</p></li><li><p><strong>空间复杂度：O(∣Σ∣)，其中 \SigmaΣ 是字符串的字符集。</strong>哈希表存储字符的空间取决于字符串的字符集大小，最坏情况下每个字符均不相同，需要 O(∣Σ∣) 的空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-205-同构字符串&quot;&gt;&lt;a href=&quot;#Leetcode-205-同构字符串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-205-同构字符串&quot;&gt;&lt;/a&gt;Leetcode-205-&lt;a href=&quot;https://leetcode-cn.com/problems/isomorphic-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;同构字符串&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;em&gt;t&lt;/em&gt;，判断它们是否是同构的。&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 中的字符可以被替换得到 &lt;em&gt;t&lt;/em&gt; ，那么这两个字符串是同构的。&lt;/li&gt;
&lt;li&gt;所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;egg&amp;quot;, t &amp;#x3D; &amp;quot;add&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;foo&amp;quot;, t &amp;#x3D; &amp;quot;bar&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;paper&amp;quot;, t &amp;#x3D; &amp;quot;title&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 s 和 t 具有相同的长度。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>单调栈-合集</title>
    <link href="http://zhuuu.work/2020/12/25/LeetcodeExplore/%E5%8D%95%E8%B0%83%E6%A0%88-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/12/25/LeetcodeExplore/%E5%8D%95%E8%B0%83%E6%A0%88-%E5%90%88%E9%9B%86/</id>
    <published>2020-12-25T07:11:53.000Z</published>
    <updated>2020-12-26T02:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈-合集"><a href="#单调栈-合集" class="headerlink" title="单调栈-合集"></a>单调栈-合集</h1><p>以下列出了单调栈的问题，供大家参考。</p><table><thead><tr><th><strong>序号</strong></th><th><strong>题目</strong></th><th><strong>题解</strong></th></tr></thead><tbody><tr><td>1</td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水（困难）</a></td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/" target="_blank" rel="noopener">暴力解法、优化、双指针、单调栈</a></td></tr><tr><td>2</td><td><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度（中等）</a></td><td><a href="https://leetcode-cn.com/problems/daily-temperatures/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419/" target="_blank" rel="noopener">暴力解法 + 单调栈</a></td></tr><tr><td>3</td><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I（简单）</a></td><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419-2/" target="_blank" rel="noopener">暴力解法、单调栈</a></td></tr><tr><td>4</td><td><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母（困难）</a></td><td><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/zhan-by-liweiwei1419/" target="_blank" rel="noopener">栈 + 哨兵技巧（Java、C++、Python）</a></td></tr><tr><td>5</td><td><a href="https://leetcode-cn.com/problems/online-stock-span/" target="_blank" rel="noopener">901. 股票价格跨度（中等）</a></td><td><a href="https://blog.csdn.net/lw_power/article/details/103957702" target="_blank" rel="noopener"> 「力扣」第 901 题：股票价格跨度（单调栈）</a></td></tr><tr><td>6</td><td><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></td><td></td></tr><tr><td>7</td><td><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></td><td></td></tr><tr><td>8</td><td></td><td></td></tr><tr><td>9</td><td></td><td></td></tr></tbody></table><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单调栈-合集&quot;&gt;&lt;a href=&quot;#单调栈-合集&quot; class=&quot;headerlink&quot; title=&quot;单调栈-合集&quot;&gt;&lt;/a&gt;单调栈-合集&lt;/h1&gt;&lt;p&gt;以下列出了单调栈的问题，供大家参考。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;题解&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;42. 接雨水（困难）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法、优化、双指针、单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;739. 每日温度（中等）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法 + 单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;496. 下一个更大元素 I（简单）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法、单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;316. 去除重复字母（困难）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/solution/zhan-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;栈 + 哨兵技巧（Java、C++、Python）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/online-stock-span/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;901. 股票价格跨度（中等）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://blog.csdn.net/lw_power/article/details/103957702&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 「力扣」第 901 题：股票价格跨度（单调栈）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;402. 移掉K位数字&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;581. 最短无序连续子数组&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://zhuuu.work/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-290-单词规律</title>
    <link href="http://zhuuu.work/2020/12/16/Leetcode/Leetcode-290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/"/>
    <id>http://zhuuu.work/2020/12/16/Leetcode/Leetcode-290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</id>
    <published>2020-12-16T05:52:53.000Z</published>
    <updated>2020-12-16T08:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-290-单词规律"><a href="#Leetcode-290-单词规律" class="headerlink" title="Leetcode-290-单词规律"></a>Leetcode-290-<a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">单词规律</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p></li><li><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着<strong>双向连接的对应规律</strong>。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;aaaa&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br><span class="line">说明:</span><br><span class="line">你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。</span><br></pre></td></tr></table></figure><p>​    </p><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li><p>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。<strong>在集合论中，这种关系被称为「双射」。</strong></p></li><li><p>想要解决本题，我们可以利用<strong>哈希表记录每一个字符对应的字符串</strong>，<strong>以及每一个字符串对应的字符。</strong></p></li><li><p>然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。</p></li></ul><p><strong>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。</strong></p><p><strong>每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Character&gt; str2ch = <span class="keyword">new</span> HashMap&lt;&gt;();         <span class="comment">// 字符串映射字符</span></span><br><span class="line">        Map&lt;Character,String&gt; ch2str = <span class="keyword">new</span> HashMap&lt;&gt;();         <span class="comment">// 字符映射字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m   = s.length();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;                                            <span class="comment">// idx 用于记录每个单词的开头位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举pattern中的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>;p &lt; pattern.length();++p)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern.charAt(p);                                <span class="comment">// 枚举pattern中的每一个字符</span></span><br><span class="line">            <span class="keyword">if</span>(idx &gt;= m)&#123;                                               <span class="comment">// 说明字符和对应字符串的数量不匹配，直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理空格之间的字符串单词</span></span><br><span class="line">            <span class="keyword">int</span> j = idx;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; m &amp;&amp; s.charAt(j) != <span class="string">' '</span>)&#123;                         <span class="comment">// j用于记录每个字符串单词的结束位置</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            String temp = s.substring(idx,j);                           <span class="comment">// 拿出空格之间的这个单词</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 离散数学：集合的双射匹配</span></span><br><span class="line">            <span class="keyword">if</span>(str2ch.containsKey(temp) &amp;&amp; str2ch.get(temp) != ch)&#123;     <span class="comment">// 字符串不匹配字符直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch2str.containsKey(ch) &amp;&amp; !temp.equals(ch2str.get(ch)))&#123; <span class="comment">// 字符不匹配字符串直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不在哈希表中 就加入到哈希表中 并且进入下一轮字符匹配</span></span><br><span class="line">            str2ch.put(temp,ch);</span><br><span class="line">            ch2str.put(ch,temp);</span><br><span class="line">            idx = j + <span class="number">1</span>;            <span class="comment">// 从下一个单词的开头进行匹配 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配到结束都满足条件（idx = j + 1）</span></span><br><span class="line">        <span class="keyword">return</span> idx &gt; m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong> ： O(n + m)。 其中 n 是pattern的长度 , m是str 的长度。每个字符至多只被遍历一次，插入和查询哈希表的均摊时间复杂度为O(n + m)</li><li><strong>空间复杂度</strong> ： O(n + m) 。其中 n 是pattern的长度 , m是str 的长度。最坏情况下，我们需要存储pattern的每一个字符和str中的每一个字符串</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-290-单词规律&quot;&gt;&lt;a href=&quot;#Leetcode-290-单词规律&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-290-单词规律&quot;&gt;&lt;/a&gt;Leetcode-290-&lt;a href=&quot;https://leetcode-cn.com/problems/word-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词规律&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着&lt;strong&gt;双向连接的对应规律&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat fish&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;aaaa&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog dog dog dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;​    &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>排序-04-基数排序</title>
    <link href="http://zhuuu.work/2020/12/13/Sort/%E6%8E%92%E5%BA%8F-04-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/12/13/Sort/%E6%8E%92%E5%BA%8F-04-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-12-13T10:33:24.000Z</published>
    <updated>2020-12-13T08:34:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-04-基数排序"><a href="#排序-04-基数排序" class="headerlink" title="排序-04-基数排序"></a>排序-04-基数排序</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-04-基数排序&quot;&gt;&lt;a href=&quot;#排序-04-基数排序&quot; class=&quot;headerlink&quot; title=&quot;排序-04-基数排序&quot;&gt;&lt;/a&gt;排序-04-基数排序&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-376-摆动序列</title>
    <link href="http://zhuuu.work/2020/12/12/Leetcode/Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <id>http://zhuuu.work/2020/12/12/Leetcode/Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-12T01:52:53.000Z</published>
    <updated>2020-12-12T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-376-摆动序列"><a href="#Leetcode-376-摆动序列" class="headerlink" title="Leetcode-376-摆动序列"></a>Leetcode-376-<a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">摆动序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p><strong>如果连续数字之间的差严格地在正数和负数之间交替</strong>，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p></li><li><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反,<code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p></li><li><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 <strong>通过从原始序列中删除一些（也可以不删除）元素来获得子序列</strong>，剩下的元素保持其原始顺序。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题?</p><a id="more"></a><h2 id="算法思路-：-贪心算法"><a href="#算法思路-：-贪心算法" class="headerlink" title="算法思路 ： 贪心算法"></a>算法思路 ： 贪心算法</h2><ul><li><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p></li><li><p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p></li></ul><p>用示例二来举例，如图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201212/092659036.png" alt="mark"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p><p>（为方便表述，以下说的峰值都是指局部峰值）</p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong>。</p><ul><li>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</li><li>例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</li><li>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即<code>preDiff = 0</code>，如图：<ul><li>此时<code>curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0</code>，那么<code>result++</code></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201212/092926932.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 长度为1的都是摆动序列</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 初始化</span></span><br><span class="line">        <span class="keyword">int</span> prevdiff = nums[<span class="number">1</span>] - nums[<span class="number">0</span>];        <span class="comment">// 记录相邻三个元素 x y z(x 和 y 的差是正还是负)</span></span><br><span class="line">        <span class="keyword">int</span> ret = prevdiff != <span class="number">0</span>?<span class="number">2</span>:<span class="number">1</span>;             <span class="comment">// 前两个元素是否有重复（产生了坡度）</span></span><br><span class="line">        <span class="comment">// 3. 贪心遍历数组:加入一个新元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];   <span class="comment">// 记录相邻三个元素 x y z(y 和 z 的差是正还是负)</span></span><br><span class="line">            <span class="keyword">if</span>((diff &gt; <span class="number">0</span> &amp;&amp; prevdiff &lt;= <span class="number">0</span>) || (diff &lt; <span class="number">0</span> &amp;&amp; prevdiff &gt;= <span class="number">0</span>))&#123;  <span class="comment">// 如果出现了峰或者谷</span></span><br><span class="line">                ret++;                          <span class="comment">// 如果出现了「峰」或「谷」，答案加一</span></span><br><span class="line">                prevdiff = diff;                <span class="comment">// 更新当前序列的上升下降趋势</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-376-摆动序列&quot;&gt;&lt;a href=&quot;#Leetcode-376-摆动序列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-376-摆动序列&quot;&gt;&lt;/a&gt;Leetcode-376-&lt;a href=&quot;https://leetcode-cn.com/problems/wiggle-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摆动序列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如果连续数字之间的差严格地在正数和负数之间交替&lt;/strong&gt;，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如， &lt;code&gt;[1,7,4,9,2,5]&lt;/code&gt; 是一个摆动序列，因为差值 &lt;code&gt;(6,-3,5,-7,3)&lt;/code&gt; 是正负交替出现的。相反,&lt;code&gt;[1,4,7,2,5]&lt;/code&gt; 和 &lt;code&gt;[1,7,4,5,5]&lt;/code&gt; 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定一个整数序列，返回作为摆动序列的最长子序列的长度。 &lt;strong&gt;通过从原始序列中删除一些（也可以不删除）元素来获得子序列&lt;/strong&gt;，剩下的元素保持其原始顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,7,4,9,2,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 整个序列均为摆动序列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,17,5,10,13,15,10,5,16,8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,4,5,6,7,8,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;br&gt;你能否用 O(&lt;em&gt;n&lt;/em&gt;) 时间复杂度完成此题?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-649-Dota2参议院</title>
    <link href="http://zhuuu.work/2020/12/11/Leetcode/Leetcode-649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
    <id>http://zhuuu.work/2020/12/11/Leetcode/Leetcode-649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/</id>
    <published>2020-12-11T07:52:53.000Z</published>
    <updated>2020-12-11T02:12:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-649-Dota2-参议院"><a href="#Leetcode-649-Dota2-参议院" class="headerlink" title="Leetcode-649-Dota2 参议院"></a>Leetcode-649-<a href="https://leetcode-cn.com/problems/dota2-senate/" target="_blank" rel="noopener">Dota2 参议院</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><ul><li><p>禁止一名参议员的权利：</p></li><li><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p></li></ul><p>宣布胜利：</p><pre><code>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</code></pre><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p><strong>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</strong></p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 <code>Dota2</code>游戏中决定改变。输出应该是 <code>Radiant</code> 或 <code>Dire</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：&quot;RD&quot;</span><br><span class="line">输出：&quot;Radiant&quot;</span><br><span class="line">解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：&quot;RDD&quot;</span><br><span class="line">输出：&quot;Dire&quot;</span><br><span class="line">解释：</span><br><span class="line">第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span><br><span class="line">第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止</span><br><span class="line">第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span><br><span class="line">因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定字符串的长度在 <code>[1, 10,000]</code> 之间.</li></ul><a id="more"></a><h2 id="算法思路-循环队列"><a href="#算法思路-循环队列" class="headerlink" title="算法思路 : 循环队列"></a>算法思路 : 循环队列</h2><ul><li>我们以天辉方的议员为例。当一名天辉方的议员行使权利时：<ul><li>如果目前所有的议员都为天辉方，那么该议员可以直接宣布天辉方取得胜利；</li><li>如果目前仍然有夜魇方的议员，那么这名天辉方的议员只能行使「禁止一名参议员的权利」这一项权利。<ul><li>显然，该议员不会令一名同为天辉方的议员丧失权利，所以他一定会挑选一名夜魇方的议员。那么应该挑选哪一名议员呢？</li><li>容易想到的是，<strong>应该贪心地挑选按照投票顺序的下一名夜魇方的议员</strong>。</li><li>这也是很容易形象化证明的：既然只能挑选<strong>一名</strong>夜魇方的议员，那么就应该挑最早可以进行投票的那一名议员；</li><li>如果挑选了其它较晚投票的议员，那么等到最早可以进行投票的那一名议员行使权利时，一名天辉方议员就会丧失权利，这样就得不偿失了。</li></ul></li></ul></li></ul><p><strong>具体算法</strong></p><ul><li>由于我们总要挑选投票顺序最早的议员 ，因此我们可以使用两个队列<code>radiant</code> 和 <code>dire</code> 分别按照投票顺序存储天辉方和夜魇方每一名议员的投票时间</li><li>随后我们就可以开始模拟整个投票的过程：<ul><li><strong>如果此时 队列<code>radiant</code> 或者 <code>dire</code> 为空</strong>，那么就可以宣布另一方获得胜利；</li><li><strong>如果此时队列不为空</strong> ： 那么比较这两个队列的首元素，就可以确定当前行使权利的是哪一名议员<ul><li><strong>如果 <em>radiant</em> 的首元素较小，</strong>那说明轮到天辉方的议员行使权利，其会挑选 <em>dire</em> 的首元素对应的那一名议员</li><li><strong>因此，我们会将 <em>dire</em> 的首元素永久地弹出</strong></li><li><strong>并将 <em>radiant</em> 的首元素弹出，增加 <em>n</em> 之后再重新放回队列</strong></li><li>这里 n 是给给定字符串 senate 的长度,即表示该议员因为没有被ban掉所以参加了下一轮投票</li><li>同理 ： 如果dire 首元素较小,那么会永久的弹出 <code>radiant  的首元素，剩余的处理方法也是一样的</code></li></ul></li></ul></li></ul><blockquote><p>为什么这里是固定地增加 n，而不是增加与当前剩余议员数量相关的一个数？</p></blockquote><p>这样一来，我们就模拟了整个投票的过程，也就可以得到最终的答案了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">predictPartyVictory</span><span class="params">(String senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = senate.length();</span><br><span class="line">        Queue&lt;Integer&gt; radiant = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; dire    = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历数组 记录下每个阵营议员的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(senate.charAt(i) == <span class="string">'R'</span>)&#123;</span><br><span class="line">                radiant.offer(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dire.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果两个队列都不空的情况下</span></span><br><span class="line">        <span class="keyword">while</span>(!radiant.isEmpty() &amp;&amp; !dire.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> radiantIndex = radiant.poll();      <span class="comment">// radiant的第一名议员 暂时弹出</span></span><br><span class="line">            <span class="keyword">int</span> direIndex    = dire.poll();         <span class="comment">// dire 的第一名议员   暂时弹出</span></span><br><span class="line">            <span class="keyword">if</span>(radiantIndex &lt; direIndex)&#123;           <span class="comment">// 如果radiant第一名议员首元素较小</span></span><br><span class="line">                radiant.offer(radiantIndex + n);    <span class="comment">// 暂时弹出 +n之后重新放回队列 对应dire第一名议员永久弹出</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                     <span class="comment">// 加上n后，可以保证这个议员只会参加下一轮，或者被上一轮的对手干掉。</span></span><br><span class="line">                dire.offer(direIndex + n);          <span class="comment">// 暂时弹出 +n之后重新放回队列 对应radiant第一名议员永久弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 宣布胜利</span></span><br><span class="line">        <span class="keyword">return</span> !radiant.isEmpty()?<span class="string">"Radiant"</span>:<span class="string">"Dire"</span>; <span class="comment">// 最后非空的队列宣布胜利</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ：</strong> O(n)   其中 <code>n</code> 是字符串<code>senate</code> 的长度。在模拟整个投票过程的每一步，我们进行的操作的时间复杂度均为<code>O(1)</code>，并且会弹出一名天辉方或夜魇方的议员。由于议员的数量为 n，因此模拟的步数不会超过 n，时间复杂度即为 O(n)。</li><li><strong>空间复杂度</strong> ： O(n)   队列所需要的复杂度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-649-Dota2-参议院&quot;&gt;&lt;a href=&quot;#Leetcode-649-Dota2-参议院&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-649-Dota2 参议院&quot;&gt;&lt;/a&gt;Leetcode-649-&lt;a href=&quot;https://leetcode-cn.com/problems/dota2-senate/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dota2 参议院&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)&lt;/p&gt;
&lt;p&gt;Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;禁止一名参议员的权利：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宣布胜利：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 &lt;code&gt;Dota2&lt;/code&gt;游戏中决定改变。输出应该是 &lt;code&gt;Radiant&lt;/code&gt; 或 &lt;code&gt;Dire&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;RD&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;Radiant&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;RDD&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;Dire&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定字符串的长度在 &lt;code&gt;[1, 10,000]&lt;/code&gt; 之间.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-860-柠檬水找零</title>
    <link href="http://zhuuu.work/2020/12/10/Leetcode/Leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>http://zhuuu.work/2020/12/10/Leetcode/Leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2020-12-10T02:52:53.000Z</published>
    <updated>2020-12-10T01:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-860-柠檬水找零"><a href="#Leetcode-860-柠檬水找零" class="headerlink" title="Leetcode-860-柠檬水找零"></a>Leetcode-860-<a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">柠檬水找零</a></h1><h2 id="思路：贪心算法"><a href="#思路：贪心算法" class="headerlink" title="思路：贪心算法"></a>思路：贪心算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p></li><li><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p></li><li><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p></li></ul><p>  注意，一开始你手头没有任何零钱。</p><p>  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">3</span> 位顾客那里，我们按顺序收取 <span class="number">3</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">第 <span class="number">4</span> 位顾客那里，我们收取一张 <span class="number">10</span> 美元的钞票，并返还 <span class="number">5</span> 美元。</span><br><span class="line">第 <span class="number">5</span> 位顾客那里，我们找还一张 <span class="number">10</span> 美元的钞票和一张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 <span class="keyword">true</span>。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">2</span> 位顾客那里，我们按顺序收取 <span class="number">2</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">对于接下来的 <span class="number">2</span> 位顾客，我们收取一张 <span class="number">10</span> 美元的钞票，然后返还 <span class="number">5</span> 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 <span class="number">15</span> 美元，因为我们现在只有两张 <span class="number">10</span> 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 <span class="keyword">false</span>。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路：贪心-模拟（CRUD）"><a href="#算法思路：贪心-模拟（CRUD）" class="headerlink" title="算法思路：贪心 + 模拟（CRUD）"></a>算法思路：贪心 + 模拟（CRUD）</h2><p>由于顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票的面值只可能是 5 美元，10美元和 20 美元三种。基于此，我们可以进行如下的分类讨论。</p><ol><li><strong>5 美元</strong>，由于柠檬水的价格也为 5美元，因此我们直接收下即可</li><li><strong>10 美元，我们需要找回 5 美元</strong>，如果没有 5 美元面值的钞票，则无法正确找零。</li><li><strong>20 美元，我们需要找回 15 美元</strong>，此时有<strong>两种组合方式</strong><ul><li>一种是一张 10 美元和 5 美元的钞票</li><li>一种是 3 张  5 美元的钞票</li><li>如果两种组合方式都没有，则无法正确找零</li></ul></li></ol><ol start="4"><li><strong>对于情况三的找零方式 ：</strong> <ul><li>当可以正确找零时，两种找零的方式中我们更倾向于第一种</li><li>即如果存在5美元和10美元 我们就按照第一种方式找零</li><li>否则按照第二种情况找零，这样的目的是尽可以保留5美元的钞票</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  遍历所有的数组元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> bill:bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bill == <span class="number">5</span>)&#123;          <span class="comment">// 如果发现是五块钱，直接收了</span></span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bill == <span class="number">10</span>)&#123;   <span class="comment">// 如果发现是10块钱</span></span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>)&#123;      <span class="comment">// 如果没有钱来找零了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                  <span class="comment">// 如果账单是20块钱</span></span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>)&#123;    <span class="comment">// 1. 首先判断10块和5块的组合够不够找钱</span></span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>)&#123;        <span class="comment">// 2. 不够的话就用3张5块钱去找零</span></span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 3. 都没有零钱可找了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以找零的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong> ： O（N） 遍历一遍数组所需要的时间</li><li><strong>空间复杂度</strong>  ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-860-柠檬水找零&quot;&gt;&lt;a href=&quot;#Leetcode-860-柠檬水找零&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-860-柠檬水找零&quot;&gt;&lt;/a&gt;Leetcode-860-&lt;a href=&quot;https://leetcode-cn.com/problems/lemonade-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;柠檬水找零&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：贪心算法&quot;&gt;&lt;a href=&quot;#思路：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;思路：贪心算法&quot;&gt;&lt;/a&gt;思路：贪心算法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 5 美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 位顾客那里，我们按顺序收取 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 位顾客那里，我们收取一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票，并返还 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 位顾客那里，我们找还一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票和一张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于所有客户都得到了正确的找零，所以我们输出 &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 位顾客那里，我们按顺序收取 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于接下来的 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 位顾客，我们收取一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票，然后返还 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于最后一位顾客，我们无法退回 &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; 美元，因为我们现在只有两张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于不是每位顾客都得到了正确的找零，所以答案是 &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学-伽马修正</title>
    <link href="http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E4%BC%BD%E9%A9%AC%E4%BF%AE%E6%AD%A3/"/>
    <id>http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E4%BC%BD%E9%A9%AC%E4%BF%AE%E6%AD%A3/</id>
    <published>2020-12-09T09:38:38.000Z</published>
    <updated>2020-12-09T09:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-伽马修正"><a href="#图像学-伽马修正" class="headerlink" title="图像学-伽马修正"></a>图像学-伽马修正</h1><h1 id="计算机图形学-伽马修正"><a href="#计算机图形学-伽马修正" class="headerlink" title="计算机图形学-伽马修正"></a>计算机图形学-伽马修正</h1><p><strong>起因：</strong> [][][一个伽马矫正的视频][<a href="https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]</a></p><p><strong>答案 ：</strong> [一个知乎答案][<a href="https://www.zhihu.com/question/27467127]" target="_blank" rel="noopener">https://www.zhihu.com/question/27467127]</a></p><p><strong>参考博客 ：</strong> [博客地址][<a href="http://hanshilin.com/blog/gamma-and-linear-workflow/]" target="_blank" rel="noopener">http://hanshilin.com/blog/gamma-and-linear-workflow/]</a></p><a id="more"></a><h2 id="1-韦伯-费希纳定律"><a href="#1-韦伯-费希纳定律" class="headerlink" title="1. 韦伯-费希纳定律"></a>1. 韦伯-费希纳定律</h2><ul><li>最早见到韦伯定律的时候，以为就是个非常简单的式子：△I/I=K，△I是差别阈限；I是刺激强度；K是韦伯常数</li><li>根据刺激的不同，受试的不同，其值不同，但对于同一个被试在同等条件下进行同类型的刺激，该值为常数。</li><li>意思是，刺激强度I和在该刺激强度下引起最小可觉差所需要的刺激强度呈正比。例如，假设手里拿一个重量为10g的物体，若增加1g能让你恰好感觉到它的重量产生了变化（增加的重量低于1g你便不能感觉到重量发生了改变），那么如果手里拿一个重量为100g的物体，则需要增加其重量10g才能让你恰好感觉到重量发生了变化。</li></ul><p><strong>费希纳则在韦伯的基础上作出这样一个假设</strong>：</p><ul><li><strong>恰好引起感觉变化的刺激强度变化所引起的感觉变化是相等的。</strong>以上面那个例子为例，<ul><li>意思是，对于给10g物体增加1g所引起的你感觉变化与给100g物体增加10g所引起的你的感觉变化是一样的，都是1个单位的感觉变化。</li><li>换言之，你左手拿11g物体右手拿10g物体，你感觉左手比右手重”一些“；你左手拿110g物体右手拿100g物体，感觉左手比右手重”一些“，这两个”一些“的程度是一样的。 </li></ul></li></ul><ul><li>在这个假设的基础上，费希纳总结出公式：△P = k * △S/S         </li><li>根据该公式，若在某初始刺激为S的条件下，进行强度为10倍最小可觉差的刺激，则相应的感觉变化也应当变成10倍。比如给10g物体增加1g重量刚好能感觉到重量发生了改变，主观感觉变化量为△p；</li></ul><ul><li>虽然这个公式有一部分与韦伯定律的公式非常相似，但意义并不相同：<ul><li>在韦伯定律那里， △I/I=K指的是“当前刺激强度下的最小可觉差”与”当前刺激强度“的关系， △I与I均为变量。</li><li>而关系式△P = k * △S/S 则指示了在初始刺激强度为S时，刺激变化量△S与主观感觉变化量△P的关系。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">将上式改写成微分式，则有dP &#x3D; k * dS &#x2F; S</span><br><span class="line">   </span><br><span class="line">      对该式两侧同时进行积分：</span><br><span class="line">       ∫ dP  &#x3D; P &#x3D;  ∫ k&#x2F;S * dS  &#x3D;  k*lnS + C</span><br><span class="line">      </span><br><span class="line">      得到了主观感觉量P与刺激强度S的关系式：</span><br><span class="line">      P &#x3D; k*lnS + C</span><br><span class="line"></span><br><span class="line">      为消除积分常数C，令P&#x3D;0，有C &#x3D; -k*lns, s是绝对阈限。</span><br><span class="line"></span><br><span class="line">      可得：</span><br><span class="line">      P &#x3D; k * (lnS - lns)</span><br><span class="line">     </span><br><span class="line">     设绝对阈限为单位1，则lns &#x3D;0，</span><br><span class="line"></span><br><span class="line">     故可改写为P &#x3D;k *lnS &#x3D; k*(lgS&#x2F;lge) &#x3D; k&#x2F;lge * lgS  </span><br><span class="line">                         &#x3D; K * lgS</span><br><span class="line"></span><br><span class="line">     得到费希纳定律的公式。</span><br><span class="line"></span><br><span class="line">     若某振幅为10个单位的音波引起的声音的主观感觉量为1，如果把该音波的振幅扩大到100个单位，则声音的主观感觉量仅增加1。换言之，根据费希纳定律，若要感觉强度呈线性增长，则刺激强度需要呈几何倍数增长。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>[知乎另外一个答案][<a href="https://www.zhihu.com/question/314657948?sort=created]" target="_blank" rel="noopener">https://www.zhihu.com/question/314657948?sort=created]</a></p><p><strong>参考博客 ：</strong> </p><p><a href="https://www.douban.com/note/506270934/" target="_blank" rel="noopener">https://www.douban.com/note/506270934/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-伽马修正&quot;&gt;&lt;a href=&quot;#图像学-伽马修正&quot; class=&quot;headerlink&quot; title=&quot;图像学-伽马修正&quot;&gt;&lt;/a&gt;图像学-伽马修正&lt;/h1&gt;&lt;h1 id=&quot;计算机图形学-伽马修正&quot;&gt;&lt;a href=&quot;#计算机图形学-伽马修正&quot; class=&quot;headerlink&quot; title=&quot;计算机图形学-伽马修正&quot;&gt;&lt;/a&gt;计算机图形学-伽马修正&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;起因：&lt;/strong&gt; [][][一个伽马矫正的视频][&lt;a href=&quot;https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案 ：&lt;/strong&gt; [一个知乎答案][&lt;a href=&quot;https://www.zhihu.com/question/27467127]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/27467127]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考博客 ：&lt;/strong&gt; [博客地址][&lt;a href=&quot;http://hanshilin.com/blog/gamma-and-linear-workflow/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hanshilin.com/blog/gamma-and-linear-workflow/]&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-897-递增顺序查找树</title>
    <link href="http://zhuuu.work/2020/12/07/Leetcode/Leetcode-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/12/07/Leetcode/Leetcode-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2020-12-07T07:52:53.000Z</published>
    <updated>2020-12-07T03:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-897-递增顺序查找树"><a href="#Leetcode-897-递增顺序查找树" class="headerlink" title="Leetcode-897-递增顺序查找树"></a>Leetcode-897-<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">递增顺序查找树</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p><pre><code>示例 ：输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]      5      /     \    3    6   / \    \  2   4    8 /        / \ 1        7   9输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1  \   2    \     3      \       4        \         5          \           6            \             7              \               8                \                 9  </code></pre><a id="more"></a><h2 id="思路：中序遍历-构造新树"><a href="#思路：中序遍历-构造新树" class="headerlink" title="思路：中序遍历 + 构造新树"></a>思路：中序遍历 + 构造新树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root,vals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造新树</span></span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode cur = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:vals)&#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> TreeNode(val);  <span class="comment">// 构造新的结点</span></span><br><span class="line">            cur = cur.right;    <span class="comment">// 方向只向右延伸</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node,List&lt;Integer&gt; vals)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(node.left,vals);</span><br><span class="line">        vals.add(node.val);</span><br><span class="line">        inorder(node.right,vals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，其中 N 是树上的节点个数。</li><li><strong>空间复杂度</strong>：O(N)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-897-递增顺序查找树&quot;&gt;&lt;a href=&quot;#Leetcode-897-递增顺序查找树&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-897-递增顺序查找树&quot;&gt;&lt;/a&gt;Leetcode-897-&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-order-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;递增顺序查找树&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给你一个树，请你 &lt;strong&gt;按中序遍历&lt;/strong&gt; 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 ：

输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]

      5
      /     \
    3    6
   / \    \
  2   4    8
 /        / \ 
1        7   9

输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="中序遍历" scheme="http://zhuuu.work/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
</feed>
